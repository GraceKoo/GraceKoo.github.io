<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git</title>
    <url>/posts/25246/</url>
    <content><![CDATA[<h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><h2 id="config文件"><a href="#config文件" class="headerlink" title="config文件"></a>config文件</h2><ul>
<li><p>/etc/gitconfig文件：系统中对所有的用户都普遍适用的配置。若使用git config —system选项，读写就是这个文件</p>
</li>
<li><p>～/.gitconfig文件：用户目录下的配置文件，只适用于该用户。若使用config —global选项，读写就是这个文件</p>
</li>
<li><p>当前Git仓库的git文件（.git/config），这里配置只对当前项目有效，每个配置级别都会覆盖上层的配置，所以.git/config会覆盖/etc/gitconfig里的文件</p>
<p>在Windows系统上，Git会找主目录下的.gitconfig文件，主目录即$HOME变量指定的目录，一般在C:\Documents and Settings$USER中</p>
<p>此外，Git还会尝试找寻/etc/gitconfig文件，只不过看当初Git装在什么目录，就以此作为根目录来定位</p>
</li>
</ul>
<h2 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git config --<span class="keyword">global</span> user.name <span class="string">"loen"</span></span><br><span class="line">$ git config --<span class="keyword">global</span> user.email loen@qq.com</span><br></pre></td></tr></tbody></table></figure>
<p>利用gloabal选项，更改用户主目录下的config文件，以后所有项目都会默认使用这里配置的用户信息</p>
<p>如果要在某个特定项目里使用其他名字或者邮件，只要去掉—global选项重新配置即可，新的设定保存在当前目录的.git/config 文件里</p>
<h2 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h2> <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git config --<span class="built_in">list</span></span><br></pre></td></tr></tbody></table></figure>
<p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件( 比如/etc/gitconfig和~./gitconfig)，不过Git实际采用的是最后一个</p>
<p>也可以在/etc/gitconfig和~./gitconfig里看到</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ vim ~/.gitconfig</span><br></pre></td></tr></tbody></table></figure>
<h2 id="忽略特殊文件-gitignore"><a href="#忽略特殊文件-gitignore" class="headerlink" title="忽略特殊文件.gitignore"></a>忽略特殊文件.gitignore</h2><p>有时必须把某些文件放入Git工作目录中，但是又不能将其提交，如存储了数据库密码的配置文件。</p>
<p>只需在Git工作区的根目录下创建一个名为.gitignore的文件，写入过滤规则就可以了</p>
<p>.gitignore不需要从头写，所有配置文件可以直接在线浏览<a href="https://github.com/github/.gitignore">https://github.com/github/.gitignore</a></p>
<p>忽略文件的原则是：</p>
<p>1.忽略系统自动生成的文件</p>
<p>2.忽略编译生成的中间文件</p>
<p>3.忽略用户带有敏感信息的配置文件</p>
<h1 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h1><p>Git（Global Information Tracker）是一个开源的分布式版本控制系统，是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源代码的软件。</p>
<p>Git一般的工作流程如下：</p>
<a id="more"></a>
<ul>
<li><p>克隆Git资源作为本地的工作目录</p>
</li>
<li><p>在工作目录上添加或者修改文件</p>
</li>
<li><p>提交修改</p>
</li>
<li><p>可以撤回提交并再次修改</p>
<p><img data-src="/images/git/git_1.png" alt="屏幕快照 2019-08-18 下午9.21.01"></p>
</li>
</ul>
<h1 id="快速入门Git"><a href="#快速入门Git" class="headerlink" title="快速入门Git"></a>快速入门Git</h1><h2 id="创建版本库：git-init"><a href="#创建版本库：git-init" class="headerlink" title="创建版本库：git init"></a>创建版本库：git init</h2><p>在本地目录中执行git init，创建一个新的Git仓库FirstGit。.git用于跟踪管理版本库。</p>
<p><img data-src="/images/git/git_0.png" alt="屏幕快照 2019-08-18 下午9.34.53"></p>
<h2 id="添加到暂存区：git-add"><a href="#添加到暂存区：git-add" class="headerlink" title="添加到暂存区：git add"></a>添加到暂存区：git add</h2><p>在FirstGit目录下添加文件README.md</p>
<p><img data-src="/images/git/git_2.png" alt="屏幕快照 2019-08-18 下午9.43.56"></p>
<ul>
<li>git status用于查看项目的当前状态，-s表示查看简要信息</li>
<li>git add命令将其添加到暂存区，也可以使用git add . 用于添加当前目录下的所有文件</li>
</ul>
<p>改动README.md，再次执行git status</p>
<p><img data-src="/images/git/git_3.png" alt="屏幕快照 2019-08-18 下午9.50.02"></p>
<ul>
<li>“AM”状态表示这个文件在被添加到暂存区后进行了修改</li>
<li>再次执行git add命令将其添加到暂存区（缓存）</li>
</ul>
<p>再次改动README.md</p>
<p><img data-src="/images/git/git_4.png" alt="屏幕快照 2019-08-18 下午10.04.07"></p>
<p><img data-src="/images/git/git_5.png" alt="屏幕快照 2019-08-18 下午10.04.47"></p>
<ul>
<li>git diff：查看写入缓存与已修改但尚未写入缓存的区别</li>
<li>git diff —cached：查看已缓存的改动</li>
<li>git diff HEAD：查看已缓存的与未缓存的所有改动</li>
<li>git diff —stat：显示摘要而非整个diff</li>
</ul>
<h2 id="向仓库提交代码：git-commit"><a href="#向仓库提交代码：git-commit" class="headerlink" title="向仓库提交代码：git commit"></a>向仓库提交代码：git commit</h2><p>git add将快照内容写入缓存区，git commit则是将缓存区的内容添加到远程仓库中</p>
<p><img data-src="/images/git/git_6.png" alt="屏幕快照 2019-08-18 下午10.18.43"></p>
<p><img data-src="/images/git/git_7.png" alt="屏幕快照 2019-08-18 下午10.22.09"></p>
<ul>
<li>-m 选项表示提交的注释</li>
<li>再次执行git status，输出表示在上次提交之后，没有作出任何更改</li>
<li>也可以利用git commit -am “lala”来替代git add  . 与 git commit -m “lala”</li>
</ul>
<h2 id="取消已缓存的内容：git-reset-HEAD"><a href="#取消已缓存的内容：git-reset-HEAD" class="headerlink" title="取消已缓存的内容：git reset HEAD"></a>取消已缓存的内容：git reset HEAD</h2><p><img data-src="/images/git/git_8.png" alt="屏幕快照 2019-08-18 下午10.47.03"></p>
<p>可以看到git add后将README文件添加到了缓存区，利用git reset命令取消了README的缓存，HEAD表示指向的版本为当前版本</p>
<h2 id="删除文件：git-rm"><a href="#删除文件：git-rm" class="headerlink" title="删除文件：git rm"></a>删除文件：git rm</h2><ul>
<li>git rm <file>：从版本库中删除文件</file></li>
<li>git rm -f <file>：从暂存区中删除文件（必须进行强制删除）</file></li>
<li>git rm —cached <file>：从暂存区中删除文件，保留工作区中的文件</file></li>
<li>git rm -r test：递归删除test目录下的所有目录与文件</li>
</ul>
<h2 id="回滚-git-reset"><a href="#回滚-git-reset" class="headerlink" title="回滚: git reset"></a>回滚: git reset</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset --hard 5ec6ff1</span><br></pre></td></tr></tbody></table></figure>
<h2 id="恢复文件：git-checkout"><a href="#恢复文件：git-checkout" class="headerlink" title="恢复文件：git checkout"></a>恢复文件：git checkout</h2><p>git checkout —file：工作区的文件替换为版本库的文件</p>
<h2 id="移动-重命名：git-mv"><a href="#移动-重命名：git-mv" class="headerlink" title="移动/重命名：git mv"></a>移动/重命名：git mv</h2><p>git mv ：用于移动或者重命名一个文件、目录</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git add README</span><br><span class="line">$ git mv README README.md </span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></tbody></table></figure>
<h1 id="远程仓库GitHub"><a href="#远程仓库GitHub" class="headerlink" title="远程仓库GitHub"></a>远程仓库GitHub</h1><p>GitHub是一个面向开源及私有软件项目的托管平台，仅支持git作为唯一的版本库格式进行托管。</p>
<h2 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h2><p>本地创建新的仓库并与GitHub进行关联</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git remote add origin https://github.com/gracekoo/gitlearn.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></tbody></table></figure>
<p>或者将本地已有仓库与之关联</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/gracekoo/gitlearn.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></tbody></table></figure>
<h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><p>git clone：拷贝一个git仓库到本地，还可以在命令末尾加上自己想要的名字</p>
 <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git clone https://github.com/gracekoo/gitlearn.git mygit</span><br></pre></td></tr></tbody></table></figure>
<h2 id="更新数据：git-fetch"><a href="#更新数据：git-fetch" class="headerlink" title="更新数据：git fetch"></a>更新数据：git fetch</h2><p>git fetch：从远程获取最新版本到本地，不会自动merge</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout issue12 </span><br><span class="line">$ git fetch origin issue12 </span><br><span class="line">$ git log -p issue12..origin/issue12</span><br><span class="line">$ git merge origin/issue12</span><br></pre></td></tr></tbody></table></figure>
<p>(1) 换到issue12分支</p>
<p>(2)从远程的origin的issue12分支下载最新版本到issue12分支上</p>
<p>(3)比较本地issue12分支和origin/issue12分支的差别</p>
<p>(4)将origin/issue12分支合并到issue12</p>
<h2 id="更新数据：git-pull"><a href="#更新数据：git-pull" class="headerlink" title="更新数据：git pull"></a>更新数据：git pull</h2><p>git pull：从远程获取最新版本并merge到本地</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout issue12</span><br><span class="line">$ git pull origin issue12 // git fetch + git merge</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h1><h2 id="分支原理"><a href="#分支原理" class="headerlink" title="分支原理"></a>分支原理</h2><ul>
<li><p>执行git init时，缺省情况下Git会创建“master”分支</p>
</li>
<li><p>master指向提交，HEAD指向当前分支</p>
</li>
<li><p>每次提交，master分支都会向前移动一步。当创建新的分支，如dev时，Git新建一个指针dev，指向与master相同的<strong>提交</strong>，再把HEAD指向dev，表示现在分支在dev上</p>
<p><img data-src="/images/git/git_9.jpeg" alt="WechatIMG265"></p>
</li>
<li><p>从现在开始，对工作区的修改和提交就是针对dev分支了，比如一次新提交后，dev指针向前移动一步，而master指针不变</p>
<p><img data-src="/images/git/git_10.jpeg" alt="WechatIMG263"></p>
</li>
<li><p>在dev上完成相应的开发后，将其合并到master分支上</p>
<p><img data-src="/images/git/git_11.jpeg" alt="WechatIMG264"></p>
</li>
</ul>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>使用分支意味着从开发主线上分离开，然后在不影响主线的同时继续工作</p>
<ul>
<li>创建新分支new_branch</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch new_branch </span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>切换到新分支new_branch：当切换到新分支时，Git会用该分支的最后提交的快照替换工作目录的内容</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout new_branch //切换到new_branch</span><br><span class="line">$ git checkout -b new_branch //创建并切换到new_branch</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>合并分支</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git merge</span><br></pre></td></tr></tbody></table></figure>
<p>通常Git在合并分支时会用Fast Forward模式，这样删除分支后，会丢失分支信息。</p>
<p>因此在合并分支时可以使用—no-ff，强制禁用Fast Forward模式，这样Git在合并时会生成一个新的commit，然后就可以在历史分支上看到分支信息。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev2</span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>删除分支</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch -d new_branch</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>查看分支</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch </span><br><span class="line">$ git branch -r //查看远程分支</span><br><span class="line">$ git branch -a //查看远程和本地的所有分支</span><br></pre></td></tr></tbody></table></figure>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>在两个分支中修改了同一个文件的同一行代码，在合并时就会发生冲突，使用git status可以显示存在冲突的文件和文件名</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></tbody></table></figure>
<p>当发生冲突时，必须手动解决冲突，并再次提交</p>
<p>利用带参数的git log也可以看到合并后的情况</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></tbody></table></figure>
<p>实际开发中，应该按照以下基本原则来进行分支管理</p>
<ul>
<li>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不用于开发</li>
<li>团队成员在dev上开发，时不时的往dev上进行合并，等到发布新版本时，再将dev往master上合并</li>
</ul>
<h2 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h2><p>当从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git remote //查看远程库信息，远程仓库默认名字是origin</span><br><span class="line">origin</span><br><span class="line">$ git remote -v //更详细的信息</span><br><span class="line">origin</span><br><span class="line">https://github.com/asdf2014/algorithm.git</span><br></pre></td></tr></tbody></table></figure>
<h2 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h2><p>将本地的master分支推送到远程库origin</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></tbody></table></figure>
<p>将本地的dev2分支推送到远程库origin</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git push origin dev2</span><br></pre></td></tr></tbody></table></figure>
<h2 id="拉取分支"><a href="#拉取分支" class="headerlink" title="拉取分支"></a>拉取分支</h2><p>将origin最新的提交拉取下来</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></tbody></table></figure>
<p>关联本地dev分支与远程origin/dev分支</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream dev origin/dev</span><br></pre></td></tr></tbody></table></figure>
<h1 id="回退与撤销"><a href="#回退与撤销" class="headerlink" title="回退与撤销"></a>回退与撤销</h1><h2 id="撤销修改：git-checkout-file"><a href="#撤销修改：git-checkout-file" class="headerlink" title="撤销修改：git checkout - - file"></a>撤销修改：git checkout - - file</h2><p>把该文件在工作区的修改全部撤销，如果文件修改后还没有放到暂存区，撤销修改就是用版本库里的替代工作区内的。如果文件已经被添加到暂存区，那么撤销修改就是用暂存区里的文件替代当前文件。</p>
<p>总之就是让这个文件回到最近一次git commit或git add时的状态。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></tbody></table></figure>
<h2 id="历史记录：git-log"><a href="#历史记录：git-log" class="headerlink" title="历史记录：git log"></a>历史记录：git log</h2><p>git log显示从最近到最远的提交日志。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></tbody></table></figure>
<p>显示简要的commit历史记录。commit ID用SHA1计算出的16进制表示。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">git log --pretty=online</span><br></pre></td></tr></tbody></table></figure>
<h2 id="版本回退：git-reset"><a href="#版本回退：git-reset" class="headerlink" title="版本回退：git reset"></a>版本回退：git reset</h2><p>利用git log来查看当前的历史记录</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">git log --pretty=online</span><br></pre></td></tr></tbody></table></figure>
<p>使用git reset回退到上一个版本</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></tbody></table></figure>
<p>Git中，用HEAD表示当前的版本，上一个版本就是HEAD^，上上个版本就是HEAD^^,前100个版本可以用HEAD~100表示。</p>
<p>如果回退失误，想要改回原来的版本，就必须通过git log命令找到版本的commit id</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">git log --pretty=online</span><br></pre></td></tr></tbody></table></figure>
<p>假如ID为asdhasdjfnaslkgnsd，利用git reset命令进行版本回退</p>
 <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">git reset --hard asdhasdjfnaslkgnsd</span><br></pre></td></tr></tbody></table></figure>
<p>git reflog命令用于显示整个本地库的commit，包括所有branch 的commit，甚至包括已经撤销的commit，只要HEAD发生了变化，就会在reflog中看到。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></tbody></table></figure>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><h2 id="创建标签：git-tag"><a href="#创建标签：git-tag" class="headerlink" title="创建标签：git tag"></a>创建标签：git tag</h2><p>标签是默认打在最新提交的commit id上的</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switch to branch <span class="string">'master'</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git tag v1<span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure>
<p>也可以直接在某个commit id上打标签</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git log --pretty=online --abbrev-commit //找到历史的commit <span class="built_in">id</span></span><br><span class="line">a923sad1 You <span class="keyword">is</span> pig</span><br><span class="line">a923sad2 You <span class="keyword">is</span> cat</span><br><span class="line">$ git tag v0<span class="number">.8</span> a923sad2 //给You <span class="keyword">is</span> cat打标签</span><br><span class="line">$ git tag //查看当前标签</span><br><span class="line">v0<span class="number">.8</span></span><br></pre></td></tr></tbody></table></figure>
<p>也可以创建带有说明的标签：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git tag -a v0<span class="number">.9</span> -m <span class="string">"This is v0.9"</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><p>可以使用git tag来查看所有的标签</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1<span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure>
<p>查看标签信息</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git show v0<span class="number">.9</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git tag -d v0<span class="number">.9</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="推送标签到远程"><a href="#推送标签到远程" class="headerlink" title="推送标签到远程"></a>推送标签到远程</h2><p>推送某个标签到远程</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git push origin v1<span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure>
<p>一次性推送全部尚未送到远程的本地标签</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></tbody></table></figure>
<p>如果标签已经推送到远程，要删除远程标签，先从本地删除</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git tag -d v0<span class="number">.9</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后从远程删除</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0<span class="number">.9</span> To https://github.com/liming/gitlearn.git</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Algorithm-Summarize</title>
    <url>/posts/58748/</url>
    <content><![CDATA[<h1 id="YUV、RGB、HSV"><a href="#YUV、RGB、HSV" class="headerlink" title="YUV、RGB、HSV"></a>YUV、RGB、HSV</h1><p>YUV：亮度信息 即灰度值。UV：色彩信息 定义了颜色的两个方面-色调与饱和度，分别用Cr和CB来表示。其中，Cr反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。而CB反映的是RGB输入信号蓝色部分与RGB信号亮度值之同的差异。通过运算，YUV三分量可以还原出R（红），G（绿），B（蓝）。</p>
<p>HSV: 色调（H），饱和度（S），明度（V）</p>
<p>相互转换</p>
<h2 id="ARGB-gt-RGB"><a href="#ARGB-gt-RGB" class="headerlink" title="ARGB -> RGB"></a>ARGB -&gt; RGB</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">//unsigned char *data 存的是ARGB的裸数据；</span><br><span class="line"> </span><br><span class="line">cv::Mat argbImg;</span><br><span class="line">cv::Mat rgbImg(cy, cx,CV_8UC3);</span><br><span class="line">yuvImg.create(cy, cx, CV_8UC4);</span><br><span class="line">memcpy(argbImg.data, data, <span class="built_in">len</span>);</span><br><span class="line">cv::cvtColor(argbImg, rgbImg, CV_RGBA2RGB);</span><br><span class="line">flip(rgbImg, rgbImg, <span class="number">0</span>);    //垂直翻转</span><br></pre></td></tr></tbody></table></figure>
<h2 id="YUV-gt-RGB"><a href="#YUV-gt-RGB" class="headerlink" title="YUV -> RGB"></a>YUV -&gt; RGB</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">//unsigned char *data 存的是YUYV的裸数据；</span><br><span class="line"> </span><br><span class="line">cv::Mat yuvImg;</span><br><span class="line">cv::Mat rgbImg(cy, cx,CV_8UC3);</span><br><span class="line">yuvImg.create(cy , cx, CV_8UC2);</span><br><span class="line">memcpy(yuvImg.data, data, <span class="built_in">len</span>);</span><br><span class="line">cv::cvtColor(yuvImg, rgbImg, CV_YUV2BGR_YUYV);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="I420-gt-RGB"><a href="#I420-gt-RGB" class="headerlink" title="I420 -> RGB"></a>I420 -&gt; RGB</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">//unsigned char *data 存的是I420的裸数据；</span><br><span class="line"> </span><br><span class="line">cv::Mat yuvImg;</span><br><span class="line">cv::Mat rgbImg(cy, cx,CV_8UC3);</span><br><span class="line">yuvImg.create(cy * <span class="number">3</span>/<span class="number">2</span>, cx, CV_8UC1);</span><br><span class="line">memcpy(yuvImg.data, data, <span class="built_in">len</span>);</span><br><span class="line">cv::cvtColor(yuvImg, rgbImg, CV_YUV2BGR_I420);</span><br></pre></td></tr></tbody></table></figure>
<p>OpenCV提供的转换函数实现YUV到RGB的转换：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> YV12ToBGR24_OpenCV(unsigned char* pYUV,unsigned char* pBGR24,<span class="built_in">int</span> width,<span class="built_in">int</span> height) </span><br><span class="line">{ </span><br><span class="line"><span class="keyword">if</span> (width &lt; <span class="number">1</span> || height &lt; <span class="number">1</span> || pYUV == NULL || pBGR24 == NULL) </span><br><span class="line"><span class="keyword">return</span> false; </span><br><span class="line">Mat dst(height,width,CV_8UC3,pBGR24); </span><br><span class="line">Mat src(height + height/<span class="number">2</span>,width,CV_8UC1,pYUV); </span><br><span class="line">cvtColor(src,dst,CV_YUV2BGR_YV12); </span><br><span class="line"><span class="keyword">return</span> true; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="RGB-gt-HSV"><a href="#RGB-gt-HSV" class="headerlink" title="RGB -> HSV"></a>RGB -&gt; HSV</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"># -*- coding:utf<span class="number">-8</span> -*-</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">功能：读取一张图片，显示出来，并转化为HSV色彩空间</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">image = cv2.imread('images/my_wife2.jpg') # 根据路径读取一张图片</span><br><span class="line">cv2.imshow(<span class="string">"BGR"</span>, image) # 显示图片</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 转化图片到HSV色彩空间</span><br><span class="line">dst = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)</span><br><span class="line">cv2.imshow(<span class="string">"HSV"</span>, dst) # 显示图片</span><br><span class="line">cv2.waitKey(<span class="number">0</span>) # 等待键盘触发事件，释放窗口</span><br></pre></td></tr></tbody></table></figure>
<h1 id="White-Balance"><a href="#White-Balance" class="headerlink" title="White Balance"></a>White Balance</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>相机的白平衡控制，是为了让实际环境中白色的物体在你拍摄的画面中也呈现出“真正”的白色。不同性质的光源会在画面中产生不同的色彩倾向，比如说，蜡烛的光线会使画面偏橘黄色，而黄昏过后的光线则会为景物披上一层蓝色的冷调。而我们的视觉系统会自动对不同的光线作出补偿，所以无论在暖调还是冷调的光线环境下，我们看一张白纸永远还是白色的。但相机则不然，它只会直接记录呈现在它面前的色彩，这就会导致画面色彩偏暖或偏冷。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>开暖光灯：YUV -&gt; RGB -&gt; SV ，全图SV值S需在0～0.1之间，V需在90～255之间。</p>
<a id="more"></a>
<h1 id="IR-Cut"><a href="#IR-Cut" class="headerlink" title="IR-Cut"></a>IR-Cut</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>自然界存在着各种波长的光线，通过折射人眼能看到不同颜色的光线，这就是光线的波长不同所导致的。其实还有许多光线是人眼看不到的，人眼识别光线的波长范围在320nm-760nm之间， 超过760nm的光线人眼就无法见到，比如红外光等。<br>随着科学的进步，人类发明了摄像机，理论上讲摄像机可以看到绝大部分波长的光线，但在摄像机的使用过程中就出现了一个问题，由于各种光线的参杂，摄像机看到的物体反映在监视器上与人眼直接看到的就变样了。如人眼看到绿色，通过摄像机则变成蓝色，产生彩色失真。过去，为解决色彩失真问题，一般在CCD前贴有一低通滤片，该滤片阻碍了红外光的进出，故白天彩色不失真，但夜间却没有了夜视功能。<br>IR CUT是一种机械装置，内有两个窗口，一为低通滤片一为透明玻璃，可依需要左右移动，从而白天彩色不失真，且夜间仍有夜视功能。简单的说，通过IR CUT，白天只允许760nm或780nm以下波长的光线进入，避免了白天的彩色失真。晚上只允许760nm或780nm以上波长的红外光线进入，避免760nm或780nm以下波长的可见光对红外光的干扰，于是在白天与夜晚都能取得最佳视觉效果。随着技术的进步，IR CUT结合低通滤片与<a href="https://www.baidu.com/s?wd=高通&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">高通</a>滤片在改进<a href="https://www.baidu.com/s?wd=夜视摄像机&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">夜视摄像机</a>的性能上发挥越来越重要的作用．低通滤片：以镀膜方式使光线中波长在760nm或780nm以下的光线通过，超过760nm或780nm波长的光线阻止通过。<a href="https://www.baidu.com/s?wd=高通&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">高通</a>滤片：以镀膜方式使光线中波长在760nm或780nm以下的光线阻止通过，只准超过760nm或780nm以上波长的光线通过。<br>根据上述分析，应用低通滤片技术，摄像机能够模拟人的眼睛，只接收同样范围波长的光线，这样就解决了摄像机的色彩失真问题。而通过<a href="https://www.baidu.com/s?wd=高通&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">高通</a>滤片技术的应用，解决了在夜间杂光干扰红外光问题。LED红外技术的出现，大大拓宽了监控领域的时空范畴，<a href="https://www.baidu.com/s?wd=红外摄像机&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">红外摄像机</a>得到了广泛的应用。但同时，我们也发现市场上流行的传统LED<a href="https://www.baidu.com/s?wd=红外摄像机&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">红外摄像机</a>存在着许多致命的缺陷：如散热问题、寿命问题、手电筒效应问题，夜晚可见光干扰的问题等。LED Array 技术解决了寿命问题，新一代的LED Array技术基本解决了“手电筒”效应，而IR CUT技术完美地解决了杂光干扰。</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>关、开滤光片，打开红外灯，计算平均亮度是否符合要求（155～255之间）。</p>
<h1 id="Bad-Pixel"><a href="#Bad-Pixel" class="headerlink" title="Bad Pixel"></a>Bad Pixel</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>图像坏点(Bad pixel) : 图像传感器上光线采集点(像素点)所形成的阵列存在工艺上的缺陷，或光信号进行转化为电信号的过程中出现错误，从而会造成图像上像素信息错误，导致图像中的像素值不准确，这些有缺陷的像素即为图像坏点。</p>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>根据灰度值确定坏点</p>
<h1 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>暗角一词属于摄影术语。对着亮度均匀景物，画面四角有变暗的现象，叫做“失光”，俗称“暗角”。</p>
<p>产生暗角的原因主要有：</p>
<p>1.边角的成像光线与<a href="https://baike.baidu.com/item/镜头光轴/10196349">镜头光轴</a>有较大的夹角，是造成边角失光的主要原因。沿着<a href="https://baike.baidu.com/item/视场/8231871">视场</a>边缘的光线的前进方向看<a href="https://baike.baidu.com/item/光圈/94964">光圈</a>，由于光线与光圈所在的平面有夹角，看到的光圈是椭圆的，所以通光面积减小。镜头光心到胶片的边缘距离较大，同样的光圈直径到达底片的光线夹角较小，亮度必然减小。同理，同样的光线偏角，对于边角光线位移较大，等价于照在较大的面积上。而面积是与位移的平方成正比的，所以综合上述原因，边缘亮度与光线和光轴夹角的COS值的4次方成正比。换句话说，<a href="https://baike.baidu.com/item/广角镜头/278835">广角镜头</a>边缘亮度随着视角变大急剧下降。</p>
<p>2.<a href="https://baike.baidu.com/item/长焦镜头/879928">长焦镜头</a>尤其是<a href="https://baike.baidu.com/item/变焦/9696019">变焦</a>长焦镜头镜片很多，偏离<a href="https://baike.baidu.com/item/光圈/94964">光圈</a>比较远的镜片为了能让边角光线通过，这些镜片必须很大。为了降低成本，缩小了这些镜片直径，造成边角成像光线不能完全通过，降低了边角的亮度。</p>
<p>3.边角的<a href="https://baike.baidu.com/item/像差/448364">像差</a>较大。为了提高像质，某些镜片的边缘或专门设置的光阑有意挡住部分影响成像质量的边缘光线，造成边角失光。</p>
<p><a href="https://baike.baidu.com/item/鱼眼镜头/343506">鱼眼镜头</a>虽然视角极大，但是由于边缘<a href="https://baike.baidu.com/item/放大倍率/10294653">放大倍率</a>很小，所以几乎没有边角失光。</p>
<p>高档<a href="https://baike.baidu.com/item/变焦镜头/2971419">变焦镜头</a>已经花了大的成本，可以加大某些镜片、完美地校正像差，高档长焦镜头包括变焦镜头边缘失光很小。</p>
<p>还有：<a href="https://baike.baidu.com/item/广角镜头/278835">广角镜头</a>如果使用了过多的<a href="https://baike.baidu.com/item/滤色镜/205532">滤色镜</a>，等价于增长了镜筒，可能造成边角暗角甚至黑角！</p>
<p>暗角在任何一只镜头上都存在，在MTF<a href="https://baike.baidu.com/item/透光率/1192539">透光率</a>图上可以知道，从中心到边缘会损失不少，尤其在<a href="https://baike.baidu.com/item/大光圈/8567887">大光圈</a>。在冲扩<a href="https://baike.baidu.com/item/负片/3897269">负片</a>是问题不大，因为放大头也存在这个问题，会抵消掉一部分影响，当然，如果镜头太滥，失光极其明显，那就能在照片上看出来了。</p>
<p>对于<a href="https://baike.baidu.com/item/反转片/3897682">反转片</a>，问题就严重一些，就需要仔细研究研究了，一般的现象是：广角比长焦明显一些，反正怎么样全看你的使用情况，缩小一下<a href="https://baike.baidu.com/item/光圈/94964">光圈</a>就是了。 </p>
<p>— from baike.baidu.com</p>
<h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><p>开冷光灯：分为亮度暗角和色彩暗角。</p>
<p>亮度暗角：取四个角（10 * 10像素），四个角亮度与中间块做比值，需在0.3～1之间。</p>
<p>色彩暗角：图像被分成20 * 20块，算每块的R/G、B/G，分别除以中心的R/G，四个角比值都应在0.8～1.2之间。</p>
<h1 id="清晰度测试"><a href="#清晰度测试" class="headerlink" title="清晰度测试"></a>清晰度测试</h1><p>清晰度：影像细部影纹及边界的清晰程度，摄像机一般使用分解力来衡量它分解被摄景物细节的能力，单位有TVLine、4K分辨率、8K分辨率</p>
<p>衡量分解力的三个标准：</p>
<ol>
<li><p>TVLine检测（锲形线测试），用于主观测试，ISO 12233 chart读出的线对数</p>
</li>
<li><p>MTF检测（频率线测试），调制传递函数，调制度随空间频率变化的函数，镜头的MTF曲线表明镜头的能力。</p>
<p>MTF计算线对间最亮和最暗线对的对比度</p>
<p>MTF = （最大亮度 - 最小亮度） / （最大亮度 + 最小亮度）</p>
<p>测不用频率下的MTF值，通过将这些值和空间频率进行一一对照。</p>
</li>
<li><p>SFR检测（spatial frequency response）用于测量随着空间频率的线条增加对单一影像所造成的影响。SFR是MTF的另一种测试方法。SFR最终是希望得到MTF曲线。</p>
<p>SFR不需拍不同空间频率下的线对。只需一个黑白刀口（斜边），即可换算约略相等于所有空间频率下的MTF。</p>
<p>斜边 -&gt; 超采样 -&gt; 得到黑白变换的直线（ESF） -&gt; 求导  -&gt; 直线变换率 -&gt; FFT变换  -&gt; 各个频率下的MTF值</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>ImageAlgorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java接口自动化测试</title>
    <url>/posts/252123234598/</url>
    <content><![CDATA[<h1 id="接口自动化测试开发技能"><a href="#接口自动化测试开发技能" class="headerlink" title="接口自动化测试开发技能"></a>接口自动化测试开发技能</h1><ul>
<li>测试框架：TestNG、HttpClient</li>
<li>Mock技术</li>
<li>数据持久层框架：MyBatis</li>
<li>持续集成工具：Jenkins</li>
<li>接口协议相关基础知识：HTTP协议</li>
</ul>
<a id="more"></a>
<h1 id="接口测试的范围"><a href="#接口测试的范围" class="headerlink" title="接口测试的范围"></a>接口测试的范围</h1><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><ul>
<li>等价类划分法</li>
<li>边界值分析法</li>
<li>错误推断法</li>
<li>因果图法</li>
<li>判定表驱动法</li>
<li>正交实验法</li>
<li>功能图法</li>
<li>场景法</li>
</ul>
<h1 id="TestNG"><a href="#TestNG" class="headerlink" title="TestNG"></a>TestNG</h1><h2 id="mvn依赖"><a href="#mvn依赖" class="headerlink" title="mvn依赖"></a>mvn依赖</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.testng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testng<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h2><div class="table-container">
<table>
<thead>
<tr>
<th>注释</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Test</td>
<td>一个测试方法或者测试类</td>
</tr>
<tr>
<td>@BeforeMethod</td>
<td>每个测试方法前需要执行的方法</td>
</tr>
<tr>
<td>@AfterMethod</td>
<td>每个测试方法后需要执行的方法</td>
</tr>
<tr>
<td>@BeforeClass</td>
<td>标注类运行前运行的方法</td>
</tr>
<tr>
<td>@AfterClass</td>
<td>标注类运行后运行的方法</td>
</tr>
<tr>
<td>@BeforeSuite</td>
<td>Suite可以包含多个class，类运行前运行</td>
</tr>
<tr>
<td>@AfterSuite</td>
<td>类运行后运行</td>
</tr>
<tr>
<td>@Test(enabled = false)</td>
<td>忽略执行</td>
</tr>
<tr>
<td>@BeforeGroups(“server”)</td>
<td>组测试前的测试方法</td>
</tr>
</tbody>
</table>
</div>
<h2 id="套件测试"><a href="#套件测试" class="headerlink" title="套件测试"></a>套件测试</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// LoginTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.course.testng.suite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginTest</span> </span>{</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loginTaobao</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"淘宝登陆成功"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//PayTest.java</span></span><br><span class="line"><span class="keyword">package</span> com.course.testng.suite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayTest</span> </span>{</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payAli</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"支付宝登陆成功"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//SuiteConfig.java</span></span><br><span class="line"><span class="keyword">package</span> com.course.testng.suite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.AfterSuite;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.BeforeSuite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuiteConfig</span> </span>{</span><br><span class="line">    <span class="meta">@BeforeSuite</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeSuite</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"before suite start"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@AfterSuite</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSuite</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"after suite start"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在对应的resource 文件夹下创建suite.xml文件，并指定套件和其中的执行顺序。执行这个xml，即可执行</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">suite</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"https://testng.org/testng-1.0.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">suite</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span> <span class="attr">name</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">classes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.course.testng.suite.SuiteConfig"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.course.testng.suite.PayTest"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">classes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span> <span class="attr">name</span>=<span class="string">"pay"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">classes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.course.testng.suite.SuiteConfig"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.course.testng.suite.PayTest"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">classes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">suite</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="组测试"><a href="#组测试" class="headerlink" title="组测试"></a>组测试</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.course.testng.group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.AfterGroups;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.BeforeGroups;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrouponMethod</span> </span>{</span><br><span class="line">    <span class="meta">@Test(groups = "server")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"这是服务端组的测试方法1"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(groups = "server")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"这是服务端组的测试方法2"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(groups = "client")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"这是客户端组的测试方法1"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(groups = "client")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"这是客户端组的测试方法2"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeGroups("server")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeGroupOnServer</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"这服务端组运行前的测试方法"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@AfterGroups("server")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterGroupOnServer</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"这服务端组运行后的测试方法"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="类分组测试"><a href="#类分组测试" class="headerlink" title="类分组测试"></a>类分组测试</h2><p>只运行@Test中name为stu的测试方法</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">name</span>=<span class="string">"pay"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groups</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">run</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span> = <span class="string">"stu"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">run</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">groups</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">classes</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.course.testng.suite.SuiteConfig"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.course.testng.suite.PayTest"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">classes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h2><p>在希望得到某个异常时使用</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.course.testng.suite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptedException</span> </span>{</span><br><span class="line">    <span class="comment">//这是一个会失败的异常测试</span></span><br><span class="line">    <span class="meta">@Test(expectedExceptions = RuntimeException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runtime</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"这是一个失败的异常测试"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个会成功的异常测试</span></span><br><span class="line">    <span class="meta">@Test(expectedExceptions = RuntimeException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runtime1</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"这是一个会成功的异常测试"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="依赖测试"><a href="#依赖测试" class="headerlink" title="依赖测试"></a>依赖测试</h2><p>一个方法的执行需要依赖于另一个方法成功的执行</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.course.testng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"test1 run"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(dependsOnMethods = {"test1"})</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"test2 run"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h2><h3 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.course.testng.parameter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Parameters;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterTest</span> </span>{</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Parameters({"name","age"})</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paramTest1</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"name = "</span> + name + <span class="string">"age = "</span> + age );</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>在resource文件下新建一个parameters.xml，并在xml中传入paramTest1所需参数，利用xml文档来运行测试</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">suite</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"https://testng.org/testng-1.0.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">suite</span> <span class="attr">name</span>=<span class="string">"test_param"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span> <span class="attr">name</span>=<span class="string">"param"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">classes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">parameter</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zhangssan"</span> /&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">parameter</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.course.testng.parameter.ParameterTest"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">classes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">suite</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="DataProvidor方式"><a href="#DataProvidor方式" class="headerlink" title="@DataProvidor方式"></a>@DataProvidor方式</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.course.testng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.DataProvider;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataProvidor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(dataProvider = "methodData")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"test1方法 name = "</span>+name+<span class="string">";age = "</span> + age);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(dataProvider = "methodData")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"test2方法 name = "</span>+name+<span class="string">";age = "</span> + age);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@DataProvider(name = "methodData")</span></span><br><span class="line">    <span class="keyword">public</span> Object[][] methodDataTest(Method method){</span><br><span class="line">        Object[][] result = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">"test1"</span>)){</span><br><span class="line">            result = <span class="keyword">new</span> Object[][]{</span><br><span class="line">                    {<span class="string">"zhangsan"</span>, <span class="number">20</span>},</span><br><span class="line">                    {<span class="string">"lisi"</span>,<span class="number">25</span>}</span><br><span class="line">            };</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(method.getName().equals(<span class="string">"test2"</span>)){</span><br><span class="line">            result = <span class="keyword">new</span> Object[][]{</span><br><span class="line">                    {<span class="string">"wangwu"</span>, <span class="number">50</span>},</span><br><span class="line">                    {<span class="string">"zhaoliu"</span>, <span class="number">60</span>}</span><br><span class="line">            };</span><br><span class="line">            </span><br><span class="line">        };</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="多线程测试"><a href="#多线程测试" class="headerlink" title="多线程测试"></a>多线程测试</h2><h3 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h3><p>@Test(invocationCount = 10, threadPoolSize = 3)</p>
<h3 id="xml实现"><a href="#xml实现" class="headerlink" title="xml实现"></a>xml实现</h3><p>tests级别：不同的test tag下的用例可以在不同的线程下执行；相同的test tag下的用例只能在相同的线程下执行</p>
<p>class级别：相同的class tag下的用例在同一个线程中去执行；不同的class tag下的用例可以在不同线程中去执行</p>
<p>methods级别：所有用例都可以在不同的线程下去执行</p>
<p>thread-count：代表了最大并发线程数</p>
<p>xml文件配置这种方式不能指定线程池，只有方法上才可以指定线程池</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">suite</span> <span class="attr">name</span>=<span class="string">"thread"</span> <span class="attr">parallel</span> = <span class="string">"tests"</span> <span class="attr">threads-count</span> = <span class="string">"2"</span> &gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="超时测试"><a href="#超时测试" class="headerlink" title="超时测试"></a>超时测试</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.course.testng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutTest</span> </span>{</span><br><span class="line">    <span class="meta">@Test(timeOut = 3000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSuccess</span> <span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"超时测试"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(timeOut = 2000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFail</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"超时测试"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="忽略测试"><a href="#忽略测试" class="headerlink" title="忽略测试"></a>忽略测试</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IgnoreTest</span></span>{</span><br><span class="line">  <span class="meta">@Test(enabled = false)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ignore</span><span class="params">()</span></span>{</span><br><span class="line">    System.out.println(<span class="string">"忽略测试"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Mock框架"><a href="#Mock框架" class="headerlink" title="Mock框架"></a>Mock框架</h1><p>Mock框架是github上的一个开源项目，用于模拟各种HTTP请求。下载</p>
<p>moco-runner-0.11.0-standalone.jar</p>
<figure class="highlight http"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">https://repo1.maven.org/maven2/com/github/dreamhead/moco-runner/0.11.0/</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Mock的启动"><a href="#Mock的启动" class="headerlink" title="Mock的启动"></a>Mock的启动</h2><p>例如如下命令来启动</p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">java -jar ./moco-runner-<span class="number">0.11</span><span class="number">.0</span>-standalone.jar http -p <span class="number">8899</span> -c startup.json</span><br></pre></td></tr></tbody></table></figure>
<p>startup.json如下</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"first mock sample"</span>,</span><br><span class="line">    <span class="attr">"request"</span>: {</span><br><span class="line">      <span class="attr">"uri"</span>: <span class="string">"/demo"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"response"</span>: {</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"first mock demo"</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p>可在浏览器中打开如下网址</p>
<figure class="highlight http"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">http://127.0.0.1:8899/demo</span></span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Java/AutomationTest/firstmockdemo.png" alt="mock demo"></p>
<h2 id="在mock中配置get请求"><a href="#在mock中配置get请求" class="headerlink" title="在mock中配置get请求"></a>在mock中配置get请求</h2><p>startupget.json里面用于模拟一个get请求</p>
<ul>
<li>下面是一个不带参数的get请求</li>
</ul>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"mock a get request"</span>,</span><br><span class="line">    <span class="attr">"request"</span>: {</span><br><span class="line">      <span class="attr">"uri"</span>: <span class="string">"/getdemo"</span>,</span><br><span class="line">      <span class="attr">"method"</span>: <span class="string">"get"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"response"</span>: {</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"这是一个没有参数的get请求"</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -jar ./moco-runner-0.11.0-standalone.jar http -p 8899 -c startupget.json</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight http"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">http://127.0.0.1:8899/getdemo</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>下面是一个带参数的get请求</li>
</ul>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"mock a get request"</span>,</span><br><span class="line">    <span class="attr">"request"</span>: {</span><br><span class="line">      <span class="attr">"uri"</span>: <span class="string">"/getwithparam"</span>,</span><br><span class="line">      <span class="attr">"method"</span>: <span class="string">"get"</span>,</span><br><span class="line">      <span class="attr">"queries"</span>: {</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"hi"</span>,</span><br><span class="line">        <span class="attr">"age"</span>: <span class="string">"18"</span></span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"response"</span>: {</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"这是一个带参数的get请求"</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p>请求</p>
<figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">http://127.0.0.1:8899/getwithparam?name=hi&amp;age=18</span><br></pre></td></tr></tbody></table></figure>
<h2 id="在mock中配置post请求"><a href="#在mock中配置post请求" class="headerlink" title="在mock中配置post请求"></a>在mock中配置post请求</h2><ul>
<li>不带参数的post请求</li>
</ul>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"mock a post request"</span>,</span><br><span class="line">    <span class="attr">"request"</span>: {</span><br><span class="line">      <span class="attr">"uri"</span>: <span class="string">"/getdemo"</span>,</span><br><span class="line">      <span class="attr">"method"</span>: <span class="string">"post"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"response"</span>: {</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"这是一个没有参数的post请求"</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p>因为浏览器中只能输入get请求，所以我们用insomina或者postman来模拟post请求</p>
<ol>
<li>启动服务</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">java -jar ./moco-runner-0.11.0-standalone.jar http -p 8899 -c startuppost.json</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>insomina发出post请求</li>
</ol>
<p><img data-src="/images/Java/AutomationTest/mockpost.png" alt="insomina mock post"></p>
<ul>
<li>带参数的post请求</li>
</ul>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"mock a post request"</span>,</span><br><span class="line">    <span class="attr">"request"</span>: {</span><br><span class="line">      <span class="attr">"uri"</span>: <span class="string">"/getdemo"</span>,</span><br><span class="line">      <span class="attr">"method"</span>: <span class="string">"post"</span>,</span><br><span class="line">      <span class="attr">"forms"</span>: {</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"hi"</span>,</span><br><span class="line">        <span class="attr">"age"</span>: <span class="string">"18"</span></span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"response"</span>: {</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"这是一个带参数的post请求"</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="带cookies信息的get请求"><a href="#带cookies信息的get请求" class="headerlink" title="带cookies信息的get请求"></a>带cookies信息的get请求</h2><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"mock a get request with cookies"</span>,</span><br><span class="line">    <span class="attr">"request"</span>: {</span><br><span class="line">      <span class="attr">"uri"</span>: <span class="string">"/get/with/cookies"</span>,</span><br><span class="line">      <span class="attr">"method"</span>: <span class="string">"get"</span>,</span><br><span class="line">      <span class="attr">"cookies"</span>:{</span><br><span class="line">        <span class="attr">"login"</span>:<span class="string">"true"</span></span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"response"</span>: {</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"这是一个带cookies的get请求"</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="带cookies、body信息的post请求"><a href="#带cookies、body信息的post请求" class="headerlink" title="带cookies、body信息的post请求"></a>带cookies、body信息的post请求</h2><p>其中json内的信息需要加到body里</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"mock a post request with cookies"</span>,</span><br><span class="line">    <span class="attr">"request"</span>: {</span><br><span class="line">      <span class="attr">"uri"</span>: <span class="string">"/post/with/cookies"</span>,</span><br><span class="line">      <span class="attr">"method"</span>: <span class="string">"post"</span>,</span><br><span class="line">      <span class="attr">"cookies"</span>:{</span><br><span class="line">        <span class="attr">"login"</span>:<span class="string">"true"</span></span><br><span class="line">      },</span><br><span class="line">      <span class="attr">"json"</span>: {</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"grace"</span>,</span><br><span class="line">        <span class="attr">"age"</span>: <span class="string">"18"</span></span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"response"</span>: {</span><br><span class="line">      <span class="attr">"status"</span>: <span class="number">200</span>,</span><br><span class="line">      <span class="attr">"json"</span>: {</span><br><span class="line">      	<span class="attr">"isSuccess"</span>: <span class="string">"success"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">1</span></span><br><span class="line">    	}</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="带有headers信息的mock请求"><a href="#带有headers信息的mock请求" class="headerlink" title="带有headers信息的mock请求"></a>带有headers信息的mock请求</h2><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"mock a post request with headers"</span>,</span><br><span class="line">    <span class="attr">"request"</span>: {</span><br><span class="line">      <span class="attr">"uri"</span>: <span class="string">"/post/with/headers"</span>,</span><br><span class="line">      <span class="attr">"method"</span>: <span class="string">"post"</span>,</span><br><span class="line">      <span class="attr">"headers"</span>:{</span><br><span class="line">        <span class="attr">"content-type"</span>:<span class="string">"application/json"</span></span><br><span class="line">      },</span><br><span class="line">      <span class="attr">"json"</span>:{</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"grace"</span>,</span><br><span class="line">        <span class="attr">"gender"</span>: <span class="string">"woman"</span></span><br><span class="line">      }</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"response"</span>: {</span><br><span class="line">      <span class="attr">"json"</span>: {</span><br><span class="line">        <span class="attr">"isSuccess"</span>: <span class="string">"success"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="string">"1"</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="实现请求重定向"><a href="#实现请求重定向" class="headerlink" title="实现请求重定向"></a>实现请求重定向</h2><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"mock a redirect request"</span>,</span><br><span class="line">    <span class="attr">"request"</span>: {</span><br><span class="line">      <span class="attr">"uri"</span>: <span class="string">"/redirect"</span>,</span><br><span class="line">      <span class="attr">"redirectTo"</span>: <span class="string">"http://www.baidu.com"</span></span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"重定向的请求"</span>,</span><br><span class="line">    <span class="attr">"request"</span>: {</span><br><span class="line">      <span class="attr">"uri"</span>: <span class="string">"/redirect/toPath"</span>,</span><br><span class="line">      <span class="attr">"redirectTo"</span>: <span class="string">"/redirect/new"</span></span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">   {</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"被重定向的请求"</span>,</span><br><span class="line">    <span class="attr">"request"</span>: {</span><br><span class="line">      <span class="attr">"uri"</span>: <span class="string">"/redirect/new"</span>,</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"response"</span>:{</span><br><span class="line">      <span class="attr">"test"</span>: <span class="string">"重定向成功"</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<h1 id="HTTP协议接口"><a href="#HTTP协议接口" class="headerlink" title="HTTP协议接口"></a>HTTP协议接口</h1><h2 id="常用请求头"><a href="#常用请求头" class="headerlink" title="常用请求头"></a>常用请求头</h2><p>Accept：浏览器告诉服务器它所支持的数据类型</p>
<p>Accept-Charset：浏览器告诉服务器它采用的字符集</p>
<p>Accept-Encoding：浏览器告诉服务器它所支持的压缩格式</p>
<p>Accept-Language：浏览器告诉服务器它所支持的语言</p>
<p>Host：浏览器告诉服务器它想访问的主机</p>
<p>If-Modified-Since：浏览器告诉服务器它缓存数据的时间</p>
<p>Referer：浏览器告诉服务器是从哪个网页而来（防盗链）</p>
<p>User-Agent：浏览器告诉服务器所使用的浏览器类型、版本等信息</p>
<p>Date：浏览器告诉服务器访问时间</p>
<h2 id="常用响应头"><a href="#常用响应头" class="headerlink" title="常用响应头"></a>常用响应头</h2><p>Location：服务器告知浏览器你去找谁，配合302状态码使用</p>
<p>Server：浏览器的类型</p>
<p>Content-Encoding：数据的压缩格式</p>
<p>Content-Type：回送数据的地址</p>
<p>Last-Modified：数据的最后修改时间</p>
<p>Refresh：控制浏览器定时刷新</p>
<p>Content-Disposition：需要以下载方式打开回送的数据</p>
<p>Transfer-Encoding：浏览器数据是以分块形式回送的</p>
<h2 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h2><ul>
<li>cookie存储在客户端的头信息中</li>
<li>session在服务端存储，文件、数据库都可以</li>
<li>session的验证需要cookie带一个字段来表示这个用户是哪个session，当客户端禁用cookie时，session将失效</li>
<li>cookie的格式为key:value; key:value</li>
<li>cookie的值由服务端生成，客户端保存</li>
</ul>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Java Automation Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka初探</title>
    <url>/posts/252123/</url>
    <content><![CDATA[<h1 id="Kafka的设计和结构"><a href="#Kafka的设计和结构" class="headerlink" title="Kafka的设计和结构"></a>Kafka的设计和结构</h1><h2 id="Kafka基本概念"><a href="#Kafka基本概念" class="headerlink" title="Kafka基本概念"></a>Kafka基本概念</h2><ul>
<li><p>Producer：消息和数据的生产者，向Kafka的一个Topic发布消息的进程/代码/服务</p>
</li>
<li><p>Consumer：消息和数据的消费者，订阅数据(Topic)并且处理其发布的消息的进程/代码/服务</p>
</li>
<li><p>Consumer Group：逻辑概念，对于同一个Topic，会广播给不同的group，一个group中，只有一个Consumer可以消费该消息</p>
</li>
<li><p>Broker：物理概念，Kafka集群中的每个Kafka节点</p>
</li>
<li><p>Topic：逻辑概念，Kafka消息的类别，对数据进行分区、隔离</p>
</li>
<li><p>Partition：物理概念，Kafka下数据存储的基本单元，一个Topic数据，会被分散存储到多个Partition，每一个Partition是有序的</p>
</li>
<li><p>Replication：同一个Partition可能会有多个Replica，多个Replica之间数据是一样的</p>
</li>
<li><p>Replication Leader：一个Partition的多个Replica上，需要一个Leader负责该Partition上与Producer和Consumer交互</p>
</li>
<li><p>Replica Manager：负责管理当前Broker所有分区和副本的信息，处理Kafka Controller发起的一些请求，副本状态的切换、添加/读取消息等</p>
</li>
</ul>
<h2 id="Kafka基本结构"><a href="#Kafka基本结构" class="headerlink" title="Kafka基本结构"></a>Kafka基本结构</h2><ul>
<li>Produer Api</li>
<li>Consumer Api</li>
<li>Streams Api</li>
<li>Connectors Api</li>
</ul>
<p><img data-src="/images/kafka/KafkaBaseStruct.png" alt="KafkaBaseStruct"></p>
<p>Kafka消费架构</p>
<p><img data-src="/images/kafka/KafkaConsumeStruct.png" alt="KafkaConsumeStruct"></p>
<p>Kafka消息结构</p>
<p><img data-src="/images/kafka/MessageStruct.png" alt="MessageStruct"></p>
<h1 id="Kafka应用场景"><a href="#Kafka应用场景" class="headerlink" title="Kafka应用场景"></a>Kafka应用场景</h1><ul>
<li>消息队列</li>
<li>行为跟踪</li>
<li>元信息监控</li>
<li>日志收集</li>
<li>流处理</li>
<li>事件源</li>
<li>持久性日志</li>
</ul>
<h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><ul>
<li><p>ZooKeeper下载：</p>
<p><a href="http://zookeeper.apache.org/releases.html#download">http://zookeeper.apache.org/releases.html#download</a></p>
</li>
<li><p>Kafka下载：</p>
<p><a href="http://kafka.apache.org/downloads">http://kafka.apache.org/downloads</a></p>
</li>
<li><p>安装：解压，配置环境变量</p>
</li>
<li><p>Mac便捷安装：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">brew install kafka</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Kafka高级特性"><a href="#Kafka高级特性" class="headerlink" title="Kafka高级特性"></a>Kafka高级特性</h1></li>
</ul>
<h2 id="消息事务"><a href="#消息事务" class="headerlink" title="消息事务"></a>消息事务</h2><h3 id="为什么要支持事务"><a href="#为什么要支持事务" class="headerlink" title="为什么要支持事务"></a>为什么要支持事务</h3><ul>
<li>满足“读取-处理-写入”模式</li>
<li>流处理需求的不断增强</li>
<li>不准确的数据处理的容忍度</li>
</ul>
<h3 id="数据传输的事务定义"><a href="#数据传输的事务定义" class="headerlink" title="数据传输的事务定义"></a>数据传输的事务定义</h3><ul>
<li>最多一次：消息不会被重复发送，最多被传输一次，但也有可能一次不传输</li>
<li>最少一次：消息不会被漏发送，最少被传输一次，但也有可能被重复传输</li>
<li>精确的一次：不会漏传输也不会重复传输，每个消息都传输一次且仅仅被传输一次，这是大家希望的</li>
</ul>
<h3 id="Kafka消息事务"><a href="#Kafka消息事务" class="headerlink" title="Kafka消息事务"></a>Kafka消息事务</h3><ul>
<li>事务保证<ul>
<li>内部重试问题：Procedure幂等处理</li>
<li>多分区原子写入</li>
</ul>
</li>
<li>事务保证 — 避免僵尸实例<ul>
<li>每个事务Producer分配一个transactional.id，在进程重新启动时能够识别相同的Producer实例</li>
<li>Kafka增加了一个与transactional.id相关的epoch，存储每个transaction.id内部元数据</li>
<li>一旦epoch被触发，任何具有相同的transactional.id和更旧的epoch的Producer被视为僵尸，Kafka会拒绝来自这些Producer的后续事务性写入</li>
</ul>
</li>
</ul>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h3 id="零拷贝简介"><a href="#零拷贝简介" class="headerlink" title="零拷贝简介"></a>零拷贝简介</h3><p>文件传输网络的公共数据路径</p>
<ul>
<li>操作系统将数据从<strong>磁盘</strong>读入到<strong>内核空间的页缓存</strong></li>
<li>应用程序将数据从<strong>内核空间</strong>读入到<strong>用户空间缓存</strong>中</li>
<li>应用程序将数据写回到<strong>内核空间到socket缓存</strong>中</li>
<li>操作系统将数据从socket缓存区复制到<strong>网卡缓冲区</strong>，以便将数据经网络发出</li>
</ul>
<p>零拷贝过程</p>
<ul>
<li>操作系统将数据从<strong>磁盘</strong>读入到<strong>内核空间的页缓存</strong></li>
<li>将数据的位置和长度的信息描述符增加至<strong>内核空间</strong>（socket缓冲区）</li>
<li>操作系统直接将数据从内核空间拷贝到<strong>网卡缓冲区</strong>，以便将数据经网络发出</li>
</ul>
<p><img data-src="/images/kafka/0Copy.png" alt="0Copy"></p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning基础</title>
    <url>/posts/59544/</url>
    <content><![CDATA[<p><img data-src="/images/MachineLearning/MLMindNode.png" alt="MLMindNode"></p>
<a id="more"></a>
<h1 id="Introduction-of-Machine-Learning"><a href="#Introduction-of-Machine-Learning" class="headerlink" title="Introduction of Machine Learning"></a>Introduction of Machine Learning</h1><p>机器学习可以揭示数据背后的真实含义。</p>
<p><strong>监督学习</strong>需要用户知道目标值，简单的说就是知道数据在找什么。而<strong>无监督学习</strong>则无需用户知道搜寻的目标，只需要从算法程序中得到这些数据的共同特征。</p>
<p>保证算法应用的正确性：</p>
<ol>
<li>确保算法应用可以正确处理简单的数据。</li>
<li>将现实世界中得到的数据格式化为算法可以处理的格式。</li>
<li>将步骤2得到的数据输入到步骤1的算法中，检验算法的运行结果。</li>
</ol>
<p>千万不要忽略前两个步骤而直接跳到步骤3来检验算法处理真实数据的效果。任何复杂系统都是由基础工程构成的，尤其是算法出现问题时，增量地搭建系统可以确保我们及时找到问题出现的位置和原因。</p>
<p>后续根据监督学习和无监督学习进行分类讨论。</p>
<p>在监督学习中，我们只需要给定输入样本，机器就可以从中推演出指定目标变量的可能结果。监督学习相对比较简单，机器只需从输入数据中预测合适的模型，并从中计算出目标变量的结果。</p>
<p>监督学习一般使用两种类型的目标变量：标称型和数值型。<strong>标称型</strong>目标变量的结果只在有限目标集中取值，如真与假，动物分类集合；<strong>数值型</strong>目标变量则可以从无限的数值集合中取值，一般用于回归分析。</p>
<h2 id="Key-Terminology"><a href="#Key-Terminology" class="headerlink" title="Key Terminology"></a>Key Terminology</h2><p>我们使用机器学习的某个算法进行分类结果，首先要做的是<strong>算法训练</strong>，即学习如何<strong>分类</strong>。通常我们为算法输入大量的已分类数据作为算法的<strong>训练集</strong>。训练集是用于训练机器学习算法的数据样本集合。<strong>目标变量</strong>是机器学习算法的预测结果。</p>
<p>在分类算法中目标变量的类型通常是标称型的，而在回归算法中通常是连续型的。</p>
<p>训练样本集必须确定知道目标变量的值，以便机器学习算法可以发现特征和目标变量之间的关系。</p>
<p>当机器学习程序开始运行时，使用训练样本集作为算法的输入，<strong>训练完成</strong>后输入<strong>测试样本</strong>，由程序决定样本属于哪个类别。</p>
<h2 id="Primary-Mission"><a href="#Primary-Mission" class="headerlink" title="Primary Mission"></a>Primary Mission</h2><p>监督学习中的任务：</p>
<p>1.将实例数据划分到合适的<strong>分类</strong>中。</p>
<p>2.<strong>回归</strong>，主要用于预测数值型数据。</p>
<p>无监督学习中的任务：</p>
<p>数据没有类别信息，也不会给定目标值。</p>
<p>1.在无监督学习中，将数据集合分成由类似的对象组成的多个类的过程被称为<strong>聚类</strong>。</p>
<p>2.将寻找描述数据统计值的过程称之为<strong>密度估计</strong>。</p>
<h2 id="Overview-of-Algorithm"><a href="#Overview-of-Algorithm" class="headerlink" title="Overview of Algorithm"></a>Overview of Algorithm</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">监督学习的用途</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">K-近邻算法</td>
<td style="text-align:center">线性回归</td>
</tr>
<tr>
<td style="text-align:center">朴素贝叶斯算法</td>
<td style="text-align:center">局部加权线性回归</td>
</tr>
<tr>
<td style="text-align:center">支持向量机</td>
<td style="text-align:center">Ridge回归</td>
</tr>
<tr>
<td style="text-align:center">决策树</td>
<td style="text-align:center">Lasso最小回归系数估计</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">无监督学习的用途</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">K-均值</td>
<td style="text-align:center">最大期望算法</td>
</tr>
<tr>
<td style="text-align:center">DBSCAN</td>
<td style="text-align:center">Parzen窗设计</td>
</tr>
</tbody>
</table>
</div>
<h2 id="How-to-choose"><a href="#How-to-choose" class="headerlink" title="How to choose"></a>How to choose</h2><p>首先考虑使用机器学习算法的目的。如果想要预测目标变量的值，则可以选择监督学习算法，否则选择无监督学习算法。</p>
<p>如果确定选择监督学习算法后，需要进一步确定目标变量类型。</p>
<ul>
<li>如果目标变量是离散型，如是／否，1/2/3，红／黄／黑等，则可以选择<strong>分类算法</strong>。</li>
<li>如果目标变量是连续型的数值，则需要选择<strong>回归算法</strong>。</li>
</ul>
<p>如果不想预测目标变量的值，则可以选择无监督学习算法。</p>
<ul>
<li>需要将数据划分为离散的组。如果这是唯一的需求，则使用<strong>聚类算法</strong>。</li>
<li>需要估计数据与每个分组的相似程度，需要使用<strong>密度估计算法。</strong></li>
</ul>
<h2 id="Steps-in-Machine-Learning"><a href="#Steps-in-Machine-Learning" class="headerlink" title="Steps in Machine Learning"></a>Steps in Machine Learning</h2><ol>
<li>收集数据</li>
<li>准备输入数据</li>
<li>分析输入数据。确保数据集中没有垃圾数据。</li>
<li><strong>训练算法</strong>（监督学习）</li>
<li>测试算法。</li>
<li>使用算法。将机器学习算法转化为应用程序，执行实际任务。</li>
</ol>
<h1 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h1><h2 id="损失函数-目标函数"><a href="#损失函数-目标函数" class="headerlink" title="损失函数(目标函数)"></a>损失函数(目标函数)</h2><h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><ol>
<li>平方差损失函数</li>
</ol>
<script type="math/tex; mode=display">\frac{1}{n}\sum\frac{1}{2}(y - Model(x))^2</script><ol>
<li>交叉熵损失</li>
</ol>
<p>多用于多分类</p>
<script type="math/tex; mode=display">\frac{1}{n}\sum yln(Model(x))</script><h3 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h3><ol>
<li>平方差损失函数</li>
</ol>
<script type="math/tex; mode=display">\frac{1}{n}\sum\frac{1}{2}(y - Model(x))^2</script><ol>
<li>绝对值损失</li>
</ol>
<script type="math/tex; mode=display">\frac{1}{n}\sum|y - Model(x)|</script><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><h2 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h2><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><h2 id="梯度验证"><a href="#梯度验证" class="headerlink" title="梯度验证"></a>梯度验证</h2><h2 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h2><h2 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h2><h2 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h2><h1 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h1><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><h2 id="A-B测试"><a href="#A-B测试" class="headerlink" title="A/B测试"></a>A/B测试</h2><h2 id="过拟合于欠拟合"><a href="#过拟合于欠拟合" class="headerlink" title="过拟合于欠拟合"></a>过拟合于欠拟合</h2><h2 id="超参数选择"><a href="#超参数选择" class="headerlink" title="超参数选择"></a>超参数选择</h2><h1 id="DeepLearning-Model"><a href="#DeepLearning-Model" class="headerlink" title="DeepLearning Model"></a>DeepLearning Model</h1><h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2><p>移步☞博文：<a href="https://unknown.yuzhouwan.com/posts/16452/">CNN</a></p>
<h2 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h2><h2 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h2><h2 id="AutoML"><a href="#AutoML" class="headerlink" title="AutoML"></a>AutoML</h2><h2 id="深度学习优化技巧"><a href="#深度学习优化技巧" class="headerlink" title="深度学习优化技巧"></a>深度学习优化技巧</h2><h3 id="批量归一化BN"><a href="#批量归一化BN" class="headerlink" title="批量归一化BN"></a>批量归一化BN</h3><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><h4 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h4><p>二分类逻辑回归模型</p>
<script type="math/tex; mode=display">f(x)=\frac{1}{1+e^{-W^TX}}</script><p><img data-src="/images/Python-base/DataView_Sigmoid.png" alt="DataView_Sigmoid"></p>
<h4 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h4><p>多分类逻辑回归模型</p>
<p><script type="math/tex">P(Y=k|x)=\frac{e^{-W^T_kx}}{1+\sum_{1}^{k-1}e^{-W^T_kX}}</script>, k=1,2,…..,K-1</p>
<p><script type="math/tex">P(Y=k|x)=\frac{1}{1+\sum_{1}^{k-1}e^{-W^T_kX}}</script>, k=K</p>
<h4 id="Tanh"><a href="#Tanh" class="headerlink" title="Tanh"></a>Tanh</h4><h4 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h4>]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>AI中的数学知识</title>
    <url>/posts/59545/</url>
    <content><![CDATA[<h1 id="线性代数部分"><a href="#线性代数部分" class="headerlink" title="线性代数部分"></a>线性代数部分</h1><h2 id="矩阵及其运算合集"><a href="#矩阵及其运算合集" class="headerlink" title="矩阵及其运算合集"></a>矩阵及其运算合集</h2><a id="more"></a>
<h2 id="矩阵的行列式"><a href="#矩阵的行列式" class="headerlink" title="矩阵的行列式"></a>矩阵的行列式</h2><h2 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h2><h2 id="矩阵的初等变换"><a href="#矩阵的初等变换" class="headerlink" title="矩阵的初等变换"></a>矩阵的初等变换</h2><h2 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h2><h2 id="矩阵的特征值和特征向量"><a href="#矩阵的特征值和特征向量" class="headerlink" title="矩阵的特征值和特征向量"></a>矩阵的特征值和特征向量</h2><h2 id="矩阵对角化二次型"><a href="#矩阵对角化二次型" class="headerlink" title="矩阵对角化二次型"></a>矩阵对角化二次型</h2><h2 id="SVD分解的证明"><a href="#SVD分解的证明" class="headerlink" title="SVD分解的证明"></a>SVD分解的证明</h2><h2 id="SVD的应用与多元线性回归"><a href="#SVD的应用与多元线性回归" class="headerlink" title="SVD的应用与多元线性回归"></a>SVD的应用与多元线性回归</h2><h1 id="微积分部分"><a href="#微积分部分" class="headerlink" title="微积分部分"></a>微积分部分</h1><h2 id="导数中的中值定理"><a href="#导数中的中值定理" class="headerlink" title="导数中的中值定理"></a>导数中的中值定理</h2><h2 id="泰勒公式函数极值定积分"><a href="#泰勒公式函数极值定积分" class="headerlink" title="泰勒公式函数极值定积分"></a>泰勒公式函数极值定积分</h2><h2 id="多元微积分"><a href="#多元微积分" class="headerlink" title="多元微积分"></a>多元微积分</h2><h1 id="概率论部分"><a href="#概率论部分" class="headerlink" title="概率论部分"></a>概率论部分</h1><h2 id="概率基础"><a href="#概率基础" class="headerlink" title="概率基础"></a>概率基础</h2><h2 id="随机变量与多维随机变量"><a href="#随机变量与多维随机变量" class="headerlink" title="随机变量与多维随机变量"></a>随机变量与多维随机变量</h2><h2 id="期望与方差"><a href="#期望与方差" class="headerlink" title="期望与方差"></a>期望与方差</h2><h2 id="参数的估计"><a href="#参数的估计" class="headerlink" title="参数的估计"></a>参数的估计</h2><h1 id="最优化理论"><a href="#最优化理论" class="headerlink" title="最优化理论"></a>最优化理论</h1><h2 id="无约束最优化"><a href="#无约束最优化" class="headerlink" title="无约束最优化"></a>无约束最优化</h2><h2 id="带约束的最优化"><a href="#带约束的最优化" class="headerlink" title="带约束的最优化"></a>带约束的最优化</h2><h2 id="对偶理论"><a href="#对偶理论" class="headerlink" title="对偶理论"></a>对偶理论</h2>]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy基础</title>
    <url>/posts/21763/</url>
    <content><![CDATA[<p>Numpy是Python中用于科学计算的核心库。它提供了高性能的多维数组对象，以及相关工具</p>
<h1 id="绘制雪花"><a href="#绘制雪花" class="headerlink" title="绘制雪花"></a>绘制雪花</h1><p>转自博客上看到的一位大牛的程序，利用Numpy + matplotlib 绘制雪花，效果如下：</p>
<p><img data-src="/images/snow.jpg" alt="snow"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'FangSong'</span>]  <span class="comment"># 指定默认字体</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>  <span class="comment"># 解决中文显示为方块的问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">p, d</span>):</span></span><br><span class="line">    <span class="string">"""返回点p绕原点逆时针旋转d度的坐标"""</span></span><br><span class="line"></span><br><span class="line">    a = np.radians(d)</span><br><span class="line">    m = np.array([[np.cos(a), np.sin(a)], [-np.sin(a), np.cos(a)]])</span><br><span class="line">    <span class="keyword">return</span> np.dot(p, m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">koch_curve</span>(<span class="params">p, q</span>):</span></span><br><span class="line">    <span class="string">"""将线段pq生成科赫曲线，返回uvw三个点"""</span></span><br><span class="line"></span><br><span class="line">    p, q = np.array(p), np.array(q)</span><br><span class="line">    u = p + (q - p) / <span class="number">3</span>  <span class="comment"># 三等分点u的坐标</span></span><br><span class="line">    v = q - (q - p) / <span class="number">3</span>  <span class="comment"># 三等分点V的坐标</span></span><br><span class="line">    w = rotate(v - u, <span class="number">60</span>) + u  <span class="comment"># 线段uv绕u点逆时针旋转60°得到点w的坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> u.tolist(), v.tolist(), w.tolist()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snow</span>(<span class="params">triangle, k</span>):</span></span><br><span class="line">    <span class="string">"""给定三角形，生成封闭的科赫雪花"""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        result = <span class="built_in">list</span>()</span><br><span class="line">        t_len = <span class="built_in">len</span>(triangle)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(t_len):</span><br><span class="line">            p = triangle[j]</span><br><span class="line">            q = triangle[(j + <span class="number">1</span>) % t_len]</span><br><span class="line">            u, v, w = koch_curve(p, q)</span><br><span class="line">            result.extend([p, u, w, v])</span><br><span class="line">        triangle = result.copy()</span><br><span class="line"></span><br><span class="line">    triangle.append(triangle[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> triangle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_snow</span>(<span class="params">snow_list</span>):</span></span><br><span class="line">    <span class="string">"""绘制雪花"""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> triangle, k <span class="keyword">in</span> snow_list:</span><br><span class="line">        data = np.array(snow(triangle, k))</span><br><span class="line">        x, y = np.split(data, <span class="number">2</span>, axis=<span class="number">1</span>)</span><br><span class="line">        plt.plot(x, y)</span><br><span class="line"></span><br><span class="line">    plt.axis(<span class="string">'equal'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">snow_list = [</span><br><span class="line">    ([(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0.5</span>, <span class="number">0.8660254</span>), (<span class="number">1</span>, <span class="number">0</span>)], <span class="number">5</span>),</span><br><span class="line">    ([(<span class="number">1.1</span>, <span class="number">0.4</span>), (<span class="number">1.35</span>, <span class="number">0.8330127</span>), (<span class="number">1.6</span>, <span class="number">0.4</span>)], <span class="number">4</span>),</span><br><span class="line">    ([(<span class="number">1.1</span>, -<span class="number">0.1</span>), (<span class="number">1.25</span>, <span class="number">0.15980761</span>), (<span class="number">1.4</span>, -<span class="number">0.1</span>)], <span class="number">3</span>)</span><br><span class="line">]</span><br><span class="line">plot_snow(snow_list)</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>
<h1 id="数组Arrays"><a href="#数组Arrays" class="headerlink" title="数组Arrays"></a>数组Arrays</h1><p>numpy数组是一个由不同数值组成的网格。网格中的数据都是<strong>同一种数据类型</strong>，可以通过非负整型数的元组来访问。</p>
<p>我们可以从列表创建数组，然后利用方括号访问其中的元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])   <span class="comment">#创建一个一维数组</span></span><br><span class="line">print(<span class="built_in">type</span>(a))</span><br><span class="line">print(a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>])</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br><span class="line"><span class="class">1 2 3</span></span><br><span class="line"><span class="class">[5 2 3]</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="函数shape-用法"><a href="#函数shape-用法" class="headerlink" title="函数shape()用法"></a>函数shape()用法</h1><p>shape函数功能室查看矩阵或者数组的<strong>维度</strong>。</p>
<p>例如：建立一个3✖3的单位矩阵e，e.shape()为（3，3），<strong>表示三行三列</strong>，第一维的长度是3，第二维的长度也是3。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">e = np.eye(<span class="number">3</span>)</span><br><span class="line">print(e)</span><br><span class="line">print(e.shape)</span><br><span class="line">print(e[<span class="number">0</span>,<span class="number">0</span>],e[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>]]</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1.0</span> <span class="number">1.0</span></span><br></pre></td></tr></tbody></table></figure>
<p>建立一个一维矩阵b，b.shape为矩阵的长度。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(b.shape)</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>,)</span><br></pre></td></tr></tbody></table></figure>
<p>建立一个4✖2的矩阵c，c.shape[1]为第一维的长度，c.shape[0]为第二维的长度，c.shape[1]为第一维的长度。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">9</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">0</span>]])</span><br><span class="line">print(c.shape[<span class="number">0</span>])</span><br><span class="line">print(c.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>
<p>一个单独的数值，返回值为空。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">np.shape(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">()</span><br></pre></td></tr></tbody></table></figure>
<h1 id="其他创建数组的方法"><a href="#其他创建数组的方法" class="headerlink" title="其他创建数组的方法"></a>其他创建数组的方法</h1><p>Numpy还提供了很多其他创建数组的方法：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">3</span>))        <span class="comment">#创建一个2✖️3全0数组</span></span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">b = np.ones((<span class="number">1</span>,<span class="number">2</span>))         <span class="comment">#创建一个1✖️2全1数组</span></span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">c = np.full((<span class="number">4</span>,<span class="number">2</span>),<span class="number">7</span>)       <span class="comment">#创建一个4✖️2的全7数组</span></span><br><span class="line">print(c)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">d = np.eye(<span class="number">2</span>)              <span class="comment">#创建一个二维单位矩阵</span></span><br><span class="line">print(d)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">e = np.random.random((<span class="number">2</span>,<span class="number">2</span>))<span class="comment">#创建一个2✖️2由随机数字组成的数组</span></span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line">[[ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">1.</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[<span class="number">7</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[ <span class="number">0.82662589</span>  <span class="number">0.93604335</span>]</span><br><span class="line"> [ <span class="number">0.20764393</span>  <span class="number">0.53211415</span>]]</span><br></pre></td></tr></tbody></table></figure>
<h1 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h1><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片：和Python列表类似，numpy数组可以使用切片语法。因为数组是多维的，所以必须为每个维度指定好切片。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个3✖️4的数组</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用切片来截取前两行，第1到2列。注意这里“：2”是第0，1行，不包含第二行，与range()相同</span></span><br><span class="line">b = a[:<span class="number">2</span>,<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#切片是原数组的一部分，所以改变切片，原数组也会改变</span></span><br><span class="line">print(a[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">77</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">6</span> <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line">[[ <span class="number">1</span> <span class="number">77</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]]</span><br></pre></td></tr></tbody></table></figure>
<p>你可以<strong>同时使用整型和切片语法来访问数组</strong>。但是，这样<strong>会产生一个比原数组低阶的新数组。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#3✖️4</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">print(a)</span><br><span class="line">print(a.shape)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">row_r1 = a[<span class="number">1</span>,:]</span><br><span class="line">row_r2 = a[<span class="number">1</span>:<span class="number">2</span>,:]</span><br><span class="line"></span><br><span class="line">print(row_r1)</span><br><span class="line">print(row_r1.shape)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">print(row_r2)</span><br><span class="line">print(row_r2.shape)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]]</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line">(<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]]</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="整型数组访问"><a href="#整型数组访问" class="headerlink" title="整型数组访问"></a>整型数组访问</h2><p> 当我们使用切片语法访问数组时，得到的总是原数组的一个子集。整型数组访问允许我们利用其他数组的数据构建一个新的数组。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">print(a[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#上面的print等价于</span></span><br><span class="line">print([a[<span class="number">0</span>,<span class="number">0</span>],a[<span class="number">1</span>,<span class="number">1</span>],a[<span class="number">2</span>,<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>整型数组访问语法还有一个有用的技巧，可以用来选择或者更改矩阵中每行中的一个元素：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">b = np.array([<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用b中的索引在a的每行选择一个元素</span></span><br><span class="line">print(a[np.arange(<span class="number">4</span>),b])</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">a[np.arange(<span class="number">4</span>),b] += <span class="number">10</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line"> [ <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ <span class="number">1</span>  <span class="number">6</span>  <span class="number">7</span> <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">[[<span class="number">11</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span> <span class="number">16</span>]</span><br><span class="line"> [<span class="number">17</span>  <span class="number">8</span>  <span class="number">9</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">21</span> <span class="number">12</span>]]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="布尔型数组访问"><a href="#布尔型数组访问" class="headerlink" title="布尔型数组访问"></a>布尔型数组访问</h2><p>布尔数组访问可以让你选择数组中任意元素。通常，这种访问方式用于选取数组中满足某些条件的元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回大于2的元素，这返回一个与原数组同型的布尔数组</span></span><br><span class="line">bool_idx = (a &gt; <span class="number">2</span>) </span><br><span class="line"></span><br><span class="line">print(bool_idx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用生成的布尔数组构建一个大于2的一维数组</span></span><br><span class="line">print(a[bool_idx])</span><br><span class="line"></span><br><span class="line">print(a[a &gt; <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">[[<span class="literal">False</span> <span class="literal">False</span>]</span><br><span class="line"> [ <span class="literal">True</span>  <span class="literal">True</span>]</span><br><span class="line"> [ <span class="literal">True</span>  <span class="literal">True</span>]]</span><br><span class="line">[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br></pre></td></tr></tbody></table></figure>
<h1 id="数组计算"><a href="#数组计算" class="headerlink" title="数组计算"></a>数组计算</h1><p>既可利用操作符重载，也可以使用函数方式：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]],dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加</span></span><br><span class="line">print(x+y)</span><br><span class="line">print(np.add(x,y))</span><br><span class="line"></span><br><span class="line"><span class="comment">#减</span></span><br><span class="line">print(x-y)</span><br><span class="line">print(np.subtract(x,y))</span><br><span class="line"></span><br><span class="line"><span class="comment">#乘,对应元素乘法</span></span><br><span class="line">print(x*y)</span><br><span class="line">print(np.multiply(x,y))</span><br><span class="line"></span><br><span class="line"><span class="comment">#除，对应元素除法</span></span><br><span class="line">print(x/y)</span><br><span class="line">print(np.divide(x,y))</span><br><span class="line"></span><br><span class="line"><span class="comment">#开方</span></span><br><span class="line">print(np.sqrt(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">#矩阵乘法</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>,<span class="number">12</span>])</span><br><span class="line"></span><br><span class="line">print(v.dot(w))</span><br><span class="line">print(np.dot(v,w))</span><br><span class="line">print(a.dot(v))</span><br><span class="line">print(np.dot(a,v))</span><br></pre></td></tr></tbody></table></figure>
<p>Numpy提供了很多计算数组的函数，其中最常用的一个是sum:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#Compute sum of all elements</span></span><br><span class="line">print(np.<span class="built_in">sum</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Compute sum of each column</span></span><br><span class="line">print(np.<span class="built_in">sum</span>(x,axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Compute sum of each row</span></span><br><span class="line">print(np.<span class="built_in">sum</span>(x,axis=<span class="number">1</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>查看更多函数，查看<a href="https://docs.scipy.org/doc/numpy/reference/routines.math.html">SciPy.org</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="comment">#转置</span></span><br><span class="line">print(x.T)</span><br></pre></td></tr></tbody></table></figure>
<p>查看<a href="https://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html">更多操作数组的方法</a></p>
<h1 id="广播Broadcasting"><a href="#广播Broadcasting" class="headerlink" title="广播Broadcasting"></a>广播Broadcasting</h1><p>广播是一种强有力的机制，它让Numpy可以让不同大小的矩阵在一起进行数学计算。我们常会有一个小的矩阵和一个大的矩阵，然后需要用小的矩阵对大的矩阵做一些计算。</p>
<p>例如，我们想要把一个向量加到矩阵的每一行，我们可以这样做：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">#Create an empty matrix with the same shape as x</span></span><br><span class="line">y = np.empty_like(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    y[i,:] = x[i,:] + v</span><br><span class="line">    </span><br><span class="line">print(y)</span><br></pre></td></tr></tbody></table></figure>
<p>这样是行的通的，但是当x矩阵非常大，利用循环开计算就会变得很慢很慢。我们可以换一种思路。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#stack 4 copies of v on top of each other</span></span><br><span class="line">vv = np.tile(v,(<span class="number">4</span>,<span class="number">1</span>))</span><br><span class="line">print(vv)</span><br><span class="line"></span><br><span class="line">y = x + vv</span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">[[ <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">5</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">8</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">11</span> <span class="number">13</span>]]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Numpy广播机制可以让我们不用创建vv，就能直接运算</strong>，看看下面的例子。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">y = x + v</span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line">[[ <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">5</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">8</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">11</span> <span class="number">13</span>]]</span><br></pre></td></tr></tbody></table></figure>
<p>对两个数组使用广播机制要遵守下列规则：</p>
<p>1.如果数组的秩不同，使用1来将秩小的数组进行扩展，直到两个数组的尺寸长度都一样。</p>
<p>2.如果两个数组在某个维度上的长度是一样的，或者其中一个数组在该维度上的长度为1，那么我们说这两个数组在该维度上是<strong>相容</strong>的。</p>
<p>3.<strong>如果两个数组在所有维度上都是相容的，它们就能使用广播。</strong></p>
<p>4.如果两个输入数组的尺寸不同，那么注意其中较大的那个尺寸。因为广播之后，两个数组的尺寸将和较大的尺寸一样。</p>
<p>5.在任何一个维度上，如果一个数组的长度为1，另一个数组的长度大于1，那么在该维度上，就好像是对第一个数组进行了复制。</p>
<p>参阅<a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">文档</a>和<a href="http://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc">注释</a>。支持广播机制的函数是全局函数。哪些是全局函数可以在<a href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs">文档</a>中查找。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#v is [1,2,3],w is [4,5]</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">w = np.array([<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">print(np.reshape(v,(<span class="number">3</span>,<span class="number">1</span>)) * w)</span><br><span class="line"></span><br><span class="line"><span class="comment">#x is [[1,2,3]</span></span><br><span class="line"><span class="comment">#     [4,5,6]]</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(x + v)</span><br><span class="line"></span><br><span class="line">print(x.T + w)</span><br><span class="line"></span><br><span class="line">print(x + np.reshape(w,(<span class="number">2</span>,<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">print(x * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">[[ <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">8</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">12</span> <span class="number">15</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">7</span> <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">[[ <span class="number">5</span>  <span class="number">9</span>]</span><br><span class="line"> [ <span class="number">6</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">7</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">[[ <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">[[ <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>]</span><br><span class="line"> [ <span class="number">8</span> <span class="number">10</span> <span class="number">12</span>]]</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Numpy文档"><a href="#Numpy文档" class="headerlink" title="Numpy文档"></a>Numpy文档</h1><p>此文介绍了numpy中的一些重要内容，但是numpy远不止如此，可以查阅<a href="https://docs.scipy.org/doc/numpy/reference/">numpy</a>文献来学习更多。</p>
<h1 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h1><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ pip3 install Pillow</span><br></pre></td></tr></tbody></table></figure>
<p>Numpy提供了高性能的多维数组，以及计算和操作数组的基本工具。Scipy基于Numpy，提供了大量的计算和操作数组的函数，这些函数对于不同类型的科学和工程计算非常有用。</p>
<p><a href="https://docs.scipy.org/doc/scipy/reference/index.html">SciPy文档</a>。</p>
<h1 id="点之间的距离"><a href="#点之间的距离" class="headerlink" title="点之间的距离"></a>点之间的距离</h1><p>SciPy定义了一些有用的函数，可以计算集合中点之间的距离。</p>
<p>函数scipy.spatial.distance.pdist能够计算集合中所有两点之间的距离。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> pdist, squareform</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>]])</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line">d = squareform(pdist(x,<span class="string">'euclidean'</span>))</span><br><span class="line">print(d)</span><br></pre></td></tr></tbody></table></figure>
<p>具体细节请阅读<a href="http://link.zhihu.com/?target=http%3A//docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html">文档</a>。</p>
<p>函数<strong>scipy.spatial.distance.cdist</strong>可以计算不同集合中点的距离，具体请查看<a href="http://link.zhihu.com/?target=http%3A//docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html">文档</a>。</p>
]]></content>
      <categories>
        <category>DataView</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化测试框架</title>
    <url>/posts/22398665/</url>
    <content><![CDATA[<h1 id="pytest"><a href="#pytest" class="headerlink" title="pytest"></a>pytest</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>pytest是一个非常成熟的Python测试框架</p>
<ol>
<li>能够支持简单的单元测试和复杂的功能测试，还可以用来做selenium/appnium等自动化测试，接口自动化测试（pytest+request）</li>
<li>pytest具有很多第三方插件，并且可以自定义扩展，常用的插件有：<ol>
<li>pytest-selenium（集成selenium）</li>
<li>pytest-html（完美html测试报告生成）</li>
<li><strong>pytest-rerunfailures（失败case重复执行）</strong></li>
<li>pytest-xdist（多CPU分发）</li>
</ol>
</li>
<li>支持参数化，可以细粒度地控制要测试的测试用例</li>
<li>可以很好的和CI工具结合，例如Jenkins</li>
</ol>
<p><a href="https://docs.pytest.org/en/stable/">https://docs.pytest.org/en/stable/</a></p>
<p><a href="https://www.cnblogs.com/mytianying/p/12466302.html">https://www.cnblogs.com/mytianying/p/12466302.html</a></p>
<a id="more"></a>
<h3 id="编写规则"><a href="#编写规则" class="headerlink" title="编写规则"></a>编写规则</h3><ul>
<li>测试文件以test开头（以test结尾也可以）</li>
<li>测试类以Test开头，并且不能带有init方法</li>
<li>测试函数以test开头</li>
<li>断言使用基本的assert即可</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># test_whitebalance.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLoginCase</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="comment"># def __init__(self):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test01</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">"test01"</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  pytest.main([<span class="string">"-vs"</span>, <span class="string">"test_whitebalance.py"</span>])</span><br></pre></td></tr></tbody></table></figure>
<p>Console参数介绍</p>
<ul>
<li>-v 用于显示每个测试函数的执行结果</li>
<li>-q 只显示整体测试结果</li>
<li>-s 用于显示测试函数中print ()函数输出</li>
<li>-x，—exitfirst，在第一个错误或测试失败时立刻退出</li>
<li>-h 帮助</li>
</ul>
<h3 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h3><ul>
<li>配置PyCharm执行<ul>
<li>Tools -&gt; Python Integrated tools -&gt; Default test runner</li>
</ul>
</li>
<li>main方法<ul>
<li>pytest.main([“-s”, “-v”, “test_whitebalance.py”])</li>
</ul>
</li>
<li>命令行<ul>
<li>pytest -s -v test_whitebalance.py</li>
</ul>
</li>
</ul>
<h2 id="pytest标记"><a href="#pytest标记" class="headerlink" title="pytest标记"></a>pytest标记</h2><h3 id="pytest查找测试策略"><a href="#pytest查找测试策略" class="headerlink" title="pytest查找测试策略"></a>pytest查找测试策略</h3><ul>
<li>默认情况下，pytest会递归查找当前目录下所有以test开始或者结尾的Python脚本</li>
<li>并执行文件内的所有以test开始或结束的函数和方法</li>
</ul>
<h3 id="标记测试函数"><a href="#标记测试函数" class="headerlink" title="标记测试函数"></a>标记测试函数</h3><ul>
<li><p>由于某种原因（<strong>如test_func2的功能尚未开发完成</strong>），我们只想执行指定的测试函数。</p>
</li>
<li><p>第一种，显式指定函数名，通过“ :: ”标记</p>
<ul>
<li>test_whitebalance.py::test_func1</li>
</ul>
</li>
<li><p>第二种，使用模糊匹配，使用-k选项标识</p>
<ul>
<li>pytest -k func1 test_whitebalance.py</li>
</ul>
</li>
<li><p>第三种，使用pytest.mark在函数上进行标记</p>
<blockquote>
<ol>
<li><p>在项目中添加pytest.ini配置文件</p>
<p>[pytest]</p>
<p>markers=</p>
<p>​        do: do</p>
<p>​        undo: undo</p>
</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># test_whitebalance.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.do</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test01</span>():</span></span><br><span class="line">  print(<span class="string">"test01"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="meta">@pytest.mark.undo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test02</span>():</span></span><br><span class="line">  print(<span class="string">"test02"</span>)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>pytest -m do test_whitebalance.py</li>
</ul>
</li>
</ul>
<h2 id="pytest参数化处理-pytest-mark-parametrize-：数据驱动DDT"><a href="#pytest参数化处理-pytest-mark-parametrize-：数据驱动DDT" class="headerlink" title="pytest参数化处理@pytest.mark.parametrize()：数据驱动DDT"></a>pytest参数化处理@pytest.mark.parametrize()：数据驱动DDT</h2><p>pytest参数化处理：使用参数化装饰器、解析列表、元组、字典等数据</p>
<ul>
<li>在pytest中，也可以使用参数化测试，即<strong>每组参数都独立执行一次测试</strong></li>
<li>使用的工具就是<strong>pytest.mark.parametrize(arguments, argvalues)</strong></li>
</ul>
<p>例子：</p>
<p>如需要测试用户登陆功能，假设需要4个用例</p>
<ol>
<li>用户名正确，密码错误：<code>admin ***</code></li>
<li>用户名错误，密码正确：<code>*** 123</code></li>
<li>用户名正确，密码正确：<code>admin 123</code></li>
<li>用户名错误，密码错误： <code>*** ***</code></li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">data1 = [<span class="string">'123'</span>, <span class="string">'456'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">'pwd'</span>, data1</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">pwd</span>):</span></span><br><span class="line">  print(pwd)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 元组</span></span><br><span class="line">data2 = [</span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), </span><br><span class="line">  (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">'a, b, c'</span>, data2</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>(<span class="params">pwd</span>):</span></span><br><span class="line">  print(a, b, c)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 字典</span></span><br><span class="line">data3 = (</span><br><span class="line">	{</span><br><span class="line">    <span class="string">'usr'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'pwd'</span>: <span class="number">2</span></span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'email'</span>: <span class="string">'tom@qq.com'</span></span><br><span class="line">  }</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">'dic'</span>, data3</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span>(<span class="params">dic</span>):</span></span><br><span class="line">  print(dic) <span class="comment"># 再去按照字典类型遍历即可</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># id值可以自定义，只要方便理解每个用例是干什么的即可, 主要为了增强可读性</span></span><br><span class="line">data4 = [</span><br><span class="line">  pytest.param(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="built_in">id</span>=<span class="string">"(a+b):pass"</span>),</span><br><span class="line">  pytest.param(<span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="built_in">id</span>=<span class="string">"(a+b):fail"</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">"a, b, expect"</span>, data4</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_parameterize</span>(<span class="params">a, b, expect</span>):</span></span><br><span class="line">  <span class="keyword">assert</span> add(a, b) == expect</span><br></pre></td></tr></tbody></table></figure>
<h2 id="pytest-fixture"><a href="#pytest-fixture" class="headerlink" title="@pytest.fixture()"></a>@pytest.fixture()</h2><p>@pytest.fixture() 用于定义一个标记，定义好了之后在其他的测试用例里面，作为第一个参数，来直接引用就可以了。</p>
<ul>
<li>定义fixture跟定义普通函数差不多，唯一区别就是在函数上加一个装饰器@pytest.fixture()</li>
<li>fixture命名不要以test开头，跟用例区分开。fixture是有返回值的，没有返回值默认为None</li>
<li>用例调用fixture的返回值，直接就是把fixture的函数名称当作变量名称</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>():</span></span><br><span class="line">  print(<span class="string">"init..."</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">init</span>):</span></span><br><span class="line">  print(<span class="string">"test1"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>(<span class="params">init</span>):</span></span><br><span class="line">  print(<span class="string">"test2"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="pytest-setup和teardown"><a href="#pytest-setup和teardown" class="headerlink" title="pytest setup和teardown"></a>pytest setup和teardown</h2><ul>
<li>作用：<strong>每次用例开始前和结束后都会去执行一次</strong></li>
<li>还有更高级的setupClass和teardownClass，需配合@classmethod装饰器一起使用</li>
<li>在做selenium自动化的时候，它的效率尤为突出，可以只启动一次浏览器执行多个用例</li>
</ul>
<p>简介</p>
<ul>
<li><p>模块级<strong>（setup_module/teardown_module）</strong>开始于模块始末，全局的</p>
<p>即一个模块只执行一次</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_module</span>():</span></span><br><span class="line">  print(<span class="string">"setup_module"</span>)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">  print(<span class="string">"test1"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teardown_module</span>():</span></span><br><span class="line">  print(<span class="string">"teardown_module"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  pytest.main([<span class="string">'test.py'</span>, <span class="string">'-sv'</span>])</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li><p>函数级<strong>(setup_function/teardown_function)</strong>只对函数用例生效（不在类中）</p>
<p>即每次执行测试用例（函数）时，会去执行</p>
</li>
</ul>
<ul>
<li><p>类级<strong>(setup_class/teardown_class)</strong>只在类中前后运行一次（在类中）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCase01</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup_class</span>(<span class="params">cls</span>):</span></span><br><span class="line">    print(<span class="string">"setup_class"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">teardown_class</span>(<span class="params">cls</span>):</span></span><br><span class="line">    print(<span class="string">"teardown_class"</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test1</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">"test1 setup"</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li>方法级<strong>(setup_method/teardown_method)</strong>开始于方法始末（在类中）</li>
</ul>
<ul>
<li>类里面的<strong>(setup/teardown)</strong>运行在调用方法的前后（在类中）</li>
</ul>
<h2 id="pytest-allure生成测试报告"><a href="#pytest-allure生成测试报告" class="headerlink" title="pytest allure生成测试报告"></a>pytest allure生成测试报告</h2><ul>
<li>安装<ul>
<li>pip install allure-pytest</li>
</ul>
</li>
<li>官方文档<ul>
<li><a href="https://docs.qameta.io">https://docs.qameta.io</a></li>
</ul>
</li>
<li>下载allure<ul>
<li><a href="https://dl.bintray.com/qameta/generic/io/qameta/allure/allure/2.7.0/">https://dl.bintray.com/qameta/generic/io/qameta/allure/allure/2.7.0/</a></li>
</ul>
</li>
</ul>
<p>用例描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>使用方法</th>
<th>参数值</th>
<th>参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@allure.epic()</td>
<td>epic描述</td>
<td>敏捷里面的概念，定义史诗，往下是feature</td>
</tr>
<tr>
<td>@allure.feature()</td>
<td>模块名称</td>
<td>功能点的描述，往下是story</td>
</tr>
<tr>
<td>@allure.story()</td>
<td>用户故事</td>
<td>用户故事，往下是title</td>
</tr>
<tr>
<td>@allure.title(用例的标题)</td>
<td>用例的标题</td>
<td>重命名html报告名称</td>
</tr>
<tr>
<td>@allure.testcase()</td>
<td>测试用例的链接地址</td>
<td>对应功能测试用例系统里面的case</td>
</tr>
<tr>
<td>@allure.issue()</td>
<td>缺陷</td>
<td>对应缺陷管理系统里面的链接</td>
</tr>
<tr>
<td>@allure.description()</td>
<td>用例描述</td>
<td>测试用例的描述</td>
</tr>
<tr>
<td>@allure.step()</td>
<td>操作步骤</td>
<td>测试用例的步骤</td>
</tr>
<tr>
<td>@allure.severity()</td>
<td>用例等级</td>
<td>blocker、critical、normal、minor、trivial</td>
</tr>
<tr>
<td>@allure.link()</td>
<td>链接</td>
<td>定义一个链接，在测试报告展现</td>
</tr>
<tr>
<td>@allure.attachment()</td>
<td>附件</td>
<td>报告添加附件</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> allure</span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">scope=<span class="string">"session"</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">  print(<span class="string">"用例先登陆"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="meta">@allure.step(<span class="params"><span class="string">"步骤1：点***"</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_1</span>():</span></span><br><span class="line">  print(<span class="string">"111"</span>)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@allure.step(<span class="params"><span class="string">"步骤2：点***"</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_2</span>():</span></span><br><span class="line">  print(<span class="string">"222"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="meta">@allure.feature(<span class="params"><span class="string">"编辑页面"</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestEditPage</span>():</span></span><br><span class="line">  <span class="string">"""编辑页面"""</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">  @allure.story(<span class="params"><span class="string">"这是一个***的用例"</span></span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_01</span>(<span class="params">self, login</span>):</span></span><br><span class="line">  	<span class="string">"""用例描述：先登陆，再去执行xxx"""</span></span><br><span class="line">    step_1()</span><br><span class="line">    step_2()</span><br><span class="line">    print(<span class="string">"xxx"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @allure.story(<span class="params"><span class="string">"打开a页面"</span></span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_02</span>(<span class="params">self, login</span>):</span></span><br><span class="line">  	<span class="string">"""用例描述：先登陆，再去执行yyy"""</span></span><br><span class="line">    step_1()</span><br><span class="line">    step_2()</span><br><span class="line">    print(<span class="string">"yyy"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  <span class="comment"># 注意生成测试报告，必须在命令行里执行</span></span><br><span class="line">  <span class="comment"># pytest --alluredir ./report test08.py</span></span><br><span class="line">  <span class="comment"># allure serve ./report 启动allure 查看报告</span></span><br><span class="line">  pytest.main([<span class="string">'--alluredir'</span>, <span class="string">'./reports'</span>, <span class="string">'test08.py'</span>])</span><br><span class="line">  pytest.main([<span class="string">'--alluredir'</span>, <span class="string">'./reports'</span>, <span class="string">'test08.py'</span>])</span><br></pre></td></tr></tbody></table></figure>
<h2 id="使用pytest重构项目"><a href="#使用pytest重构项目" class="headerlink" title="使用pytest重构项目"></a>使用pytest重构项目</h2><ul>
<li>继承unittest.TestCase修改为继承object</li>
<li>unittest setup方法修改为pytest setup</li>
<li>unittest 的断言修改为python断言assert</li>
<li>使用pytest依赖插件</li>
<li>pip3 install pytest-dependency</li>
</ul>
<p>pytest里面的用例的依赖关系，使用@pytest.mark.dependency()</p>
<p>假如test_category.py需要依赖test_admin_login.py模块的执行成功，需要下面这样写。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># test_category.py</span></span><br><span class="line"><span class="keyword">from</span> testcases.pytest.test_admin_login <span class="keyword">import</span> TestAdminLogin</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.dependency(<span class="params">depends=[<span class="string">"admin_login"</span>], scope=<span class="string">"module"</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_add_category_error</span>(<span class="params">self</span>):</span></span><br><span class="line">  <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>日志级别</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>级别</th>
<th>信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEBUG</td>
<td>最详细日志信息，典型应用场景是问题诊断</td>
</tr>
<tr>
<td>INFO</td>
<td>信息详细程度仅次于DEBUG，通常只记录关键点信息，用于确认一切都是按照我们预期的那样进行工作</td>
</tr>
<tr>
<td>WARNING</td>
<td>当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的</td>
</tr>
<tr>
<td>ERROR</td>
<td>由于一个更严重的问题导致某些功能不能正常运行时的记录的信息</td>
</tr>
<tr>
<td>CRITICAL</td>
<td>当放生严重错误时，导致应用程序不能继续运行时记录的信息</td>
</tr>
</tbody>
</table>
</div>
<h2 id="logging模块的四大组件"><a href="#logging模块的四大组件" class="headerlink" title="logging模块的四大组件"></a>logging模块的四大组件</h2><ul>
<li>loggers提供应用程序代码直接使用的接口</li>
<li>handlers用于将日志记录发送到指定的目的位置</li>
<li>filters 提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其他的日志记录将会被忽略）</li>
<li>formatters用于控制日志信息的最终输出格式</li>
</ul>
<h1 id="POM设计模式重构项目"><a href="#POM设计模式重构项目" class="headerlink" title="POM设计模式重构项目"></a>POM设计模式重构项目</h1><ul>
<li>POM页面对象模型是一种设计模式，用来管理维护一组web元素集的对象库</li>
<li>在POM模式下，应用程序的<strong>每一个页面都有一个对应的page class</strong></li>
<li>每一个page class维护着该web页的元素集和操作这些元素的方法</li>
<li>page class中的方法命名最好根据其对应的业务场景进行</li>
</ul>
<p><img data-src="/images/data/POM.png" alt="POM"></p>
<p>一个非POM的Web测试脚本如下：(测试和代码耦合在一起)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBaidu</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setUpClass</span>(<span class="params">cls</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    cls.driver = webdriver.Chrome()</span><br><span class="line">    cls.driver.maxmize.window()</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_baidu</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.driver.get(<span class="string">"www.baidu.com"</span>)</span><br><span class="line">    self.driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(<span class="string">"selenium"</span>)</span><br><span class="line">    self.driver.find_element_by_id(<span class="string">"su"</span>).click()</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tearDownClass</span>(<span class="params">cls</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    cls.driver.quit()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  uinttest.main()</span><br></pre></td></tr></tbody></table></figure>
<p>一个POM的Web测试脚本如下：（测试和代码解耦）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 页面类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaiduPage</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.driver = webdriver.Chrome()</span><br><span class="line">    self.driver.maxmize_window()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定位器</span></span><br><span class="line">    self.input_element = (By.ID, <span class="string">"kw"</span>)</span><br><span class="line">    self.btn_element = (By.ID, <span class="string">"su"</span>)</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">goto_baidu</span>(<span class="params">self, url</span>):</span></span><br><span class="line">    self.driver.get(url)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_search</span>(<span class="params">self, url, kw</span>):</span></span><br><span class="line">    self.goto_baidu(url)</span><br><span class="line">    self.driver.find_element(*self.input_element).send_keys(kw)</span><br><span class="line">    self.driver.find_element(*self.btn_element).send_keys.click()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBaidu</span>(<span class="params">uinttest.TestCase</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    self.baiduPage = BaiduPage()</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_search</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.baduPage.test_search(<span class="string">"www.baidu.com"</span>, <span class="string">"selenium"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  uinttest.main()</span><br></pre></td></tr></tbody></table></figure>
<h1 id="持续集成和交付"><a href="#持续集成和交付" class="headerlink" title="持续集成和交付"></a>持续集成和交付</h1><h2 id="Jenkins环境搭建"><a href="#Jenkins环境搭建" class="headerlink" title="Jenkins环境搭建"></a>Jenkins环境搭建</h2><ul>
<li>下载安装JDK</li>
<li>下载安装Jenkins</li>
</ul>
<h2 id="邮件通知"><a href="#邮件通知" class="headerlink" title="邮件通知"></a>邮件通知</h2><h2 id="定时运行项目：实现自动化测试"><a href="#定时运行项目：实现自动化测试" class="headerlink" title="定时运行项目：实现自动化测试"></a>定时运行项目：实现自动化测试</h2><p><a href="https://time.geekbang.org/course/detail/100055601-280769">https://time.geekbang.org/course/detail/100055601-280769</a></p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Python Automation Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/posts/25249120/</url>
    <content><![CDATA[<h1 id="Spring概况"><a href="#Spring概况" class="headerlink" title="Spring概况"></a>Spring概况</h1><ul>
<li><p>Spring是一个开源框架，为了解决企业级应用开发的复杂性而创建的，但现在已经不止应用于企业应用</p>
</li>
<li><p>Spring是一个轻量级的控制反转(IOC)和面向切面(AOP)的容器框架</p>
<ul>
<li>从大小与开销方面而言Spring是轻量的</li>
<li>通过控制反转(IOC)的技术达到松耦合的目的</li>
<li>提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发</li>
<li>包含并管理应用对象的配置和生命周期，这个意义上是一种容器</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow2.0 In Action</title>
    <url>/posts/29871/</url>
    <content><![CDATA[<h1 id="TensorFlow2-0简化的模型开发流程"><a href="#TensorFlow2-0简化的模型开发流程" class="headerlink" title="TensorFlow2.0简化的模型开发流程"></a>TensorFlow2.0简化的模型开发流程</h1><ul>
<li>使用tf.data加载数据</li>
<li>使用tf.keras构建模型，也可以使用premade estimator来验证模型（使用tesorflow hub进行迁移学习）</li>
<li>使用eager mode进行运行和调试</li>
<li>使用分发策略来进行分布式训练</li>
<li>导出到SavedModel</li>
<li>使用TesorFlow Serve、TensorFlow Lite、TensorFlow.js部署模型</li>
</ul>
<a id="more"></a>
<h1 id="TensorFlow-Keras"><a href="#TensorFlow-Keras" class="headerlink" title="TensorFlow-Keras"></a>TensorFlow-Keras</h1><h2 id="tf-keras和keras的区别"><a href="#tf-keras和keras的区别" class="headerlink" title="tf.keras和keras的区别"></a>tf.keras和keras的区别</h2><ul>
<li>tf.keras全面支持eager mode</li>
<li>tf.keras支持基于tf.data的模型训练</li>
<li>tf.keras支持TPU训练</li>
<li>tf.keras支持tf.distribution中的分布式策略</li>
<li>tf.keras可以与TensorFlow中的estimator集成</li>
<li>tf.keras可以保存为SavedModel</li>
</ul>
<h2 id="搭建分类模型"><a href="#搭建分类模型" class="headerlink" title="搭建分类模型"></a>搭建分类模型</h2><h3 id="数据读取与展示"><a href="#数据读取与展示" class="headerlink" title="数据读取与展示"></a>数据读取与展示</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line">fashion_mnist = keras.datasets.fashion_mnist</span><br><span class="line">(x_train_all, y_train_all), (x_test, y_test) = fashion_mnist.load_data()</span><br><span class="line">x_valid, x_train = x_train_all[:<span class="number">5000</span>], x_train_all[<span class="number">5000</span>:] <span class="comment">#将数据集的前5000张作为训练集，后面的作为验证集</span></span><br><span class="line">y_valid, y_train = y_train_all[:<span class="number">5000</span>], y_train_all[<span class="number">5000</span>:]</span><br><span class="line"></span><br><span class="line">print(x_valid.shape, y_valid.shape)</span><br><span class="line">print(x_train.shape, y_train.shape)</span><br><span class="line">print(x_test.shape, y_test.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">5000</span>, <span class="number">28</span>, <span class="number">28</span>) (<span class="number">5000</span>,)</span><br><span class="line">(<span class="number">55000</span>, <span class="number">28</span>, <span class="number">28</span>) (<span class="number">55000</span>,)</span><br><span class="line">(<span class="number">10000</span>, <span class="number">28</span>, <span class="number">28</span>) (<span class="number">10000</span>,)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 展示一张图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_single_image</span>(<span class="params">img_arr</span>):</span></span><br><span class="line">    plt.imshow(img_arr, cmap=<span class="string">"binary"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">show_single_image(x_train_all[<span class="number">0</span>]) <span class="comment"># 查看训练集中的第一张图片</span></span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/tensorflow/show_image.png" alt="show_image"><br></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 展示多张图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_imgs</span>(<span class="params">n_rows, n_cols, x_data, y_data, class_names</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(x_data) == <span class="built_in">len</span>(y_data)</span><br><span class="line">    <span class="keyword">assert</span> n_rows * n_cols &lt; <span class="built_in">len</span>(x_data) <span class="comment"># 查看图片的数量不能大于原本的样本数</span></span><br><span class="line">    plt.figure(figsize = (n_cols * <span class="number">1.4</span>, n_rows * <span class="number">1.6</span>))</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(n_rows):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n_cols):</span><br><span class="line">            index = n_cols * row + col</span><br><span class="line">            plt.subplot(n_rows, n_cols, index+<span class="number">1</span>)</span><br><span class="line">            plt.imshow(x_data[index], cmap=<span class="string">"binary"</span>,</span><br><span class="line">                      interpolation = <span class="string">'nearest'</span>)</span><br><span class="line">            plt.axis(<span class="string">'off'</span>)</span><br><span class="line">            plt.title(class_names[y_data[index]])</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">class_names = [<span class="string">'T-shirt'</span>, <span class="string">'Trouser'</span>, <span class="string">'Pullover'</span>, <span class="string">'Dress'</span>,</span><br><span class="line">              <span class="string">'Coat'</span>, <span class="string">'Sandal'</span>, <span class="string">'Shirt'</span>,<span class="string">'Sneaker'</span>,</span><br><span class="line">              <span class="string">'Bag'</span>, <span class="string">'Ankle boot'</span>]</span><br><span class="line">show_imgs(<span class="number">3</span>, <span class="number">5</span>, x_train, y_train, class_names)</span><br></pre></td></tr></tbody></table></figure><br><img data-src="/images/tensorflow/show_images.png" alt="show_images"><p></p>
<h3 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">model = keras.models.Sequential()</span><br><span class="line">model.add(keras.layers.Flatten(input_shape=[<span class="number">28</span>, <span class="number">28</span>]))</span><br><span class="line">model.add(keras.layers.Dense(<span class="number">300</span>, activation=<span class="string">"relu"</span>))</span><br><span class="line">model.add(keras.layers.Dense(<span class="number">100</span>, activation=<span class="string">"relu"</span>))</span><br><span class="line">model.add(keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">"softmax"</span>))</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">"sparse_categorical_crossentropy"</span>,</span><br><span class="line">             optimizer=<span class="string">"sgd"</span>,</span><br><span class="line">             metrics=[<span class="string">"accuracy"</span>])</span><br><span class="line">model.layers</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">[&lt;tensorflow.python.keras.layers.core.Flatten at <span class="number">0x12e0e8a58</span>&gt;,</span><br><span class="line"> &lt;tensorflow.python.keras.layers.core.Dense at <span class="number">0x12e1777b8</span>&gt;,</span><br><span class="line"> &lt;tensorflow.python.keras.layers.core.Dense at <span class="number">0x12dfdb3c8</span>&gt;,</span><br><span class="line"> &lt;tensorflow.python.keras.layers.core.Dense at <span class="number">0x12dfdbdd8</span>&gt;]</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>查看模型层次</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">model.summary()</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Model: <span class="string">"sequential_4"</span></span><br><span class="line">_________________________________________________________________</span><br><span class="line">Layer (<span class="built_in">type</span>)                 Output Shape              Param <span class="comment">#   </span></span><br><span class="line">=================================================================</span><br><span class="line">flatten_4 (Flatten)          (<span class="literal">None</span>, <span class="number">784</span>)               <span class="number">0</span>         </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense_12 (Dense)             (<span class="literal">None</span>, <span class="number">300</span>)               <span class="number">235500</span>    </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense_13 (Dense)             (<span class="literal">None</span>, <span class="number">100</span>)               <span class="number">30100</span>     </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense_14 (Dense)             (<span class="literal">None</span>, <span class="number">10</span>)                <span class="number">1010</span>      </span><br><span class="line">=================================================================</span><br><span class="line">Total params: <span class="number">266</span>,<span class="number">610</span></span><br><span class="line">Trainable params: <span class="number">266</span>,<span class="number">610</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>开始训练</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">history = model.fit(x_train, y_train, epochs=<span class="number">10</span>,</span><br><span class="line">                   validation_data=(x_valid, y_valid))</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Train on <span class="number">55000</span> samples, validate on <span class="number">5000</span> samples</span><br><span class="line">Epoch <span class="number">1</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - 4s 80us/sample - loss: <span class="number">42355302163052.2422</span> - accuracy: <span class="number">0.0995</span> - val_loss: <span class="number">2.3028</span> - val_accuracy: <span class="number">0.0914</span></span><br><span class="line">Epoch <span class="number">2</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - 4s 73us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0994</span> - val_loss: <span class="number">2.3026</span> - val_accuracy: <span class="number">0.1012</span></span><br><span class="line">Epoch <span class="number">3</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - 4s 71us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0986</span> - val_loss: <span class="number">2.3027</span> - val_accuracy: <span class="number">0.1002</span></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - 4s 70us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0977</span> - val_loss: <span class="number">2.3027</span> - val_accuracy: <span class="number">0.0986</span></span><br><span class="line">Epoch <span class="number">5</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - 4s 72us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0971</span> - val_loss: <span class="number">2.3029</span> - val_accuracy: <span class="number">0.0914</span></span><br><span class="line">Epoch <span class="number">6</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - 4s 75us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0973</span> - val_loss: <span class="number">2.3028</span> - val_accuracy: <span class="number">0.0914</span></span><br><span class="line">Epoch <span class="number">7</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - 4s 72us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0981</span> - val_loss: <span class="number">2.3027</span> - val_accuracy: <span class="number">0.0986</span></span><br><span class="line">Epoch <span class="number">8</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - 4s 72us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0968</span> - val_loss: <span class="number">2.3028</span> - val_accuracy: <span class="number">0.0914</span></span><br><span class="line">Epoch <span class="number">9</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - 4s 73us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0982</span> - val_loss: <span class="number">2.3029</span> - val_accuracy: <span class="number">0.0914</span></span><br><span class="line">Epoch <span class="number">10</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - 4s 73us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0969</span> - val_loss: <span class="number">2.3028</span> - val_accuracy: <span class="number">0.0914</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>画图</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_learning_curves</span>(<span class="params">history</span>):</span></span><br><span class="line">    pd.DataFrame(history.history).plot(figsize=(<span class="number">8</span>, <span class="number">5</span>))</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line">    plt.gca().set_ylim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">plot_learning_curves(history)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/tensorflow/loss_model.png" alt="loss_model"></p>
<h2 id="Keras回调函数"><a href="#Keras回调函数" class="headerlink" title="Keras回调函数"></a>Keras回调函数</h2><h2 id="搭建回归模型"><a href="#搭建回归模型" class="headerlink" title="搭建回归模型"></a>搭建回归模型</h2><h2 id="搭建深度神经网络"><a href="#搭建深度神经网络" class="headerlink" title="搭建深度神经网络"></a>搭建深度神经网络</h2><h2 id="实现wide-amp-deep模型"><a href="#实现wide-amp-deep模型" class="headerlink" title="实现wide&amp;deep模型"></a>实现wide&amp;deep模型</h2><h2 id="Keras与scikit-learn实现超参数搜索"><a href="#Keras与scikit-learn实现超参数搜索" class="headerlink" title="Keras与scikit-learn实现超参数搜索"></a>Keras与scikit-learn实现超参数搜索</h2><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Neural Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Regex</title>
    <url>/posts/25256/</url>
    <content><![CDATA[<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:center">匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:center">匹配字母、数字、下划线、汉字</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:center">匹配任意的空白符</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:center">匹配数字</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">匹配单词的开始或结束</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">匹配字符串的开始</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">匹配字符串的结束</td>
</tr>
</tbody>
</table>
</div>
<p>例：匹配有abc开头的字符串</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">\babc或^abc</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>
<h2 id="重复限定符"><a href="#重复限定符" class="headerlink" title="重复限定符"></a>重复限定符</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">语法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">重复零次或更多次</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">重复一次或者更多次</td>
</tr>
<tr>
<td style="text-align:center">？</td>
<td style="text-align:center">重复零次或一次</td>
</tr>
<tr>
<td style="text-align:center">{n}</td>
<td style="text-align:center">重复n次</td>
</tr>
<tr>
<td style="text-align:center">{n,}</td>
<td style="text-align:center">重复n次或更多次</td>
</tr>
<tr>
<td style="text-align:center">{n,m}</td>
<td style="text-align:center">重复n次到m次</td>
</tr>
</tbody>
</table>
</div>
<p>限定符作用于与它<strong>左边</strong>最近的一个字符。</p>
<p>例：匹配以a开头，0个或者多个以b结尾的字符串</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">^ab*$</span><br></pre></td></tr></tbody></table></figure>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>以”()“作为分组。</p>
<p>例：匹配以ab开头，0个或者多个以b结尾的字符串</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">^(ab)*$</span><br></pre></td></tr></tbody></table></figure>
<p>注：如需匹配小括号，只要加转义字符串即可。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">^(\(ab\))*$</span><br></pre></td></tr></tbody></table></figure>
<h2 id="条件或"><a href="#条件或" class="headerlink" title="条件或"></a>条件或</h2><p>利用“｜”来表达条件或。</p>
<p>例：匹配130/131/181/177等开头的11位手机号。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">^(<span class="number">130</span>|<span class="number">131</span>|<span class="number">181</span>|<span class="number">177</span>)\d{<span class="number">8</span>}$</span><br></pre></td></tr></tbody></table></figure>
<h2 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h2><p>利用“[]”来表达区间条件。</p>
<blockquote>
<p>[0-9]：限定0到9</p>
<p>[A-Z]：限定A到Z</p>
<p>[165]：限定规定数字</p>
</blockquote>
<p>例：匹配130/131/132/156/158/159/145/177开头的11位数字</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">^((<span class="number">13</span>[<span class="number">0</span>-<span class="number">2</span>])|(<span class="number">15</span>[<span class="number">689</span>])|<span class="number">145</span>|<span class="number">177</span>)\d{<span class="number">8</span>}$</span><br></pre></td></tr></tbody></table></figure>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://juejin.im/post/5b96a8e2e51d450e6a2de115">掘金博文</a></li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title>Mardown</title>
    <url>/posts/20260/</url>
    <content><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><p>要启用这个功能，首先到<code>Preference</code>-&gt;<code>Editor</code>中启用。然后使用<script type="math/tex">`符号包裹Tex命令，例如：`$lim_{x \to \infty} \ exp(-x)=0</script>将产生如下的数学表达式：</p>
<p>$\lim_{x \to \infty} \exp(-x)=0$</p>
<h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p>下标使用<code>~</code>包裹，例如：<code>H~2~O</code>将产生H~2~O, 即水的分子式。</p>
<h2 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h2><p>上标使用<code>^</code>包裹，例如：<code>y^2^=4</code>将产生表达式y^2^ = 4</p>
<h2 id="插入表情-happy"><a href="#插入表情-happy" class="headerlink" title="插入表情:happy:"></a>插入表情:happy:</h2><p>使用<code>:happy:</code>输入表情:happy:,使用<code>:sad:</code>输入表情:sad:,使用<code>:cry:</code>输入表情<span class="github-emoji"><span>😢</span><img data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>等。以此类推！</p>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>用HTML的语法<code>&lt;u&gt;Underline&lt;/u&gt;</code>将产生下划线<u>Underline</u>.</p>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用<code>~~</code>包裹的文本将会具有删除的样式，例如<code>~删除文本~</code>将产生<del>删除文本</del>的样式。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li>使用`包裹的内容将会以代码样式显示，例如</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">使用`printf()`</span><br></pre></td></tr></tbody></table></figure>
<p>则会产生<code>printf()</code>样式。</p>
<a id="more"></a>
<ul>
<li>输入<code>``或者</code>然后回车，可以输入代码块，并且可以选择代码的语言。例如：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class HelloWorld{</span><br><span class="line">System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将会产生</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class HelloWorld{</span><br><span class="line">System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>使用两个<code>*</code>号或者两个<code>_</code>包裹的内容将会被强调。例如</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">**使用两个*号强调内容**</span><br><span class="line">__使用两个下划线强调内容__</span><br></pre></td></tr></tbody></table></figure>
<p>将会输出</p>
<p><strong>使用两个*号强调内容</strong><br><strong>使用两个下划线强调内容</strong><br>Typroa 推荐使用两个*号。</p>
<h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><p>  在标准的Markdown语法中，*和_包裹的内容会是斜体显示，但是GFM下划线一般用来分隔人名和代码变量名，因此我们推荐是用星号来包裹斜体内容。如果要显示星号，则使用转义：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">\*</span><br></pre></td></tr></tbody></table></figure>
<h2 id="插入URL连接"><a href="#插入URL连接" class="headerlink" title="插入URL连接"></a>插入URL连接</h2><p>使用尖括号包裹的url将产生一个连接，例如：<code>&lt;www.baidu.com&gt;</code>将产生连接:<www.baidu.com>.</www.baidu.com></p>
<p>如果是标准的url，则会自动产生连接，例如:www.google.com</p>
<h2 id="目录列表Table-of-Contents（TOC）"><a href="#目录列表Table-of-Contents（TOC）" class="headerlink" title="目录列表Table of Contents（TOC）"></a>目录列表Table of Contents（TOC）</h2><p>输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。</p>
<h2 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h2><p>使用<code>***</code>或者<code>---</code>，然后回车，来产生水平分割线。</p>
<hr>
<h2 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h2><p>我们可以对某一个词语进行标注。例如</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">某些人用过了才知道[^注释]</span><br><span class="line">[^注释]:Somebody that I used to know.</span><br></pre></td></tr></tbody></table></figure>
<p>将产生：</p>
<p>某些人用过了才知道<sup><a href="#fn_注释" id="reffn_注释">注释</a></sup><br><sup><a href="#fn_注释" id="reffn_注释">注释</a></sup>: Somebody that I used to know.</p>
<p>把鼠标放在<code>注释</code>上，将会有提示内容。</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">|姓名|性别|毕业学校|工资|</span><br><span class="line">|:---|:---:|:---:|---:|</span><br><span class="line">|杨洋|男|重庆交通大学|3200|</span><br><span class="line">|峰哥|男|贵州大学|5000|</span><br><span class="line">|小阳|女|北京大学|2000|</span><br></pre></td></tr></tbody></table></figure>
<p>将产生:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">姓名</th>
<th style="text-align:center">性别</th>
<th style="text-align:center">毕业学校</th>
<th style="text-align:right">工资</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">杨洋</td>
<td style="text-align:center">男</td>
<td style="text-align:center">重庆交通大学</td>
<td style="text-align:right">3200</td>
</tr>
<tr>
<td style="text-align:left">峰哥</td>
<td style="text-align:center">男</td>
<td style="text-align:center">贵州大学</td>
<td style="text-align:right">5000</td>
</tr>
<tr>
<td style="text-align:left">小阳</td>
<td style="text-align:center">女</td>
<td style="text-align:center">北京大学</td>
<td style="text-align:right">2000</td>
</tr>
</tbody>
</table>
</div>
<p>其中代码的第二行指定对齐的方式，第一个是左对齐，第二个和第三个是居中，最后一个是右对齐。</p>
<h2 id="数学表达式块"><a href="#数学表达式块" class="headerlink" title="数学表达式块"></a>数学表达式块</h2><p>输入两个美元符号，然后回车，就可以输入数学表达式块了。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$$\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\\end{vmatrix}$$</span><br></pre></td></tr></tbody></table></figure>
<p>将会产生:</p>
<script type="math/tex; mode=display">\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} \mathbf{i} & \mathbf{j} & \mathbf{k} \\\frac{\partial X}{\partial u} &  \frac{\partial Y}{\partial u} & 0 \\\frac{\partial X}{\partial v} &  \frac{\partial Y}{\partial v} & 0 \\\end{vmatrix}</script><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>使用如下的代码创建任务列表，在[]中输入x表示完成，也可以通过点击选择完成或者没完成。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">- [ ] 吃饭</span><br><span class="line">- [ ] 逛街</span><br><span class="line">- [ ] 看电影</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>[x] 吃饭</p>
</li>
<li><p>[x] 逛街</p>
</li>
<li><p>[x] 看电影</p>
</li>
<li><p>[x] </p>
</li>
</ul>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>输入+, -, *,创建无序的列表，使用任意数字开头，创建有序列表，例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">**无序的列表**</span><br><span class="line">* tfboys</span><br><span class="line">* 杨洋</span><br><span class="line">* Mr.Smith</span><br></pre></td></tr></tbody></table></figure>
<p><strong>无序的列表</strong></p>
<ul>
<li>tfboys</li>
<li>杨洋</li>
<li>Mr.Smith</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">**有序的列表**</span><br><span class="line">1. 苹果</span><br><span class="line">6. 香蕉</span><br><span class="line">10. 我都不喜欢</span><br></pre></td></tr></tbody></table></figure>
<p><strong>有序的列表</strong></p>
<ol>
<li>苹果</li>
<li>香蕉</li>
<li>我都不喜欢</li>
</ol>
<h2 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h2><p>使用&gt;来插入块引用。例如：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&gt;这是一个块引用！</span><br></pre></td></tr></tbody></table></figure>
<p>将产生：</p>
<blockquote>
<p>这是一个块引用！</p>
</blockquote>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用#表示一级标题，##表示二级标题，以此类推，有6个标题。</p>
<h1 id="Markdown插件"><a href="#Markdown插件" class="headerlink" title="Markdown插件"></a>Markdown插件</h1><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><h3 id="Sequence-Diagrams"><a href="#Sequence-Diagrams" class="headerlink" title="Sequence Diagrams"></a>Sequence Diagrams</h3><ul>
<li><a href="https://bramp.github.io/js-sequence-diagrams/">官网链接</a></li>
</ul>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Flowcharts"><a href="#Flowcharts" class="headerlink" title="Flowcharts"></a>Flowcharts</h3><ul>
<li><a href="http://flowchart.js.org/">官网链接</a></li>
</ul>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></tbody></table></figure>
<div id="flowchart-0" class="flow-chart"></div>

<h3 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h3><ul>
<li><a href="https://knsv.github.io/mermaid/#/">官网链接</a>：支持时序图、流程图、甘特图、 类图、 状态图、派图</li>
</ul>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">%% Example with selection of syntaxes</span><br><span class="line">gantt</span><br><span class="line">dateFormat  YYYY-MM-DD</span><br><span class="line">title Adding GANTT diagram functionality to mermaid</span><br><span class="line"></span><br><span class="line">section A section</span><br><span class="line">Completed task            :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">Active task               :active,  des2, 2014-01-09, 3d</span><br><span class="line">Future task               :         des3, after des2, 5d</span><br><span class="line">Future task2               :         des4, after des3, 5d</span><br><span class="line"></span><br><span class="line">section Critical tasks</span><br><span class="line">Completed task in the critical line :crit, done, 2014-01-06,24h</span><br><span class="line">Implement parser and jison          :crit, done, after des1, 2d</span><br><span class="line">Create tests for parser             :crit, active, 3d</span><br><span class="line">Future task in critical line        :crit, 5d</span><br><span class="line">Create tests for renderer           :2d</span><br><span class="line">Add to mermaid                      :1d</span><br><span class="line"></span><br><span class="line">section Documentation</span><br><span class="line">Describe gantt syntax               :active, a1, after des1, 3d</span><br><span class="line">Add gantt diagram to demo page      :after a1  , 20h</span><br><span class="line">Add another diagram to demo page    :doc1, after a1  , 48h</span><br><span class="line"></span><br><span class="line">section Last section</span><br><span class="line">Describe gantt syntax               :after doc1, 3d</span><br><span class="line">Add gantt diagram to demo page      : 20h</span><br><span class="line">Add another diagram to demo page    : 48h</span><br></pre></td></tr></tbody></table></figure>
<pre class="mermaid">%% Example with selection of syntaxes
gantt
dateFormat  YYYY-MM-DD
title Adding GANTT diagram functionality to mermaid

section A section
Completed task            :done,    des1, 2014-01-06,2014-01-08
Active task               :active,  des2, 2014-01-09, 3d
Future task               :         des3, after des2, 5d
Future task2               :         des4, after des3, 5d

section Critical tasks
Completed task in the critical line :crit, done, 2014-01-06,24h
Implement parser and jison          :crit, done, after des1, 2d
Create tests for parser             :crit, active, 3d
Future task in critical line        :crit, 5d
Create tests for renderer           :2d
Add to mermaid                      :1d

section Documentation
Describe gantt syntax               :active, a1, after des1, 3d
Add gantt diagram to demo page      :after a1  , 20h
Add another diagram to demo page    :doc1, after a1  , 48h

section Last section
Describe gantt syntax               :after doc1, 3d
Add gantt diagram to demo page      : 20h
Add another diagram to demo page    : 48h</pre>

<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Animal &lt;|-- Duck</span><br><span class="line">Animal &lt;|-- Fish</span><br><span class="line">Animal &lt;|-- Zebra</span><br><span class="line">Animal : +int age</span><br><span class="line">Animal : +String gender</span><br><span class="line">Animal: +isMammal()</span><br><span class="line">Animal: +mate()</span><br><span class="line">class Duck{</span><br><span class="line">+String beakColor</span><br><span class="line">+swim()</span><br><span class="line">+quack()</span><br><span class="line">}</span><br><span class="line">class Fish{</span><br><span class="line">-int sizeInFeet</span><br><span class="line">-canEat()</span><br><span class="line">}</span><br><span class="line">class Zebra{</span><br><span class="line">+bool is<span class="emphasis">_wild</span></span><br><span class="line"><span class="emphasis">+run()</span></span><br><span class="line"><span class="emphasis">}</span></span><br></pre></td></tr></tbody></table></figure>
<pre class="mermaid">classDiagram
      Animal &lt;|-- Duck
      Animal &lt;|-- Fish
      Animal &lt;|-- Zebra
      Animal : +int age
      Animal : +String gender
      Animal: +isMammal()
      Animal: +mate()
      class Duck{
          +String beakColor
          +swim()
          +quack()
      }
      class Fish{
          -int sizeInFeet
          -canEat()
      }
      class Zebra{
          +bool is_wild
          +run()
      }</pre>

<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">pie</span><br><span class="line"><span class="code">    title Pie Chart</span></span><br><span class="line"><span class="code">    "Dogs" : 386</span></span><br><span class="line"><span class="code">    "Cats" : 85</span></span><br><span class="line"><span class="code">    "Rats" : 150 </span></span><br></pre></td></tr></tbody></table></figure>
<pre class="mermaid">pie
    title Pie Chart
    "Dogs" : 386
    "Cats" : 85
    "Rats" : 150</pre>

<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=&gt;start: Start
op=&gt;operation: Your Operation
cond=&gt;condition: Yes or No?
e=&gt;end

st-&gt;op-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;op</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>快捷键汇总</title>
    <url>/posts/26313/</url>
    <content><![CDATA[<h1 id="MacBook"><a href="#MacBook" class="headerlink" title="MacBook"></a>MacBook</h1><h1 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h1><h1 id="InteliJ"><a href="#InteliJ" class="headerlink" title="InteliJ"></a>InteliJ</h1><div class="table-container">
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add to classpath</td>
<td>Option + Enter</td>
</tr>
<tr>
<td>Import package</td>
<td>Option + Shift + Enter</td>
</tr>
<tr>
<td>添加注释</td>
<td>command + “/”</td>
</tr>
<tr>
<td>run</td>
<td>ctrl + r</td>
</tr>
<tr>
<td>run current</td>
<td>ctrl +  shift + r</td>
</tr>
<tr>
<td>debug</td>
<td>ctrl + d</td>
</tr>
<tr>
<td>close terminal</td>
<td>command + 4</td>
</tr>
<tr>
<td>close project</td>
<td>command + 1</td>
</tr>
</tbody>
</table>
</div>
<h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1>]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Shortcut Key</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/posts/2248809/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/27700617">https://zhuanlan.zhihu.com/p/27700617</a></p>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>（1）非叶子节点最多拥有两个子节点；</p>
<p>（2）非叶子节值大于左边子节点、小于右边子节点；</p>
<p>（3）树的左右两边的层级数相差不会大于1;</p>
<p>（4）没有值相等重复的节点;</p>
<a id="more"></a>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树与AVL的比较：</p>
<ul>
<li><p>AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，<strong>旋转的次数比红黑树要多；</strong></p>
</li>
<li><p>红黑是用非严格的平衡来<strong>换取增删节点时候旋转次数的降低</strong>；</p>
</li>
</ul>
<p>所以简单说，如果你的应用中，<strong>搜索的次数远远大于插入和删除，那么选择AVL</strong>。</p>
<p>如果<strong>搜索，插入删除次数几乎差不多，应该选择RB</strong>。</p>
<p>红黑树详解: <a href="https://xieguanglei.github.io/blog/post/red-black-tree.html">https://xieguanglei.github.io/blog/post/red-black-tree.html</a></p>
<p>教你透彻了解红黑树: <a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md">https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md</a></p>
<h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名<strong>平衡多路查找树</strong>（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构。</p>
<p>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</p>
<p>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</p>
<p>（3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p>
<p>（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</p>
<p><img data-src="/images/data/B-tree.png" alt="B-tree"></p>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>（1）B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，<strong>只进行数据索引</strong>，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</p>
<p>（2）B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p>
<p>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</p>
<p>（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</p>
<h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h1><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p>
<p>（1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b<em>树的初始化个数为（cei(2/3</em>m)）</p>
<p>（2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>DataStructure &amp; Algorithm</title>
    <url>/posts/57792/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><img data-src="/images/algorithm/栈.png" alt="栈"></p>
<h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><p><img data-src="/images/algorithm/括号匹配.png" alt="括号匹配"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">LEFT = {<span class="string">'('</span>,<span class="string">'['</span>,<span class="string">'{'</span>}</span><br><span class="line">RIGHT = {<span class="string">')'</span>,<span class="string">']'</span>,<span class="string">'}'</span>}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span>(<span class="params">expr</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> expr:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> LEFT:</span><br><span class="line">            stack.append(c)</span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> RIGHT:</span><br><span class="line">            <span class="comment">#为空</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">1</span> &lt;= <span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(stack[-<span class="number">1</span>]) &lt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.pop()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br><span class="line"></span><br><span class="line">print(match(<span class="string">'{{[]}}'</span>))</span><br><span class="line"></span><br><span class="line">TRUE</span><br></pre></td></tr></tbody></table></figure>
<h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><p><img data-src="/images/algorithm/迷宫问题.png" alt="宫问"></p>
<p>最后栈为空说明已经无路可走，如果栈不为空说明找到了一条路径。</p>
<a id="more"></a>
<p>为了让表达统一，我们初始化迷宫的时候，将迷宫四周边缘都设成1，这样我们就不用考虑一个点是边界还是非边界点，<strong>即所有点都判断上下左右点是否唯一即可。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#初始化迷宫</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initMaze</span>():</span></span><br><span class="line">    maze = [[<span class="number">0</span>] * <span class="number">7</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span> + <span class="number">2</span>)]</span><br><span class="line">    walls = [(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">3</span>),(<span class="number">5</span>,<span class="number">4</span>),]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>+<span class="number">2</span>):</span><br><span class="line">        maze[i][<span class="number">0</span>] = maze[i][-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        maze[<span class="number">0</span>][i] = maze[-<span class="number">1</span>][i] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i,j <span class="keyword">in</span> walls:</span><br><span class="line">        maze[i][j] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> maze</span><br><span class="line"></span><br><span class="line"><span class="comment">#路径选择</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">path</span>(<span class="params">maze,start,end</span>):</span></span><br><span class="line">    </span><br><span class="line">    print(maze)</span><br><span class="line">    </span><br><span class="line">    i,j = start</span><br><span class="line">    e_i,e_j = end</span><br><span class="line">    s = [(i,j)]           <span class="comment">#用栈(列表)保存路径节点</span></span><br><span class="line">    maze[i][j] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> s:         <span class="comment">#如果栈不为空,证明还有路可走</span></span><br><span class="line">        i,j = s[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (i,j) == (e_i,e_j):  <span class="comment">#如果到达终点</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> di,dj <span class="keyword">in</span> [(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>),(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>)]:    <span class="comment">#上下左右四个方向 </span></span><br><span class="line">            <span class="keyword">if</span> maze[i+di][j+dj] == <span class="number">0</span>:       <span class="comment">#如果存在为0的可走路径</span></span><br><span class="line">                maze[i+di][j+di] = <span class="number">1</span></span><br><span class="line">                s.append((i+di,j+dj))       <span class="comment">#将新的路径加入</span></span><br><span class="line">                <span class="keyword">break</span>                       <span class="comment">#跳出此循环，执行i,j = s[-1]</span></span><br><span class="line">        <span class="keyword">else</span>:                           <span class="comment">#如果不存在为0的可走路径</span></span><br><span class="line">            s.pop()                     <span class="comment">#如果发现四周都为1，即无路可走了,执行i,j = s[-1]</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">maze = initMaze()</span><br><span class="line">print(path(maze,(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">5</span>,<span class="number">5</span>)))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h2><p><img data-src="/images/algorithm/后缀表达式求值.png" alt="后缀表达式求值"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">后缀表达式求值问题</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">operators = {</span><br><span class="line">    <span class="string">"+"</span>:<span class="keyword">lambda</span> op1,op2:op1 + op2,</span><br><span class="line">    <span class="string">"-"</span>:<span class="keyword">lambda</span> op1,op2:op1 - op2,</span><br><span class="line">    <span class="string">"*"</span>:<span class="keyword">lambda</span> op1,op2:op1 * op2,</span><br><span class="line">    <span class="string">"/"</span>:<span class="keyword">lambda</span> op1,op2:op1 / op2,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">#后缀表达式求值，e是表达式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalPostfix</span>(<span class="params">e</span>):</span></span><br><span class="line">    tokens = e.split()</span><br><span class="line">    s = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="keyword">if</span> token.isdigit():</span><br><span class="line">            s.append(<span class="built_in">int</span>(token))</span><br><span class="line">        <span class="keyword">elif</span> token <span class="keyword">in</span> operators:</span><br><span class="line">            f = operators[token]</span><br><span class="line">            op2 = s.pop()</span><br><span class="line">            op1 = s.pop()</span><br><span class="line">            s.append(f(op1,op2))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.pop()</span><br><span class="line"></span><br><span class="line">print(evalPostfix(<span class="string">"2 3 4 * +"</span>))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img data-src="/images/algorithm/背包问题.png" alt="背包问题"></p>
<p><img data-src="/images/algorithm/背包问题2.png" alt="背包问题2"></p>
<p>”回溯法“就是一步一步创建解的过程。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">背包问题</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#t是求解的总重量，w是一个列表，为每个物体的重量，返回值是解</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack</span>(<span class="params">t,w</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(w)                 <span class="comment">#物体的个数</span></span><br><span class="line">    s = []                     <span class="comment">#存放对应物体的下标</span></span><br><span class="line">    k = <span class="number">0</span>                      <span class="comment">#物体的指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">or</span> k &lt; n:   <span class="comment"># 当栈里有元素(证明可能还有解)，或者初始指针小于n -- 这两种情况下，解可能存在</span></span><br><span class="line">        <span class="keyword">while</span> t &gt; <span class="number">0</span> <span class="keyword">and</span> k &lt; n: </span><br><span class="line">            <span class="keyword">if</span> t &gt;= w[k]:      <span class="comment">#求解的重量大于某个物体的重量</span></span><br><span class="line">                s.append(k)    <span class="comment">#装入对应物体的指针</span></span><br><span class="line">                t -= w[k]      <span class="comment">#总重减小</span></span><br><span class="line">            k += <span class="number">1</span>             <span class="comment">#指向下一个物体</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> t == <span class="number">0</span>:             <span class="comment">#对应上层while不成立的条件：当t已经为0(也就是已经找到解)</span></span><br><span class="line">            print(s)</span><br><span class="line">        </span><br><span class="line">        k = s.pop()    <span class="comment">#或者指针k已经超出n时，即无解情况，回溯，k指针设为栈顶的元素指针的下一个元素指针</span></span><br><span class="line">        t += w[k]</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">knapsack(<span class="number">10</span>,[<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></tbody></table></figure>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><img data-src="/images/algorithm/队列.png" alt="队列"></p>
<p>Python中队列的接口为：<img data-src="/images/algorithm/队列接口.png" alt="队列接口"></p>
<h2 id="Python标准库中的队列deque"><a href="#Python标准库中的队列deque" class="headerlink" title="Python标准库中的队列deque"></a>Python标准库中的队列deque</h2><p>队列的方法如下：</p>
<p><img data-src="/images/algorithm/队列标准库.png" alt="队列标准库"></p>
<p><img data-src="/images/algorithm/1.png" alt="屏幕快照 2018-04-06 下午12.34.52"></p>
<p><img data-src="/images/algorithm/2.png" alt="屏幕快照 2018-04-06 下午12.35.04"></p>
<h2 id="二项式系数"><a href="#二项式系数" class="headerlink" title="二项式系数"></a>二项式系数</h2><p><img data-src="/images/algorithm/多项式系数.png" alt="多项式系数"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">杨辉三角形，求解多项式系数问题</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="comment">#求解杨辉三角第k层的系数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yanghui</span>(<span class="params">k</span>):</span> </span><br><span class="line">    <span class="comment">#从第0层，一步一步推算出第k层的系数</span></span><br><span class="line">    </span><br><span class="line">    q = deque([<span class="number">1</span>]) <span class="comment">#第0层系数是1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k): <span class="comment"># k次推导，i表示当前所在的层</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(i): <span class="comment"># 第i层需要经过i次出栈操作，才能计算出来结果</span></span><br><span class="line">            </span><br><span class="line">            q.append(q.popleft() + q[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        q.append(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(q)</span><br><span class="line"></span><br><span class="line">print(yanghui(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="划分无冲突子集"><a href="#划分无冲突子集" class="headerlink" title="划分无冲突子集"></a>划分无冲突子集</h2><p><img data-src="/images/algorithm/划分无冲突子集.png" alt="划分无冲突子集"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">划分无冲突子集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">division</span>(<span class="params">M,n</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    q = deque(<span class="built_in">range</span>(n))</span><br><span class="line">    pre = n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        cur = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> pre &gt;= cur:</span><br><span class="line">            res.append([])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> res[-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> M[cur][a]:</span><br><span class="line">                q.append(cur)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[-<span class="number">1</span>].append(cur)</span><br><span class="line">        pre = cur</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = <span class="number">9</span></span><br><span class="line">R = {</span><br><span class="line">    (<span class="number">1</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">8</span>),(<span class="number">1</span>,<span class="number">8</span>),(<span class="number">1</span>,<span class="number">7</span>),</span><br><span class="line">    (<span class="number">8</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">5</span>),(<span class="number">1</span>,<span class="number">5</span>),</span><br><span class="line">    (<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>),(<span class="number">5</span>,<span class="number">2</span>),(<span class="number">6</span>,<span class="number">2</span>),(<span class="number">6</span>,<span class="number">4</span>)</span><br><span class="line">}</span><br><span class="line">M = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> R:</span><br><span class="line">    M[i][j] = M[j][i] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">print(division(M,N))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">6</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">8</span>]]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="数字变换-用队列实现广度优先搜索"><a href="#数字变换-用队列实现广度优先搜索" class="headerlink" title="数字变换(用队列实现广度优先搜索)"></a>数字变换(用队列实现广度优先搜索)</h2><p><img data-src="/images/algorithm/数字变换.png" alt="数字变换"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字变换</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将a变成b需要经过几个步骤，使用队列存储转换时的状态</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atob</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    state_queue = deque([(a,<span class="number">0</span>)]) <span class="comment"># 使用元组作为一个元素，第一个值是计算到的数字，第二个值记录现在经过的状态，使用队列记录正在被计算的数字</span></span><br><span class="line">    checked = {a} <span class="comment"># 使用集合记录已经被检查过的数字，要是队列中又出现相同的数字，则不予计算</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        num,state = state_queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> num == b:</span><br><span class="line">            <span class="keyword">break</span>   <span class="comment"># 跳出循环的条件</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; b: <span class="comment"># 比b小的数只能通过“+”，“*”操作才有可能得到b，所以忽略“-”操作</span></span><br><span class="line">            <span class="keyword">if</span> num * <span class="number">2</span> <span class="keyword">not</span> <span class="keyword">in</span> checked:</span><br><span class="line">                state_queue.append((num * <span class="number">2</span>,state + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> num + <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> checked:</span><br><span class="line">                state_queue.append((num + <span class="number">1</span>,state + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> num &gt; b:</span><br><span class="line">            <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> checked:</span><br><span class="line">                state_queue.append((num - <span class="number">1</span>,state + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line"></span><br><span class="line">print(<span class="string">"需要通过"</span> + <span class="built_in">str</span>(atob(<span class="number">3</span>,<span class="number">8</span>)) + <span class="string">"步"</span>)  </span><br><span class="line"></span><br><span class="line">需要通过<span class="number">2</span>步</span><br></pre></td></tr></tbody></table></figure>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><img data-src="/images/algorithm/二叉树.png" alt="二叉树"></p>
<h2 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,data,left=<span class="literal">None</span>,right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self)</span><br><span class="line"></span><br><span class="line">A,B,C,D,E,F,G,H,I = [TreeNode(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">"ABCDEFGHI"</span>]</span><br><span class="line">A.left = B</span><br><span class="line">A.right = C</span><br><span class="line">B.right = D</span><br><span class="line">C.left = E</span><br><span class="line">C.right = F</span><br><span class="line">E.left = G</span><br><span class="line">F.left = H</span><br><span class="line">F.right = I</span><br><span class="line"></span><br><span class="line">print(C.right.data)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="遍历二叉树（前、中、后序）（递归、回溯-栈）"><a href="#遍历二叉树（前、中、后序）（递归、回溯-栈）" class="headerlink" title="遍历二叉树（前、中、后序）（递归、回溯-栈）"></a>遍历二叉树（前、中、后序）（递归、回溯-栈）</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,data,left=<span class="literal">None</span>,right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span>():</span></span><br><span class="line">    A,B,C,D,E,F,G,H,I = [TreeNode(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">"ABCDEFGHI"</span>]</span><br><span class="line">    A.left = B</span><br><span class="line">    A.right = C</span><br><span class="line">    B.right = D</span><br><span class="line">    C.left = E</span><br><span class="line">    C.right = F</span><br><span class="line">    E.left = G</span><br><span class="line">    F.left = H</span><br><span class="line">    F.right = I</span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preOrder</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    print(node.data)</span><br><span class="line">    preOrder(node.left)</span><br><span class="line">    preOrder(node.right)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inOrder</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    inOrder(node.left)</span><br><span class="line">    print(node.data)</span><br><span class="line">    inOrder(node.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postOrder</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    postOrder(node.left)</span><br><span class="line">    postOrder(node.right)</span><br><span class="line">    print(node.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>:</span><br><span class="line">    root = createTree()</span><br><span class="line">    preOrder(root)</span><br><span class="line">    inOrder(root)</span><br><span class="line">    postOrder(root)</span><br></pre></td></tr></tbody></table></figure>
<p>使用递归的开销比较大，下面实现一个迭代版的先序遍历。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 回溯的前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preOrderIter</span>(<span class="params">root</span>):</span></span><br><span class="line">    node = root</span><br><span class="line">    s = [] <span class="comment"># 使用一个栈存未遍历的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 在节点左子树不为空的情况下，将其左子树一直压栈</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            print(node.data)</span><br><span class="line">            s.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果栈为空，则说明已经遍历完成</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 出栈操作，遍历其右子树</span></span><br><span class="line">        node = s.pop().right</span><br></pre></td></tr></tbody></table></figure>
<h2 id="遍历二叉树（层次遍历-队列）"><a href="#遍历二叉树（层次遍历-队列）" class="headerlink" title="遍历二叉树（层次遍历 - 队列）"></a>遍历二叉树（层次遍历 - 队列）</h2><p>一个节点出队后，才入队它的子节点。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">root</span>):</span></span><br><span class="line">    q = deque([root])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果队列不为空</span></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        node = q.popleft()</span><br><span class="line">        print(node.data)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            q.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            q.append(node.right)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p>采用<strong>分而治之</strong>的思路，把求一个树的深度转化为<strong>它左子树的深度</strong>加上<strong>右子树的深度</strong>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 求二叉树的深度 -- 递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dl = depth(node.left)</span><br><span class="line">    dr = depth(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dl,dr) + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 求二叉树的深度 -- 非递归方式，层次遍历，只需记录一下当前节点的深度即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth2</span>(<span class="params">root</span>):</span></span><br><span class="line">    q = deque([(root,<span class="number">1</span>)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        node,d = q.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            q.append((node.left,d+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            q.append((node.right,d+<span class="number">1</span>))</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> d</span><br></pre></td></tr></tbody></table></figure>
<h2 id="拷贝二叉树"><a href="#拷贝二叉树" class="headerlink" title="拷贝二叉树"></a>拷贝二叉树</h2><p>依旧采用分治的思想，先拷贝左子树，再拷贝右子树，接着拷贝节点。</p>
 <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyTree</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    lt = copyTree(node.left)</span><br><span class="line">    rt = copyTree(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TreeNode(node.data,lt,rt)</span><br><span class="line"></span><br><span class="line">newTree = copyTree(root)</span><br><span class="line">levelOrder(newTree)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="N个节点不同二叉树个数"><a href="#N个节点不同二叉树个数" class="headerlink" title="N个节点不同二叉树个数"></a>N个节点不同二叉树个数</h2><p>计算由N个节点，所构成的二叉树的个数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># root : 1</span></span><br><span class="line">    <span class="comment"># left : K [0,n - 1]</span></span><br><span class="line">    <span class="comment"># right : n - 1 - k</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> :  <span class="comment"># 递归的出口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        s += count(k) * count(n - <span class="number">1</span> - k)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">     </span><br><span class="line">print(count(<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树又作二叉排序树，它可以支持快速的查找。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 对于二叉搜索树的操作</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self,k</span>):</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">and</span> node.data != k:</span><br><span class="line">            <span class="keyword">if</span> k &lt; node.data:</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">if</span> k &gt; node.data:</span><br><span class="line">                node = node.right</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#同样的实现搜索操作，不过还要返回父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_</span>(<span class="params">self,k</span>):</span></span><br><span class="line">        parent = <span class="literal">None</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">and</span> node.data != k:</span><br><span class="line">            parent = node</span><br><span class="line">            <span class="keyword">if</span> k &lt; node.data:</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">if</span> k &gt; node.data:</span><br><span class="line">                node = node.right</span><br><span class="line">        <span class="keyword">return</span> node,parent</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self,k</span>):</span></span><br><span class="line">        node,parent = self.search_(k)</span><br><span class="line">        <span class="comment"># 如果返回到了node的值，说明这个node在节点上存在，则不用执行插入操作</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果是不存在的，首先构造一个新节点</span></span><br><span class="line">        node = TreeNode(k)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将node插入到parent上</span></span><br><span class="line">        <span class="comment"># 树为空，将整个节点插入到树上，赋为根节点</span></span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = node</span><br><span class="line">        <span class="keyword">elif</span> k &lt; parent.data:</span><br><span class="line">            parent.left = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parent.right = node</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self,k</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">bst = BinarySearchTree()  </span><br><span class="line">bst.insert(<span class="number">10</span>)</span><br><span class="line">bst.insert(<span class="number">5</span>)</span><br><span class="line">bst.insert(<span class="number">15</span>)</span><br><span class="line">levelOrder(bst.root)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p><img data-src="/images/algorithm/图.png" alt="图"></p>
<h2 id="在Python中使用图"><a href="#在Python中使用图" class="headerlink" title="在Python中使用图"></a>在Python中使用图</h2><p><strong>邻接矩阵表示法（有向图、无向图）：</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 用二维数组表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个点确定一条边</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Vertical</span>(<span class="params">G,n1,n2</span>):</span></span><br><span class="line">    Graph[n1][n2] = Graph[n2][n1] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">N = <span class="number">5</span>   <span class="comment"># 一共5个点</span></span><br><span class="line">a,b,c,d,e = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line">Graph = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)] <span class="comment"># 建立一个二维数组保存图</span></span><br><span class="line">Vertical(Graph,a,b)</span><br><span class="line">print(Graph)</span><br><span class="line"></span><br><span class="line">[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], </span><br><span class="line"> [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], </span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], </span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], </span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br></pre></td></tr></tbody></table></figure>
<p>邻接矩阵的缺点：</p>
<p>1.如果图中节点个数很多，边的条数很少，则会浪费资源。</p>
<p>2.访问一个节点的邻接节点，需要遍历一个列表才可以。</p>
<p><strong>邻接集合表示法（有向图和无向图）：</strong></p>
<p>用一个列表存储集合的形式保存节点和边的关系，第一个集合保存节点1，第一个集合保存节点2，以此类推。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">邻接集合表示有向图和无向图</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一个集合表示对应点相邻的点</span></span><br><span class="line">G2 = [{b,e},{c,d,e},{b,d},{b,c,e},{a,b,d}]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于b点来说</span></span><br><span class="line">G2[b]</span><br><span class="line"></span><br><span class="line">{<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>}</span><br></pre></td></tr></tbody></table></figure>
<p>邻接列表就是把集合换成列表。</p>
<p><strong>对于带权的边，可以使用邻接字典。</strong></p>
<p>不再使用集合存储，而使用字典存储，其中字典的值表示边的长度。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">G3 = [{b:<span class="number">4</span>,e:<span class="number">2</span>},{c:<span class="number">5</span>,d:<span class="number">6</span>,e:<span class="number">3</span>}]</span><br><span class="line">G3</span><br><span class="line"></span><br><span class="line">[{<span class="number">1</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">2</span>}, {<span class="number">2</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">6</span>, <span class="number">4</span>: <span class="number">3</span>}]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="图的深度优先遍历算法DFS"><a href="#图的深度优先遍历算法DFS" class="headerlink" title="图的深度优先遍历算法DFS"></a>图的深度优先遍历算法DFS</h2><p><img data-src="/images/algorithm/图1.png" alt="图1"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">G = [</span><br><span class="line">    {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}, <span class="comment"># 0的邻接节点</span></span><br><span class="line">    {<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>}, <span class="comment"># 1</span></span><br><span class="line">    {<span class="number">0</span>,<span class="number">3</span>},   <span class="comment"># 2</span></span><br><span class="line">    {<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>}, <span class="comment"># 3</span></span><br><span class="line">    {<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>},<span class="comment"># 4 </span></span><br><span class="line">    {<span class="number">4</span>,<span class="number">7</span>},   <span class="comment"># 5</span></span><br><span class="line">    {<span class="number">1</span>,<span class="number">4</span>},   <span class="comment"># 6</span></span><br><span class="line">    {<span class="number">5</span>},      <span class="comment"># 7</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">G,v,visited=<span class="built_in">set</span>(<span class="params"></span>)</span>):</span></span><br><span class="line">    print(v)</span><br><span class="line">    visited.add(v)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> G[v]:</span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            dfs(G,u,visited)</span><br><span class="line">            </span><br><span class="line">dfs(G,<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归 --  循环实现深度优先遍历    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfsIter</span>(<span class="params">G,v</span>):</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    <span class="comment"># 使用栈</span></span><br><span class="line">    s = [v]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> s:</span><br><span class="line">        u = s.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.add(u)</span><br><span class="line">            print(u)</span><br><span class="line">            s.extend(G[u])</span><br><span class="line"></span><br><span class="line">dfsIter(G,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="图的广度优先遍历算法BFS"><a href="#图的广度优先遍历算法BFS" class="headerlink" title="图的广度优先遍历算法BFS"></a>图的广度优先遍历算法BFS</h2><p><img data-src="/images/algorithm/图1.png" alt="图1"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">G = [</span><br><span class="line">    {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}, <span class="comment"># 0的邻接节点</span></span><br><span class="line">    {<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>}, <span class="comment"># 1</span></span><br><span class="line">    {<span class="number">0</span>,<span class="number">3</span>},   <span class="comment"># 2</span></span><br><span class="line">    {<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>}, <span class="comment"># 3</span></span><br><span class="line">    {<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>},<span class="comment"># 4 </span></span><br><span class="line">    {<span class="number">4</span>,<span class="number">7</span>},   <span class="comment"># 5</span></span><br><span class="line">    {<span class="number">1</span>,<span class="number">4</span>},   <span class="comment"># 6</span></span><br><span class="line">    {<span class="number">5</span>},      <span class="comment"># 7</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">G,v</span>):</span></span><br><span class="line">    <span class="comment"># 队列里放未被访问过的元素</span></span><br><span class="line">    q = deque([v])</span><br><span class="line">    visited = {v}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        u = q.popleft()</span><br><span class="line">        print(u)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> G[u]:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append(w)</span><br><span class="line">                visited.add(w)</span><br><span class="line"></span><br><span class="line">bfs(G,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="最小生成树算法（Prim算法）"><a href="#最小生成树算法（Prim算法）" class="headerlink" title="最小生成树算法（Prim算法）"></a>最小生成树算法（Prim算法）</h2><p>图的生成树：<strong>包含所有顶点不能有回环的图。</strong></p>
<p>最小生成树：代价（边的权值）最小的生成树。</p>
<p><img data-src="/images/algorithm/最小生成树.png" alt="最小生成树"></p>
<p><img data-src="/images/algorithm/Prim.png" alt="Prim"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">G = [</span><br><span class="line">    {<span class="number">1</span>:<span class="number">28</span>,<span class="number">5</span>:<span class="number">10</span>},     <span class="comment"># 0</span></span><br><span class="line">    {<span class="number">0</span>:<span class="number">28</span>,<span class="number">2</span>:<span class="number">16</span>,<span class="number">6</span>:<span class="number">14</span>},<span class="comment"># 1</span></span><br><span class="line">    {<span class="number">1</span>:<span class="number">16</span>,<span class="number">3</span>:<span class="number">12</span>},     <span class="comment"># 2</span></span><br><span class="line">    {<span class="number">2</span>:<span class="number">12</span>,<span class="number">4</span>:<span class="number">22</span>,<span class="number">6</span>:<span class="number">18</span>},<span class="comment"># 3</span></span><br><span class="line">    {<span class="number">3</span>:<span class="number">22</span>,<span class="number">5</span>:<span class="number">25</span>,<span class="number">6</span>:<span class="number">24</span>},<span class="comment"># 4</span></span><br><span class="line">    {<span class="number">0</span>:<span class="number">10</span>,<span class="number">4</span>:<span class="number">25</span>},     <span class="comment"># 5</span></span><br><span class="line">    {<span class="number">1</span>:<span class="number">14</span>,<span class="number">3</span>:<span class="number">18</span>,<span class="number">4</span>:<span class="number">24</span>},<span class="comment"># 6</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prim</span>(<span class="params">G</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(G)</span><br><span class="line">    v = <span class="number">0</span>  <span class="comment"># 初始顶点设为0</span></span><br><span class="line">    s = {v}</span><br><span class="line">    </span><br><span class="line">    edges = []</span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> u,w <span class="keyword">in</span> G[v].items():</span><br><span class="line">            heapq.heappush(edges,(w,v,u))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> edges:</span><br><span class="line">            w,p,q = heapq.heappop(edges)</span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">                s.add(q)</span><br><span class="line">                res.append(((p,q),w))</span><br><span class="line">                v = q</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"not connected gram!"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">prim(G)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[((<span class="number">0</span>, <span class="number">5</span>), <span class="number">10</span>),</span><br><span class="line"> ((<span class="number">5</span>, <span class="number">4</span>), <span class="number">25</span>),</span><br><span class="line"> ((<span class="number">4</span>, <span class="number">3</span>), <span class="number">22</span>),</span><br><span class="line"> ((<span class="number">3</span>, <span class="number">2</span>), <span class="number">12</span>),</span><br><span class="line"> ((<span class="number">2</span>, <span class="number">1</span>), <span class="number">16</span>),</span><br><span class="line"> ((<span class="number">1</span>, <span class="number">6</span>), <span class="number">14</span>)]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="最短路径算法（Dijkstra算法）"><a href="#最短路径算法（Dijkstra算法）" class="headerlink" title="最短路径算法（Dijkstra算法）"></a>最短路径算法（Dijkstra算法）</h2><p><img data-src="/images/algorithm/3.png" alt="屏幕快照 2018-04-23 下午9.04.07"></p>
<p><img data-src="/images/algorithm/Dijkstra算法.png" alt="Dijkstra算法"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a,b,c,d,e,f = <span class="built_in">range</span>(<span class="number">6</span>)</span><br><span class="line">G = {</span><br><span class="line">    a:{b:<span class="number">2</span>,c:<span class="number">1</span>,d:<span class="number">4</span>,f:<span class="number">10</span>},</span><br><span class="line">    b:{a:<span class="number">2</span>,c:<span class="number">4</span>,e:<span class="number">3</span>},</span><br><span class="line">    c:{a:<span class="number">1</span>,b:<span class="number">4</span>,d:<span class="number">2</span>,f:<span class="number">8</span>},</span><br><span class="line">    d:{a:<span class="number">4</span>,c:<span class="number">2</span>,e:<span class="number">1</span>},</span><br><span class="line">    e:{b:<span class="number">3</span>,d:<span class="number">1</span>,f:<span class="number">7</span>},</span><br><span class="line">    f:{a:<span class="number">10</span>,c:<span class="number">8</span>,e:<span class="number">7</span>},</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span>(<span class="params">G,s</span>):</span></span><br><span class="line">    <span class="comment"># D = {},D[c],D[e]</span></span><br><span class="line">    <span class="comment"># 将顶点到其他点的距离初始化为正无穷大</span></span><br><span class="line">    inf = <span class="built_in">float</span>(<span class="string">'inf'</span>)</span><br><span class="line">    D = {v: inf <span class="keyword">for</span> v <span class="keyword">in</span> G} <span class="comment"># 每个点的距离设成无穷大</span></span><br><span class="line">    D[s] = <span class="number">0</span>    <span class="comment"># 除了到自己本身，到其余各点距离都是无穷</span></span><br><span class="line">    P = {}      <span class="comment"># 建立父节点的路径</span></span><br><span class="line">    S = {s}     <span class="comment"># 已访问节点</span></span><br><span class="line">    q = []      <span class="comment"># 优先队列</span></span><br><span class="line">    v = s       <span class="comment"># 当前点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 循环次数</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(G)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> u,w <span class="keyword">in</span> G[v].items():</span><br><span class="line">            d = D[v] + G[u][v]</span><br><span class="line">            <span class="keyword">if</span> D[u] &gt; d:</span><br><span class="line">                D[u] = d</span><br><span class="line">                P[u] = v</span><br><span class="line">                heapq.heappush(q,(d,u))</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            _,v = heapq.heappop(q)</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> S:</span><br><span class="line">                S.add(v)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> D,P</span><br><span class="line"></span><br><span class="line">D,P = dijkstra(G,a)</span><br><span class="line">print(D,P)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">{<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">3</span>, <span class="number">4</span>: <span class="number">4</span>, <span class="number">5</span>: <span class="number">9</span>} {<span class="number">1</span>: <span class="number">0</span>, <span class="number">2</span>: <span class="number">0</span>, <span class="number">3</span>: <span class="number">2</span>, <span class="number">4</span>: <span class="number">3</span>, <span class="number">5</span>: <span class="number">2</span>}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h2><p><img data-src="/images/algorithm/拓扑排序算法.png" alt="拓扑排序算法"></p>
<p>首先寻找入度为0的点。添加到队列中，删除其出度的边，再次寻找入度为0的点，添加到队列中。依此类推。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">G = {</span><br><span class="line">    <span class="string">'C1'</span>:[<span class="string">'C3'</span>,<span class="string">'C8'</span>],</span><br><span class="line">    <span class="string">'C2'</span>:[<span class="string">'C3'</span>,<span class="string">'C4'</span>,<span class="string">'C5'</span>],</span><br><span class="line">    <span class="string">'C3'</span>:[<span class="string">'C4'</span>],</span><br><span class="line">    <span class="string">'C4'</span>:[<span class="string">'C6'</span>,<span class="string">'C7'</span>],</span><br><span class="line">    <span class="string">'C5'</span>:[<span class="string">'C6'</span>],</span><br><span class="line">    <span class="string">'C6'</span>:[],</span><br><span class="line">    <span class="string">'C7'</span>:[],</span><br><span class="line">    <span class="string">'C8'</span>:[<span class="string">'C9'</span>],</span><br><span class="line">    <span class="string">'C9'</span>:[<span class="string">'C7'</span>],</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topsort</span>(<span class="params">G</span>):</span></span><br><span class="line">    indegrees = {v:<span class="number">0</span> <span class="keyword">for</span> v <span class="keyword">in</span> G}</span><br><span class="line">    <span class="keyword">for</span> al <span class="keyword">in</span> G.values():</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> al:</span><br><span class="line">            indegrees[v] += <span class="number">1</span></span><br><span class="line">    q = [v <span class="keyword">for</span> v <span class="keyword">in</span> G <span class="keyword">if</span> indegrees[v] == <span class="number">0</span>] <span class="comment"># 选出所有入度为0的点</span></span><br><span class="line">    i = <span class="number">0</span> <span class="comment"># 队头</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(q):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> G[q[i]]:</span><br><span class="line">            indegrees[v] -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断是否已经入度为0了，若是，则添加到队列中</span></span><br><span class="line">            <span class="keyword">if</span> indegrees[v] ==  <span class="number">0</span>:</span><br><span class="line">                q.append(v)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> q <span class="keyword">if</span> i == <span class="built_in">len</span>(G) <span class="keyword">else</span> <span class="literal">None</span> <span class="comment"># 如果有相互依赖的情况，则返回None</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">topsort(G)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C8'</span>, <span class="string">'C3'</span>, <span class="string">'C5'</span>, <span class="string">'C9'</span>, <span class="string">'C4'</span>, <span class="string">'C6'</span>, <span class="string">'C7'</span>]</span><br></pre></td></tr></tbody></table></figure>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="枚举简介"><a href="#枚举简介" class="headerlink" title="枚举简介"></a>枚举简介</h2><p>将可能的解逐一列出。</p>
<h2 id="熄灯问题"><a href="#熄灯问题" class="headerlink" title="熄灯问题"></a>熄灯问题</h2><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ul>
<li>问题求解时，总是做出在当前来看最好的选择。即，不保证全局最优，仅是在某种意义上的<strong>局部最优解</strong>。</li>
<li>自顶向下的计算，将原问题归结为<strong>子问题</strong>。</li>
</ul>
<p>f(m,n) = f(m-1,n) + f(m,n-1)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/posts/252123234598/</url>
    <content><![CDATA[<h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><img data-src="/images/Java/keyword.png" alt="keyword"></p>
<a id="more"></a>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符就是用于给 Java 程序中变量、类、方法等命名的符号。</p>
<ol>
<li><p>标识符<strong>可以</strong>由<strong>字母、数字、下划线（_）、美元符（$）</strong>组成，但不能包含 @、%、空格等其它特殊字符<strong>，不能以数字开头</strong>。譬如：123name 就是不合法滴</p>
</li>
<li><p>标识符<strong>不能是 Java 关键字和保留字</strong>（ Java 预留的关键字，以后的升级版本中有可能作为关键字），但可以包含关键字和保留字。如：不可以使用 void 作为标识符，但是 Myvoid 可以</p>
</li>
<li><p>标识符是<strong>严格区分大小写</strong>的。 所以涅，一定要分清楚 imooc 和 IMooc 是两个不同的标识符哦！</p>
</li>
<li><p>标识符的命名最好能反映出其作用，做到<strong>见名知意</strong>。</p>
</li>
</ol>
<p><img data-src="/images/Java/biaoshifu.png" alt="biaoshifu"></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol>
<li><p>变量名由多单词组成时，<strong>第一个单词的首字母小写</strong>，<strong>其后单词的首字母大写</strong>，俗称骆驼式命名法（也称驼峰命名法），如 myAge</p>
</li>
<li><p>变量命名时，尽量简短且能清楚的表达变量的作用，做到<strong>见名知意</strong>。如：定义变量名 stuName 保存“学生姓名”信息</p>
</li>
</ol>
<p>PS： Java 变量名的<strong>长度没有限制</strong>，但 Java 语言<strong>是区分大小写</strong>的，所以 price 和 Price 是两个完全不同的变量哦！</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img data-src="/images/Java/varchar.png" alt="varchar"></p>
<p>在 Java 的领域里<strong>，基本数据类型变量</strong>存的是<strong>数据本身</strong>，而<strong>引用类型变量</strong>存的是保存<strong>数据的空间地址</strong>。</p>
<ul>
<li>常用的基本数据类型</li>
</ul>
<p><img data-src="/images/Java/normal_basic_varchar.png" alt="normal_basic_varchar"></p>
<p>float: 单精度类型,精度是8位有效数字，取值范围是10的-38次方到10的38次方，float占用4个字节的存储空间double:双精度类型，精度是17位有效数字，取值范围是10的-308次方到10的308次方。</p>
<p>double占用8个字节的存储空间若不声明的，默认小数都用double来表示，所以如果要用float的话，则应该在其后加上f例如：float a=1.63;//会显示错误，正确的写法为float a=1.63f;</p>
<ul>
<li>引用数据类型</li>
</ul>
<p><strong>String</strong> 是一种常见的<strong>引用数据类型</strong>，用来表示字符串。在程序开发中，很多操作都要使用字符串来完成，例如系统中的用户名、密码、电子邮箱等。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul>
<li>自动类型转换</li>
</ul>
<p>满足条件：</p>
<ol>
<li>目标类型能与源类型兼容，如 double 型兼容 int 型，但是 char 型不能兼容 int 型</li>
<li>目标类型<strong>大于</strong>源类型，如 double 类型长度为 8 字节， int 类型为 4 字节，因此 double 类型的变量里直接可以存放 int 类型的数据，但反过来就不可以了</li>
</ol>
<ul>
<li>强制类型转换</li>
</ul>
<p>例如：当程序中需要将 double 型变量的值赋给一个 int 型变量，该如何实现呢？</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> avg1 = <span class="number">75.8</span>;</span><br><span class="line"><span class="keyword">int</span> avg2 = (<span class="keyword">int</span>)avg1;</span><br><span class="line">System.out.println(avg2);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>所谓常量，我们可以理解为是一种特殊的变量，它的值被设定后，在<strong>程序运行过程中不允许改变</strong>。常量名一般用大写。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> String LOVE = “sh”;</span><br><span class="line">System.out.println(LOVE);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>一般来说，对于一份规范的程序源代码而言，注释应该占到源代码的 1/3 以上。因此，注释是程序源代码的重要组成部分，一定要加以重视哦！</p>
<p>注释标记：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@author</span> 标明开发该类模块的作者</span><br><span class="line"><span class="meta">@version</span> 标明该类模块的版本</span><br><span class="line"><span class="meta">@see</span> 参考转向，也就是相关主题</span><br><span class="line"><span class="meta">@param</span> 对方法中某参数的说明</span><br><span class="line"><span class="meta">@return</span> 对方法返回值的说明</span><br><span class="line"><span class="meta">@exception</span> 对方法可能抛出的异常进行说明</span><br></pre></td></tr></tbody></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>算术运算符</li>
</ul>
<p><img data-src="/images/Java/compute_operator.png" alt="compute_operator"></p>
<ul>
<li>赋值运算符</li>
</ul>
<p><img data-src="/images/Java/fuzhi_operator.png" alt="fuzhi_operator"></p>
<ul>
<li>比较运算符</li>
</ul>
<p><img data-src="/images/Java/compare_operator.png" alt="compare_operator"></p>
<ul>
<li>逻辑运算符</li>
</ul>
<p><img data-src="/images/Java/logic_operator.png" alt="logic_operator"></p>
<ul>
<li>条件运算符：三元运算符</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">语法形式：布尔表达式 ？ 表达式<span class="number">1</span> ：表达式<span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String str = (<span class="number">8</span>&gt;<span class="number">5</span>) ? <span class="string">"8大于5"</span>:<span class="string">"8不大于5"</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>优先级</li>
</ul>
<p><img data-src="/images/Java/advance.png" alt="advance"></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>声明与赋值</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 声明方法1：int[] score; 需要指定长度</span></span><br><span class="line"><span class="keyword">int</span>[] score = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span>[] score = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明方法2: int score[]; 需指定长度</span></span><br><span class="line"><span class="keyword">int</span> score = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>}; <span class="comment">//声明一个大小为5的int型数组，并赋值</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li>创建</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"s1"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String();</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"s3"</span>);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>不变性</li>
</ul>
<p>String 对象创建后则不能被修改，是不可变的，所谓的修改其实是创建了新的对象，所指向的内存空间不同。</p>
<ol>
<li>通过 String s1=”string”; 声明了一个字符串对象， s1 存放了到字符串对象的引用</li>
<li>一旦一个字符串在内存中创建，则这个字符串将不可改变。如果需要一个可以改变的字符串，我们可以使用StringBuffer或者StringBuilder</li>
<li>每次 new 一个字符串就是产生一个新的对象，即便两个字符串的内容相同，使用 ”==” 比较时也为 ”false” ，如果只需比较内容是否相同，应使用 ”equals()” 方法</li>
</ol>
<ul>
<li>String中的常用方法</li>
</ul>
<p><img data-src="/images/Java/methodsinJava.png" alt="methodsinJava"></p>
<ul>
<li>StringBuilder类</li>
</ul>
<p>在Java中，除了可以使用String来存储字符串，还可以使用StringBuilder类或StringBuffer类存储字符串。</p>
<p>String类有不变性，StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。因此一般情况下，<strong>如果需要创建一个内容可变的字符串对象，应优先考虑使用StringBuilder类。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">StringBuilder str1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">StringBuilder str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"imo"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Java/StringBuilder.png" alt="StringBuilder"></p>
<h1 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h1><ul>
<li>类是抽象的概念，是对象的模版</li>
<li>对象是具体的事物，是类的具体实例</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Dog</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="comment">//content</span></span><br><span class="line">  String name;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">    <span class="comment">//对象</span></span><br><span class="line">    Dog duoduo = <span class="keyword">new</span> Dog();</span><br><span class="line">    duoduo.name = <span class="string">"多多"</span>;</span><br><span class="line">    System.out.println(<span class="string">"Hello"</span> + duoduo.name);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>类：首字母大写</li>
<li>对象：首字母小写</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul>
<li>封装即隐藏功能的实现细节</li>
<li>利用对象与方法是实现封装的直接途径</li>
<li>良好的封装让代码更容易阅读和维护</li>
</ul>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ul>
<li>同一个package下的类无需import</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.objectproject.sample2;</span><br><span class="line"><span class="keyword">import</span> com.imooc.objectproject.sample.Sample01; <span class="comment">//引用到类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Sample02</span><span class="params">()</span></span>{</span><br><span class="line">  Sample01 s01 = <span class="keyword">new</span> Sample01();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li>访问修饰符用于<strong>控制类、成员变量、方法</strong>的访问范围</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>访问修饰符</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>公共</td>
<td>在任何地方都可以访问</td>
</tr>
<tr>
<td>(default)</td>
<td>默认</td>
<td>相同包和其他类可以访问</td>
</tr>
<tr>
<td>protected</td>
<td>继承</td>
<td>只有继承的子类可以访问</td>
</tr>
<tr>
<td>private</td>
<td>私有</td>
<td>只能在类的内部访问</td>
</tr>
</tbody>
</table>
</div>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>父类中声明为public的方法，在子类中也必须为public</li>
<li>父类中声明为default的方法，在子类中可以声明成private</li>
<li>父类中声明为protected的方法，在子类中可以声明成protected、public，不能声明成private</li>
<li>父类中声明为private的方法，不能被继承</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>多态是同一个行为具有多个不同表现形态或形态的能力</li>
<li>实现多态的关键是接口<ul>
<li>接口是一个抽象的类型，只提供方法的定义</li>
<li>实现类是一个接口的具体表现，要实现每一个接口方法的功能</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Language</span></span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">voice</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Language</span></span>{</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">voice</span><span class="params">()</span></span>{</span><br><span class="line">    System.out.println(<span class="string">"你好"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">English</span> <span class="keyword">implements</span> <span class="title">Language</span></span>{</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">voice</span><span class="params">()</span></span>{</span><br><span class="line">    System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//使用接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerService</span>()</span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Language <span class="title">contant</span><span class="params">(<span class="keyword">int</span> areaCode)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(areaCode == <span class="number">86</span>){</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Chinese();</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(areaCode == <span class="number">33</span>){</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> English();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//多态</span></span><br><span class="line">CustomerService cs = <span class="keyword">new</span> CustomerService();</span><br><span class="line">Language language = cs.contant(<span class="number">86</span>);</span><br><span class="line">language.voice();</span><br></pre></td></tr></tbody></table></figure>
<h1 id="异常与异常处理"><a href="#异常与异常处理" class="headerlink" title="异常与异常处理"></a>异常与异常处理</h1><p>Java中所有的异常都继承自Throwable类</p>
<ul>
<li>Error错误表示：虚拟机错位、线程死锁</li>
<li>Exception异常表示：编码、环境、用户操作异常<ul>
<li>非检查异常：空指针异常、数组下标越界异常、类型转换异常、算术异常</li>
<li>检查异常：文件异常、SQL异常</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 调用者可以处理异常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>{</span><br><span class="line">  <span class="comment">// 一些会抛出异常的方法</span></span><br><span class="line">}<span class="keyword">catch</span>(ArithmeticException e){</span><br><span class="line">  </span><br><span class="line">}<span class="keyword">catch</span>(Exception e){</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>自定义异常</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrunkException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>{</span><br><span class="line">  <span class="comment">// 构造器</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DrunkException</span><span class="params">(String message)</span></span>{</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 调用者不能处理异常</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> <span class="keyword">throws</span> DrunkException</span>{</span><br><span class="line">  divide(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Java中的常用类"><a href="#Java中的常用类" class="headerlink" title="Java中的常用类"></a>Java中的常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>基本数据类型是不具备对象的特性的，比如基本类型不能调用方法、功能简单。为了让基本数据类型也具备对象的特性， Java 为每个基本数据类型都提供了一个包装类，这样我们就可以像操作对象那样来操作基本数据类型。包装类主要提供了两大类方法：</p>
<ol>
<li>将本类型和其他基本类型进行转换的方法</li>
<li>将字符串和本类型及包装类互相转换的方法</li>
</ol>
<ul>
<li>基本类型和包装类之间的对应关系</li>
</ul>
<p><img data-src="/images/Java/relationship.png" alt="relationship"></p>
<ul>
<li>包装类的常用方法</li>
</ul>
<p><img data-src="/images/Java/method.png" alt="method"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 定义int类型变量，值为86</span></span><br><span class="line">		<span class="keyword">int</span> score1 = <span class="number">86</span>; </span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 创建Integer包装类对象，表示变量score1的值</span></span><br><span class="line">		Integer score2=<span class="keyword">new</span> Integer(score1);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 将Integer包装类转换为double类型</span></span><br><span class="line">		<span class="keyword">double</span> score3=score2.doubleValue();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 将Integer包装类转换为float类型</span></span><br><span class="line">		<span class="keyword">float</span> score4=score2.floatValue();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 将Integer包装类转换为int类型</span></span><br><span class="line">		<span class="keyword">int</span> score5 =score2.intValue();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"Integer包装类："</span> + score2);</span><br><span class="line">		System.out.println(<span class="string">"double类型："</span> + score3);</span><br><span class="line">		System.out.println(<span class="string">"float类型："</span> + score4);</span><br><span class="line">		System.out.println(<span class="string">"int类型："</span> + score5);</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Java 中基本类型和包装类之间的转换</li>
</ul>
<p>在 JDK1.5 引入自动装箱和拆箱的机制后，包装类和基本类型之间的转换就更加轻松便利了。</p>
<p><strong>装箱：</strong>把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>; <span class="comment">// 定义一个int基本类型值</span></span><br><span class="line">Integer x = <span class="keyword">new</span> Integer(i); <span class="comment">// 手动装箱</span></span><br><span class="line">Integer y = i; <span class="comment">// 自动装箱</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>拆箱：</strong>和装箱相反，把包装类对象转换成基本类型的值，又可分为手动拆箱和自动拆箱</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">8</span>); <span class="comment">// 定义一个Integer包装类对象，值为8</span></span><br><span class="line"><span class="keyword">int</span> m = j.intValue(); <span class="comment">// 手动装箱为int类型</span></span><br><span class="line"><span class="keyword">int</span> n = j; <span class="comment">// 自动拆箱为int类型</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="基本类型和字符串的转换"><a href="#基本类型和字符串的转换" class="headerlink" title="基本类型和字符串的转换"></a>基本类型和字符串的转换</h2><ul>
<li>基本类型转换为字符串<ul>
<li>使用包装类的 toString() 方法</li>
<li>使用String类的 valueOf() 方法</li>
<li>用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">String str1 = Integer.toString(c);</span><br><span class="line">String str2 = String.valueOf(c);</span><br><span class="line">String str3 = c + <span class="string">""</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>将字符串转换成基本类型<ul>
<li>调用包装类的 parseXxx 静态方法</li>
<li>调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String str = <span class="string">"8"</span>;</span><br><span class="line"><span class="keyword">int</span> d = Integer.parseInt(str);</span><br><span class="line"><span class="keyword">int</span> e = Integer.valueOf(str);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Date和SimpleDateFormate"><a href="#Date和SimpleDateFormate" class="headerlink" title="Date和SimpleDateFormate"></a>Date和SimpleDateFormate</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(d);</span><br></pre></td></tr></tbody></table></figure>
<p>使用 SimpleDateFormat 来对日期时间进行格式化，如可以将日期转换为指定格式的文本，也可将文本转换为日期。</p>
<ol>
<li>使用 format() 方法将日期转换为指定格式的文本</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">String today = sdf.format(d);</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>使用 parse() 方法将文本转换为日期</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">String day = <span class="string">"2021年6月22日 15:30:26"</span>;</span><br><span class="line">SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">Date date = df.parse(day);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h2><p>Date 类最主要的作用就是获得当前时间，同时这个类里面也具有设置时间以及一些其他的功能，但是由于本身设计的问题，这些方法却遭到众多批评，不建议使用，更推荐使用 Calendar 类进行时间和日期的处理。</p>
<p>java.util.Calendar 类是一个抽象类，可以通过调用 getInstance() 静态方法获取一个 Calendar 对象，此对象已由当前日期时间初始化，即默认代表当前时间，如 Calendar c = Calendar.getInstance();</p>
<p>那么如何使用 Calendar 获取年、月、日、时间等信息呢？我们来看下面的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line"><span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br></pre></td></tr></tbody></table></figure>
<p>Calendar 类提供了 getTime() 方法，用来获取 Date 对象，完成 Calendar 和 Date 的转换，还可通过 getTimeInMillis() 方法，获取此 Calendar 的时间值，以毫秒为单位。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Date date = c.getTime();</span><br><span class="line">Long time = c.getTimeInMillis();</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>Math 类位于 java.lang 包中，包含用于执行基本数学运算的方法， Math 类的所有方法都是静态方法，所以使用该类中的方法时，可以直接使用类名.方法名，如： Math.round();</p>
<p><img data-src="/images/Java/Math.png" alt="Math"></p>
<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><ul>
<li>数组的长度固定，集合长度可变</li>
<li>数据只能通过下标访问元素，类型固定，而有的集合可以通过任意类型查找所映射的具体对象</li>
<li>Java中的集合框架主要由Collection和Map组成</li>
<li><strong>Collection：List-&gt;ArrayList、Queue-&gt;LinkedList 、Set-&gt;HashSet</strong></li>
<li><strong>Map: HashMap</strong></li>
</ul>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListSample</span></span>{</span><br><span class="line">  List&lt;String&gt; bookList;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">    <span class="comment">// 泛型</span></span><br><span class="line">    <span class="keyword">this</span>.bookList  = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    bookList.add(<span class="string">"hongloumeng"</span>); <span class="comment">// 末尾添加</span></span><br><span class="line">    bookList.add(<span class="number">0</span>，<span class="string">"shuihuzhan"</span>);<span class="comment">// 指定位置添加</span></span><br><span class="line">    </span><br><span class="line">    String bookname = bookList.get(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span>(String book : bookList){</span><br><span class="line">      System.out.println(<span class="string">"《"</span> + book + <span class="string">"》"</span>);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><p>集合中的元素，可以是任意类型的对象（对象的引用）</p>
<p>如果把某个对象放入集合，则会忽略他的类型，而把它当作Object处理</p>
</li>
<li><p>泛型则是规定了某个集合只可以存放特定类型的对象</p>
<p>会在编译期间进行类型的检查</p>
</li>
<li><p>泛型集合中的限定类型不能使用基本数据类型</p>
</li>
<li><p>可以通过使用<strong>包装类</strong>限定允许存入的基本数据类型</p>
</li>
</ol>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>Set是元素无序并且不可以重复的集合，被称为集</p>
<p>HashSet — 哈希集，是Set的一个重要实现类</p>
<p>Set中，添加某个对象，无论添加多少次，最终只会保留一个该对象（的引用），并且，保留的是第一次添加的那一个。</p>
<h2 id="Map-amp-HashMap接口"><a href="#Map-amp-HashMap接口" class="headerlink" title="Map &amp; HashMap接口"></a>Map &amp; HashMap接口</h2><ul>
<li>Map提供了一种映射关系，其中的元素是以键值对（Key-Value）的形式存储的，能够实现根据Key快速查找Value</li>
<li>Map中的键值对以Entry类型的对象实例形式存在</li>
<li>键（Key）不可重复，Value可以</li>
<li>Map支持泛型，形式如Map<k，v></k，v></li>
</ul>
<h2 id="Comparable-amp-Comparator接口"><a href="#Comparable-amp-Comparator接口" class="headerlink" title="Comparable &amp; Comparator接口"></a>Comparable &amp; Comparator接口</h2><ul>
<li><p>相同点</p>
<ul>
<li>Comparable和Comparator都是用来实现对象的比较、排序</li>
<li>要想对象比较、排序，都需要实现Comparable或Comparator接口</li>
<li>Comparable和Comparator都是Java的接口</li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li>Comparator位于java.util包下，而Comparable位于java.lang包下</li>
<li>Comparable接口的实现是在类的内部（如 String、Integer已经实现了Comparable接口，自己就可以完成比较大小操作），Comparator接口的实现是在类的外部（可以理解为一个是自已完成比较，一个是外部程序实现比较）</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li>实现Comparable接口要重写compareTo方法, 在compareTo方法里面实现比较</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>{</span><br><span class="line">     String name;</span><br><span class="line">     <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student another)</span> </span>{</span><br><span class="line">          <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">          i = name.compareTo(another.name); </span><br><span class="line">          <span class="keyword">if</span>(i == <span class="number">0</span>) { </span><br><span class="line">               <span class="keyword">return</span> age - another.age;</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">               <span class="keyword">return</span> i; </span><br><span class="line">          }</span><br><span class="line">     }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以直接用 Collections.sort( StudentList ) 对其排序了.(**只需传入要排序的列表**）</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>实现Comparator需要重写 compare 方法</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>{</span><br><span class="line">     String name;</span><br><span class="line">     <span class="keyword">int</span> age</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>{ </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student one, Student another)</span> </span>{</span><br><span class="line">          <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">          i = one.name.compareTo(another.name); </span><br><span class="line">          <span class="keyword">if</span>(i == <span class="number">0</span>) { </span><br><span class="line">               <span class="keyword">return</span> one.age - another.age;</span><br><span class="line">          } <span class="keyword">else</span> {</span><br><span class="line">               <span class="keyword">return</span> i;          }</span><br><span class="line">     }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collections.sort( StudentList , new StudentComparator()) 可以对其排序（**不仅要传入待排序的列表，还要传入实现了Comparator的类的对象**）</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>总结</p>
<ul>
<li><p>如果比较的方法只要用在一个类中，用该类实现Comparable接口就可以。</p>
</li>
<li><p>如果比较的方法在很多类中需要用到，就自己写个类实现Comparator接口，这样当要比较的时候把实现了Comparator接口的类传过去就可以，省得重复造轮子。这也是为什么Comparator会在java.util包下的原因。<br> 使用Comparator的优点是：1.与实体类分离 2.方便应对多变的排序规则</p>
</li>
</ul>
</li>
</ul>
<h2 id="java-util-Collections工具类"><a href="#java-util-Collections工具类" class="headerlink" title="java.util.Collections工具类"></a>java.util.Collections工具类</h2><ul>
<li>是Java集合框架中，用来操作集合对象的工具类</li>
<li>sort()方法实现排序</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortCollections</span><span class="params">()</span></span>{</span><br><span class="line">  List&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">  Random random = <span class="keyword">new</span> Random();</span><br><span class="line">  Integer k;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>; i++){</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">      k = random.nextInt(<span class="number">100</span>); <span class="comment">// 生成一个100以内的随机整数</span></span><br><span class="line">    }<span class="keyword">while</span>(integers.contains(k));</span><br><span class="line">    integers.add(k);</span><br><span class="line">    System.out.println(<span class="string">"成功添加整数"</span>+k);</span><br><span class="line">  }</span><br><span class="line">  System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">  <span class="keyword">for</span>(Integer integer:integers){</span><br><span class="line">    System.out.println(<span class="string">"元素"</span>+integer);</span><br><span class="line">  }</span><br><span class="line">  Collections.sort(integers); <span class="comment">// 对integers排序</span></span><br><span class="line">  </span><br><span class="line">  System.out.println(<span class="string">"排序后"</span>);</span><br><span class="line">  <span class="keyword">for</span>(Integer integer:integers){</span><br><span class="line">    System.out.println(<span class="string">"元素"</span>+integer);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>psvm + Enter</td>
<td>main</td>
</tr>
<tr>
<td>Command + N</td>
<td>get，set方法</td>
</tr>
<tr>
<td>sout</td>
<td>System.out.println()</td>
</tr>
<tr>
<td>Option + command + L</td>
<td>格式化代码</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV-Base</title>
    <url>/posts/16645/</url>
    <content><![CDATA[<h1 id="OpenCV的安装"><a href="#OpenCV的安装" class="headerlink" title="OpenCV的安装"></a>OpenCV的安装</h1><p>国内一些pip的镜像源：</p>
<p>阿里云 <a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a><br>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>豆瓣(douban) <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a><br>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/">http://pypi.mirrors.ustc.edu.cn/simple/</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">(base)$ conda create -n py365 python=<span class="number">3.6</span><span class="number">.5</span>   <span class="comment"># anaconda中创建python版本为3.7.3的虚拟环境</span></span><br><span class="line">(base)$ conda activate py365                 <span class="comment"># 激活该环境</span></span><br><span class="line">pip install opencv-python==<span class="number">3.4</span><span class="number">.1</span><span class="number">.15</span> -i http://pypi.douban.com/simple --trusted-host pypi.douban.com                              <span class="comment"># 安装opencv-python 3.4.1.15，同时还会加载相应的依赖库</span></span><br></pre></td></tr></tbody></table></figure>
<p>内容完善中……</p>
<a id="more"></a>
<h1 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h1><h2 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h2><p><img data-src="/images/opencv/Pyramid_1.png" alt="Pyramid_1"></p>
<p><strong>高斯金字塔：向下采样法（缩小）</strong></p>
<p><img data-src="/images/opencv/Pyramid_2.png" alt="Pyramid_2"></p>
<p>实例：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"A.png"</span>)</span><br><span class="line">down = cv2.pyrDown(img)</span><br><span class="line">cv2.imshow(<span class="string">"down"</span>,down)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>高斯金字塔：向上采样法（放大）</strong></p>
<p><img data-src="/images/opencv/Pyramid_3.png" alt="Pyramid_3"></p>
<p>实例：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"A.png"</span>)</span><br><span class="line">up = cv2.pyrUp(img)</span><br><span class="line">cv2.imshow(<span class="string">"up"</span>,up)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h2><p><img data-src="/images/opencv/Pyramid_4.png" alt="Pyramid_4"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">down=cv2.pyrDown(img)</span><br><span class="line">down_up=cv2.pyrUp(down)</span><br><span class="line">l_img=img-down_up</span><br><span class="line">cv2.imshow(l_img,<span class="string">'l_1'</span>)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="轮廓检测"><a href="#轮廓检测" class="headerlink" title="轮廓检测"></a>轮廓检测</h1><p><strong>cv2.findContours(img,mode,method)</strong></p>
<p>mode:轮廓检索模式</p>
<ul>
<li>RETR_EXTERNAL ：只检索最外面的轮廓；</li>
<li>RETR_LIST：检索所有的轮廓，并将其保存到一条链表当中；</li>
<li>RETR_CCOMP：检索所有的轮廓，并将他们组织为两层：顶层是各部分的外部边界，第二层是空洞的边界;</li>
<li>RETR_TREE：检索所有的轮廓，并重构嵌套轮廓的整个层次;</li>
</ul>
<p>method:轮廓逼近方法</p>
<ul>
<li>CHAIN_APPROX_NONE：以Freeman链码的方式输出轮廓，所有其他方法输出多边形（顶点的序列）。</li>
<li>CHAIN_APPROX_SIMPLE:压缩水平的、垂直的和斜的部分，也就是，函数只保留他们的终点部分。</li>
</ul>
<p>为了得到更高的准确率，使用二值图像。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'contours.png'</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(gray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">cv2.imshow(thresh,<span class="string">'thresh'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># binary 输出的二值图；contours 边缘；hierarchy 层次结构</span></span><br><span class="line">binary, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制轮廓：参数分别为，轮廓，轮廓索引（-1表示所有轮廓），颜色，线条厚度</span></span><br><span class="line">draw_img = img.copy()</span><br><span class="line">res = cv2.drawContours(draw_img, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">cv_show(res,<span class="string">'res'</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h2><h3 id="炬"><a href="#炬" class="headerlink" title="炬"></a>炬</h3><h3 id="面积"><a href="#面积" class="headerlink" title="面积"></a>面积</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#面积</span></span><br><span class="line">cv2.contourArea(cnt)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="周长"><a href="#周长" class="headerlink" title="周长"></a>周长</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line">cv2.arcLength(cnt,<span class="literal">True</span>) <span class="comment"># True表示闭合</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="轮廓近似"><a href="#轮廓近似" class="headerlink" title="轮廓近似"></a>轮廓近似</h3><p><img data-src="/images/opencv/contours3.png" alt="contours3"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 找轮廓</span></span><br><span class="line">img = cv2.imread(<span class="string">'contours2.png'</span>)</span><br><span class="line"></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(gray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">binary, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">draw_img = img.copy()</span><br><span class="line">res = cv2.drawContours(draw_img, [cnt], -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">cv_show(res,<span class="string">'res'</span>)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">epsilon = <span class="number">0.15</span>*cv2.arcLength(cnt,<span class="literal">True</span>)  <span class="comment"># epsilon一般按照周长的百分比进行设置，越小，轮廓近似值越大</span></span><br><span class="line">approx = cv2.approxPolyDP(cnt,epsilon,<span class="literal">True</span>) </span><br><span class="line"></span><br><span class="line">draw_img = img.copy()</span><br><span class="line">res = cv2.drawContours(draw_img, [approx], -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">cv_show(res,<span class="string">'res'</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="边界矩形"><a href="#边界矩形" class="headerlink" title="边界矩形"></a>边界矩形</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'contours.png'</span>)</span><br><span class="line"></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(gray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">binary, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">x,y,w,h = cv2.boundingRect(cnt)</span><br><span class="line">img = cv2.rectangle(img,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">cv_show(img,<span class="string">'img'</span>)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)</span><br><span class="line">x, y, w, h = cv2.boundingRect(cnt)</span><br><span class="line">rect_area = w * h</span><br><span class="line">extent = <span class="built_in">float</span>(area) / rect_area</span><br><span class="line"><span class="built_in">print</span> (<span class="string">'轮廓面积与边界矩形比'</span>,extent)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">(x,y),radius = cv2.minEnclosingCircle(cnt) </span><br><span class="line">center = (<span class="built_in">int</span>(x),<span class="built_in">int</span>(y)) </span><br><span class="line">radius = <span class="built_in">int</span>(radius) </span><br><span class="line">img = cv2.circle(img,center,radius,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">cv_show(img,<span class="string">'img'</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="轮廓的性质"><a href="#轮廓的性质" class="headerlink" title="轮廓的性质"></a>轮廓的性质</h2><h3 id="Solidty"><a href="#Solidty" class="headerlink" title="Solidty"></a>Solidty</h3><h3 id="Equivalent-Diameter"><a href="#Equivalent-Diameter" class="headerlink" title="Equivalent Diameter"></a>Equivalent Diameter</h3><h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><h3 id="掩模和像素点"><a href="#掩模和像素点" class="headerlink" title="掩模和像素点"></a>掩模和像素点</h3><h3 id="平均颜色和平均灰度"><a href="#平均颜色和平均灰度" class="headerlink" title="平均颜色和平均灰度"></a>平均颜色和平均灰度</h3><h3 id="极点"><a href="#极点" class="headerlink" title="极点"></a>极点</h3><h1 id="模版匹配"><a href="#模版匹配" class="headerlink" title="模版匹配"></a>模版匹配</h1><p>模版匹配和卷积原理很像，模版在原图上从原点开始滑动，计算模版与（图像被模版覆盖的地方）的差别程度，这个差别程度的计算方法在opencv里有6种。然后将每次计算的结果放入一个矩阵里，作为结果输出。假如原图形是A✖️B大小，而模版是a✖️b的大小，则输出结果的矩阵是（A-a+1）✖️（B-b+1）的大小。</p>
<ul>
<li>TM_SQDIFF：计算平方差，计算出来的值越小，越相关</li>
<li>TM_CCORR：计算相关性，计算出来的值越大，越相关</li>
<li>TM_CCOEFF：计算相关系数，计算出来的值越大，越相关</li>
<li>TM_SQDIFF_NORMED：计算归一化平方差，计算出来的值越接近0，越相关</li>
<li><p>TM_CCORR_NORMED：计算归一化相关性，计算出来的值越接近1，越相关</p>
</li>
<li><p>TM_CCOEFF_NORMED：计算归一化相关系数，计算出来的值越接近1，越相关</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"lena.jpg"</span>,<span class="number">0</span>)</span><br><span class="line">h,w = img.shape[:<span class="number">2</span>][::-<span class="number">1</span>]</span><br><span class="line">template = cv2.imread(<span class="string">"face"</span>,<span class="number">0</span>)</span><br><span class="line">methods = [<span class="string">'cv2.TM_CCOEFF'</span>,<span class="string">'cv2.TM_CCORR_NORME'</span>,<span class="string">'cv2.TM_CCORR'</span>,<span class="string">'cv2.TM_CCORR_NORMED'</span>,<span class="string">'cv2.TM_SQDIFF'</span>,<span class="string">'cv2.TM_SQDIFF_NORMED'</span>]</span><br><span class="line">res = cv2.matchTemplate(img,template,<span class="number">1</span>) <span class="comment"># 模版匹配</span></span><br><span class="line">min_val,max_val,min_loc,max_loc = cv2.minMacLoc(res) <span class="comment"># 返回最小最大值的坐标和位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> meth <span class="keyword">in</span> methods:</span><br><span class="line">  img2 = img.copy()</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 匹配方法的真值</span></span><br><span class="line">  method = <span class="built_in">eval</span>(meth)</span><br><span class="line">  res = cv2.matchTemplate(img,template,<span class="number">1</span>) <span class="comment"># 模版匹配</span></span><br><span class="line">  min_val,max_val,min_loc,max_loc = cv2.minMacLoc(res) <span class="comment"># 返回最小最大值的坐标和位置</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 如果是平方差匹配TM_SQDIFF或者归一化平方差匹配TM_SQDIFF_NORMED，取最小值</span></span><br><span class="line">  <span class="keyword">if</span> method <span class="keyword">in</span> [cv2.TM_SQDIFF,cv2.TM_SQDIFF_NORMED]:</span><br><span class="line">    top_left = min_loc</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    top_left = max_loc</span><br><span class="line">  bottom_right = (top_left[<span class="number">0</span>]+w,top_left[<span class="number">1</span>]+h)</span><br><span class="line">  </span><br><span class="line">  cv2.rectangle(img2,top_left,bottom_right,<span class="number">255</span>,<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">  plt.subplot(<span class="number">121</span>),plt.imshow(res,cmap=<span class="string">'gray'</span>)</span><br><span class="line">  plt.sticks([]),plt.yticks([])</span><br><span class="line">  plt.subplot(<span class="number">122</span>),plt.imshow(img2,cmap=<span class="string">'gray'</span>)</span><br><span class="line">  plt.sticks([]),plt.yticks([])</span><br><span class="line">  plt.subtitle(meth)</span><br><span class="line">  plt.show()</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配多个对象</span></span><br><span class="line">img = cv2.imread(<span class="string">"lena.jpg"</span>,<span class="number">0</span>)</span><br><span class="line">h,w = img.shape[:<span class="number">2</span>][::-<span class="number">1</span>]</span><br><span class="line">template = cv2.imread(<span class="string">"face"</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">res = cv2.matchTemplate(img,template,cv2.TM_CCORR_NORME) <span class="comment"># 模版匹配</span></span><br><span class="line">threshold = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取匹配程度大于0.8的坐标</span></span><br><span class="line">loc = np.where(res &gt;= threshold)</span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> <span class="built_in">zip</span>(*loc[::-<span class="number">1</span>]): <span class="comment">#*号表示可选参数</span></span><br><span class="line">  bottom_right = (pt[<span class="number">0</span>] + w, pt[<span class="number">1</span>] + h)</span><br><span class="line">  cv2.rectangle(img,pt,bottom_right,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">cv2.imshow(<span class="string">"img"</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h1><p>统计图中的像素点分布。</p>
<h2 id="直方图的计算、绘制与分析"><a href="#直方图的计算、绘制与分析" class="headerlink" title="直方图的计算、绘制与分析"></a>直方图的计算、绘制与分析</h2><p>cv2.calcHist(images, channels,mask,histSize,range)</p>
<ul>
<li>images:原图像格式为uint8或float32，当传入函数时应用中括号，例如[img]</li>
<li>channels:同样用中括号，如果图像时灰度图，它的值是[0]，如果是彩色图像，那传入的参数可以是【0】【1】【2】</li>
<li>mask:掩模图像，统计整幅图像就将它设为None，但是如果只想统计一部分，就制作一个掩模。</li>
<li>histSize:BIN的数目，也用中括号</li>
<li>ranges:像素值范围，为[0,256]</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"cat.png"</span>,<span class="number">0</span>)</span><br><span class="line">hist = cv2.calcHist([img],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.hist(img.ravel(),<span class="number">256</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="mask操作"><a href="#mask操作" class="headerlink" title="mask操作"></a>mask操作</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 创建mask</span></span><br><span class="line">mask = np.zeros(img.shape[:<span class="number">2</span>],np.uint8)</span><br><span class="line">mask[<span class="number">100</span>:<span class="number">300</span>,<span class="number">100</span>:<span class="number">400</span>] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作mask</span></span><br><span class="line">mask_img = cv2.bitwise_and(img,img,mask=mask) <span class="comment">#与操作</span></span><br><span class="line">cv2.imshow(<span class="string">"img"</span>,img)</span><br><span class="line"></span><br><span class="line">hist_full = cv2.calHist([img],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">hist_mask = cv2.calHist([img],[<span class="number">0</span>],mask,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br></pre></td></tr></tbody></table></figure>
<h2 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h2><p>均衡后，色彩和亮度能够稍微的提升。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">equ = cv2.equalizeHist(img)</span><br><span class="line">plt.hist(equ,ravel(<span class="number">0</span>,<span class="number">256</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>自适应直方图均衡化</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">clahe = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>,tilerGridSize(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">res_clahe = clahe.apple(img)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="傅立叶变换"><a href="#傅立叶变换" class="headerlink" title="傅立叶变换"></a>傅立叶变换</h1><p>中心思想：<strong>任何函数都能通过傅立叶堆叠出来。</strong></p>
<p>以时间为参照就是时域分析。</p>
<p><strong>傅立叶变换的作用：</strong></p>
<ul>
<li>高频：变化剧烈的灰度分量，例如边界</li>
<li>低频：变化缓慢的灰度分量，例如一片大海</li>
</ul>
<p>可以找到图像中的高频与低频部分。</p>
<p><strong>滤波：</strong></p>
<ul>
<li>低通滤波器：只保留低频，会使图像模糊</li>
<li>高通滤波器：只保留高频，会使图像细节增强</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv2.imread(<span class="string">"lena.jpg"</span>,<span class="number">0</span>)</span><br><span class="line">img_float32 = np.float32(img)</span><br><span class="line"></span><br><span class="line">dft = cv2.dft(img_float32,flags = cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">dft_shift = np.fft.fftshift(dft) <span class="comment">#将低频值转换到中间的位置</span></span><br><span class="line"><span class="comment"># 得到灰度图能够表示的形式</span></span><br><span class="line">magnitude_spectrum = <span class="number">20</span>*np.log(cv2.magnitude(dft_shift[:,:,<span class="number">0</span>],dft_shift[:,:,<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">plt.subplot((<span class="number">121</span>),plt.imshow(img,cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">"Input image"</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(magnitude_spectrum,cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'magnitude_spectrum'</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<h1 id="图像特征"><a href="#图像特征" class="headerlink" title="图像特征"></a>图像特征</h1><h2 id="Harris角点检测"><a href="#Harris角点检测" class="headerlink" title="Harris角点检测"></a>Harris角点检测</h2><p>边界：一个特征值大，一个特征值小，自相关函数值在某一方向上大，在其他方向上小。</p>
<p>平面：两个特征值都小，且近似相等，自相关函数数值在各个方向上都小。</p>
<p>角点：两个特征值都大，且近似相等，自相关函数在所有方向都增大。</p>
<h3 id="cv2-cornerHarris"><a href="#cv2-cornerHarris" class="headerlink" title="cv2.cornerHarris()"></a>cv2.cornerHarris()</h3><ul>
<li>img： 数据类型为 ﬂoat32 的入图像</li>
<li>blockSize： 角点检测中指定区域的大小</li>
<li>ksize： Sobel求导中使用的窗口大小</li>
<li>k： 取值参数为 [0,04,0.06]</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">dst = cv2.cornerHarris(gray, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0.04</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">'dst.shape:'</span>,dst.shape)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">img[dst&gt;<span class="number">0.01</span>*dst.<span class="built_in">max</span>()]=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>] <span class="comment">#大于最大值的0.01倍，就认为是一个角点</span></span><br><span class="line">cv2.imshow(<span class="string">'dst'</span>,img) </span><br><span class="line">cv2.waitKey(<span class="number">0</span>) </span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Sift特征"><a href="#Sift特征" class="headerlink" title="Sift特征"></a>Sift特征</h2><p>Scale Invariant Feature Transform</p>
<h3 id="图像尺度空间"><a href="#图像尺度空间" class="headerlink" title="图像尺度空间"></a>图像尺度空间</h3><p>在一定的范围内，无论物体是大还是小，人眼都可以分辨出来，然而计算机要有相同的能力却很难，所以要让机器能够对物体在不同尺度下有一个统一的认知，就需要考虑图像在不同的尺度下都存在的特点。</p>
<p>尺度空间的获取通常使用高斯模糊来实现。</p>
<p><img data-src="/images/opencv/sift_3.png" alt="sift_3"></p>
<p><img data-src="/images/opencv/sift_2.png" alt="sift_2"></p>
<p>不同σ的高斯函数决定了对图像的平滑程度，越大的σ值对应的图像越模糊。</p>
<h3 id="多分辨率金字塔"><a href="#多分辨率金字塔" class="headerlink" title="多分辨率金字塔"></a>多分辨率金字塔</h3><p><img data-src="/images/opencv/sift_4.png" alt="sift_4"></p>
<h3 id="高斯差分金字塔（DOG）"><a href="#高斯差分金字塔（DOG）" class="headerlink" title="高斯差分金字塔（DOG）"></a>高斯差分金字塔（DOG）</h3><p><img data-src="/images/opencv/sift_5.png" alt="sift_5"></p>
<p><img data-src="/images/opencv/sift_6.png" alt="sift_6"></p>
<h3 id="DoG空间极值检测"><a href="#DoG空间极值检测" class="headerlink" title="DoG空间极值检测"></a>DoG空间极值检测</h3><p>为了寻找尺度空间的极值点，每个像素点要和其图像域（同一尺度空间）和尺度域（相邻的尺度空间）的所有相邻点进行比较，当其大于（或者小于）所有相邻点时，该点就是极值点。如下图所示，中间的检测点要和其所在图像的3×3邻域8个像素点，以及其相邻的上下两层的3×3领域18个像素点，共26个像素点进行比较。</p>
<p><img data-src="/images/opencv/sift_7.png" alt="sift_7"></p>
<h3 id="关键点的精确定位"><a href="#关键点的精确定位" class="headerlink" title="关键点的精确定位"></a>关键点的精确定位</h3><p>这些候选关键点是DOG空间的局部极值点，而且这些极值点均为离散的点，精确定位极值点的一种方法是，对尺度空间DoG函数进行曲线拟合，计算其极值点，从而实现关键点的精确定位。</p>
<p><img data-src="/images/opencv/sift_8.png" alt="sift_8"></p>
<p><img data-src="/images/opencv/sift_9.png" alt="sift_9"></p>
<h3 id="消除边界响应"><a href="#消除边界响应" class="headerlink" title="消除边界响应"></a>消除边界响应</h3><p><img data-src="/images/opencv/sift_10.png" alt="sift_10"></p>
<h3 id="特征点的主方向"><a href="#特征点的主方向" class="headerlink" title="特征点的主方向"></a>特征点的主方向</h3><p><img data-src="/images/opencv/sift_11.png" alt="sift_11"></p>
<p>每个特征点可以得到三个信息(x,y,σ,θ)，即位置、尺度和方向。具有多个方向的关键点可以被复制成多份，然后将方向值分别赋给复制后的特征点，一个特征点就产生了多个坐标、尺度相等，但是方向不同的特征点。</p>
<h3 id="生成特征描述"><a href="#生成特征描述" class="headerlink" title="生成特征描述"></a>生成特征描述</h3><p>在完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。</p>
<p><img data-src="/images/opencv/sift_12.png" alt="sift_12"></p>
<p>为了保证特征矢量的旋转不变性，要以特征点为中心，在附近邻域内将坐标轴旋转θ角度，即将坐标轴旋转为特征点的主方向。</p>
<p><img data-src="/images/opencv/sift_14.png" alt="sift_14"></p>
<p>旋转之后的主方向为中心取8x8的窗口，求每个像素的梯度幅值和方向，箭头方向代表梯度方向，长度代表梯度幅值，然后利用高斯窗口对其进行加权运算，最后在每个4x4的小块上绘制8个方向的梯度直方图，计算每个梯度方向的累加值，即可形成一个种子点，即每个特征的由4个种子点组成，每个种子点有8个方向的向量信息。</p>
<p><img data-src="/images/opencv/sift_15.png" alt="sift_15"></p>
<p>论文中建议对每个关键点使用4x4共16个种子点来描述，这样一个关键点就会产生128维的SIFT特征向量。</p>
<p><img data-src="/images/opencv/sift_17.png" alt="sift_17"></p>
<h3 id="OpenCV-SIFT函数"><a href="#OpenCV-SIFT函数" class="headerlink" title="OpenCV SIFT函数"></a>OpenCV SIFT函数</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'test_1.jpg'</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">sift = cv2.xfeatures2d.SIFT_create()</span><br><span class="line">kp = sift.detect(gray, <span class="literal">None</span>) <span class="comment"># kp：关键点</span></span><br><span class="line"></span><br><span class="line">img = cv2.drawKeypoints(gray, kp, img)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'drawKeypoints'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>
<p>计算特征</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">kp, des = sift.compute(gray, kp)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (np.array(kp).shape)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">des.shape</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">des[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure>
<h1 id="背景建模"><a href="#背景建模" class="headerlink" title="背景建模"></a>背景建模</h1><h2 id="帧差法"><a href="#帧差法" class="headerlink" title="帧差法"></a><strong>帧差法</strong></h2><p>由于场景中的目标在运动，目标的影像在不同图像帧中的位置不同。该类算法对时间上连续的两帧图像进行差分运算，不同帧对应的像素点相减，判断灰度差的绝对值，当绝对值超过一定阈值时，即可判断为运动目标，从而实现目标的检测功能。</p>
<p><img data-src="/images/opencv/bg_2.png" alt="bg_2"></p>
<p>帧差法非常简单，但是会引入噪音和空洞问题。</p>
<h2 id="混合高斯模型"><a href="#混合高斯模型" class="headerlink" title="混合高斯模型"></a>混合高斯模型</h2><p>（视频变化趋势应该是符合高斯分布的）</p>
<p>在进行前景检测前，先对背景进行训练，对图像中每个背景采用一个混合高斯模型进行模拟，每个背景的混合高斯的个数可以自适应。然后在测试阶段，对新来的像素进行GMM匹配，如果该像素值能够匹配其中一个高斯，则认为是背景，否则认为是前景。由于整个过程GMM模型在不断更新学习中，所以对动态背景有一定的鲁棒性。最后通过对一个有树枝摇摆的动态背景进行前景检测，取得了较好的效果。</p>
<p>在视频中对于像素点的变化情况应当是符合高斯分布。</p>
<p><img data-src="/images/opencv/bg_3.png" alt="bg_3"></p>
<p>背景的实际分布应当是多个高斯分布混合在一起，每个高斯模型也可以带有权重。</p>
<p><img data-src="/images/opencv/bg_4.png" alt="bg_4"></p>
<p><strong>混合高斯模型学习方法</strong></p>
<ul>
<li>1.首先初始化每个高斯模型矩阵参数。</li>
<li>2.取视频中T帧数据图像用来训练高斯混合模型。来了第一个像素之后用它来当做第一个高斯分布。</li>
<li>3.当后面来的像素值时，与前面已有的高斯的均值比较，如果该像素点的值与其模型均值差在3倍的方差内，则属于该分布，并对其进行参数更新。</li>
<li>4.如果下一次来的像素不满足当前高斯分布，用它来创建一个新的高斯分布。</li>
</ul>
<p><strong>混合高斯模型测试方法</strong></p>
<p>在测试阶段，对新来像素点的值与混合高斯模型中的每一个均值进行比较，如果其差值在2倍的方差之间的话，则认为是背景，否则认为是前景。将前景赋值为255，背景赋值为0。这样就形成了一副前景二值图。</p>
<p><img data-src="/images/opencv/bg_5.png" alt="bg_5"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment">#经典的测试视频</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">'test.avi'</span>)</span><br><span class="line"><span class="comment">#形态学操作需要使用</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment">#创建混合高斯模型用于背景建模</span></span><br><span class="line">fgbg = cv2.createBackgroundSubtractorMOG2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    fgmask = fgbg.apply(frame)</span><br><span class="line">    <span class="comment">#形态学开运算去噪点</span></span><br><span class="line">    fgmask = cv2.morphologyEx(fgmask, cv2.MORPH_OPEN, kernel)</span><br><span class="line">    <span class="comment">#寻找视频中的轮廓</span></span><br><span class="line">    im, contours, hierarchy = cv2.findContours(fgmask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> contours:</span><br><span class="line">        <span class="comment">#计算各轮廓的周长</span></span><br><span class="line">        perimeter = cv2.arcLength(c,<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> perimeter &gt; <span class="number">188</span>:</span><br><span class="line">            <span class="comment">#找到一个直矩形（不会旋转）</span></span><br><span class="line">            x,y,w,h = cv2.boundingRect(c)</span><br><span class="line">            <span class="comment">#画出这个矩形</span></span><br><span class="line">            cv2.rectangle(frame,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)    </span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>,frame)</span><br><span class="line">    cv2.imshow(<span class="string">'fgmask'</span>, fgmask)</span><br><span class="line">    k = cv2.waitKey(<span class="number">150</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure>
<h1 id="光流估计"><a href="#光流估计" class="headerlink" title="光流估计"></a>光流估计</h1><p>光流是空间运动物体在观测成像平面上的<strong>像素运动的“瞬时速度”，</strong>根据各个像素点的速度矢量特征，可以<strong>对图像进行动态分析，例如目标跟踪。</strong></p>
<ul>
<li>亮度恒定：同一点随着时间的变化，其亮度不会发生改变。</li>
<li>小运动：随着时间的变化不会引起位置的剧烈变化，只有小运动情况下才能用前后帧之间单位位置变化引起的灰度变化去近似灰度对位置的偏导数。</li>
<li>空间一致：一个场景上邻近的点投影到图像上也是邻近点，且邻近点速度一致。因为光流法基本方程约束只有一个，而要求x，y方向的速度，有两个未知变量。所以需要连立n多个方程求解。</li>
</ul>
<p><img data-src="/images/opencv/lk_2.png" alt="lk_2"></p>
<p><img data-src="/images/opencv/lk_1.png" alt="lk_1"></p>
<h2 id="Lucas-Kanade-算法"><a href="#Lucas-Kanade-算法" class="headerlink" title="Lucas-Kanade 算法"></a>Lucas-Kanade 算法</h2><p><img data-src="/images/opencv/lk_3.png" alt="lk_3"></p>
<p>如何求解方程组呢？看起来一个像素点根本不够，在物体移动过程中还有哪些特性呢？</p>
<p><img data-src="/images/opencv/lk_4.png" alt="lk_4"></p>
<p><strong>cv2.calcOpticalFlowPyrLK():</strong></p>
<p>参数：</p>
<ul>
<li>prevImage 前一帧图像</li>
<li>nextImage 当前帧图像</li>
<li>prevPts 待跟踪的特征点向量</li>
<li>winSize 搜索窗口的大小</li>
<li>maxLevel 最大的金字塔层数</li>
</ul>
<p>返回：</p>
<ul>
<li>nextPts 输出跟踪特征点向量</li>
<li>status 特征点是否找到，找到的状态为1，未找到的状态为0</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">'test.avi'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 角点检测所需参数</span></span><br><span class="line">feature_params = <span class="built_in">dict</span>( maxCorners = <span class="number">100</span>,</span><br><span class="line">                       qualityLevel = <span class="number">0.3</span>,</span><br><span class="line">                       minDistance = <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># lucas kanade参数</span></span><br><span class="line">lk_params = <span class="built_in">dict</span>( winSize  = (<span class="number">15</span>,<span class="number">15</span>),</span><br><span class="line">                  maxLevel = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机颜色条</span></span><br><span class="line">color = np.random.randint(<span class="number">0</span>,<span class="number">255</span>,(<span class="number">100</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿到第一帧图像</span></span><br><span class="line">ret, old_frame = cap.read()</span><br><span class="line">old_gray = cv2.cvtColor(old_frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 返回所有检测特征点，需要输入图像，角点最大数量（效率），品质因子（特征值越大的越好，来筛选）</span></span><br><span class="line"><span class="comment"># 距离相当于这区间有比这个角点强的，就不要这个弱的了</span></span><br><span class="line">p0 = cv2.goodFeaturesToTrack(old_gray, mask = <span class="literal">None</span>, **feature_params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个mask</span></span><br><span class="line">mask = np.zeros_like(old_frame)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line">    frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 需要传入前一帧和当前图像以及前一帧检测到的角点</span></span><br><span class="line">    p1, st, err = cv2.calcOpticalFlowPyrLK(old_gray, frame_gray, p0, <span class="literal">None</span>, **lk_params)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># st=1表示</span></span><br><span class="line">    good_new = p1[st==<span class="number">1</span>]</span><br><span class="line">    good_old = p0[st==<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制轨迹</span></span><br><span class="line">    <span class="keyword">for</span> i,(new,old) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(good_new,good_old)):</span><br><span class="line">        a,b = new.ravel()</span><br><span class="line">        c,d = old.ravel()</span><br><span class="line">        mask = cv2.line(mask, (a,b),(c,d), color[i].tolist(), <span class="number">2</span>)</span><br><span class="line">        frame = cv2.circle(frame,(a,b),<span class="number">5</span>,color[i].tolist(),-<span class="number">1</span>)</span><br><span class="line">    img = cv2.add(frame,mask)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>,img)</span><br><span class="line">    k = cv2.waitKey(<span class="number">150</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新</span></span><br><span class="line">    old_gray = frame_gray.copy()</span><br><span class="line">    p0 = good_new.reshape(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line">cap.release()</span><br></pre></td></tr></tbody></table></figure>
<h1 id="DNN模块"><a href="#DNN模块" class="headerlink" title="DNN模块"></a>DNN模块</h1><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">blob_from_images.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入工具包</span></span><br><span class="line"><span class="keyword">import</span> utils_paths</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签文件处理</span></span><br><span class="line">rows = <span class="built_in">open</span>(<span class="string">"synset_words.txt"</span>).read().strip().split(<span class="string">"\n"</span>)</span><br><span class="line">classes = [r[r.find(<span class="string">" "</span>) + <span class="number">1</span>:].split(<span class="string">","</span>)[<span class="number">0</span>] <span class="keyword">for</span> r <span class="keyword">in</span> rows]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Caffe所需配置文件</span></span><br><span class="line">net = cv2.dnn.readNetFromCaffe(<span class="string">"bvlc_googlenet.prototxt"</span>,</span><br><span class="line">	<span class="string">"bvlc_googlenet.caffemodel"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像路径</span></span><br><span class="line">imagePaths = <span class="built_in">sorted</span>(<span class="built_in">list</span>(utils_paths.list_images(<span class="string">"images/"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像数据预处理</span></span><br><span class="line">image = cv2.imread(imagePaths[<span class="number">0</span>])</span><br><span class="line">resized = cv2.resize(image, (<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"><span class="comment"># image scalefactor size mean swapRB </span></span><br><span class="line">blob = cv2.dnn.blobFromImage(resized, <span class="number">1</span>, (<span class="number">224</span>, <span class="number">224</span>), (<span class="number">104</span>, <span class="number">117</span>, <span class="number">123</span>))</span><br><span class="line">print(<span class="string">"First Blob: {}"</span>.<span class="built_in">format</span>(blob.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到预测结果</span></span><br><span class="line">net.setInput(blob)</span><br><span class="line">preds = net.forward()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序，取分类可能性最大的</span></span><br><span class="line">idx = np.argsort(preds[<span class="number">0</span>])[::-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">text = <span class="string">"Label: {}, {:.2f}%"</span>.<span class="built_in">format</span>(classes[idx],</span><br><span class="line">	preds[<span class="number">0</span>][idx] * <span class="number">100</span>)</span><br><span class="line">cv2.putText(image, text, (<span class="number">5</span>, <span class="number">25</span>),  cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line">	<span class="number">0.7</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示</span></span><br><span class="line">cv2.imshow(<span class="string">"Image"</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Batch数据制作</span></span><br><span class="line">images = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一样，数据是一个batch</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> imagePaths[<span class="number">1</span>:]:</span><br><span class="line">	image = cv2.imread(p)</span><br><span class="line">	image = cv2.resize(image, (<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">	images.append(image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># blobFromImages函数，注意有s</span></span><br><span class="line">blob = cv2.dnn.blobFromImages(images, <span class="number">1</span>, (<span class="number">224</span>, <span class="number">224</span>), (<span class="number">104</span>, <span class="number">117</span>, <span class="number">123</span>))</span><br><span class="line">print(<span class="string">"Second Blob: {}"</span>.<span class="built_in">format</span>(blob.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取预测结果</span></span><br><span class="line">net.setInput(blob)</span><br><span class="line">preds = net.forward()</span><br><span class="line"><span class="keyword">for</span> (i, p) <span class="keyword">in</span> <span class="built_in">enumerate</span>(imagePaths[<span class="number">1</span>:]):</span><br><span class="line">	image = cv2.imread(p)</span><br><span class="line">	idx = np.argsort(preds[i])[::-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">	text = <span class="string">"Label: {}, {:.2f}%"</span>.<span class="built_in">format</span>(classes[idx],</span><br><span class="line">		preds[i][idx] * <span class="number">100</span>)</span><br><span class="line">	cv2.putText(image, text, (<span class="number">5</span>, <span class="number">25</span>),  cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line">		<span class="number">0.7</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">	cv2.imshow(<span class="string">"Image"</span>, image)</span><br><span class="line">	cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="图像基本操作"><a href="#图像基本操作" class="headerlink" title="图像基本操作"></a>图像基本操作</h1><h1 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h1><h2 id="简单阈值"><a href="#简单阈值" class="headerlink" title="简单阈值"></a>简单阈值</h2><h2 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h2><h2 id="Otsu‘s-二值化"><a href="#Otsu‘s-二值化" class="headerlink" title="Otsu‘s 二值化"></a>Otsu‘s 二值化</h2><h1 id="平滑处理"><a href="#平滑处理" class="headerlink" title="平滑处理"></a>平滑处理</h1><h2 id="平均"><a href="#平均" class="headerlink" title="平均"></a>平均</h2><h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><h2 id="中值模糊"><a href="#中值模糊" class="headerlink" title="中值模糊"></a>中值模糊</h2><h2 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h2><h1 id="形态学处理"><a href="#形态学处理" class="headerlink" title="形态学处理"></a>形态学处理</h1><h2 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h2><h2 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h2><h2 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h2><h2 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h2><h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><h2 id="礼帽"><a href="#礼帽" class="headerlink" title="礼帽"></a>礼帽</h2><h2 id="黑帽"><a href="#黑帽" class="headerlink" title="黑帽"></a>黑帽</h2><h1 id="梯度处理"><a href="#梯度处理" class="headerlink" title="梯度处理"></a>梯度处理</h1><p>边缘检测就是检测出图像上的边缘信息</p>
<p><strong>1.导数</strong>，连续函数上某点斜率，导数越大表示变化率越大，变化率越大的地方就越是“边缘”，但是在计算机中不常用，因为在斜率90度的地方，导数无穷大，计算机很难表示这些无穷大的东西。</p>
<p><strong>2.微分</strong>，连续函数上x变化了dx，导致y变化了dy，dy值越大表示变化的越大，那么计算整幅图像的微分，dy的大小就是边缘的强弱了。<br> 微分与导数的关系：dy = f ‘(x) dx</p>
<h2 id="Sobel算子和Scharr算子"><a href="#Sobel算子和Scharr算子" class="headerlink" title="Sobel算子和Scharr算子"></a>Sobel算子和Scharr算子</h2><p>基于一阶微分</p>
<p>中心点 f(x, y) 是重点考虑的，它的权重应该多一些，所以改进成下面这样的</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span></span><br><span class="line">-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>这就是 Sobel 边缘检测算子，偏 x 方向的。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">1</span></span><br><span class="line"> <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="laplacian算子"><a href="#laplacian算子" class="headerlink" title="laplacian算子"></a>laplacian算子</h2><p>拉普拉斯是用二阶差分计算边缘的</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">0</span>,  <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="number">1</span>, -<span class="number">4</span>, <span class="number">1</span></span><br><span class="line"><span class="number">0</span>,  <span class="number">1</span>, <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<p>考虑两个斜对角的情况</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>,  <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="number">1</span>, -<span class="number">8</span>, <span class="number">1</span></span><br><span class="line"><span class="number">1</span>,  <span class="number">1</span>, <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h2><p>Canny边缘检测的步骤：</p>
<p>1.<strong>消除噪声</strong>：一般情况下，使用<strong>高斯平滑滤波器卷积降噪</strong>。</p>
<p>2.<strong>计算梯度幅值和方向</strong>。此时，按照<strong>Sobel滤波器的步骤</strong>。<br>怎么表征这种灰度值的变化呢？这里想到的就是导数微分，导数就是表征变化率的，但是数字图像都是<strong>离散</strong>的，也就是<strong>导数肯定会用差分</strong>来替代。<strong>用相邻像素的差分来计算梯度的大小和方向。</strong></p>
<p>然后我们可以计算图像中每个像素的梯度大小为$G=\sqrt{G_x^2+G_y^2}$，梯度方向为$\theta=arctan(G_x/G_y)$</p>
<p>3.<strong>非极大值抑制</strong>。这一步排除非边缘像素，仅仅保留了一些细线条(候选边缘)。</p>
<p>对规定方向以外的梯度方向进行最大抑制。</p>
<p>理论上图像梯度幅值的元素值越大，说明图像中该点的梯度值越大，但这不能说明该点就是边缘。非极大值抑制是进行边缘检测的重要步骤，<strong>寻找像素点的局部最大值</strong>，沿着梯度方向，比较它前面和后面的梯度值，<strong>若梯度值局部最大则有可能为边缘像素，进行保留，否则就进行抑制(置为0)。</strong></p>
<p><img data-src="../images/opencv/NMS.png" alt="NMS"></p>
<p>4.<strong>滞后阈值</strong>：Canny使用了滞后阈值，滞后阈值需要两个阈值(高阈值和低阈值)：<strong>用双阈值算法检测和连接边缘。</strong>（保证了低错误率：与Sobel之间的区别）</p>
<p>a.如果某一像素位置的幅值超过高阈值，该像素被保留为边缘像素。</p>
<p>b.如果某一像素位置的幅值小于低阈值，该像素被排除。</p>
<p>c.<strong>如果某一像素位置的幅值在两个阈值之间，该像素仅仅在连接到一个高于阈值的像素时被保留。</strong></p>
<p>Canny推荐的高低阈值比在2:1到3:1之间。</p>
<p><img data-src="../images/opencv/backNMS.png" alt="滞后阈值"></p>
<h2 id="三个算子区别"><a href="#三个算子区别" class="headerlink" title="三个算子区别"></a>三个算子区别</h2><p>sobel 产生的边缘有强弱，抗噪性好<br>laplace 对边缘敏感，可能有些是噪声的边缘，也被算进来了<br>canny 产生的边缘很细，可能就一个像素那么细，没有强弱之分。</p>
<h1 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h1><h1 id="Hough变换"><a href="#Hough变换" class="headerlink" title="Hough变换"></a>Hough变换</h1><h2 id="直线变换"><a href="#直线变换" class="headerlink" title="直线变换"></a>直线变换</h2><ul>
<li>基本思想</li>
</ul>
<p>主要原理是对于边缘的每一个像素点（x0,y0），把可能经过它的所有直线，映射到仿射参数空间（即hough space），然后<strong>投票</strong>，每次有直线方程满足($\theta$，$r_\theta$)，此处</p>
<p><img data-src="/images/opencv/houghtrans.png" alt="houghtrans"></p>
<ul>
<li>详细推导</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/47649796">参考链接</a></p>
<p><a href="https://www.cnblogs.com/cheermyang/p/5348820.html">参考链接</a></p>
<p>它追踪图像中每个点对应曲线间的交点. 如果交于一点的曲线的数量超过了阈值， 那么可以认为这个交点所代表的参数对($\theta$，$r_\theta$)在原图像中为一条直线。</p>
<p>对图像做霍夫变换，也就是分别代入霍夫变换公式</p>
<blockquote>
<p>$r = xcos\theta + ysin\theta$</p>
</blockquote>
<p>在仿射参数空间的结果是这个样子的：</p>
<p><img data-src="/images/opencv/hough_line.png" alt="hough_line"></p>
<p>原图上红色紫色绿色蓝色的点对应的变换曲线相交在同一个点上，<strong>这个点对应的原点距和角方向就是原图中的四个点所在的直线的方向</strong>：</p>
<p><img data-src="/images/opencv/line.png" alt="line"></p>
<p>这意味着一般来说, 一条直线能够通过在平面($\theta$，$r_\theta$)上寻找交于一点的曲线数量来检测。 越多曲线交于一点也就意味着这个交点表示的直线由更多的点组成. 一般来说我们可以通过设置直线上点的 阈值 来定义多少条曲线交于一点我们才认为 检测 到了一条直线。</p>
<ul>
<li>代码参考</li>
</ul>
<p><a href="https://blog.csdn.net/jia20003/article/details/7724530">源代码参考链接</a></p>
<ul>
<li>OpenCV接口</li>
</ul>
<h2 id="圆形变换"><a href="#圆形变换" class="headerlink" title="圆形变换"></a>圆形变换</h2><p><a href="https://kevinnnm.github.io/2019/07/26/Day12/#%E5%9F%BA%E4%BA%8E%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E5%9C%86%E5%BD%A2%E6%A3%80%E6%B5%8B">参考链接</a></p>
<ul>
<li>基本思想</li>
</ul>
<p>跟霍夫直线检测一样，同样的原理，可以用于检测圆，只是对于圆的方程。</p>
<blockquote>
<p>$(x –a ) ^2 + (y-b) ^ 2 = r^2$</p>
</blockquote>
<p>其中(a,b)代表圆心，r是圆的半径<br>依旧是把图像空间转换成参数空间，这里是将X-Y平面转化成a-b-r参数空间，则在图像空间中的一个过(x,y)点的圆，对应参数空间中高度变化的三维锥面。</p>
<p><img data-src="/images/opencv/houghcircle_1.png" alt="houghcircle"></p>
<p>同理，过图像空间的任意一点的圆都对应于参数空间的一个三维锥面，因此，过图像空间上同一圆的点，对应的参数空间中的三维锥面，在r平面必然相交于一点(a,b,r)，这样通过这一点就可以得到一个圆的参数。</p>
<p><img data-src="/images/opencv/houghcircle_1.png" alt="houghcircle_1"></p>
<ul>
<li>详细推导</li>
</ul>
<p>在极坐标系下，假设圆心为$(𝑥0,𝑦0)$,圆上的点可以表示为:</p>
<blockquote>
<p>$𝑥=𝑥0+𝑟𝑐𝑜𝑠𝜃,𝑦=𝑦0+𝑟𝑠𝑖𝑛𝜃$</p>
</blockquote>
<p>对于一个圆，假如中心像素点$(𝑥0,𝑦0)$，半径r已知，那么旋转360°，圆上的所有点就可以求得。同样，<strong>假如圆上的所有点，半径r已知，旋转360°，则会得到一个累加的极值点，那么这个点就是圆心了。</strong></p>
<ul>
<li>21HT的具体步骤:<br>第一阶段：检测圆心</li>
</ul>
<p>1.1、对输入图像边缘检测（Canny）；</p>
<p>1.2、计算图形的梯度，并确定圆周线，其中圆周的梯度就是它的法线；</p>
<p>1.3、在二维霍夫空间内，绘出所有图形的梯度直线，某坐标点上累加和的值越大，说明在该点上直线相交的次数越多，也就是越有可能是圆心；</p>
<p>1.4、在霍夫空间的4邻域内进行非最大值抑制；</p>
<p>1.5、设定一个阈值，<strong>霍夫空间内累加和大于该阈值的点</strong>就对应于圆心。</p>
<p>第二阶段：检测圆半径</p>
<p>2.1、计算某一个圆心到所有圆周线的距离，这些距离中就有该圆心所对应的圆的半径的值，这些半径值当然是相等的，并且这些圆半径的数量要远远大于其他距离值相等的数量；</p>
<p>2.2、设定两个阈值，定义为最大半径和最小半径，保留距离在这两个半径之间的值，这意味着我们检测的圆不能太大，也不能太小；</p>
<p>2.3、对保留下来的距离进行排序；</p>
<p>2.4、找到距离相同的那些值，并计算相同值的数量；</p>
<p>2.5、设定一个阈值，只有相同值的数量大于该阈值，才认为该值是该圆心对应的圆半径；</p>
<p>2.6、对每一个圆心，完成上面的2.1～2.5步骤，得到所有的圆半径。</p>
<ul>
<li>OpenCV接口</li>
</ul>
<blockquote>
<p>void HoughCircles(InputArray image,OutputArray circles, int method, double dp, double minDist, double param1=100, double param2=100, int minRadius=0,int maxRadius=0 )</p>
</blockquote>
<p>image为输入图像，要求是灰度图像<br>circles为输出圆向量，每个向量包括三个浮点型的元素——圆心横坐标，圆心纵坐标和圆半径<br>method为使用霍夫变换圆检测的算法，Opencv2.4.9只实现了2-1霍夫变换，它的参数是CV_HOUGH_GRADIENT<br>dp为第一阶段所使用的霍夫空间的分辨率，dp=1时表示霍夫空间与输入图像空间的大小一致，dp=2时霍夫空间是输入图像空间的一半，以此类推<br>minDist为圆心之间的最小距离，如果检测到的两个圆心之间距离小于该值，则认为它们是同一个圆心<br>param1为边缘检测时使用Canny算子的高阈值<br>param2为步骤1.5和步骤2.5中所共有的阈值<br>minRadius和maxRadius为所检测到的圆半径的最小值和最大值</p>
]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Python进阶</title>
    <url>/posts/23063/</url>
    <content><![CDATA[<h1 id="args-和-Kwargs"><a href="#args-和-Kwargs" class="headerlink" title="*args 和 **Kwargs"></a><strong>*args</strong> 和 **Kwargs</h1><ul>
<li>*args 是用来发送一个非键值对的可变数量的参数列表给一个函数</li>
<li>kwargs 允许你将不定长度的键值对, 作为参数传递给一个函数。 如果你想要在一个函 数里处理带名字的参数, 你应该使用kwargs。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_args_kwargs</span>(<span class="params">arg1, arg2, arg3</span>):</span></span><br><span class="line">    print(<span class="string">"arg1:"</span>, arg1)</span><br><span class="line">    print(<span class="string">"arg2:"</span>, arg2)</span><br><span class="line">    print(<span class="string">"arg3:"</span>, arg3)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Test *args</span></span><br><span class="line">args = (<span class="string">"two"</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">test_args_kwargs(*args)</span><br><span class="line"></span><br><span class="line">arg1: two</span><br><span class="line">arg2: <span class="number">3</span></span><br><span class="line">arg3: <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Test **kwargs</span></span><br><span class="line">kwargs = {<span class="string">"arg3"</span>: <span class="number">3</span>, <span class="string">"arg2"</span>: <span class="string">"two"</span>, <span class="string">"arg1"</span>: <span class="number">5</span>}</span><br><span class="line">test_args_kwargs(**kwargs)</span><br><span class="line">arg1: <span class="number">5</span></span><br><span class="line">arg2: two</span><br><span class="line">arg3: <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>
<h1 id="Debugging模式"><a href="#Debugging模式" class="headerlink" title="Debugging模式"></a>Debugging模式</h1><p>python提供的pdb功能可以在命令行模式下或者函数内部设置断点进行调试。</p>
<p>常见命令列表如下：</p>
<ul>
<li>c: 继续执行</li>
<li>w: 显示当前正在执行的代码行的上下文信息</li>
<li>a: 打印当前函数的参数列表</li>
<li>s: 执行当前代码行，并停在第一个能停的地方(相当于单步进入)</li>
<li>n: 继续执行到当前函数的下一行，或者当前行直接返回(单步跳过)</li>
</ul>
<ul>
<li>命令行模式</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ python -m pdb my_script.py</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>函数内部执行</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_bread</span>():</span> pdb.set_trace()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is pdb mode"</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="生成器：Generator"><a href="#生成器：Generator" class="headerlink" title="生成器：Generator"></a>生成器：Generator</h1><p>生成器也是一种迭代器，但<strong>只使用一次迭代</strong>。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。你通过遍历来使用它们，要么用一个“for”循环，要么将它们传递给任意可以进行迭代的函数和结构。大多数时候生成器是以函数来实现的。然而， 它们并不返回一个值，而是<strong>yield</strong>(暂且译作“生出”)一个值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_function</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> generator_function():</span><br><span class="line">print(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: 0 </span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="comment">#3</span></span><br></pre></td></tr></tbody></table></figure>
<p>应用场景：不同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环。用这种方式，不必担心会大量使用资源。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 斐波那契数列的迭代器：会大量使用内存资源（在在计算很大的输入参数时）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibon</span>(<span class="params">n</span>):</span> a=b=<span class="number">1</span></span><br><span class="line">	result = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">		result.append(a)</span><br><span class="line">		a, b = b, a + b </span><br><span class="line">  <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 斐波那契数列的生成器：不会大量使用内存资源</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibon</span>(<span class="params">n</span>):</span></span><br><span class="line">	a=b=<span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">		<span class="keyword">yield</span> a</span><br><span class="line">		a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> fibon(<span class="number">1000000</span>):</span><br><span class="line">    print(x)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="内置函数：next"><a href="#内置函数：next" class="headerlink" title="内置函数：next()"></a>内置函数：next()</h2><p>Python内置函数:next()。允许我们获取一个序列的下一个元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_function</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">				<span class="keyword">yield</span> i</span><br><span class="line">gen = generator_function() </span><br><span class="line">print(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="comment"># Output: 0 </span></span><br><span class="line">print(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="comment"># Output: 1</span></span><br><span class="line">print(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="comment"># Output: 2</span></span><br><span class="line">print(<span class="built_in">next</span>(gen))</span><br><span class="line"><span class="comment"># Output: Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#            File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#         StopIteration</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="内置函数：iter"><a href="#内置函数：iter" class="headerlink" title="内置函数：iter()"></a>内置函数：iter()</h2><p>一个可迭代对象并不是一个迭代器，如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">my_string = <span class="string">"Yasoob"</span></span><br><span class="line"><span class="built_in">next</span>(my_string)</span><br><span class="line"><span class="comment"># Output: Traceback (most recent call last): </span></span><br><span class="line"><span class="comment"># File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># TypeError: str object is not an iterator</span></span><br></pre></td></tr></tbody></table></figure>
<p>iter。它将根据一个可迭代对象返回一个迭代器对象。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">my_string = <span class="string">"Yasoob"</span> </span><br><span class="line">my_iter = <span class="built_in">iter</span>(my_string) </span><br><span class="line"><span class="built_in">next</span>(my_iter)</span><br><span class="line"><span class="comment"># Output: 'Y'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="装饰器：Decorator"><a href="#装饰器：Decorator" class="headerlink" title="装饰器：Decorator"></a>装饰器：Decorator</h1><ul>
<li><p>作用：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic。装饰器让你在一个函数的前后去执行代码。</p>
</li>
<li><p>“@decorator_name” is meaning of</p>
<blockquote>
<p>f = decorator_name(f)</p>
</blockquote>
</li>
<li><p>@wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表 等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_name</span>(<span class="params">f</span>):</span></span><br><span class="line"><span class="meta">  @wraps(<span class="params">f</span>)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">decorated</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> can_run:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Function will not run"</span></span><br><span class="line">  	<span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">  <span class="keyword">return</span> decorated</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="string">"Function is running"</span>)</span><br><span class="line"></span><br><span class="line">can_run = <span class="literal">True</span></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># Output: Function is running</span></span><br><span class="line"></span><br><span class="line">can_run = <span class="literal">False</span></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># Output: Function will not run</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="容器-Collections"><a href="#容器-Collections" class="headerlink" title="容器 Collections"></a>容器 Collections</h1><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>与dict类型不同，defaultdict不需要检查key是否存在</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">tree = <span class="keyword">lambda</span>: collections.defaultdict(tree) </span><br><span class="line">some_dict = tree() </span><br><span class="line">some_dict[<span class="string">'colours'</span>][<span class="string">'favourite'</span>] = <span class="string">"yellow"</span></span><br><span class="line"></span><br><span class="line">print(json.dumps(some_dict))</span><br><span class="line"><span class="comment">## 输出: {"colours": {"favourite": "yellow"}}</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h2><p>Counter是一个计数器，它可以帮助我们针对某项数据进行计数。比如它可以用来计算每个人喜欢多少种颜色:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">colours = (</span><br><span class="line">  (<span class="string">'Yasoob'</span>, <span class="string">'Yellow'</span>), </span><br><span class="line">  (<span class="string">'Ali'</span>, <span class="string">'Blue'</span>), </span><br><span class="line">  (<span class="string">'Arham'</span>, <span class="string">'Green'</span>), </span><br><span class="line">  (<span class="string">'Ali'</span>, <span class="string">'Black'</span>), </span><br><span class="line">  (<span class="string">'Yasoob'</span>, <span class="string">'Red'</span>), </span><br><span class="line">  (<span class="string">'Ahmed'</span>, <span class="string">'Silver'</span>),</span><br><span class="line">)</span><br><span class="line">favs = Counter(name <span class="keyword">for</span> name, colour <span class="keyword">in</span> colours) </span><br><span class="line">print(favs)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出:</span></span><br><span class="line"><span class="comment">## Counter({</span></span><br><span class="line"><span class="comment">##    'Yasoob': 2,</span></span><br><span class="line"><span class="comment">## 		'Ali': 2,</span></span><br><span class="line"><span class="comment">##    'Arham': 1,</span></span><br><span class="line"><span class="comment">##    'Ahmed': 1</span></span><br><span class="line"><span class="comment">##  })</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque提供了一个双端队列，你可以从头/尾两端添加或删除元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">d = deque()</span><br><span class="line">d.append(<span class="string">'1'</span>) </span><br><span class="line">d.append(<span class="string">'2'</span>) </span><br><span class="line">d.append(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">print(d[<span class="number">0</span>])</span><br><span class="line"><span class="comment">## 输出: '1'</span></span><br><span class="line">print(d[-<span class="number">1</span>])</span><br><span class="line"><span class="comment">## 输出: '3'</span></span><br><span class="line"></span><br><span class="line">d.popleft() <span class="comment">## 输出: 1</span></span><br><span class="line">d.pop() <span class="comment">## 输出: 3</span></span><br></pre></td></tr></tbody></table></figure>
<p>也可以限制这个列表的大小，当超出设定的限制时，数据会从对队列另一端被挤出 去(pop)。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">d = deque(maxlen=<span class="number">30</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>还可以从任一端扩展这个队列中的数据</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">d = deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) </span><br><span class="line">d.extendleft([<span class="number">0</span>]) </span><br><span class="line">d.extend([<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]) </span><br><span class="line">print(d)</span><br><span class="line"><span class="comment">## 输出: deque([0, 1, 2, 3, 4, 5, 6, 7, 8])</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h2><p>命名元组把元组变成一个针对简单任务的容器。你不必使用整数索引来访问一个namedtuples的数据。你可以像字典(dict)一样访问namedtuples， 但namedtuples是不可变的。</p>
<ul>
<li>命名元组(namedtuple)有两个必需的参数。它们是元组名称和字段名称。</li>
</ul>
<p>下面例子中，我们的元组名称是Animal，字段名称是’name’，’age’和’type’。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">perry = Animal(name=<span class="string">"perry"</span>, age=<span class="number">31</span>, <span class="built_in">type</span>=<span class="string">"cat"</span>) </span><br><span class="line">print(perry)</span><br><span class="line"><span class="comment">## 输出: Animal(name='perry', age=31, type='cat')</span></span><br><span class="line"></span><br><span class="line">print(perry.name)</span><br><span class="line"><span class="comment">## 输出: 'perry'</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>namedtuple的每个实例没有对象字典，所以它们很轻量，与普通的元组比，并不 需要更多的内存。这使得它们比字典更快。</li>
<li>命名元组向后兼容于普通的元组，这意味着可以既使用整数索引，也可以使用名称来访问namedtuple:</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>) </span><br><span class="line">perry = Animal(name=<span class="string">"perry"</span>, age=<span class="number">31</span>, <span class="built_in">type</span>=<span class="string">"cat"</span>) </span><br><span class="line">print(perry[<span class="number">0</span>])</span><br><span class="line"><span class="comment">## 输出: perry</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>可以将一个命名元组转换为字典</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>) </span><br><span class="line">perry = Animal(name=<span class="string">"Perry"</span>, age=<span class="number">31</span>, <span class="built_in">type</span>=<span class="string">"cat"</span>) </span><br><span class="line">print(perry._asdict())</span><br><span class="line"><span class="comment">## 输出: OrderedDict([('name', 'Perry'), ('age', 31), ...</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="enum-Enum"><a href="#enum-Enum" class="headerlink" title="enum.Enum"></a>enum.Enum</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Species</span>(<span class="params">Enum</span>):</span> </span><br><span class="line">  cat = <span class="number">1</span></span><br><span class="line">	dog = <span class="number">2</span> </span><br><span class="line"></span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">tom = Animal(name=<span class="string">"Tom"</span>, age=<span class="number">75</span>, <span class="built_in">type</span>=Species.cat)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="枚举-enumerate"><a href="#枚举-enumerate" class="headerlink" title="枚举 enumerate"></a>枚举 enumerate</h1><p>enumerate()是在python2.3中引入的。它具有一定的惰性，只在需要的时候才会产生一个(index,value)。</p>
<blockquote>
<p>enumerate(sequence, start = 0)</p>
</blockquote>
<p>接受一个可迭代的对象作为输入，如list或者set，函数返回一个迭代器。可以使用next()方法获取下一个元素。枚举(enumerate)是Python内置函数，它允许我们遍历数据并自动计数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">my_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grapes'</span>, <span class="string">'pear'</span>] </span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">len</span>(my_list),mylist)</span><br><span class="line">		print(index,value)</span><br></pre></td></tr></tbody></table></figure>
<p>等价于</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">my_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grapes'</span>, <span class="string">'pear'</span>] </span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(my_list, <span class="number">1</span>):</span><br><span class="line">    print(index, value)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">'apple'</span>) </span><br><span class="line">(<span class="number">2</span>, <span class="string">'banana'</span>) </span><br><span class="line">(<span class="number">3</span>, <span class="string">'grapes'</span>) </span><br><span class="line">(<span class="number">4</span>, <span class="string">'pear'</span>)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">my_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grapes'</span>, <span class="string">'pear'</span>] </span><br><span class="line">e = <span class="built_in">enumerate</span>(my_list)</span><br><span class="line">e.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">(<span class="number">0</span>, <span class="string">'apple'</span>) </span><br></pre></td></tr></tbody></table></figure>
<p>enumerate()的函数实现非常简单，实际相当于以下代码</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enumerate</span>(<span class="params">sequence, start=<span class="number">0</span></span>):</span></span><br><span class="line">   	n = start</span><br><span class="line">   	<span class="keyword">for</span> elem <span class="keyword">in</span> sequence:</span><br><span class="line">    	<span class="keyword">yield</span> n,elem</span><br><span class="line">    	n += <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="对象自省"><a href="#对象自省" class="headerlink" title="对象自省"></a>对象自省</h1><p>自省(introspection)，是指在运行时来判断一个对象的类型的能力。 它是Python的强项之一。</p>
<h2 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h2><p>dir返回一个列表，列出了一个对象所拥有的属性和方法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">dir</span>(my_list)</span><br><span class="line"><span class="comment"># Output: ['__add__', '__class__', '__contains__', '__delattr__', '__delit # '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattri # '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul # '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne_ # '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '_ # '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', # '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop # 'remove', 'reverse', 'sort']</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="type和id"><a href="#type和id" class="headerlink" title="type和id"></a>type和id</h2><ul>
<li>type函数返回一个对象的类型。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">print(<span class="built_in">type</span>(<span class="string">''</span>))</span><br><span class="line"><span class="comment"># Output: &lt;type 'str'&gt;</span></span><br><span class="line">print(<span class="built_in">type</span>([]))</span><br><span class="line"><span class="comment"># Output: &lt;type 'list'&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>id()函数返回任意不同种类对象的唯一ID。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">name = <span class="string">"Yasoob"</span> </span><br><span class="line">print(<span class="built_in">id</span>(name))</span><br><span class="line"><span class="comment"># Output: 139972439030304</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="inspect模块"><a href="#inspect模块" class="headerlink" title="inspect模块"></a>inspect模块</h2><p>inspect模块也提供了许多有用的函数，来获取活跃对象的信息。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line">print(inspect.getmembers(<span class="built_in">str</span>))</span><br><span class="line"><span class="comment"># Output: [('__add__', &lt;slot wrapper '__add__' of ... ...</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a><strong>lambda</strong>表达式</h1><p>它们在其他语言中也被称为匿名函数。如果你不想在程序中对一个函数使用两次，你也许会想用lambda表达式。</p>
<blockquote>
<p>lambda 参数:操作(参数)</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x, y: x + y </span><br><span class="line">print(add(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># Output: 8</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Map、Filter、Reduce"><a href="#Map、Filter、Reduce" class="headerlink" title="Map、Filter、Reduce"></a>Map、Filter、Reduce</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map()会将一个函数映射到一个输入列表的所有元素上。</p>
<blockquote>
<p>map(function_to_apply, list_of_inputs)​</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, items))</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (x*x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (x+x)</span><br><span class="line">funcs = [multiply, add] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">	value = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x(i), funcs)</span><br><span class="line">	print(<span class="built_in">list</span>(value))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># [0, 0]</span></span><br><span class="line"><span class="comment"># [1, 2]</span></span><br><span class="line"><span class="comment"># [4, 4]</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>filter()过滤列表中的元素，并且返回一个由所有符合要求的元素所构成的列表，符合要求即函数映射到该元素时返回值为True。filter()是一个内置函数，类似于for循环，但是执行会更快。</p>
<blockquote>
<p>filter(function_to_apply, list_of_inputs)</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">number_list = <span class="built_in">range</span>(-<span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">less_than_zero = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &lt; <span class="number">0</span>, number_list)</span><br><span class="line">print(<span class="built_in">list</span>(less_than_zero))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: [-5, -4, -3, -2, -1]</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><p>Reduce()用于对一个列表进行一些计算并返回结果。</p>
<blockquote>
<p>reduce(function_to_apply, list_of_inputs)</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">product = reduce((<span class="keyword">lambda</span> x, y: x * y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 24</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><p>如果条件为真，返回真 否则返回假</p>
<blockquote>
<p>condition_is_true if condition else condition_is_false</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">is_fat = <span class="literal">True</span></span><br><span class="line">state = <span class="string">"fat"</span> <span class="keyword">if</span> is_fat <span class="keyword">else</span> <span class="string">"not fat"</span></span><br></pre></td></tr></tbody></table></figure>
<p>另一个晦涩一点的用法比较少见，它使用了元组:</p>
<blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">(if_test_is_false, if_test_is_true)[test]</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">fat = <span class="literal">True</span></span><br><span class="line">fitness = (<span class="string">"skinny"</span>, <span class="string">"fat"</span>)[fat] print(<span class="string">"Ali is "</span>, fitness)</span><br><span class="line"><span class="comment">#输出: Ali is fat</span></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h1 id="对象的可变-mutable-与不可变-immutable"><a href="#对象的可变-mutable-与不可变-immutable" class="headerlink" title="对象的可变( mutable)与不可变(immutable)"></a>对象的可变( mutable)与不可变(immutable)</h1><p>每当你将一个变量赋值为另一个可变类型的变量时，对这个数据的任意改动会同时反映到这两个变量上去。新变量只不过是 老变量的一个别名而已。这个情况只是针对可变数据类型。<br></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">foo = [<span class="string">'hi'</span>] print(foo)</span><br><span class="line"><span class="comment"># Output: ['hi']</span></span><br><span class="line"></span><br><span class="line">bar = foo</span><br><span class="line">bar += [<span class="string">'bye'</span>] print(foo)</span><br><span class="line"><span class="comment"># Output: ['hi', 'bye']</span></span><br></pre></td></tr></tbody></table></figure><br>在Python中当函数被定义时，默认参数只会运算一次，而不是每次被调用时都会重新运算。<br><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to</span>(<span class="params">num, target=[]</span>):</span> target.append(num) <span class="keyword">return</span> target</span><br><span class="line">add_to(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># Output: [1]</span></span><br><span class="line"></span><br><span class="line">add_to(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Output: [1, 2]</span></span><br></pre></td></tr></tbody></table></figure><br>现在每当你在调用这个函数不传入target参数的时候，一个新的列表会被创建。<p></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to</span>(<span class="params">element, target=<span class="literal">None</span></span>):</span> </span><br><span class="line">  <span class="keyword">if</span> target <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    target = [] </span><br><span class="line">  target.append(element) </span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line"></span><br><span class="line">add_to(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># Output: [42]</span></span><br><span class="line"></span><br><span class="line">add_to(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># Output: [42]</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="slot"><a href="#slot" class="headerlink" title="__slot__"></a>__slot__</h1><p>在Python中，每个类都有实例属性。默认情况下Python用一个字典来保存一个对象的实例属性 。然而，对于有着已知属性的小类来说，它可能是个瓶颈。这个字典浪费了很多内存。 Python不能在对象创建时直接分配一个固定量的内存来保存所有的属性。</p>
<p>不过还是有一个方法来规避这个问题。这个方法需要使用__slots__来告诉Python不要使用字典，而且只给一个<strong>固定集合的属性分配空间</strong>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, identifier</span>):</span></span><br><span class="line">	self.name = name </span><br><span class="line">   self.identifier = identifier </span><br><span class="line">   self.set_up()</span><br></pre></td></tr></tbody></table></figure>
<p>第二段代码会为你的内存减轻负担。通过这个技巧，可以看到内存占用率几乎 40%~50%的减少。<br></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">		__slots__ = [<span class="string">'name'</span>, <span class="string">'identifier'</span>] </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, identifier</span>):</span></span><br><span class="line">				self.name = name </span><br><span class="line">        self.identifier = identifier </span><br><span class="line">        self.set_up()</span><br></pre></td></tr></tbody></table></figure><p></p>
<h1 id="Comprehension推导式"><a href="#Comprehension推导式" class="headerlink" title="Comprehension推导式"></a>Comprehension推导式</h1><p>推导式(又称解析式)是Python的一种独有特性。推导式是可以从一个数据序列构建另一个新的数据序列的结构体。 共有三种推导：</p>
<ul>
<li>列表(list)推导式</li>
<li>字典(dict)推导式</li>
<li>集合(set)推导式</li>
</ul>
<h2 id="列表-list-推导式"><a href="#列表-list-推导式" class="headerlink" title="列表(list)推导式"></a>列表(list)推导式</h2><p>列表推导式(又称列表解析式)提供了一种简明扼要的方法来创建列表。它的结构是在一个中括号里包含一个表达式，然后是一个for语句，然后是0个或多个for 或者if语句。</p>
<blockquote>
<p>variable = [out_exp for out_exp in input_list if out_exp == 2]</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">multiples = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> <span class="keyword">is</span> <span class="number">0</span>] </span><br><span class="line">print(multiples)</span><br><span class="line"><span class="comment"># Output: [0, 3, 6, 9, 12, 15, 18, 21, 24, 27]</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="字典-dict-推导式"><a href="#字典-dict-推导式" class="headerlink" title="字典(dict)推导式"></a>字典(dict)推导式</h2><p>字典推导和列表推导的使用方法是类似的。如快速对换一个字典的键和值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">{v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> some_dict.items()}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="集合-set-推导式"><a href="#集合-set-推导式" class="headerlink" title="集合(set)推导式"></a>集合(set)推导式</h2><p>它跟列表推导式也是类似的。 唯一的区别在于它使用大括号{}。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">squared = {x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]}</span><br><span class="line">print(squared)</span><br><span class="line"><span class="comment"># Output: {1, 4}</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><ul>
<li>处理一个异常</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  file = <span class="built_in">open</span>(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">  print(<span class="string">"An EOF error occurred."</span>) <span class="keyword">raise</span> e</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>处理多个异常：在你不知道你要捕捉什么异常时，非常有用</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  file = <span class="built_in">open</span>(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line"><span class="comment"># 打印一些异常日志，如果你想要的话 </span></span><br><span class="line">	<span class="keyword">raise</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h2><p>包裹到finally从 句中的代码不管异常是否触发都将会被执行。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">		file = <span class="built_in">open</span>(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">		print(<span class="string">'An IOError occurred. {}'</span>.<span class="built_in">format</span>(e.args[-<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">"This would be printed whether or not an exception occurred!"</span></span><br><span class="line"><span class="comment"># Output: An IOError occurred. No such file or directory</span></span><br><span class="line"><span class="comment"># This would be printed whether or not an exception occurred!</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="try-else"><a href="#try-else" class="headerlink" title="try/else"></a>try/else</h2><p>else从句只会在没有异常的情况下执行，而且它会在finally语句之前执行。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'I am sure no exception is going to occur!'</span>)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    print(<span class="string">'exception'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">		<span class="comment"># 这里的代码只会在try语句里没有触发异常时运行,</span></span><br><span class="line">		<span class="comment"># 但是这里的异常将 *不会* 被捕获</span></span><br><span class="line">		print(<span class="string">'This would only run if no exception occurs. And an error here '</span></span><br><span class="line">					<span class="string">'would NOT be caught.'</span>)</span><br><span class="line">		print(<span class="string">'This would be printed in every case.'</span>)</span><br><span class="line"><span class="comment"># Output: I am sure no exception is going to occur! # This would only run if no exception occurs.</span></span><br><span class="line"><span class="comment"># This would be printed in every case.</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="一行式"><a href="#一行式" class="headerlink" title="一行式"></a>一行式</h1><h2 id="简易Web-Server"><a href="#简易Web-Server" class="headerlink" title="简易Web Server"></a>简易Web Server</h2><p>通过网络快速共享文件，进入到共享文件的目录下并在命令行中运行下面的代码:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">python -m http.server</span><br></pre></td></tr></tbody></table></figure>
<h2 id="漂亮的打印"><a href="#漂亮的打印" class="headerlink" title="漂亮的打印"></a>漂亮的打印</h2><p>Python REPL可漂亮的打印出<strong>列表和字典</strong>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">my_dict = {<span class="string">'name'</span>: <span class="string">'Yasoob'</span>, <span class="string">'age'</span>: <span class="string">'undefined'</span>}</span><br><span class="line">pprint(my_dict)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="脚本性能分析"><a href="#脚本性能分析" class="headerlink" title="脚本性能分析"></a>脚本性能分析</h2><p>cProfile是一个比profile更快的实现，因为它是用c写的。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">python -m cProfile my_script.py</span><br></pre></td></tr></tbody></table></figure>
<h2 id="CSV转换为json"><a href="#CSV转换为json" class="headerlink" title="CSV转换为json"></a><strong>CSV</strong>转换为json</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">python -c <span class="string">"import csv,json;print json.dumps(list(csv.reader(open('csv.csv'))))</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="列表辗平"><a href="#列表辗平" class="headerlink" title="列表辗平"></a>列表辗平</h2><p>通过使用itertools包中的itertools.chain.from_iterable轻松快速的辗平一个列表。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a_list = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">print(<span class="built_in">list</span>(itertools.chain.from_iterable(a_list)))</span><br><span class="line"><span class="comment"># Output: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">print(<span class="built_in">list</span>(itertools.chain(*a_list)))</span><br><span class="line"><span class="comment"># Output: [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="一行式的构造器"><a href="#一行式的构造器" class="headerlink" title="一行式的构造器"></a>一行式的构造器</h2><p>避免类初始化时大量重复的赋值语句</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, b, c, d, e, f</span>):</span></span><br><span class="line">    self.__dict__.update({k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">locals</span>().items()})</span><br></pre></td></tr></tbody></table></figure>
<h1 id="For-Else"><a href="#For-Else" class="headerlink" title="For-Else"></a>For-Else</h1><p>for循环还有一个else从句，我们大多数人并不熟悉。这个else从句会在循环正常结束时执行。这意味着，循环没有遇到任何break。</p>
<p>有个常见的构造是跑一个循环，并查找一个元素。如果这个元素被找到了，我们使 用break来中断这个循环。有两个场景会让循环停下来。</p>
<ul>
<li>第一个是当一个元素被找到，break被触发。 </li>
<li>第二个场景是循环结束。</li>
</ul>
<p>现在我们也许想知道其中哪一个，才是导致循环完成的原因。一个方法是先设置一个标记，然后在循环结束时打上标记。另一个是使用else从句。</p>
<p><strong>简而言之：当循环自然终结（未调用break），else从句会被执行一次。</strong></p>
<p>以下例子会找出2到10之间的数字的因子。附加的else语句块，用来抓住质数： </p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">      <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">        print( n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n/x) <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># loop fell through without finding a factor</span></span><br><span class="line">        print(n, <span class="string">'is a prime number'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># output        </span></span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2.0</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3.0</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4.0</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3.0</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="使用C扩展"><a href="#使用C扩展" class="headerlink" title="使用C扩展"></a>使用<strong>C</strong>扩展</h1><p>CPython使得Python可以轻松调用C代码。</p>
<h2 id="ctypes"><a href="#ctypes" class="headerlink" title="ctypes"></a>ctypes</h2><p>ctypes模块提供了和C语言 兼容的数据类型和函数来加载dll文件，因此在调用时不需对源文件做任何的修改。</p>
<ol>
<li>实现两数求和的C代码，保存为add.c</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_float</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_float</span><span class="params">(<span class="keyword">float</span> num1, <span class="keyword">float</span> num2)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>接下来将C文件编译为.so文件(windows下为DLL)</li>
</ol>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">For Linux</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -Wl,-soname,adder -o adder.so -fPIC add.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">For Mac</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -Wl,-install_name,adder.so -o adder.so -fPIC add.c</span></span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>现在在Python代码中来调用它</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#load the shared object file</span></span><br><span class="line">adder = CDLL(<span class="string">'./adder.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find sum of integers</span></span><br><span class="line">res_int = adder.add_int(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">"Sum of 4 and 5 = "</span> + <span class="built_in">str</span>(res_int)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find sum of floats</span></span><br><span class="line">a = c_float(<span class="number">5.5</span>)</span><br><span class="line">b = c_float(<span class="number">4.1</span>)</span><br><span class="line">add_float = adder.add_float</span><br><span class="line">add_float.restype = c_float</span><br><span class="line"><span class="built_in">print</span> <span class="string">"Sum of 5.5 and 4.1 = "</span>, <span class="built_in">str</span>(add_float(a, b))</span><br><span class="line"></span><br><span class="line">Sum of <span class="number">4</span> <span class="keyword">and</span> <span class="number">5</span> = <span class="number">9</span></span><br><span class="line">Sum of <span class="number">5.5</span> <span class="keyword">and</span> <span class="number">4.1</span> = <span class="number">9.60000038147</span></span><br></pre></td></tr></tbody></table></figure>
<p>这种方法虽然简单，清晰，但是却很受限。例如，并不能在C中对对象进行操作。</p>
<h2 id="SWIG"><a href="#SWIG" class="headerlink" title="SWIG"></a>SWIG</h2><p>SWIG是Simplified Wrapper and Interface Generator的缩写。是Python中调用C代码的另一种 方法。在这个方法中，开发人员必须编写一个额外的接又文件来作为SWIG(终端工具)的入口。Python开发者一般不会采用这种方法，因为大多数情况它会带来不必要的复杂。而当你有一个C/C++代码库需要被多种语言调用时，这将是个非常不错的选择。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">​```C</span><br><span class="line"><span class="comment">#include</span></span><br><span class="line">double My_variable = <span class="number">3.0</span>;</span><br><span class="line"><span class="built_in">int</span> fact(<span class="built_in">int</span> n) {</span><br><span class="line">  ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译它</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">unix % swig -python example.i</span><br><span class="line">unix % gcc -c example.c example_wrap.c \</span><br><span class="line">					 -I/usr/local/include/python2.1</span><br><span class="line">unix % ld -shared example.o example_wrap.o -o _example.so</span><br></pre></td></tr></tbody></table></figure>
<p>Python的调用</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> example</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.fact(<span class="number">5</span>) </span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.my_mod(<span class="number">7</span>,<span class="number">3</span>) </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.get_time()</span><br><span class="line"><span class="string">'Sun Feb 11 23:01:07 1996'</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Python-C-API"><a href="#Python-C-API" class="headerlink" title="Python/C API"></a>Python/C API</h2><p>Python/C API可能是被最广泛使用的方法。它不仅简单，而且可以在C代码中操作你的Python对象。这种方法需要以特定的方式来编写C代码以供Python去调用它。所有的Python对象都被表 示为一种叫做PyObject的结构体，并且Python.h头文件中提供了各种操作它的函数。</p>
<ol>
<li>编写一个C扩展，添加所有元素到一个Python列表(所有元素都是数字)</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//Python.h has all the required function definitions to manipulate the Pyt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="comment">//This is the function that is called from your python code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">addList_add</span><span class="params">(PyObject* self, PyObject* args)</span></span>{</span><br><span class="line">    PyObject * listObj;</span><br><span class="line">    <span class="keyword">if</span> (! PyArg_ParseTuple( args, <span class="string">"O"</span>, &amp;listObj ))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">long</span> length = PyList_Size(listObj); <span class="comment">//iterate over all the elements</span></span><br><span class="line">		<span class="keyword">int</span> i, sum =<span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">			sum += elem;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> addList_docs[] =</span><br><span class="line"><span class="string">"add( ): add all elements of the list\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyMethodDef addList_funcs[] = {</span><br><span class="line">{<span class="string">"add"</span>, (PyCFunction)addList_add, METH_VARARGS, addList_docs}, {<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">initaddList</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line">    Py_InitModule3(<span class="string">"addList"</span>, addList_funcs,</span><br><span class="line">            <span class="string">"Add all ze lists"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Python.h头文件中包含了所有需要的类型(Python对象类型的表示)和函数定义(对 Python对象的操作)<br> 接下来我们编写将要在Python调用的函数, 函数传统的命名方式由{模块名}_{函数 名}组成，所以我们将其命名为addList_add 然后填写想在模块内实现函数的相关信息表，每行一个函数，以空行作为结束 最后的模块初始化块签名为PyMODINIT_FUNC init{模块名}。</p>
<ol>
<li>现在我们已经编写完C模块了。将下列代码保存为setup.py</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">​```</span><br><span class="line"><span class="comment">#build the modules</span></span><br><span class="line">​```</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">'addList'</span>, version=<span class="string">'1.0'</span>, \ ext_modules=[Extension(<span class="string">'addList'</span>, [<span class="string">'adder.c'</span>])])</span><br></pre></td></tr></tbody></table></figure>
<p>运行，现在应该已经将我们的C文件编译安装到我们的Python模块中了。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>验证</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#module that talks to the C code</span></span><br><span class="line"><span class="keyword">import</span> addList l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">"Sum of List - "</span> + <span class="built_in">str</span>(l) + <span class="string">" = "</span> + <span class="built_in">str</span>(addList.add(l))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">Sum of List - [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] = <span class="number">15</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h2><h1 id="Open"><a href="#Open" class="headerlink" title="Open()"></a>Open()</h1><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'photo.jpg'</span>, <span class="string">'r+'</span>) <span class="keyword">as</span> f: </span><br><span class="line">  jpgdata = f.read()</span><br></pre></td></tr></tbody></table></figure>
<p>open的第一个参数是文件名。第二个(mode 打开模式)决定了这个文件如何被打开。</p>
<ul>
<li>如果你想读取文件，传入r </li>
<li>如果你想读取并写入文件，传入r+ </li>
<li>如果你想覆盖写入文件，传入w </li>
<li>如果你想在文件末尾附加内容，传入a</li>
</ul>
<p>如果不传入任意编码，一个系统 - 以及Python -指定的默认选项将被选中。你也许会·去依赖这个默认选项，但这个默认选项经常是错误的，或者默认编码实际上不能表达文件里的所有字符(这将经常发生在Python 2.x和/或Windows)。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'photo.jpg'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> inf:</span><br><span class="line">	jpgdata = inf.read()</span><br><span class="line">	<span class="keyword">if</span> jpgdata.startswith(<span class="string">b'\xff\xd8'</span>):</span><br><span class="line">		text = <span class="string">u'This is a JPEG file (%d bytes long)\n'</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		text = <span class="string">u'This is a random file (%d bytes long)\n'</span></span><br><span class="line"><span class="keyword">with</span> io.<span class="built_in">open</span>(<span class="string">'summary.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> outf: </span><br><span class="line">  outf.write(text % <span class="built_in">len</span>(jpgdata))</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Python-2-3"><a href="#Python-2-3" class="headerlink" title="Python 2+3"></a>Python 2+3</h1><h2 id="Future模块导入"><a href="#Future模块导入" class="headerlink" title="Future模块导入"></a>Future模块导入</h2><p>Future模块可以帮你在Python2中导入 Python3的功能。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function </span><br><span class="line">print(<span class="built_in">print</span>)</span><br><span class="line"><span class="comment"># Output: &lt;built-in function print&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="模块重命名"><a href="#模块重命名" class="headerlink" title="模块重命名"></a>模块重命名</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib_request <span class="comment"># for Python 3</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">  <span class="keyword">import</span> urllib2 <span class="keyword">as</span> urllib_request <span class="comment"># for Python 2</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>Python中的协程和生成器很相似但又稍有不同。主要区别在于: </p>
<ul>
<li><p>生成器是数据的生产者</p>
</li>
<li><p>协程则是数据的消费者</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grep</span>(<span class="params">pattern</span>):</span></span><br><span class="line">  print(<span class="string">"Searching for"</span>, pattern)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		line = (<span class="keyword">yield</span>)</span><br><span class="line">		<span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">			print(line)</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以通过send()方法向它传值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">search = grep(<span class="string">'coroutine'</span>)</span><br><span class="line"><span class="built_in">next</span>(search)</span><br><span class="line"><span class="comment">#output: Searching for coroutine </span></span><br><span class="line">search.send(<span class="string">"I love you"</span>) </span><br><span class="line">search.send(<span class="string">"Don't you love me?"</span>) </span><br><span class="line">search.send(<span class="string">"I love coroutine instead!"</span>) </span><br><span class="line"><span class="comment">#output: I love coroutine instead!</span></span><br></pre></td></tr></tbody></table></figure>
<p>发送的值会被yield接收。</p>
<p>next()方法启动一个协程。就像协程中包含的生成器并不是立刻执行，而是通过next()方法来响应send()方法。因此，你必须通过next()方法来执行yield表达式。</p>
<p>可以通过调用close()方法来关闭一个协程。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">search = grep(<span class="string">'coroutine'</span>)</span><br><span class="line">search.close()</span><br></pre></td></tr></tbody></table></figure>
<h1 id="函数缓存"><a href="#函数缓存" class="headerlink" title="函数缓存"></a>函数缓存</h1><p>在Python 3.2以后版本，lru_cache的装饰器，允许我们将一个函数的返回值快速地缓存或取消缓存。</p>
<p>实现一个斐波那契计算器，并使用lru_cache。</p>
<ul>
<li>maxsize参数是告诉lru_cache，最多缓存最近多少个返回值。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">32</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line"><span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([fib(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br><span class="line"><span class="comment"># Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>也可以轻松地对返回值清空缓存</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">fib.cache_clear()</span><br></pre></td></tr></tbody></table></figure>
<h1 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h1><p>上下文管理器允许你在有需要的时候，精确地分配和释放资源。with确保我们的文件会被关闭，而不用关注嵌套代码如何退出。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'some_file'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> opened_file: </span><br><span class="line">  opened_file.write(<span class="string">'Hola!'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>等价于：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">'some_file'</span>, <span class="string">'w'</span>) </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  file.write(<span class="string">'Hola!'</span>) </span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	file.close()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="自行实现上下文管理器-—-基于类的实现"><a href="#自行实现上下文管理器-—-基于类的实现" class="headerlink" title="自行实现上下文管理器 — 基于类的实现"></a>自行实现上下文管理器 — 基于类的实现</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, file_name, method</span>):</span></span><br><span class="line">      self.file_obj = <span class="built_in">open</span>(file_name, method)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span> </span><br><span class="line">  <span class="keyword">return</span> self.file_obj</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, <span class="built_in">type</span>, value, traceback</span>):</span> </span><br><span class="line">  print(<span class="string">"Exception has been handled"</span>) </span><br><span class="line">  self.file_obj.close()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>
<p>通过定义enter和exit方法，我们可以在with语句里使用它。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> File(<span class="string">'demo.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">  opened_file.write(<span class="string">'Hola!'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>exit函数接受三个参数。这些参数对于每个上下文管理器类中的exit方法都是必须的。</p>
<ol>
<li>with语句先暂存了File类的exit方法 </li>
<li>然后它调用File类的enter方法</li>
<li>enter__方法打开文件并返回给with语句 </li>
<li>打开的文件句柄被传递给opened_file参数 </li>
<li><p>我们使用.write()来写文件</p>
</li>
<li><p>with语句调用之前暂存的exit方法 </p>
</li>
<li><p>exit方法关闭了文件</p>
<p>在4与6之前，如果发生了异常，Python会将异常的type,value和traceback传递给exit方法。它让exit方法来决定如何关闭文件以及是否需要其他步骤。</p>
</li>
<li><p>如果exit返回的是True，那么这个异常就被优雅地处理了。</p>
</li>
<li>如果exit返回的是True以外的任何东西，那么这个异常将被with语句抛出。</li>
</ol>
<h2 id="自行实现上下文管理器-—-基于生成器的实现"><a href="#自行实现上下文管理器-—-基于生成器的实现" class="headerlink" title="自行实现上下文管理器 — 基于生成器的实现"></a>自行实现上下文管理器 — 基于生成器的实现</h2><p>还可以使用一个生成器函数来实现一 个上下文管理器，而不是使用一个类。</p>
<ol>
<li>Python解释器遇到了yield关键字。因为这个缘故它创建了一个生成器而不是一个普通的函数。</li>
<li>因为这个装饰器，contextmanager会被调用并传入函数名(open_file)作为 参数。</li>
<li>contextmanager函数返回一个以GeneratorContextManager对象封装过的 生成器。</li>
<li>这个GeneratorContextManager被赋值给open_file函数，我们实际上是在 调用GeneratorContextManager对象。</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_file</span>(<span class="params">name</span>):</span></span><br><span class="line">	f = <span class="built_in">open</span>(name, <span class="string">'w'</span>) </span><br><span class="line">  <span class="keyword">yield</span> f</span><br><span class="line">	f.close()</span><br></pre></td></tr></tbody></table></figure>
<p>等价于：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open_file(<span class="string">'some_file'</span>) <span class="keyword">as</span> f: </span><br><span class="line">  f.write(<span class="string">'hola!'</span>)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Pythonic的代码"><a href="#Pythonic的代码" class="headerlink" title="Pythonic的代码"></a>Pythonic的代码</h1><h2 id="print-字符串格式化"><a href="#print-字符串格式化" class="headerlink" title="print 字符串格式化"></a>print 字符串格式化</h2><p>非常Pythonic的代码应该是这样：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">print(<span class="string">'Hello %(name)s!'</span>%{<span class="string">'name'</span>:<span class="string">'Tom'</span>})</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">print(<span class="string">'{greet} from {language}.'</span>.<span class="built_in">format</span>(greet = <span class="string">'Hello world'</span>,language = <span class="string">'Python'</span>))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="风格检查工具"><a href="#风格检查工具" class="headerlink" title="风格检查工具"></a>风格检查工具</h2><p>风格检查工具提出了保持代码一致性细节的要求。包括代码布局、注释、命名规范等方面的要求。这种工具有PEP8、Pychecker、Pylint等。如PEP8的安装与使用如下：</p>
<ul>
<li>安装：使用conda或者pip进行安装</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ conda install -c anaconda pycodestyle</span><br></pre></td></tr></tbody></table></figure>
<p>or</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ pip install -U pycodestyle</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>简单的检测代码</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ pycodestyle --first test.py</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>还可以使用—show-source参数让PEP8显示每一个错误和警告对应的代码</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ pycodestyle --show-source --show-pep8 test.py</span><br></pre></td></tr></tbody></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol>
<li>函数注释：给外部可访问的函数与方法添加文档注释。注释要清楚的描述方法的功能，并对参数、返回值以及可能发生的异常进行说明。</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FuncName</span>(<span class="params">parameter1,parameter2</span>):</span></span><br><span class="line">  <span class="string">"""Describe what this Function does:</span></span><br><span class="line"><span class="string">     # such as "Find wheter the special string is in the queue or not"</span></span><br><span class="line"><span class="string">     Args:</span></span><br><span class="line"><span class="string">     	parameter1:parameter type,what is the parameter used for.</span></span><br><span class="line"><span class="string">     	parameter2:parameter type,what is the parameter used for.</span></span><br><span class="line"><span class="string">      return type, return value.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  function body</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>推荐在文件头中包含copyright申明、模块描述等，如有必要可以加入作者信息及变更记录。</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Licensed Materials - Property of CorpA</span></span><br><span class="line"><span class="string">(C) Copyright A Corp.1999,2011 All Right Reserved</span></span><br><span class="line"><span class="string">CopyRight statement and purpose...</span></span><br><span class="line"><span class="string">-------------------------------------------------------------</span></span><br><span class="line"><span class="string"># @Time: 2020/2/27 12:08 </span></span><br><span class="line"><span class="string"># @Author: GraceKoo</span></span><br><span class="line"><span class="string"># @File: 55_jump-game.py</span></span><br><span class="line"><span class="string"># @Desc:https://leetcode-cn.com/problems/jump-game/</span></span><br><span class="line"><span class="string">-------------------------------------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>Python的内建命名空间是支持一小部分常量的，如True、Flase、None等。只是Python没有提供常量的直接方式而已。</p>
<ul>
<li>常量名所有字母应大写，用下划线连接各个单词，如：MAX_OVERFLOW</li>
<li>将常量集中到一个文件</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_const</span>:</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ConstError</span>(<span class="params">TypeError</span>):</span><span class="keyword">pass</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ConstCaseError</span>(<span class="params">constError</span>):</span><span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_setattr_</span>(<span class="params">self, name, value</span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.__dict__.has_key(name):</span><br><span class="line">      <span class="keyword">raise</span> self.ConstError, <span class="string">"can not change const"</span> %name</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> name.isupper():</span><br><span class="line">      <span class="keyword">raise</span> self.ConstCaseError,\</span><br><span class="line">      		  <span class="string">'const name "%s" is not all uppercase'</span> %name</span><br><span class="line">    self.__dict__[name] = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.modules[__name__]=_const()</span><br></pre></td></tr></tbody></table></figure>
<p>设置常量<br></p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> const</span><br><span class="line">const.COMPANY = <span class="string">"IBM"</span></span><br></pre></td></tr></tbody></table></figure><br>使用常量<p></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> constant <span class="keyword">import</span> const</span><br><span class="line">print(const.COMPANY)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h1><p>内建函数type() 用于返回当前对象的类型，但type()有时并不能准确返回结果。建议使用isinstance()来检测。</p>
<blockquote>
<p>isinstance(object, classinfo)</p>
</blockquote>
<p>classinfo为直接或者间接的类名，基本类型名称或者由它们组成的元组。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">isinstance</span>(<span class="number">2</span>, <span class="built_in">float</span>)</span><br><span class="line"><span class="built_in">isinstance</span>(<span class="string">"a"</span>, (<span class="built_in">str</span>.unicode))</span><br><span class="line"><span class="built_in">isinstance</span>((<span class="number">2</span>,<span class="number">3</span>), (<span class="built_in">str</span>, <span class="built_in">list</span>, <span class="built_in">tuple</span>))</span><br></pre></td></tr></tbody></table></figure>
<h1 id="浮点计算"><a href="#浮点计算" class="headerlink" title="浮点计算"></a>浮点计算</h1><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">print(<span class="number">1.1</span> + <span class="number">1.1</span> + <span class="number">1.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0.30000000000003</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果对精度要求比较高，可以用Decimal来进行处理。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Decimal <span class="keyword">import</span> *</span><br><span class="line">getcontext().prec = <span class="number">6</span></span><br><span class="line">Decimal(<span class="number">1</span>) / Decimal(<span class="number">7</span>) <span class="comment"># Decimal('0.142857') 保留6个有效数字</span></span><br><span class="line"></span><br><span class="line">Decimal(<span class="string">'50.5679'</span>).quantize(Decimal(<span class="string">'0.00'</span>)) <span class="comment"># Decimal('50.57') 四舍五入保留两位小数</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="官方资源地址"><a href="#官方资源地址" class="headerlink" title="官方资源地址"></a>官方资源地址</h1><p><a href="https://docs.python.org/2/library/pdb.html">https://docs.python.org/2/library/pdb.html</a> </p>
<p><a href="https://docs.python.org/3/library/pdb.html">https://docs.python.org/3/library/pdb.html</a></p>
<h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><ul>
<li>《Intermediate Python》</li>
<li>《编写高质量代码 改善Python程序的91个建议》</li>
<li>《Python核心编程 第三版》</li>
</ul>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Web框架</title>
    <url>/posts/2248001/</url>
    <content><![CDATA[<h1 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h1><h2 id="为什么要用Web框架"><a href="#为什么要用Web框架" class="headerlink" title="为什么要用Web框架"></a>为什么要用Web框架</h2><p><img data-src="/images/data/WebFrame.png" alt="WebFrame"></p>
<h2 id="Flask程序运行过程"><a href="#Flask程序运行过程" class="headerlink" title="Flask程序运行过程"></a>Flask程序运行过程</h2><ol>
<li>客户端通过浏览器发送<strong>HTTP请求</strong>，请求获取资源</li>
<li>Web服务器会把来自客户端的所有请求都<strong>交给Flask程序实例</strong></li>
<li><p>Flask程序实例通过<strong>Werkzeug来做路由分发</strong>（<strong>URL请求和视图函数之间的对应关系</strong>）</p>
</li>
<li><p>根据每个URL请求，找到具体的视图函数并进行调用</p>
<ul>
<li>在Flask程序中，路由的实现一般是通过程序实例的<strong>装饰器实现</strong></li>
</ul>
</li>
<li>Flask调用视图函数后，可以返回两种内容<ul>
<li>字符串内容：将视图函数的返回值作为响应的内容，返回给客户端（浏览器）</li>
<li>HTML模版内容：获取到数据后，把数据传入HTML模版文件中，<strong>模版引擎负责渲染HTTP响应数据</strong>，然后返回响应数据给客户端（浏览器）</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># "/"代表一个URL请求；hello_world()是视图函数；</span></span><br><span class="line"><span class="comment"># 写在一起代表对应关系</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">"/"</span>, methods=[<span class="string">"GET"</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  <span class="comment"># 执行run方法，将flask程序运行在简易服务器里（Flask提供）</span></span><br><span class="line">  app.run()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="路由请求方式限定"><a href="#路由请求方式限定" class="headerlink" title="路由请求方式限定"></a>路由请求方式限定</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">"/orders/&lt;int:orderid&gt;"</span>, methods=[<span class="string">"GET"</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>(<span class="params">orderid</span>):</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"order id is %d"</span> %orderid</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>数据强转为int，能转成功，则可以进行路由匹配</li>
<li>如果不能转成功，则无法进行路由匹配</li>
</ul>
<h2 id="Jinja2模版引擎"><a href="#Jinja2模版引擎" class="headerlink" title="Jinja2模版引擎"></a>Jinja2模版引擎</h2><p>视图函数的主要作用是生成请求的响应，这是最简单的请求。实际上，视图函数有两个作用：处理业务逻辑和返回响应内容。在大型应用中，<strong>把业务逻辑和表现内容放在一起，会增加代码的复杂度和维护成本。</strong>利用模版，可以承担视图函数的另一个作用：<strong>返回响应内容。</strong></p>
<p>使用模版的好处：</p>
<ul>
<li>视图函数只负责业务逻辑和数据处理（业务逻辑方面）</li>
<li><strong>模版则取到视图函数的数据结果进行展示（视图展示方面）</strong></li>
<li>代码结构清晰，耦合度低</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回一个网页（模版）</span></span><br><span class="line"><span class="comment"># 给模版填充数据</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">"/"</span>, methods=[<span class="string">"GET"</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">  <span class="comment"># 比如需要传入一个网址</span></span><br><span class="line">  url_str = <span class="string">'这里是动态传入的内容'</span></span><br><span class="line">  <span class="keyword">return</span> render_template(<span class="string">"index.html"</span>, url_str=url_str)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  app.run()</span><br></pre></td></tr></tbody></table></figure>
<p>在html中，动态的变量只需要以下方式写就可以进行定位了<br></p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line">{{ url_str }}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="变量代码块"><a href="#变量代码块" class="headerlink" title="变量代码块"></a>变量代码块</h3><p><code>{{}}`来表示变量名，这种`{{}}</code>语法叫做变量代码块</p>
<p>jinjia2模版中的变量代码块可以是任意python类型或者对象，只要它能够被Python的<code>str()</code>方法转为一个字符串就可以</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">{{your_dict[<span class="string">'key'</span>]}}</span><br><span class="line">{{your_list[<span class="number">0</span>]}}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="控制代码块"><a href="#控制代码块" class="headerlink" title="控制代码块"></a>控制代码块</h3><p>用<code>{%%}</code>定义的控制代码块，可以实现一些语言层次的功能，比如循环或者if语句</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">{% <span class="keyword">if</span> usr %}</span><br><span class="line">		{{ usr }}</span><br><span class="line">{% <span class="keyword">else</span> %}</span><br><span class="line">		hello!</span><br><span class="line">  </span><br><span class="line">{% <span class="keyword">for</span> index <span class="keyword">in</span> indexs %}</span><br><span class="line">		{{ index }}</span><br><span class="line">{% endfor %}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>过滤器的本质就是函数，有时候我们不仅仅只需要输出变量的值，<strong>还需要修改变量的显示，甚至格式、运算符等等</strong>，而在模版中是不能直接调用Python中的某些方法，那么就用到了<strong>过滤器</strong>。</p>
<ul>
<li>使用方法</li>
</ul>
<p>过滤器的使用方法为：<strong>变量名 | 过滤器</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">{{variable | filter_name(*args)}}</span><br></pre></td></tr></tbody></table></figure>
<p>如果没有任何参数传给过滤器，可以把括号省掉</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">{{variable | filter_name}}</span><br></pre></td></tr></tbody></table></figure>
<p>如：’’，这个过滤器的作用：把变量variable的值的首字母转化为大写，其他字母转化为小写</p>
<ul>
<li>链式调用</li>
</ul>
<p>在jinjia2中，过滤器是可以支持链式调用的</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">{{<span class="string">"hello world"</span> | reverse | upper}}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>常见内置过滤器</p>
<ul>
<li>字符串操作</li>
</ul>
<p>禁用转义-safe、capitalize-首字母改大写、lower-小写、upper-大写、title-每个值改大写、truncate[i]-字符串截断</p>
<ul>
<li>列表操作</li>
</ul>
<p>first-取第一个、last-取最后一个、length-获取长度、sum-列表求和、sort-列表排序</p>
<ul>
<li>语句块过滤</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">{% <span class="built_in">filter</span> upper %}</span><br><span class="line">	一大堆文字</span><br><span class="line">{% endfilter %}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="Python中三大框架各自的应用场景"><a href="#Python中三大框架各自的应用场景" class="headerlink" title="Python中三大框架各自的应用场景"></a>Python中三大框架各自的应用场景</h2><ul>
<li><p>django:主要是用来搞快速开发的，他的亮点就是快速开发，节约成本，如果要实现高并发的话，就要对django进行二次开发，比如把整个笨重的框架给拆掉自己写socket实现http的通信,底层用纯c，c++写提升效率，ORM框架给干掉，自己编写封装与数据库交互的框架, <strong>ORM虽然面向对象来操作数据库，但是它的效率很低，使用外键来联系表与表之间的查询;</strong></p>
</li>
<li><p>flask: 轻量级，主要是用来写接口的一个框架，<strong>实现前后端分离</strong>，提高开发效率，Flask本身相当于一个内核，其他几乎所有的功能都要用到扩展(邮件扩展Flask-Mail，用户认证Flask-Login),都需要用第三方的扩展来实现。比如可以用Flask-extension加入ORM、文件上传、身份验证等。<strong>Flask没有默认使用的数据库，你可以选择MySQL，也可以用NoSQL。</strong></p>
<p>其<strong>WSGI工具用Werkzeug(路由模块—负责路由转发)</strong>，<strong>模板引擎则使用Jinja2</strong>，这两个也是Flask框架的核心。</p>
</li>
<li><p>Tornado： Tornado是一种Web服务器软件的开源版本。Tornado和现在的主流Web服务器框架（包括大多数Python的框架）有着明显的区别：<strong>它是非阻塞式服务器，而且速度相当快</strong>。得利于其非阻塞的方式和对epoll的运用，Tornado每秒可以处理数以千计的连接<strong>因此Tornado是实时Web服务的一个理想框架</strong></p>
</li>
</ul>
<h2 id="对Flask蓝图-Blueprint-的理解？"><a href="#对Flask蓝图-Blueprint-的理解？" class="headerlink" title="对Flask蓝图(Blueprint)的理解？"></a>对Flask蓝图(Blueprint)的理解？</h2><ul>
<li>蓝图的定义</li>
</ul>
<p>蓝图 /Blueprint 是Flask应用程序组件化的方法，可以在一个应用内或跨越多个项目共用蓝图。使用蓝图可以极大简化大型应用的开发难度，也为Flask扩展提供了一种在应用中注册服务的集中式机制。</p>
<ul>
<li>蓝图的应用场景：</li>
</ul>
<p>把一个应用分解为一个蓝图的集合。这对大型应用是理想的。一个项目可以实例化一个应用对象，初始化几个扩展，并注册一集合的蓝图。</p>
<p>以URL前缀和/或子域名，在应用上注册一个蓝图。URL前缀/子域名中的参数即成为这个蓝图下的所有视图函数的共同的视图参数（默认情况下）<br>在一个应用中用不同的URL规则多次注册一个蓝图。</p>
<p>通过蓝图提供模板过滤器、静态文件、模板和其他功能。一个蓝图不一定要实现应用或视图函数。</p>
<p>初始化一个Flask扩展时，在这些情况中注册一个蓝图。</p>
<p>蓝图的缺点：</p>
<p>不能在应用创建后撤销注册一个蓝图而不销毁整个应用对象。</p>
<ul>
<li>使用蓝图的三个步骤</li>
</ul>
<p>1.创建一个蓝图对象</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">blue = Blueprint(<span class="string">"blue"</span>,__name__)</span><br></pre></td></tr></tbody></table></figure>
<p>2.在这个蓝图对象上进行操作，例如注册路由、指定静态文件夹、注册模板过滤器…</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@blue.route(<span class="params"><span class="string">'/'</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blue_index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Welcome to my blueprint"</span></span><br></pre></td></tr></tbody></table></figure>
<p>3.在应用对象上注册这个蓝图对象</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">app.register_blueprint(blue,url_prefix=<span class="string">"/blue"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Flask-和-Django-路由映射的区别？"><a href="#Flask-和-Django-路由映射的区别？" class="headerlink" title="Flask 和 Django 路由映射的区别？"></a>Flask 和 Django 路由映射的区别？</h2><p>在django中，路由是浏览器访问服务器时，<strong>先访问的项目中的url，再由项目中的url找到应用中url</strong>，这些url是放在一个列表里，遵从从前往后匹配的规则。</p>
<p>在flask中，路由是<strong>通过装饰器给每个视图函数提供的</strong>，而且根据请求方式的不同url用于不同的作用。</p>
<h2 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h2><p>WSGI(Web Server Gateway Interface)<strong>Web服务器网关接口</strong>，是<strong>Python应用程序或框架和Web服务器</strong>之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p>
<p>它不是服务器,也不是python模块,<strong>它是一种规范,描述Web服务器和应用之间的交互</strong>.通俗来讲, 它就是一条纽带,连接着Web服务器和应用。</p>
<h1 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h1><h2 id="Django程序运行过程"><a href="#Django程序运行过程" class="headerlink" title="Django程序运行过程"></a>Django程序运行过程</h2><p>一般是用户通过浏览器向我们的服务器发起一个请求(request),这个请求会去访问视图函数，如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户）<br>视图函数调用模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。</p>
<p>1.wsgi ,请求封装后交给web框架（Flask，Django)</p>
<p>2.中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf,request.session</p>
<p>3.路由匹配 根据浏览器发送的不同url去匹配不同的视图函数</p>
<p>4.视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm，templates </p>
<p>5.中间件，对响应的数据进行处理</p>
<p>6.wsgi，将响应的内容发送给浏览器</p>
<h2 id="wsgi-uwsgi-uWSGI"><a href="#wsgi-uwsgi-uWSGI" class="headerlink" title="wsgi,uwsgi,uWSGI?"></a>wsgi,uwsgi,uWSGI?</h2><p>WSGI:</p>
<p>web服务器网关接口，<strong>是一套协议</strong>。用于<strong>接收用户请求并将请求进行初次封装</strong>，然后将请求<strong>交给web框架</strong>。</p>
<p>实现wsgi协议的模块：wsgiref, 本质上就是编写一socket服务端，用于接收用户请求（django)</p>
<p>werkzeug,本质上就是编写一个socket服务端，用于接收用户请求(flask)</p>
<p>uwsgi:</p>
<p>与WSGI一样是一种通信协议，<strong>它是uWSGI服务器的独占协议</strong>，用于定义传输信息的类型。</p>
<p>uWSGI:</p>
<p>是一个web服务器，实现了WSGI的协议，uWSGI协议，http协议</p>
<h2 id="nginx-tomcat-apache都是什么？"><a href="#nginx-tomcat-apache都是什么？" class="headerlink" title="nginx,tomcat,apache都是什么？"></a>nginx,tomcat,apache都是什么？</h2><ul>
<li><p>Nginx（engine x)是一个高性能的HTTP和反向代理服务器，也是 一个IMAP/POP3/SMTP服务器，工作在OSI七层，负载的实现方式：轮询，IP_HASH,fair,session_sticky.</p>
<p><strong>nginx 是一个开源的高性能的HTTP服务器和反向代理</strong>：</p>
<p>1.作为web服务器，它处理静态文件和索引文件效果非常高</p>
<p>2.它的设计非常注重效率，最大支持5万个并发连接，但只占用很少的内存空间</p>
<p>3.稳定性高，配置简洁。</p>
<p>4.强大的反向代理和负载均衡功能，平衡集群中各个服务器的负载压力应用</p>
</li>
</ul>
<ul>
<li><p>Apache HTTP Server是一个模块化的服务器，源于NCSAhttpd服务器</p>
</li>
<li><p>Tomcat 服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，是开发和调试JSP程序的首选。</p>
</li>
</ul>
<h2 id="Django、Flask、Tornado的对比？"><a href="#Django、Flask、Tornado的对比？" class="headerlink" title="Django、Flask、Tornado的对比？"></a>Django、Flask、Tornado的对比？</h2><p>1、 Django走的大而全的方向，<strong>重量级web框架，功能齐全，提供一站式解决的思路</strong>，能让开发者不用在选择上花费大量时间。</p>
<ul>
<li>自带ORM和模板引擎，支持jinja等非官方模板引擎。</li>
</ul>
<p>自带ORM使Django和关系型数据库耦合度高，如果要使用非关系型数据库，需要使用第三方库。</p>
<ul>
<li>自带数据库管理app</li>
</ul>
<p>成熟，稳定，开发效率高，相对于Flask，<strong>Django的整体封闭性比较好</strong>，适合做企业级网站的开发。python web框架的先驱，第三方库丰富</p>
<p>2、 Flask 是轻量级的框架，自由，灵活，可扩展性强，核心基于Werkzeug WSGI工具 和jinja2 模板引擎</p>
<p>适用于做小网站以及web服务的API,开发大型网站无压力，但架构需要自己设计</p>
<p>与关系型数据库的结合不弱于Django，而与<strong>非关系型数据库的耦合度高，远远优于Django</strong></p>
<p>3、 Tornado走的是少而精的方向，性能优越，它最出名的异步非阻塞的设计方式</p>
<p>Tornado的两大核心模块：</p>
<p>iostraem:对非阻塞的socket进行简单的封装</p>
<p>ioloop: 对I/O 多路复用的封装,它实现一个单例</p>
<h2 id="Session-Cookie-JWT的理解"><a href="#Session-Cookie-JWT的理解" class="headerlink" title="Session,Cookie, JWT的理解"></a>Session,Cookie, JWT的理解</h2><p>为什么要使用会话管理</p>
<p>众所周知，HTTP协议是一个无状态的协议，也就是说每个请求都是一个独立的请求，请求与请求之间并无关系。但在实际的应用场景，这种方式并不能满足我们的需求。举个大家都喜欢用的例子，把商品加入购物车，单独考虑这个请求，服务端并不知道这个商品是谁的，应该加入谁的购物车？因此这个请求的上下文环境实际上应该包含用户的相关信息，在每次用户发出请求时把这一小部分额外信息，也做为请求的一部分，这样服务端就可以根据上下文中的信息，针对具体的用户进行操作。所以这几种技术的出现都是对HTTP协议的一个补充，使得我们可以用HTTP协议+状态管理构建一个的面向用户的WEB应用。</p>
<p>Session 和Cookie的区别</p>
<p>  这里我想先谈谈session与cookies,因为这两个技术是做为开发最为常见的。那么session与cookies的区别是什么？个人认为session与cookies最核心区别在于额外信息由谁来维护。利用cookies来实现会话管理时，用户的相关信息或者其他我们想要保持在每个请求中的信息，都是放在cookies中,而cookies是由客户端来保存，每当客户端发出新请求时，就会稍带上cookies,服务端会根据其中的信息进行操作。<br>  当利用session来进行会话管理时，客户端实际上只存了一个由服务端发送的session_id,而由这个session_id,可以在服务端还原出所需要的所有状态信息，从这里可以看出这部分信息是由服务端来维护的。</p>
<p>除此以外，session与cookies都有一些自己的缺点：</p>
<p>cookies的安全性不好，攻击者可以通过获取本地cookies进行欺骗或者利用cookies进行CSRF攻击。使用cookies时, 在多个域名下，会存在跨域问题。<br>session 在一定的时间里，需要存放在服务端，因此当拥有大量用户时，也会大幅度降低服务端的性能，当有多台机器时，如何共享session也会是一个问题.(redis集群)也就是说，用户第一个访问的时候是服务器A，而第二个请求被转发给了服务器B，那服务器B如何得知其状态。实际上，session与cookies是有联系的，比如我们可以把session_id存放在cookies中的。</p>
<p>JWT是如何工作的</p>
<p>首先用户发出登录请求，服务端根据用户的登录请求进行匹配，如果匹配成功，将相关的信息放入payload中，利用算法，加上服务端的密钥生成token，这里需要注意的是secret_key很重要，如果这个泄露的话，客户端就可以随机篡改发送的额外信息，它是信息完整性的保证。生成token后服务端将其返回给客户端，客户端可以在下次请求时，将token一起交给服务端，一般是说我们可以将其放在Authorization首部中，这样也就可以避免跨域问题。</p>
<h2 id="用的restframework完成api发送时间时区"><a href="#用的restframework完成api发送时间时区" class="headerlink" title="用的restframework完成api发送时间时区"></a>用的restframework完成api发送时间时区</h2><p>当前的问题是用django的rest framework模块做一个get请求的发送时间以及时区信息的api</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">getCurrenttime</span>(<span class="params">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        local_time = time.localtime()</span><br><span class="line">        time_zone =settings.TIME_ZONE</span><br><span class="line">        temp = {<span class="string">'localtime'</span>:local_time,<span class="string">'timezone'</span>:time_zone}</span><br><span class="line">        <span class="keyword">return</span> Response(temp)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="django中间件的使用？"><a href="#django中间件的使用？" class="headerlink" title="django中间件的使用？"></a>django中间件的使用？</h2><p>Django在中间件中预置了六个方法，这六个方法的区别在于不同的阶段执行，对输入或输出进行干预，方法如下：</p>
<p>1.初始化：无需任何参数，服务器响应第一个请求的时候调用一次，用于确定是否启用当前中间件</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
<p>2.处理请求前：在每个请求上调用，返回None或HttpResponse对象。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
<p>3.处理视图前:在每个请求上调用，返回None或HttpResponse对象。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_view</span>(<span class="params">request,view_func,view_args,view_kwargs</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
<p>4.处理模板响应前：在每个请求上调用，返回实现了render方法的响应对象。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_template_response</span>(<span class="params">request,response</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
<p>5.处理响应后：所有响应返回浏览器之前被调用，在每个请求上调用，返回HttpResponse对象。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_response</span>(<span class="params">request,response</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
<p>6.异常处理：当视图抛出异常时调用，在每个请求上调用，返回一个HttpResponse对象。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_exception</span>(<span class="params">request,exception</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Django中哪里用到了线程？哪里用到了协程？哪里用到了进程？"><a href="#Django中哪里用到了线程？哪里用到了协程？哪里用到了进程？" class="headerlink" title="Django中哪里用到了线程？哪里用到了协程？哪里用到了进程？"></a>Django中哪里用到了线程？哪里用到了协程？哪里用到了进程？</h2><p>1.Django中耗时的任务用一个进程或者线程来执行，比如发邮件，使用celery.</p>
<p>2.部署django项目是时候，配置文件中设置了进程和协程的相关配置。</p>
<h2 id="有用过Django-REST-framework吗？"><a href="#有用过Django-REST-framework吗？" class="headerlink" title="有用过Django REST framework吗？"></a>有用过Django REST framework吗？</h2><p>Django REST framework是一个强大而灵活的Web API工具。使用RESTframework的理由有：</p>
<p>Web browsable API对开发者有极大的好处</p>
<p>包括OAuth1a和OAuth2的认证策略</p>
<p>支持ORM和非ORM数据资源的序列化</p>
<p>全程自定义开发—如果不想使用更加强大的功能，可仅仅使用常规的function-based views额外的文档和强大的社区支持</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>WEB FrameWork</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/posts/2246/</url>
    <content><![CDATA[<h1 id="同步，异步，阻塞，非阻塞？"><a href="#同步，异步，阻塞，非阻塞？" class="headerlink" title="同步，异步，阻塞，非阻塞？"></a>同步，异步，阻塞，非阻塞？</h1><p>同步： 多个任务之间有先后顺序执行，一个执行完下个才能执行。</p>
<p>异步： 多个任务之间没有先后顺序，可以同时执行，有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！</p>
<p>阻塞： 如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。</p>
<p>非阻塞： 如果不会卡住，可以继续执行，就是说非阻塞的。</p>
<p>同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。</p>
<a id="more"></a>
<h2 id="同步阻塞、同步非阻塞、多路I-O复用、异步I-O"><a href="#同步阻塞、同步非阻塞、多路I-O复用、异步I-O" class="headerlink" title="同步阻塞、同步非阻塞、多路I/O复用、异步I/O"></a>同步阻塞、同步非阻塞、多路I/O复用、异步I/O</h2><ul>
<li><p><strong>同步阻塞I/O:</strong> </p>
<p>当进程调用某些涉及I/O操作的系统调用或库函数时，比如send()、accept()等，进程便暂停下来，等I/O操作完成后再继续运行。</p>
</li>
<li><p><strong>同步非阻塞I/O: (轮询)</strong></p>
<ol>
<li><p>不会等待数据就绪，而是结合反复轮询来尝试数据是否就绪</p>
</li>
<li><p>与同步阻塞相比，同步非阻塞好处是在一个进程中可以同时处理多个I/O操作，而不是阻塞在一个I/O操作上</p>
</li>
</ol>
</li>
<li><p><strong>多路I/O复用</strong></p>
<ol>
<li>允许进程通过一种方法来同时监听所有文件描述符，并可以快速获得所有就绪的文件描述符，然后只针对这些文件描述符进行数据访问。select、poll、epoll等函数使用了I/O 复用模型</li>
</ol>
</li>
<li><p><strong>异步I/O</strong></p>
<ol>
<li>启动某个操作，并让内核在整个操作（包括等待数据和将数据从内核复制到用户空间）完成后通知应用进程。<strong>应用进程在整个操作期间都不会被阻塞。</strong></li>
</ol>
</li>
</ul>
<h2 id="Python异步使用场景有哪些"><a href="#Python异步使用场景有哪些" class="headerlink" title="Python异步使用场景有哪些"></a>Python异步使用场景有哪些</h2><p>异步的使用场景:</p>
<p>1、 不涉及共享资源，获对共享资源只读，即<strong>非互斥</strong>操作</p>
<p>2、 <strong>没有时序上的严格关系</strong></p>
<p>3、 不需要原子操作，或可以通过其他方式控制原子性</p>
<p>4、 <strong>常用于IO操作等耗时操作</strong>，因为比较影响客户体验和使用性能</p>
<p>5、 <strong>不影响主线程逻辑</strong></p>
<h2 id="select-poll和epoll"><a href="#select-poll和epoll" class="headerlink" title="select,poll和epoll"></a>select,poll和epoll</h2><p><strong>进程监视多个描述符</strong></p>
<p><strong>进程监视多个描述符</strong></p>
<p><strong>进程监视多个描述符</strong></p>
<p>Select、poll、epoll都是I/O多路复用的机制。<strong>I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（通常是读写操作），能够通知程序进行相应的读写操作。</strong></p>
<p><strong>都是I/O轮询的方法（同步I/O）</strong>，它们都需要在读写事件就绪后自己负责读写。</p>
<p><a href="https://www.wemeng.top/2019/08/22/%E8%81%8A%E8%81%8AIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3/">聊聊I/O多路复用之select、poll、epoll</a></p>
<p>关于epoll的: <a href="http://www.cnblogs.com/my_life/articles/3968782.html">http://www.cnblogs.com/my_life/articles/3968782.html</a></p>
<p>基本上select有3个缺点:</p>
<ol>
<li><strong>连接数受限</strong>：单个进程所打开的fd是有一定限制的</li>
<li><strong>查找配对速度慢</strong>：对socket进行轮询扫描时是<strong>线性扫描</strong>，效率较低。</li>
<li><strong>数据由内核拷贝到用户态</strong>：维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li>
</ol>
<p>poll改善了第一个缺点：原因是它是基于<strong>链表来存储的</strong></p>
<p>epoll改了三个缺点：<strong>epoll通过内核和用户空间共享一块内存来实现</strong>。通知机制需要很多函数回调。</p>
<h2 id="边沿触发和水平触发"><a href="#边沿触发和水平触发" class="headerlink" title="边沿触发和水平触发"></a>边沿触发和水平触发</h2><p>水平触发是<strong>只要满足条件</strong>就发生一个 io 事件，边缘触发是指每当<strong>状态变化</strong>时发生一个 io 事件。</p>
<p>如：epoll也是实现I/O多路复用的一种方法。</p>
<p>epoll有<strong>水平触发</strong>（level trigger，LT，LT为epoll的默认工作模式）与<strong>边缘触发</strong>（edge trigger，ET）两种工作模式。</p>
<ul>
<li>水平触发</li>
</ul>
<ol>
<li>对于读操作</li>
</ol>
<p>只要<strong>缓冲内容</strong>不为空，LT模式返回读就绪。</p>
<ol>
<li>对于写操作</li>
</ol>
<p>只要缓冲区还不满，LT模式会返回写就绪。</p>
<ul>
<li>边缘触发</li>
</ul>
<ol>
<li>对于读操作</li>
</ol>
<p>（1）当缓冲区<strong>由不可读变为可读</strong>的时候，即缓冲区<strong>由空变为不空</strong>的时候。</p>
<p>（2）当有<strong>新数据到达</strong>时，即缓冲区中的待读数据变多的时候。</p>
<p>（3）当缓冲区有数据可读，且应用进程对相应的描述符进行<code>EPOLL_CTL_MOD</code> 修改<code>EPOLLIN</code>事件时。</p>
<ol>
<li>对于写操作</li>
</ol>
<p>（1）当缓冲区由不可写变为可写时。</p>
<p>（2）当有旧数据被发送走，即缓冲区中的内容变少的时候。</p>
<p>（3）当缓冲区有空间可写，且应用进程对相应的描述符进行<code>EPOLL_CTL_MOD</code> 修改<code>EPOLLOUT</code>事件时。</p>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程总结"><a href="#进程总结" class="headerlink" title="进程总结"></a>进程总结</h2><p><strong>进程：程序运行在操作系统上的一个实例，就称之为进程。进程需要相应的系统资源：内存、时间片、pid。</strong><br>创建进程：<br>首先要导入multiprocessing中的Process：<br>创建一个Process对象;<br>创建Process对象时，可以传递参数;</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">p = Process(target=XXX,args=(<span class="built_in">tuple</span>,),kwargs={key:value})</span><br><span class="line">target = XXX 指定的任务函数，不用加(),</span><br><span class="line">args=(<span class="built_in">tuple</span>,)kwargs={key:value}给任务函数传递的参数</span><br></pre></td></tr></tbody></table></figure>
<p>使用start()启动进程<br>结束进程<br>给子进程指定函数传递参数Demo</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> mulitprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pro_func</span>(<span class="params">name,age,**kwargs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"子进程正在运行中，name=%s,age=%d,pid=%d"</span>%(name,age,os.getpid()))</span><br><span class="line">        print(kwargs)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#创建Process对象</span></span><br><span class="line">    p = Process(target=pro_func,args=(<span class="string">'小明'</span>,<span class="number">18</span>),kwargs={<span class="string">'m'</span>:<span class="number">20</span>})</span><br><span class="line">    <span class="comment">#启动进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#1秒钟之后，立刻结束子进程</span></span><br><span class="line">    p.terminate()</span><br><span class="line">    p.join()</span><br></pre></td></tr></tbody></table></figure>
<p>注意：进程间不共享全局变量</p>
<p>进程之间的通信-Queue</p>
<p>在初始化Queue()对象时（例如q=Queue(),若在括号中没有指定最大可接受的消息数量，获数量为负值时，那么就代表可接受的消息数量没有上限一直到内存尽头）</p>
<p>Queue.qsize():返回当前队列包含的消息数量</p>
<p>Queue.empty():如果队列为空，返回True，反之False</p>
<p>Queue.full():如果队列满了，返回True,反之False</p>
<p>Queue.get([block[,timeout]]):获取队列中的一条消息，然后将其从队列中移除，</p>
<p>block默认值为True。</p>
<p>如果block使用默认值，且没有设置timeout（单位秒),消息队列如果为空，此时程序将被阻塞（停在读中状态），直到消息队列读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出“Queue.Empty”异常：</p>
<p>Queue.get_nowait()相当于Queue.get(False)</p>
<p>Queue.put(item,[block[,timeout]]):将item消息写入队列，block默认值为True;<br>如果block使用默认值，且没有设置timeout（单位秒），消息队列如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息队列腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常<br>如果block值为False，消息队列如果没有空间可写入，则会立刻抛出”Queue.Full”异常;<br>Queue.put_nowait(item):相当Queue.put(item,False)</p>
<p>进程间通信Demo:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process.Queue</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"><span class="comment">#写数据进程执行的代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">q</span>):</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>]:</span><br><span class="line">        print(<span class="string">"Put %s to queue..."</span>,%value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"><span class="comment">#读数据进程执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">q</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            value = q.get(<span class="literal">True</span>)</span><br><span class="line">            print(<span class="string">"Get %s from queue."</span>,%value)</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#父进程创建Queue，并传给各个子进程</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write,args=(q,))</span><br><span class="line">    pr = Process(target=read,args=(q,))</span><br><span class="line">    <span class="comment">#启动子进程pw ，写入：</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment">#等待pw结束</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment">#启动子进程pr，读取：</span></span><br><span class="line">    pr.start()</span><br><span class="line">    pr.join()</span><br><span class="line">    <span class="comment">#pr 进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    print(<span class="string">''</span>)</span><br><span class="line">    print(<span class="string">'所有数据都写入并且读完'</span>)</span><br></pre></td></tr></tbody></table></figure>
<pre><code>进程池Pool
</code></pre><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">msg</span>):</span></span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(<span class="string">"%s 开始执行，进程号为%d"</span>%(msg,os.getpid()))</span><br><span class="line">    <span class="comment"># random.random()随机生成0-1之间的浮点数</span></span><br><span class="line">    time.sleep(random.random()*<span class="number">2</span>)</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(msg,<span class="string">"执行完毕，耗时%0.2f”%（t_stop-t_start))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">po = Pool(3)#定义一个进程池，最大进程数3</span></span><br><span class="line"><span class="string">for i in range(0,10):</span></span><br><span class="line"><span class="string">    po.apply_async(worker,(i,))</span></span><br><span class="line"><span class="string">print("</span>---start----<span class="string">")</span></span><br><span class="line"><span class="string">po.close()</span></span><br><span class="line"><span class="string">po.join()</span></span><br><span class="line"><span class="string">print("</span>----end----<span class="string">")</span></span><br></pre></td></tr></tbody></table></figure>
<p>进程池中使用Queue</p>
<p>如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue(),而不是multiprocessing.Queue(),否则会得到如下的错误信息：</p>
<p>RuntimeError： Queue objects should only be shared between processs through inheritance</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager,Pool</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span>(<span class="params">q</span>):</span></span><br><span class="line">    print(<span class="string">"reader 启动(%s),父进程为（%s)"</span>%(os.getpid(),os.getpid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q.qsize()):</span><br><span class="line">        print(<span class="string">"reader 从Queue获取到消息:%s"</span>%q.get(<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span>(<span class="params">q</span>):</span></span><br><span class="line">    print(<span class="string">"writer 启动（%s),父进程为(%s)"</span>%(os.getpid(),os.getpid()))</span><br><span class="line">    <span class="keyword">for</span> i ini <span class="string">"itcast"</span>:</span><br><span class="line">        q.put(i)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"(%s)start"</span>%os.getpid())</span><br><span class="line">    q = Manager().Queue()<span class="comment">#使用Manager中的Queue</span></span><br><span class="line">    po = Pool()</span><br><span class="line">    po.apply_async(wrtier,(q,))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    po.apply_async(reader,(q,))</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    print(<span class="string">"(%s)End"</span>%os.getpid())</span><br></pre></td></tr></tbody></table></figure>
<h2 id="多进程，多线程，协程"><a href="#多进程，多线程，协程" class="headerlink" title="多进程，多线程，协程"></a>多进程，多线程，协程</h2><p>这个问题被问的概念相当之大。<br>进程：<strong>一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间</strong>，所有进程间数据不共享，开销大。</p>
<p>线程: <strong>cpu调度执行的最小单位，依赖进程存在</strong>，一个进程至少有一个线程，叫主线程，而<strong>多个线程共享内存</strong>（数据共享，共享全局变量), 从而极大地提高了程序的运行效率。</p>
<p>协程: 是一种用户态的轻量级线程，<strong>协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。</strong>协程调度时，将<strong>寄存器上下文和栈</strong>保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<p>协程是进程和线程的升级版, <strong>进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.</strong>（实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU））</p>
<p><strong>Python里最常见的yield就是协程的思想</strong>!</p>
<p>协程：<a href="https://www.cnblogs.com/zingp/p/8678109.html">https://www.cnblogs.com/zingp/p/8678109.html</a></p>
<h2 id="协程库：python-asyncio的原理"><a href="#协程库：python-asyncio的原理" class="headerlink" title="协程库：python asyncio的原理"></a>协程库：python asyncio的原理</h2><p>asyncio这个库就是实现协程，<strong>底层都是基于生成器（yield）来实现的。</strong></p>
<p>在生成器的基础上实现了：</p>
<ol>
<li><p>现在的生成器虽然可以在暂停执行时吐出一个值，<strong>但是恢复生成器时，我们不能传入参数。</strong> （言下之意是恢复协程时，应该需要支持传入参数）</p>
</li>
<li><p>现在的生成器不支持在 try block 中暂停（言下之意是<strong>协程应该要支持在 try block 中暂停</strong>）</p>
</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'hello world'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">job1</span>():</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'job1 started...'</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'job1 paused'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> hello_world()</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'job1 resumed'</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'job1 finished'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loop = asyncio.get_event_loop()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loop.run_until_complete(job1())</span><br></pre></td></tr></tbody></table></figure>
<p><a href="http://cosven.me/blogs/88">http://cosven.me/blogs/88</a></p>
<h2 id="僵尸进程和孤儿进程？怎么避免僵尸进程"><a href="#僵尸进程和孤儿进程？怎么避免僵尸进程" class="headerlink" title="僵尸进程和孤儿进程？怎么避免僵尸进程"></a>僵尸进程和孤儿进程？怎么避免僵尸进程</h2><ul>
<li><p>孤儿进程： <strong>父进程退出，子进程还在运行的这些子进程都是孤儿进程</strong>，孤儿进程将被init 进程（进程号为1）所收养，并<strong>由init 进程对他们完成状态收集工作</strong>。</p>
</li>
<li><p>僵尸进程： <strong>进程使用fork 创建子进程，如果子进程退出</strong>，而父进程并没有<strong>调用wait （join方法）获waitpid 获取子进程的退出状态信息</strong>，那么<strong>子进程的进程描述符仍然保存在系统中</strong>的这些进程是僵尸进程。</p>
</li>
</ul>
<p>避免僵尸进程的方法：</p>
<ol>
<li><p><strong>暴力法</strong>：结束父进程（主进程），父进程退出时子进程也会退出。</p>
</li>
<li><p><strong>用wait使父进程阻塞</strong>：如join()方法来wait</p>
</li>
<li><p><strong>使用信号量</strong>：在<strong>父进程中处理</strong>signal handler信号，在<strong>处理程序中调用waitpid</strong>, 这样父进程不用阻塞</p>
</li>
</ol>
<h2 id="进程与线程的使用场景"><a href="#进程与线程的使用场景" class="headerlink" title="进程与线程的使用场景"></a>进程与线程的使用场景</h2><p>多线程适合在IO密性型操作（读写数据操作比较多的，比如爬虫）</p>
<p>多进程适合在CPU密集操作（cpu操作指令比较多，如位多的的浮点运算）。</p>
<h2 id="IO密集型和CPU密集型区别"><a href="#IO密集型和CPU密集型区别" class="headerlink" title="IO密集型和CPU密集型区别"></a>IO密集型和CPU密集型区别</h2><p>IO密集型： 系统运行，大部分的状况是CPU在等 I/O（硬盘/内存）的读/写</p>
<p>CPU密集型： 大部分时间用来做计算，逻辑判断等CPU动作的程序称之CPU密集型。</p>
<h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><ul>
<li><p>并发（concurrency)：不会在同一时刻同时运行，存在交替执行的情况。（threading）</p>
</li>
<li><p>并行（parallel）： 同一时刻多个任务同时在运行（multiprocessing）</p>
</li>
</ul>
<p>程序需要执行较多的读写、请求和回复任务的需要大量的IO操作，IO密集型操作使用并发更好<strong>（I/O密集型 - 线程 - 并发）</strong></p>
<p>CPU运算量大的程序，使用并行会更好<strong>（CPU密集型 - 进程 - 并行）</strong></p>
<h2 id="线程，进程是并发还是并行"><a href="#线程，进程是并发还是并行" class="headerlink" title="线程，进程是并发还是并行"></a>线程，进程是并发还是并行</h2><ul>
<li><p>线程是并发</p>
</li>
<li><p>进程是并行</p>
</li>
</ul>
<p>进程之间互相独立，是系统分配资源的最小单位，同一个线程中的所有线程共享资源。</p>
<h2 id="什么是多线程竞争"><a href="#什么是多线程竞争" class="headerlink" title="什么是多线程竞争"></a>什么是多线程竞争</h2><ul>
<li><p>线程是非独立的，<strong>同一个进程里线程是数据共享的，当各个线程访问数据资源时会出现竞争状态即：数据几乎同步会被多个线程占用，造成数据混乱</strong>，即所谓的线程不安全</p>
</li>
<li><p>怎么解决多线程竞争问题？—- <strong>锁</strong></p>
</li>
</ul>
<p>锁的好处： 确保了某段关键代码（共享数据资源）只能由一个线程从头到尾完整地执行能解决多线程资源竞争下的原子操作问题。</p>
<p>锁的坏处： <strong>阻止了多线程并发执行</strong>，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</p>
<p><strong>锁的致命问题: 死锁</strong></p>
<h2 id="Python的线程同步"><a href="#Python的线程同步" class="headerlink" title="Python的线程同步"></a>Python的线程同步</h2><p> 一、 setDaemon(False)<br>当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行的最小单位，当设置多线程时，<strong>主线程会创建多个子线程</strong>，在Python中，默认情况下就是setDaemon(False), <strong>主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。</strong></p>
<p>例子</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'---子线程结束---'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    t1 = threading.Thread(target=thread)</span><br><span class="line">    t1.start()</span><br><span class="line">    print(<span class="string">'---主线程--结束'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line">---主线程--结束</span><br><span class="line">---子线程结束---</span><br></pre></td></tr></tbody></table></figure>
<p>二、 setDaemon（True) <strong>— 主线程结束、子线程也结束</strong><br>当我们使用setDaemon(True)时，<strong>这是子线程为守护线程，主线程一旦执行结束，则全部子线程被强制终止</strong></p>
<p>例子</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(’---子线程结束---<span class="string">')</span></span><br><span class="line"><span class="string">def main():</span></span><br><span class="line"><span class="string">    t1 = threading.Thread(target=thread)</span></span><br><span class="line"><span class="string">    t1.setDaemon(True)#设置子线程守护主线程</span></span><br><span class="line"><span class="string">    t1.start()</span></span><br><span class="line"><span class="string">    print('</span>---主线程结束---<span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ =='</span>__main__<span class="string">':</span></span><br><span class="line"><span class="string">    main()</span></span><br><span class="line"><span class="string">#执行结果</span></span><br><span class="line"><span class="string">---主线程结束--- #只有主线程结束，子线程来不及执行就被强制结束</span></span><br></pre></td></tr></tbody></table></figure>
<p>三、 join（线程同步) <strong>— 主线程等子线程结束后再结束</strong><br><strong>join 所完成的工作就是线程同步</strong>，即主线程任务结束以后，进入堵塞状态，一直<strong>等待所有的子线程结束以后，主线程再终止</strong>。</p>
<p>当设置守护线程时，含义是<strong>主线程对于子线程等待timeout的时间将会杀死该子线程</strong>，最后退出程序，所以说，如果有10个子线程，全部的等待时间就是每个timeout的累加和，简单的来说，就是给每个子线程一个timeou的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。</p>
<p>没有设置守护线程时，主线程将会等待timeout的累加和这样的一段时间，时间一到，主线程结束，但是并没有杀死子线程，子线程依然可以继续执行，直到子线程全部结束，程序退出。</p>
<p>例子</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'---子线程结束---'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    t1 = threading.Thread(target=thread)</span><br><span class="line">    t1.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t1.join(timeout=<span class="number">1</span>)<span class="comment">#1 线程同步，主线程堵塞1s 然后主线程结束，子线程继续执行</span></span><br><span class="line">                        <span class="comment">#2 如果不设置timeout参数就等子线程结束主线程再结束</span></span><br><span class="line">                        <span class="comment">#3 如果设置了setDaemon=True和timeout=1主线程等待1s后会强制杀死子线程，然后主线程结束</span></span><br><span class="line">    print(<span class="string">'---主线程结束---'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main___'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="多线程交互访问数据，如果访问到了就不访问了"><a href="#多线程交互访问数据，如果访问到了就不访问了" class="headerlink" title="多线程交互访问数据，如果访问到了就不访问了"></a>多线程交互访问数据，如果访问到了就不访问了</h2><p>怎么避免重读？</p>
<p><strong>创建一个已访问数据列表，用于存储已经访问过的数据，并加上互斥锁</strong>，在多线程访问数据的时候先查看数据是否在已访问的列表中，若已存在就直接跳过。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><p>锁(Lock)是python提供的对线程控制的对象。<strong>有互斥锁，可重入锁，死锁</strong>。</p>
<ul>
<li>死锁：死锁是一个资源被多次调用，而多次调用方都未能释放该资源就会造成死锁</li>
<li>互斥锁：threading.Lock</li>
<li>可重入锁：threading.RLock，为了支持在<strong>同一线程中多次请求同一资源</strong>，python提供了“可重入锁”：threading.RLock。<strong>RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次acquire。</strong>直到一个线程所有的acquire都被release，其他的线程才能获得资源。</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>若干子线程在<strong>系统资源竞争</strong>时，都在<strong>等待对方对某部分资源解除占用状态</strong>，结果是<strong>谁也不愿先解锁</strong>，互相干等着，程序无法执行下去，这就是死锁。</p>
<p>必要条件:</p>
<ol>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ol>
<p>处理死锁基本方法:</p>
<ol>
<li>预防死锁(摒弃除1以外的条件)</li>
<li><strong>避免死锁(银行家算法)</strong>：当一个进程申请使用资源的时候，银行家算法通过先 <strong>试探</strong> 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。</li>
<li>检测死锁(<strong>资源分配图</strong>)</li>
<li>解除死锁<ol>
<li><strong>剥夺资源</strong></li>
<li><strong>撤销进程</strong></li>
</ol>
</li>
</ol>
<p>死锁概念处理策略详细介绍:<a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html">https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html</a></p>
<p>一个死锁的例子：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_numbers</span>():</span></span><br><span class="line">    print(<span class="string">"1"</span>)</span><br><span class="line">    s2.acquire()</span><br><span class="line">    print(<span class="string">"2"</span>)</span><br><span class="line">    s1.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_char</span>():</span></span><br><span class="line">    print(<span class="string">"3"</span>)</span><br><span class="line">    s1.acquire()</span><br><span class="line">    print(<span class="string">"4"</span>)</span><br><span class="line">    s2.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 创建锁</span></span><br><span class="line">    s1 = Lock()</span><br><span class="line">    s2 = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建两个线程</span></span><br><span class="line">    t1 = Thread(name=<span class="string">"打印字符"</span>, target=print_numbers)</span><br><span class="line">    t2 = Thread(name=<span class="string">"打印字母"</span>, target=print_char)</span><br><span class="line">    s1.acquire()</span><br><span class="line">    s2.acquire()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="互斥锁、线程安全"><a href="#互斥锁、线程安全" class="headerlink" title="互斥锁、线程安全"></a>互斥锁、线程安全</h2><p><strong>每个对象</strong>都对应于一个可称为’互斥锁‘的标记，这个<strong>标记用来保证在任一时刻，只能有一个线程访问该对象。</strong></p>
<p>同一进程中的多线程之间是共享系统资源的，多个线程同时对一个对象进行操作，一个线程操作尚未结束，另一线程已经对其进行操作，导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。</p>
<h2 id="GIL锁-全局解释器锁"><a href="#GIL锁-全局解释器锁" class="headerlink" title="GIL锁 全局解释器锁"></a>GIL锁 全局解释器锁</h2><p>作用： 限制多线程同时执行，保证同一时间只有一个线程执行，所以cython里的多线程其实是伪多线程！</p>
<p>所以python里常常使用协程技术来代替多线程，协程是一种更轻量级的线程。</p>
<p>进程和线程的切换时由系统决定，而协程由我们程序员自己决定，而模块gevent下切换是遇到了耗时操作时才会切换</p>
<p>三者的关系：进程里有线程，线程里有协程。</p>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><ul>
<li><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反<strong>数据完整性</strong>的操作</p>
<p><strong>互斥锁、可重入锁都属于悲观锁。</strong>当你读取或者写入数据时，你都悲观地认为有别人正在改动数据，所以你希望在你 操作数据的时候上锁，防止别人改动。当然，当已经有别人上锁，你必须等待别人操作完毕。</p>
</li>
</ul>
<p>  悲观锁的业务流程:</p>
<blockquote>
<p>事务开始<br>查询、修改数据表之前 加锁<br>对数据库 操作<br>事务提交（检测、返回冲突）</p>
</blockquote>
<ul>
<li><p>乐观锁：假设不会发生并发冲突，只在<strong>提交操作时检查</strong>是否违反数据完整性。</p>
<p><strong>Redis的并发竞争解决方案</strong>，使用乐观锁，成本低，非阻塞，性能高。</p>
<p>每次去取数据的时候总认为不会有其他线程对数据进行修改，因此<strong>不会上锁</strong>，但是在更新时会判断其他线程在这之前有没有对数据进行修改。</p>
</li>
</ul>
<p>乐观锁与悲观锁的具体区别:</p>
<p> <a href="http://www.cnblogs.com/Bob-FD/p/3352216.html">http://www.cnblogs.com/Bob-FD/p/3352216.html</a></p>
<p><a href="http://blog.csdn.net/chosen0ne/article/details/18093187">http://blog.csdn.net/chosen0ne/article/details/18093187</a>)</p>
<h2 id="多线程共同操作同一个数据互斥锁同步？"><a href="#多线程共同操作同一个数据互斥锁同步？" class="headerlink" title="多线程共同操作同一个数据互斥锁同步？"></a>多线程共同操作同一个数据互斥锁同步？</h2><p>两个线程循环打印数字和字母</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/11/9 11:00 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: test.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_numbers</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">27</span>):</span><br><span class="line">        <span class="keyword">if</span> s1.acquire(): <span class="comment"># 判断是否得到锁</span></span><br><span class="line">            print(<span class="built_in">str</span>(i))</span><br><span class="line">            s1.release() <span class="comment"># 释放锁</span></span><br><span class="line">            time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_char</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">65</span>, <span class="number">91</span>):</span><br><span class="line">        <span class="keyword">if</span> s1.acquire():</span><br><span class="line">            print(<span class="built_in">chr</span>(i))</span><br><span class="line">            s1.release()</span><br><span class="line">            time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 创建锁</span></span><br><span class="line">    s1 = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建两个线程</span></span><br><span class="line">    t1 = Thread(name=<span class="string">"打印字符"</span>, target=print_numbers)</span><br><span class="line">    t2 = Thread(name=<span class="string">"打印字母"</span>, target=print_char)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h1><ol>
<li><p>先来先服务(FCFS, First Come First Serve)</p>
</li>
<li><p><strong>短作业优先</strong>(SJF, Shortest Job First)</p>
</li>
<li><p><strong>最高优先权调度</strong>(Priority Scheduling)</p>
</li>
<li><p><strong>时间片轮转</strong>(RR, Round Robin)：把CPU的时间分给各个任务用</p>
</li>
<li><p><strong>多级反馈队列调度</strong>(multilevel feedback queue scheduling)：能使优先级高的作业得到响应又能使短作业（进程）迅速完成。</p>
<p>对于优先级高的作业，首先执行；</p>
<p>对于优先级低的队列，采用时间片轮询的方法。</p>
</li>
</ol>
<p>常见的调度算法总结:<a href="http://www.jianshu.com/p/6edf8174c1eb">http://www.jianshu.com/p/6edf8174c1eb</a></p>
<p>实时调度算法:</p>
<ol>
<li>最早截至时间优先 EDF</li>
<li>最低松弛度优先 LLF</li>
</ol>
<h1 id="程序编译与链接"><a href="#程序编译与链接" class="headerlink" title="程序编译与链接"></a>程序编译与链接</h1><p>推荐: <a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html">http://www.ruanyifeng.com/blog/2014/11/compiler.html</a></p>
<p>Bulid过程可以分解为4个步骤:<strong>预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking)</strong></p>
<p>以c语言为例:</p>
<h2 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1 预处理"></a>1 预处理</h2><p><strong>预编译过程主要处理那些源文件中的以“#”开始的预编译指令</strong>，主要处理规则有：</p>
<ol>
<li>将所有的“<strong>#define</strong>”删除，并展开所用的宏定义</li>
<li>处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif”</li>
<li>处理“<strong>#include</strong>”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是<strong>递归</strong>进行的</li>
<li><strong>删除所有注释</strong></li>
<li><strong>添加行号和文件名标识</strong>，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号</li>
<li>保留所有的#pragma编译器指令。</li>
</ol>
<h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2 编译"></a>2 编译</h2><p>编译过程就是把预处理完的文件进行一系列的<strong>词法分析、语法分析、语义分析及优化</strong>后<strong>生成相应的汇编代码文件</strong>。这个过程是整个程序构建的核心部分。</p>
<h2 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3 汇编"></a>3 汇编</h2><p>汇编器是将<strong>汇编代码转化成机器可以执行的指令</strong>，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件<strong>成为目标文件</strong>(Object File)</p>
<h2 id="4-链接"><a href="#4-链接" class="headerlink" title="4 链接"></a>4 链接</h2><p>链接的主要内容就是把<strong>各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。</strong><br>链接的主要过程包块地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。</p>
<h1 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h1><ul>
<li><p>静态链接方法：<strong>静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来</strong><br>静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库</p>
</li>
<li><p>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是<strong>直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址</strong>，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式<strong>使程序初始化时间较短，但运行期间的性能比不上静态链接的程序</strong></p>
</li>
</ul>
<h1 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h1><p>虚拟存储器是指具有<strong>请求调入</strong>功能和<strong>置换功能</strong>,能<strong>从逻辑上对内存容量加以扩充的一种存储系统.</strong></p>
<h1 id="分页和分段"><a href="#分页和分段" class="headerlink" title="分页和分段"></a>分页和分段</h1><p>分页: <strong>用户程序的地址空间被划分成若干固定大小的区域，称为“页”</strong>，相应地，<strong>内存空间分成若干个物理块，页和块的大小相等</strong>。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p>
<p>分段: 将用户程序地址空间分成<strong>若干个大小不等的段</strong>，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，<strong>段与段在内存中可以不相邻接，也实现了离散分配。</strong></p>
<h1 id="分页与分段的主要区别"><a href="#分页与分段的主要区别" class="headerlink" title="分页与分段的主要区别"></a>分页与分段的主要区别</h1><ol>
<li><p><strong>页是信息的物理单位</strong>,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于<strong>系统管理的需要</strong>.</p>
<p><strong>段是信息的逻辑单位</strong>,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,<strong>满足用户的需要</strong>.</p>
</li>
<li><p>页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是<strong>由机器硬件实现的</strong>.</p>
<p>而段的长度却不固定,决定于用户所编写的程序,通常由<strong>编译程序</strong>在对源程序进行编译时根据信息的性质来划分.</p>
</li>
<li><p>分页的作业地址空间是一维的.</p>
<p>分段的地址空间是二维的.</p>
</li>
</ol>
<h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><ol>
<li><strong>最佳置换算法OPT</strong>:不可能实现，选择的被淘汰的页面将是以后永不使用的，或是在最长（未来）时间内不再被访问的页面。采用最佳置换算法通常可保证<strong>最低的缺页率</strong>。</li>
<li><strong>先进先出FIFO</strong></li>
<li><strong>最近最久未使用算法LRU</strong>: 最近一段时间里最久没有使用过的页面予以置换.</li>
<li><strong>clock算法</strong></li>
</ol>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础</title>
    <url>/posts/22488/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>数据库事务(Database Transaction) ，是指为访问并可能操作各个数据项的<strong>一个数据库操作序列，这些操作要么全部执行，要么全部不执行</strong>，是一个不可分割的工作单位。事务由事务开始与结束之间执行的全部数据库操作组成。</p>
<p>如：我们去银行转账，操作可能分为以下两个环节：</p>
<p>（1）从第一个账户划出款项</p>
<p>（2）将款项存入第二个账户</p>
<p>这两个环节是关联的，如果第二个环节没有完成，那么所有的环节都应该取消。</p>
<p>性质：</p>
<p>A：原子性（Atomicity）事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全部不执行。</p>
<p>C：一致性（Consistency）几个并行执行的事务，其执行结果必须与按某一顺序 串行执行的结果相一致。</p>
<p>I：隔离性（Isolation）事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。</p>
<p>D：持久性（Durability）对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。</p>
<p>彻底理解数据库事务: <a href="http://www.hollischuang.com/archives/898">http://www.hollischuang.com/archives/898</a></p>
<a id="more"></a>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="主键-超键-候选键-外键"><a href="#主键-超键-候选键-外键" class="headerlink" title="主键 超键 候选键 外键"></a>主键 超键 候选键 外键</h2><ul>
<li><p><strong>主键</strong>：指的是<strong>一个列或多列的组合，其值能唯一地标识表中的每一行</strong>，通过它可强制表的实体完整性。主键主要是用与其他表的外键关联，以及本记录的修改与删除。</p>
<p>身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。 所以，选取主键的一个基本原则是：<strong>不使用任何业务相关的字段作为主键</strong>。 因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。</p>
</li>
<li><p><strong>外键</strong>：关系模式R1中的某属性集不是R1的主键，而是另一个<strong>关系R2的主键</strong>则该属性集是关系模式<strong>R1的外键</strong>。</p>
</li>
<li><p><strong>超键</strong>：<strong>在关系中能唯一标识元组的属性集称为关系模式的超键</strong>。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。<strong>超键包含候选键和主键。</strong></p>
</li>
<li><p><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</p>
</li>
</ul>
<p>例子：</p>
<blockquote>
<p>假设有如下两个表：</p>
<p>学生（学号，姓名，性别，身份证号，教师编号）</p>
<p>教师（教师编号，姓名，工资）</p>
</blockquote>
<p><strong>超键：</strong></p>
<p>由超键的定义可知，学生表中含有学号或者身份证号的任意组合都为此表的超键。如：（学号）、（学号，姓名）、（身份证号，性别）等。</p>
<p><strong>候选键：</strong></p>
<p>候选键属于超键，它是最小的超键，就是说如果再去掉候选键中的任何一个属性它就不再是超键了。学生表中的候选键为：（学号）、（身份证号）。</p>
<p><strong>主键：</strong></p>
<p>主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，教师表中让“教师编号”做主键。</p>
<p><strong>外键：</strong></p>
<p>外键比较简单，学生表中的外键就是“教师编号”。外键主要是用来描述两个表的关系。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>索引是关系数据库中对<strong>某一列或多个列的值进行预排序的数据结构</strong>。通过使用索引，可以让数据库系统不必扫描整个表，而是<strong>直接定位到符合条件的记录，这样就大大加快了查询速度。</strong></li>
</ul>
<p>索引的效率<strong>取决于索引列的值是否散列</strong>，即该<strong>列的值如果越不相同，那么索引效率越高</strong>。反过来，如果记录的列存在大量相同的值。例如gender列，那对该列创建索引就没有意义。</p>
<p>例如：创建名称为idx_score，使用列score的索引。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_score (score)</span><br></pre></td></tr></tbody></table></figure>
<p>推荐:<a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1218728442198976">https://www.liaoxuefeng.com/wiki/1177760294764384/1218728442198976</a></p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a></p>
<p>聚集索引,非聚集索引, B-Tree（B树属于多叉树又名<strong>平衡多路查找树</strong>（查找路径不只两个））,B+Tree, 最左前缀原理</p>
<ul>
<li>数据库索引，<strong>是数据库管理系统中一个排序的数据结构，以协助快速查询</strong>，更新数据库表中数据。索引的实现通常使用<strong>B树($O(Log_2N)$)以其变种B+树</strong>。</li>
</ul>
<p>在数据之外，数据库系统还维护着<strong>满足特定查找算法的数据结构</strong>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。<strong>这种数据结构，就是索引</strong>。</p>
<p>为表设置索引要付出代价的：<strong>一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间（因为索引也要随之变动）</strong></p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul>
<li><strong>视图是虚拟的表，主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</strong>隐藏具体的细节，保护数据; 视图创建后，可以使用与表相同的方式利用它们。</li>
</ul>
<p>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by则对视图再次order by将被覆盖。</p>
<blockquote>
<p>创建视图： create view xxx as xxxxxx</p>
</blockquote>
<p>优点：</p>
<ol>
<li>使用视图，可以定制用户数据，聚焦特定的数据。</li>
<li>使用视图，可以简化数据操作。</li>
<li>使用视图，基表中的数据就有了一定的安全性</li>
</ol>
<p><a href="https://www.jianshu.com/p/6a2c7407be4c">https://www.jianshu.com/p/6a2c7407be4c</a></p>
<h2 id="drop-truncate-delete的区别"><a href="#drop-truncate-delete的区别" class="headerlink" title="drop, truncate, delete的区别"></a>drop, truncate, delete的区别</h2><ul>
<li><p>drop直接删掉表</p>
</li>
<li><p>truncate删除表中数据，<strong>再插入时自增长id又从1开始</strong></p>
<p>truncate table则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，<strong>删除行是不能恢复的</strong>。并且在删除的过程中不会激活与表有关的删除触发器，执行速度快；</p>
</li>
<li><p>delete删除表中数据，<strong>可以加where字句</strong></p>
<p>delete 语句执行删除的过程是<strong>每次从表中删除一行</strong>，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。</p>
</li>
</ul>
<ol>
<li><p>表和索引所占空间：drop语句将表所占用的空间全释放掉；当表被truncate后，这个表和索引所占用的空间会恢复到初始大小，而delete操作不会减少表或索引所占用的空间。</p>
</li>
<li><p>一般而言，drop&gt;truncate&gt;delete</p>
</li>
<li><p>应用范围。truncate只能对table，delete可以是table和view</p>
</li>
<li><p>truncate和delete只删除数据，而drop则删除整个表<strong>（结构和数据)</strong></p>
</li>
<li><p>truncate与不带where的delete:只删除数据，<strong>而不删除表的结构（定义）</strong>drop语句将删除表的结构被依赖的<strong>约束(constrain),触发器（trigger)索引(index)</strong>;依赖于该表的存储过程/函数将被保留，但其状态会变为:invalid.</p>
</li>
</ol>
<h2 id="连接的种类：内连接、外连接、交叉连接"><a href="#连接的种类：内连接、外连接、交叉连接" class="headerlink" title="连接的种类：内连接、外连接、交叉连接"></a>连接的种类：内连接、外连接、交叉连接</h2><p>join_type 指出连接类型。join_condition指连接条件。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">FROM  join_table join_type join_table[ON (join_condition)]</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><strong>内连接（inner join）</strong>：使用比较运算符（包括=、&gt;、&lt;、&lt;&gt;、&gt;=、&lt;=、!&gt;和!&lt;）进行表间的比较操作，查询与连接条件相匹配的数据</p>
<ul>
<li>等值连接（=）</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_student s, T_class c <span class="keyword">where</span> s.classID = c.classID</span><br><span class="line">等于</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_student s <span class="keyword">inner</span> <span class="keyword">join</span> T_class <span class="keyword">on</span> s.classID = c.classID</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>自然连接：与等值相同，<strong>但是会删除表中的重复列</strong></li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.*,c.className <span class="keyword">from</span> T_student s <span class="keyword">inner</span> <span class="keyword">join</span> T_class c <span class="keyword">on</span> s.classId = c.classId</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>不等连接（&lt;, &gt;, &lt;&gt;, &gt;=, &lt;=, !&gt;, !&lt;）</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_student s <span class="keyword">inner</span> <span class="keyword">join</span> T_class c <span class="keyword">on</span> s.classId &lt;&gt; c.classId</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>外连接</strong>（left join、right join、full join）</p>
<ul>
<li><p><strong>左连接</strong>（LEFT JOIN）：返回左表中的所有行，如果左表中行在右表中没有匹配行，则结果中右表中的列返回空值。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span>  T_student s <span class="keyword">left</span> <span class="keyword">join</span> T_class c <span class="keyword">on</span> s.classId = c.classId</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>左外连接（LEFT OUTER JOIN）:</p>
</li>
<li><p><strong>右连接</strong>（RIGHT JOIN）: 与左连接相反</p>
</li>
<li><p>右外连接（RIGHT OUTER JOIN）</p>
</li>
<li><p><strong>全连接</strong>（FULL JOIN）: 返回左表和右表中的所有行。当某行在另一表中没有匹配行，则另一表中的列返回空值</p>
</li>
<li><p>全外连接（FULL OUTER JOIN）</p>
</li>
</ul>
</li>
<li><p><strong>交叉连接</strong>：笛卡尔积（cross join）</p>
<p>不带WHERE条件子句，<strong>它将会返回被连接的两个表的笛卡尔积</strong>，返回结果的行数等于两个表行数的乘积（例如：T_student和T_class，返回4*4=16条记录）；如果带where，返回或显示的是匹配的行数。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_student s <span class="keyword">cross</span> <span class="keyword">join</span> T_class c <span class="keyword">where</span> s.classId = c.classId </span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="存储过程与触发器的区别"><a href="#存储过程与触发器的区别" class="headerlink" title="存储过程与触发器的区别"></a>存储过程与触发器的区别</h2><ul>
<li>存储过程：用户调用的时候才会执行</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 创建的存储过程名字(<span class="keyword">OUT</span>|<span class="keyword">IN</span>|INOUT 参数名 数据类型,...,...) 特征 过程体</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>触发器：对表进行诸如UPDATE、INSERT、DELETE等时，<strong>SqlServer自动执行触发器定义的SQL语句</strong>，通过事件触发</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 创建的触发器名字 BEFFOR|<span class="keyword">AFTER</span>  <span class="keyword">INSERT</span>|<span class="keyword">UPDATE</span>|<span class="keyword">DELETE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> 表名字 <span class="keyword">FOR</span>  触发器的执行间隔   触发器的<span class="keyword">SQL</span>语句</span><br></pre></td></tr></tbody></table></figure>
<h2 id="数据库优化的思路"><a href="#数据库优化的思路" class="headerlink" title="数据库优化的思路"></a>数据库优化的思路</h2><ol>
<li><p>SQL语句优化</p>
<ul>
<li>应尽量避免在 where 子句中对字段进行 <strong>null 值</strong>判断，否则将导致<strong>引擎放弃使用索引而进行全表扫描</strong></li>
<li>应尽量避免在 where 子句中使用<strong>!=或&lt;&gt;操作符</strong>，否则将<strong>引擎放弃使用索引而进行全表扫描</strong></li>
</ul>
</li>
<li><p>索引优化</p>
<ul>
<li>创建索引：<strong>对经常需要搜索的列上</strong>，可以加快搜索的速度；<strong>在经常需要排序的列上创建索引</strong>，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>不应该创建索引：对于那些在查询中很少使用或者参考的列不应该创建索引；当修改性能远远大于检索性能时，不应该创建索引</li>
</ul>
</li>
<li><p>数据库结构优化</p>
<ul>
<li>范式优化：消除冗余（节省空间）</li>
<li>反范式优化：适当增加冗余（减少join）</li>
</ul>
</li>
<li><p>服务器硬件优化</p>
<p>花钱</p>
</li>
</ol>
<p><a href="https://www.jishuchi.com/read/mysql-interview/2810">https://www.jishuchi.com/read/mysql-interview/2810</a></p>
<h2 id="关系数据库范式"><a href="#关系数据库范式" class="headerlink" title="关系数据库范式"></a>关系数据库范式</h2><p>在进行数据库的设计时，所遵循的一些规范，只要按照设计规范进行设计，就能设计出没有数据冗余和数据维护异常的数据库结构。</p>
<p>数据库的设计的规范有很多，通常来说我们在设是数据库时只要达到其中一些规范就可以了，这些规范又称之为数据库的三范式，一共有三条，也存在着其他范式，我们只要做到满足前三个范式的要求，就能设陈出符合我们的数据库了，我们也不能全部来按照范式的要求来做，还要考虑实际的业务使用情况，所以有时候也需要做一些违反范式的要求。</p>
<ol>
<li><p>数据库设计的第一范式(最基本)，基本上所有数据库的范式都是符合第一范式的，符合第一范式的表具有以下几个特点：</p>
<p><strong>数据库表中的所有字段都只具有单一属性，是指数据库表的每一列(即每个属性)都是不可分割的基本数据项，同一列中不能有多个值</strong>（整型，浮点型，字符型等）</p>
</li>
<li><p>数据库设计的第二范式(是在第一范式的基础上设计的)，<strong>要求一个表中只具有一个业务主键</strong>，也就是说符合第二范式的表中<strong>不能存在非主键列对只对部分主键的依赖关系</strong></p>
</li>
<li><p>数据库设计的第三范式，<strong>第三范式就是属性不依赖于其它非主属性</strong>。</p>
</li>
</ol>
<h2 id="MySQL引擎：InnoDB、MyIASM和MEMORY"><a href="#MySQL引擎：InnoDB、MyIASM和MEMORY" class="headerlink" title="MySQL引擎：InnoDB、MyIASM和MEMORY"></a>MySQL引擎：InnoDB、MyIASM和MEMORY</h2><p>MySQL支持三个引擎：InnoDB、MyIASM和MEMORY</p>
<p><strong>InnoDB 和 MyISAM之间的区别：</strong></p>
<ul>
<li><p>两者索引<strong>都使用B+树</strong>，InnoDB是MySQL默认的存储引擎</p>
</li>
<li><p>InnoDB<strong>支持事务</strong>，而MyISAM不支持事务</p>
</li>
<li>InnoDB<strong>支持外键</strong>，而MyISAM不支持</li>
<li>InnoDB<strong>支持MVCC,</strong> 而MyISAM不支持</li>
<li>InnoDB<strong>不支持全文索引</strong>，而MyISAM支持</li>
</ul>
<p><strong>InnoDB</strong> ：如果要提供提交、回滚、崩溃恢复的事务安全能力，用InnoDB</p>
<p><strong>MyISAM</strong>：如果数据表主要用来<strong>插入和查询</strong>记录，MyISAM能提供较高的处理速度</p>
<p><strong>MEMORY：</strong>如果只是临时存放数据，数据量不大，不需要较高的安全性，可以选择将数据保存在内存中的MEMORY引擎</p>
<p>mysql 数据库引擎: <a href="http://www.cnblogs.com/0201zcr/p/5296843.html">http://www.cnblogs.com/0201zcr/p/5296843.html</a><br>MySQL存储引擎－－MyISAM与InnoDB区别: <a href="https://segmentfault.com/a/1190000008227211">https://segmentfault.com/a/1190000008227211</a></p>
<h2 id="？-MySQL的innodb引擎是如何实现MVCC的"><a href="#？-MySQL的innodb引擎是如何实现MVCC的" class="headerlink" title="？ MySQL的innodb引擎是如何实现MVCC的"></a>？ <a href="http://lib.csdn.net/base/mysql">MySQL</a>的innodb引擎是如何实现MVCC的</h2><blockquote>
<p>​    全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，<strong>每个读操作会看到一个一致性的snapshot</strong>，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。</p>
</blockquote>
<p>innodb会为每一行添加两个字段，分别表示该行<strong>创建的版本</strong>和<strong>删除的版本</strong>，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（<a href="http://blog.csdn.net/chosen0ne/article/details/10036775">事务的隔离级别请看这篇文章</a>）下，具体各种数据库操作的实现：</p>
<ul>
<li>select：满足以下两个条件innodb会返回该行数据：<ul>
<li>该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。</li>
<li>该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。</li>
</ul>
</li>
<li>insert：将新插入的行的创建版本号设置为当前系统的版本号。</li>
<li>delete：将要删除的行的删除版本号设置为当前系统的版本号。</li>
<li>update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。</li>
</ul>
<p>其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。</p>
<p>​    由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。</p>
<p>通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。</p>
<h2 id="MySQL怎么限制IP访问？"><a href="#MySQL怎么限制IP访问？" class="headerlink" title="MySQL怎么限制IP访问？"></a>MySQL怎么限制IP访问？</h2><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> priviledge <span class="keyword">on</span> <span class="string">"*"</span> <span class="keyword">to</span> <span class="string">"用户名@ip地址"</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">"数据库密码"</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'admin@192.168.0.1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改密码</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> <span class="keyword">for</span> <span class="string">'admin@192.168.0.1'</span> = <span class="keyword">password</span>(<span class="string">"admin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权：只有来自192.168.0.1的用户才能通过admin访问服务器</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> priviledges <span class="keyword">on</span> <span class="string">"*"</span> <span class="keyword">to</span> <span class="string">"admin@192.168.0.1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line"><span class="keyword">flush</span> priviledges</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h2><ol>
<li>是一个完全开源免费的<strong>key-value内存数据库</strong> </li>
<li>通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets</li>
</ol>
<h2 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h2><blockquote>
<p>​    通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用<strong>来处理高并发的数据库操作</strong></p>
</blockquote>
<ul>
<li>速度快：使用标准C写，<strong>所有数据都在内存中完成</strong>，读写速度分别达到10万/20万 </li>
<li>持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof) </li>
<li>自动操作：对不同数据类型的操作都是自动的，很安全 </li>
<li><strong>快速的主—从复制</strong>，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。 </li>
<li>Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。</li>
</ul>
<h2 id="Redis缺点"><a href="#Redis缺点" class="headerlink" title="Redis缺点"></a>Redis缺点</h2><ul>
<li><strong>是数据库容量受到物理内存的限制,</strong> 不能用作海量数据的高性能读写, 因此Redis适合的场景主要<strong>局限在较小数据量的高性能操作和运算上。</strong></li>
<li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h2 id="Redis宕机怎么解决"><a href="#Redis宕机怎么解决" class="headerlink" title="Redis宕机怎么解决"></a>Redis宕机怎么解决</h2><p>宕机:服务器停止服务</p>
<p><strong>如果只有一台redis，肯定会造成数据丢失，无法挽救</strong></p>
<p>多台redis或者是redis集群，宕机则需要分为在主从模式下区分来看：</p>
<ul>
<li><p>slave从redis宕机：配置主从复制的时候才配置从的redis，从的会从主的redis中读取主的redis的操作日志，在redis中从库重新启动后会自动加入到主从架构中，自动完成同步数据;</p>
</li>
<li><p>主redis宕机：如果从数据库实现了持久化，此时千万不要立马重启服务，否则可能会造成数据丢失，正确的操作如下：<strong>在slave</strong>数据上执行SLAVEOF ON ONE, <strong>来断开主从关系并把slave升级为主库</strong>，此时重新启动主数据库，执行SLAVEOF，<strong>把主库设置为从库</strong>，连接到主的redis上面做主从复制，自动备份数据。</p>
</li>
</ul>
<p>以上过程很容易配置错误，可以使用redis提供的哨兵机制来简化上面的操作。简单的方法: <strong>redis的哨兵(sentinel)</strong>的功能</p>
<h2 id="Redis和mecached的区别，以及使用场景"><a href="#Redis和mecached的区别，以及使用场景" class="headerlink" title="Redis和mecached的区别，以及使用场景"></a>Redis和mecached的区别，以及使用场景</h2><p>总结</p>
<p>都是内存数据库</p>
<p>redis挂掉后会备份，并实现了持久化，除了k/v，还支持多种类型的数据存储。</p>
<p>memcache挂掉后，数据不可恢复，仅支持k/v。</p>
<p>使用场景</p>
<ol>
<li><p>如果有<strong>持久方面的需求</strong>或对<strong>数据类型和处理有要求</strong>的应该选择redis</p>
</li>
<li><p>如果<strong>简单的key/value存储应该选择memcached</strong>.</p>
</li>
</ol>
<p>区别</p>
<p>1、redis和Memcache都是<strong>将数据存放在内存中，都是内存数据库</strong>。不过memcache还可以用于缓存其他东西，例如图片，视频等等</p>
<p>2、Redis不仅仅支持简单的<strong>k/v类型的数据</strong>，同时还提供<strong>list,set,hash等数据结构的存储</strong></p>
<p>3、虚拟内存-redis当物流内存用完时，可以将一些很久没用的value交换到磁盘</p>
<p>4、过期策略-memcache在set时就指定，例如set key1 0 0 8，即永不过期。Redis可以通过例如expire设定，例如expire name 10</p>
<p>5、分布式-设定memcache集群，利用magent做一主多从，redis可以做一主多从。都可以一主一从</p>
<p>6、存储数据安全-<strong>memcache挂掉后，数据没了</strong>。<strong>redis可以定期保存到磁盘(持久化)</strong></p>
<p>7、灾难恢复-<strong>memcache挂掉后，数据不可恢复</strong>。redis数据丢失后可以通过aof恢复</p>
<p>8、Redis支持数据的备份，即master-slave模式的数据备份</p>
<p>9、应用场景不一样，redis除了作为NoSQL数据库使用外，还能用做消息队列，数据堆栈和数据缓存等; Memcache适合于缓存SQL语句，数据集，用户临时性数据，延迟查询数据和session等</p>
<h2 id="Redis集群方案该怎么做-都有哪些方案"><a href="#Redis集群方案该怎么做-都有哪些方案" class="headerlink" title="Redis集群方案该怎么做?都有哪些方案?"></a>Redis集群方案该怎么做?都有哪些方案?</h2><ol>
<li><p>codis</p>
<p>目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在节点数量改变情况下，旧节点数据客恢复到新hash节点</p>
</li>
<li><p>redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方介绍</p>
</li>
<li><p>在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key进行hash计算，然后去对应的redis实例操作数据。这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的字典脚本恢复，实例的监控，等等</p>
</li>
</ol>
<h2 id="Redis回收进程是如何工作的"><a href="#Redis回收进程是如何工作的" class="headerlink" title="Redis回收进程是如何工作的"></a>Redis回收进程是如何工作的</h2><p>一个客户端运行了新的命令，添加了新的数据。</p>
<p>redis检查内存使用情况，如果大于maxmemory的限制，则根据<strong>设定好的策略</strong>进行回收。</p>
<p>一个新的命令被执行等等，所以我们不断地穿越内存限制的边界，通过<strong>不断达到边界然后不断回收回到边界以下</strong>。</p>
<p>如果一个命令的结果导致大量内存被使用(例如很大的集合的交集保存到一个新的键)，不用多久内存限制就会被这个内存使用量超越。</p>
<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="211-MongoDB中对多条记录做更新操作命令是什么？"><a href="#211-MongoDB中对多条记录做更新操作命令是什么？" class="headerlink" title="211.MongoDB中对多条记录做更新操作命令是什么？"></a>211.MongoDB中对多条记录做更新操作命令是什么？</h2><h2 id="212-MongoDB如何才会拓展到多个shard里？"><a href="#212-MongoDB如何才会拓展到多个shard里？" class="headerlink" title="212.MongoDB如何才会拓展到多个shard里？"></a>212.MongoDB如何才会拓展到多个shard里？</h2>]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>DataBase Basic</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/posts/6678/</url>
    <content><![CDATA[<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><ol>
<li><p>客户端通过向服务器端<strong>发送一个请求报文SYN</strong>来创建一个主动打开。</p>
</li>
<li><p>Server端接受连接后<strong>回复ACK报文</strong>，并为这次连接分配资源。</p>
<p>如果只有两次通信的话，这时候B不确定A是否收到了确认消息，有可能这个确认消息由于某些原因丢了。</p>
</li>
<li><p>Client端接收到<strong>ACK报文</strong>后也向Server段发送报文，并分配资源，这样TCP连接就建立了。</p>
<p>这个时候经过了三次握手，A和B双方确认了两边都是通的，可以相互通信了，已经可以建立一个可靠的连接，并且可以相互发送数据。</p>
<p>这个时候已经不需要B再发送一个确认消息了，两边已经通过前三次建立了一个可靠的连接，如果再发送第四次确认消息的话，就浪费资源了。</p>
</li>
</ol>
<a id="more"></a>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 00.57.08.png" alt="Screen Shot 2020-11-08 at 00.57.08"></p>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p><em>注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.</em></p>
<ol>
<li>客户端发送一个<strong>FIN报文</strong>. 客户端进入 <strong>FIN-WAIT 状态</strong>. 该状态下客户端只接收数据, 不再发送数据.</li>
<li>服务器接收到带有 FIN = 1 的数据分段, 发送带有 <strong>ACK = 1 的剩余数据分段</strong>, 确认收到客户端发来的 FIN 信息.</li>
<li>服务器<strong>等到所有数据传输结束,</strong> 向客户端发送一个带有 <strong>FIN = 1 的数据分段</strong>, 并进入 <strong>CLOSE-WAIT 状态</strong>, 等待客户端发来带有 ACK = 1 的确认报文.</li>
<li>客户端收到服务器发来带有 FIN = 1 的报文, 返回 <strong>ACK = 1 的报文</strong>确认, <strong>为了防止服务器端未收到需要重发</strong>, 进入 <strong>TIME-WAIT</strong> 状态. 服务器接收到报文后关闭连接. 客户端等待 <strong>2MSL 后未收到回复, 则认为服务器成功关闭</strong>, 客户端关闭连接。</li>
</ol>
<blockquote>
<p> 注：MSL是报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。RFC规定为两分钟，实际应用中常用的是30秒，1分钟和2分钟。</p>
</blockquote>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 00.57.38.png" alt="Screen Shot 2020-11-08 at 00.57.38"></p>
<p>图解: <a href="http://blog.csdn.net/whuslei/article/details/6667471">http://blog.csdn.net/whuslei/article/details/6667471</a></p>
<h1 id="七层网络模型"><a href="#七层网络模型" class="headerlink" title="七层网络模型"></a>七层网络模型</h1><p>网络通信的分层模型讲起：七层模型，也称OSI (Open System Interconnection)模型。</p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 11.56.48.png" alt="Screen Shot 2020-11-08 at 11.56.48"></p>
<h1 id="TCP和UDP对比"><a href="#TCP和UDP对比" class="headerlink" title="TCP和UDP对比"></a>TCP和UDP对比</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>TCP</th>
<th style="text-align:left">UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">是否连接</td>
<td>面向连接</td>
<td style="text-align:left">无连接，想发就发</td>
</tr>
<tr>
<td style="text-align:left">是否可靠</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
<td style="text-align:left">不可靠传输，不使用流量控制和拥塞控制</td>
</tr>
<tr>
<td style="text-align:left">连接对象个数</td>
<td>只能是一对一通信</td>
<td style="text-align:left">支持一对一，一对多，多对一和多对多交互通信</td>
</tr>
<tr>
<td style="text-align:left">传输方式</td>
<td>面向字节流</td>
<td style="text-align:left">面向报文</td>
</tr>
<tr>
<td style="text-align:left">首部开销</td>
<td>首部最小20字节，最大60字节</td>
<td style="text-align:left">首部开销小，仅8字节</td>
</tr>
<tr>
<td style="text-align:left">适用场景</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
<td style="text-align:left">适用于实时应用（IP电话、视频会议、直播等）</td>
</tr>
</tbody>
</table>
</div>
<p>总结</p>
<ul>
<li>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。</li>
<li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li>
<li>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</li>
</ul>
<h1 id="Socket-Ip-address-TCP-UDP-port"><a href="#Socket-Ip-address-TCP-UDP-port" class="headerlink" title="Socket(Ip address+ TCP/UDP + port)"></a>Socket(Ip address+ TCP/UDP + port)</h1><p><strong>套接字用于描述IP地址和端口，是一个通信链的句柄。</strong>应用程序通过套接字向网络发出请求或应答网络请求。注意的是套接字既不是程序也不是协议，只是<strong>操作系统提供给通信层的一组抽象API接口。</strong></p>
<p>Socket=Ip address+ TCP/UDP + port</p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.31.08.png" alt="Screen Shot 2020-11-08 at 15.31.08"></p>
<p>推荐: <a href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></p>
<p>使用Socket套接字需要传入哪些参数？</p>
<ul>
<li><p><strong>地址族(Address Family)</strong></p>
<p>地址族通常作为 socket() 函数的第一个参数。</p>
<p>socket.AF_INET 　IPv4地址族，(host, port) 形式的二元组，host是一个表示网络主机的字符串，port为套接字的端口号。AF_INET对应的数值是：2。</p>
<p>socket.AF_INET6 　(host, port, flowinfo, scopeid) 形式的四元组。AF_INET6对应的数值是：23。</p>
</li>
<li><p><strong>套接字类型（Type）</strong></p>
<p>套接字类型用于 socket() 函数的第二个参数。</p>
<p>但是只有 SOCK_STREAM （TCP）和 SOCK_DGRAM （UDP）是比较常见的。</p>
</li>
</ul>
<h1 id="怎么强行关闭客户端和服务器的连接"><a href="#怎么强行关闭客户端和服务器的连接" class="headerlink" title="怎么强行关闭客户端和服务器的连接"></a>怎么强行关闭客户端和服务器的连接</h1><ul>
<li><p>关闭TCP连接是指TCP协议层的东西，就是两个TCP端之间交换了一些协议包（FIN，RST等），具体的交换过程可以看TCP协议。</p>
</li>
<li><p>而关闭socket是指<strong>关闭用户应用程序中的socket句柄，释放相关资源</strong>。但是当用户<strong>关闭socket句柄时会隐含的触发TCP连接的关闭过程</strong>。</p>
</li>
</ul>
<p>TCP连接的关闭过程有两种，一种是<strong>优雅关闭</strong>（graceful close），一种是<strong>强制关闭</strong>（hard close或abortive close）</p>
<ul>
<li>优雅关闭是指，如果<strong>发送缓存</strong>中还有数据未发出则其发出去，<strong>并且收到所有数据的ACK之后，发送FIN包，开始关闭过程</strong>。</li>
<li>强制关闭是指如果<strong>缓存中</strong>还有数据，则这些数据都将被丢弃，然后发送<strong>RST</strong>包，直接重置TCP连接。</li>
</ul>
<p>shutdown函数，用于关闭TCP连接，但并不关闭socket句柄。</p>
<ul>
<li>SD_RECEIVE表明<strong>关闭接收通道</strong>，在该socket上不能再接收数据，如果当前接收缓存中仍有未取出数据或者<strong>以后再有数据到达，则TCP会向发送端发送RST包</strong>，将连接重置。</li>
<li>SD_SEND表明<strong>关闭发送通道</strong>，TCP会将发送缓存中的数据都发送完毕并<strong>收到所有数据的ACK后向对端发送FIN包</strong>，表明本端没有更多数据发送。这个是一个优雅关闭过程。</li>
<li>SD_BOTH则表示<strong>同时关闭接收通道和发送通道</strong>。</li>
</ul>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1xx 报告</td>
<td style="text-align:left">接收到请求，继续进程</td>
</tr>
<tr>
<td style="text-align:left">2xx 成功</td>
<td style="text-align:left">步骤成功接收，被理解，并被接受</td>
</tr>
<tr>
<td style="text-align:left">3xx 重定向</td>
<td style="text-align:left">为了完成请求,必须采取进一步措施</td>
</tr>
<tr>
<td style="text-align:left">4xx 客户端出错</td>
<td style="text-align:left">请求包括错的顺序或不能完成</td>
</tr>
<tr>
<td style="text-align:left">5xx 服务器出错</td>
<td style="text-align:left">服务器无法完成显然有效的请求</td>
</tr>
</tbody>
</table>
</div>
<p>403: Forbidden<br>404: Not Found</p>
<h2 id="HTTP1-0和HTTP1-1"><a href="#HTTP1-0和HTTP1-1" class="headerlink" title="HTTP1.0和HTTP1.1"></a>HTTP1.0和HTTP1.1</h2><p>推荐: <a href="http://blog.csdn.net/elifefly/article/details/3964766">http://blog.csdn.net/elifefly/article/details/3964766</a></p>
<p><strong>HTTP 1.0*规定浏览器与服务器只保持短暂的连接</strong>，浏览器的每次请求都需要与服务器建立一个<em>TCP</em>连接，服务器完成请求处理后立即断开<em>TCP</em>连接，服务器不跟踪每个客户也不记录过去的请求。</p>
<p><strong>HTTP1.1改进点</strong></p>
<ol>
<li><strong>支持了长链接</strong>：在一个<em>TCP</em>连接上可以传送多个<em>HTTP</em>请求和响应，减少了建立和关闭连接的消耗和延迟。</li>
<li><strong>HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求</strong>。但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</li>
<li><strong>增加请求头Host字段</strong>：一个服务器多个虚拟Web站点。</li>
<li><strong>身份认证,状态管理,Cache缓存等机制</strong>相关的请求头和响应头。</li>
</ol>
<h2 id="HTTP常见请求头与响应头"><a href="#HTTP常见请求头与响应头" class="headerlink" title="HTTP常见请求头与响应头"></a>HTTP常见请求头与响应头</h2><p>常见请求头：Request</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Accept</th>
<th>可接受的响应内容类型（<code>Content-Types</code>）。</th>
<th><code>Accept: text/plain</code></th>
<th>固定</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Charset</td>
<td>浏览器可接受的字符集</td>
<td><code>Accept-Charset: utf-8</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>可接受的响应内容的数据压缩格式</td>
<td><code>Accept-Encoding: gzip, deflate</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>可接受的响应内容语言列表。</td>
<td><code>Accept-Language: en-US</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Datetime</td>
<td>可接受的按照时间来表示的响应内容版本</td>
<td>Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT</td>
<td>临时</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>用来指定当前的请求/回复中的，是否使用缓存机制。</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>常见响应头：Response</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">响应头</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Age</td>
<td style="text-align:left">响应对象在代理缓存中存在的时间，以秒为单位</td>
<td style="text-align:left"><code>Age: 12</code></td>
<td style="text-align:left">固定</td>
</tr>
<tr>
<td style="text-align:left">Cache-Control</td>
<td style="text-align:left">通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒</td>
<td style="text-align:left"><code>Cache-Control: max-age=3600</code></td>
<td style="text-align:left">固定</td>
</tr>
</tbody>
</table>
</div>
<p><a href="https://itbilu.com/other/relate/EJ3fKUwUx.html">https://itbilu.com/other/relate/EJ3fKUwUx.html</a></p>
<p><a href="https://juejin.im/post/6844903745004765198">https://juejin.im/post/6844903745004765198</a></p>
<h2 id="HTTP协议以及协议头部中表示数据类型的字段"><a href="#HTTP协议以及协议头部中表示数据类型的字段" class="headerlink" title="HTTP协议以及协议头部中表示数据类型的字段"></a>HTTP协议以及协议头部中表示数据类型的字段</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Accept</th>
<th>可接受的响应内容类型（<code>Content-Types</code>）。</th>
<th><code>Accept: text/plain</code></th>
<th>固定</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Charset</td>
<td>浏览器可接受的字符集</td>
<td><code>Accept-Charset: utf-8</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>可接受的响应内容的数据压缩格式</td>
<td><code>Accept-Encoding: gzip, deflate</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>可接受的响应内容语言列表。</td>
<td><code>Accept-Language: en-US</code></td>
<td>固定</td>
</tr>
</tbody>
</table>
</div>
<h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>HTTP请求8种方法介绍<br>HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。</p>
<ol>
<li>GET</li>
</ol>
<p><strong>GET请求会显示请求指定的资源</strong>。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的幂等的操作中。</p>
<p>GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。</p>
<ol>
<li>HEAD</li>
</ol>
<p><strong>HEAD方法与GET方法一样，都是向服务器发出指定资源的请求</strong>。但是，服务器在响应HEAD请求时<strong>不会回传资源的内容部分，即：响应主体</strong>。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。</p>
<ol>
<li>POST</li>
</ol>
<p><strong>POST请求会向指定资源提交数据，请求服务器进行处理</strong>，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。<strong>POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。</strong></p>
<ol>
<li>PUT</li>
</ol>
<p><strong>PUT请求会身向指定资源位置上传其最新内容</strong>，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</p>
<ol>
<li>DELETE</li>
</ol>
<p><strong>DELETE请求用于请求服务器删除所请求URI</strong>（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。</p>
<ol>
<li>CONNECT</li>
</ol>
<p><strong>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器</strong>。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p>
<ol>
<li>OPTIONS</li>
</ol>
<p><strong>OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能</strong>。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许</p>
<ol>
<li>TRACE</li>
</ol>
<p><strong>TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。</strong></p>
<p>HTTP/1.1之后增加的方法</p>
<p>在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：</p>
<ol>
<li>PATCH</li>
</ol>
<p>PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：</p>
<p><strong>但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。</strong><br>当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。</p>
<h2 id="Post和Get"><a href="#Post和Get" class="headerlink" title="Post和Get"></a>Post和Get</h2><p><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html">GET和POST有什么区别？及为什么网上的多数答案都是错的</a><br><a href="https://www.zhihu.com/question/31640769?rf=37401322">知乎回答</a></p>
<p>get: <a href="http://tools.ietf.org/html/rfc2616#section-9.3">RFC 2616 - Hypertext Transfer Protocol — HTTP/1.1</a><br>post: <a href="http://tools.ietf.org/html/rfc2616#section-9.5">RFC 2616 - Hypertext Transfer Protocol — HTTP/1.1</a></p>
<p>HTTP协议用法的约定，使用上的区别：</p>
<ol>
<li><strong>GET使用URL或Cookie传参，而POST将数据放在BODY中。</strong></li>
<li><strong>GET方式提交的数据长度有限，而POST的数据则可以非常大。</strong>（这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。也不是GET和POST本身的区别。）</li>
<li><strong>POST比GET安全，因为数据在地址栏上不可见。</strong></li>
<li>对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据</li>
</ol>
<p>终极区别：</p>
<ol>
<li><strong>GET请求是满足幂等性的，POST请求不是。</strong>所以不应该且不能用get请求做数据的<strong>增删改</strong>这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用。</li>
</ol>
<blockquote>
<p>什么是幂等性？简单来说意味着对同一URL的多个请求应该返回同样的结果。</p>
</blockquote>
<h2 id="幂等-Idempotence"><a href="#幂等-Idempotence" class="headerlink" title="幂等 Idempotence"></a>幂等 Idempotence</h2><p><strong>HTTP方法的幂等性是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用</strong>。(注意是副作用)</p>
<p>1.、HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>2、GET：<strong>向特定的资源发出请求数据。（要数据）</strong><br>3、POST：<strong>向指定资源提交数据进行处理请求（给数据）</strong>（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。<br>4、PUT：向指定资源位置上传其最新内容。<br>5、DELETE：请求服务器删除Request-URI所标识的资源。 </p>
<p>如：</p>
<p><code>GET http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，<strong>这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。</strong><code>GET http://www.news.com/latest-news</code>这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，<strong>因而是满足幂等性的。</strong></p>
<p>DELETE方法用于删除资源，有副作用，但它<strong>应该满足幂等性</strong>。比如：<code>DELETE http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p>
<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：<code>POST http://www.forum.com/articles</code>的语义是在<code>http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，<strong>POST方法不具备幂等性</strong>。</p>
<p>PUT所对应的URI是要创建或更新的资源本身。比如：<code>PUT http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，<strong>PUT方法具有幂等性</strong>。</p>
<h2 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h2><p>HTTPS协议是由<strong>SSL+HTTP协议构建的可进行加密传输</strong>、身份认证的网络协议，要比http协议安全。(SSL: Secure Sockets Layer)</p>
<p>HTTPS和HTTP的区别主要如下：</p>
<ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li><p>http的连接很简单，<strong>是无状态的</strong>；HTTPS协议是由SSL+HTTP协议构建的<strong>可进行加密传输、身份认证的网络协议</strong>，比http协议安全。</p>
</li>
<li><p>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
</li>
</ol>
<h1 id="URL的形式"><a href="#URL的形式" class="headerlink" title="URL的形式"></a>URL的形式</h1><ul>
<li>定义</li>
</ul>
<p>URL(Uniform Resource Locator,统一资源定位符)，定义资源在网上唯一的地址。</p>
<ul>
<li>组成部分</li>
</ul>
<p>URL由三部分组成：资源类型、存放资源的主机域名、资源文件名</p>
<blockquote>
<p>protocol :// hostname[:port] / path / [;parameters][?query]#fragment</p>
</blockquote>
<ul>
<li>protocol(协议):</li>
</ul>
<p>file 资源是本地计算机上的文件。格式file:///，注意后边应是三个斜杠。</p>
<p>ftp 通过 FTP访问资源。格式 FTP://</p>
<p>http 通过 HTTP 访问该资源。 格式 </p>
<p>HTTP:// https 通过安全的 HTTPS 访问该资源。 格式 HTTPS://</p>
<p>mailto 资源为电子邮件地址，通过 SMTP 访问。 格式 mailto:</p>
<ul>
<li>hostname(主机名)</li>
</ul>
<p>是指存放资源的服务器的域名系统(DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式: username:password@hostname）。</p>
<ul>
<li>Path(路径)</li>
</ul>
<p>由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。parameters（参数）</p>
<ul>
<li>query（查询）</li>
</ul>
<p>可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">//变量url即具有了url模块所提供的方法</span><br><span class="line">var url = require(<span class="string">'url'</span>);</span><br><span class="line">var queryUrl = <span class="string">"http://localhost:8888/bb?name=bigbear&amp;memo-helloworld"</span>;</span><br><span class="line">console.log(typeof url.parse(queryUrl));</span><br><span class="line">console.log(url.parse(queryUrl));</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">object</span></span><br><span class="line">Url {</span><br><span class="line">  protocol: <span class="string">'http:'</span>,</span><br><span class="line">  slashes: true,</span><br><span class="line">  auth: null,</span><br><span class="line">  host: <span class="string">'localhost:8888'</span>,</span><br><span class="line">  port: <span class="string">'8888'</span>,</span><br><span class="line">  hostname: <span class="string">'localhost'</span>,</span><br><span class="line">  <span class="built_in">hash</span>: null,</span><br><span class="line">  search: <span class="string">'?name=bigbear&amp;memo-helloworld'</span>,</span><br><span class="line">  query: <span class="string">'name=bigbear&amp;memo-helloworld'</span>,</span><br><span class="line">  pathname: <span class="string">'/bb'</span>,</span><br><span class="line">  path: <span class="string">'/bb?name=bigbear&amp;memo-helloworld'</span>,</span><br><span class="line">  href: <span class="string">'http://localhost:8888/bb?name=bigbear&amp;memo-helloworld'</span> }</span><br></pre></td></tr></tbody></table></figure>
<h1 id="urllib和urllib2的区别"><a href="#urllib和urllib2的区别" class="headerlink" title="urllib和urllib2的区别"></a>urllib和urllib2的区别</h1><p>这个面试官确实问过,当时答的<strong>urllib2可以Post而urllib不可以</strong>.</p>
<ol>
<li>urllib提供<strong>urlencode</strong>方法用来<strong>GET查询字符串的产生</strong>，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li>
<li>urllib2可以接受一个<strong>Request类的实例来设置URL请求的headers，urllib仅可以接受URL</strong>。<strong>这意味着，你不可以伪装你的用户代理字符串等</strong>。</li>
</ol>
<h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><p><strong>地址解析协议(Address Resolution Protocol)</strong>，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，<strong>以保证通信的顺利进行</strong>。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被<strong>邻居发现协议（NDP）所替代</strong>（Neighbor Discovery Protocol）。</p>
<h1 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Cookie</th>
<th style="text-align:left">Session</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">储存位置</td>
<td style="text-align:left">客户端</td>
<td style="text-align:left">服务器端</td>
</tr>
<tr>
<td style="text-align:left">目的</td>
<td style="text-align:left">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td>
<td style="text-align:left">跟踪会话</td>
</tr>
<tr>
<td style="text-align:left">安全性</td>
<td style="text-align:left">不安全</td>
<td style="text-align:left">安全</td>
</tr>
</tbody>
</table>
</div>
<p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p>
<p>但是禁用Cookie就不能得到Session。因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于SessionID,也就得不到Session。</p>
<h1 id="apache和nginx的区别（Web服务器）"><a href="#apache和nginx的区别（Web服务器）" class="headerlink" title="apache和nginx的区别（Web服务器）"></a>apache和nginx的区别（Web服务器）</h1><p>nginx 相对 apache 的优点：</p>
<ul>
<li><strong>轻量级</strong>，同样起web 服务，比apache 占用更少的内存及资源</li>
<li><strong>抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接</strong>，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能</li>
<li><strong>配置简洁</strong></li>
<li>高度模块化的设计，编写模块相对简单</li>
<li>社区活跃</li>
</ul>
<p>apache 相对nginx 的优点：</p>
<ul>
<li><p><strong>rewrite ，比nginx 的rewrite 强大</strong></p>
</li>
<li><p><strong>模块超多</strong>，基本想到的都可以找到</p>
</li>
<li><p><strong>少bug</strong> ，nginx 的bug 相对较多</p>
</li>
<li><p><strong>超稳定</strong></p>
</li>
</ul>
<h1 id="网站用户密码保存"><a href="#网站用户密码保存" class="headerlink" title="网站用户密码保存"></a>网站用户密码保存</h1><ol>
<li><strong>明文保存</strong>在数据库中</li>
<li><strong>明文hash后保存,如MD5</strong></li>
<li><strong>MD5+Salt方式,这个Salt可以随机</strong></li>
<li>知乎使用了Bcrypy(好像)加密</li>
</ol>
<h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><p>推荐: <a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p>
<p>304 Not Modified</p>
<p>浏览器缓存机制，其实<strong>主要就是HTTP协议定义的缓存机制</strong>（如：Expires；Cache-control等）</p>
<p>但是也有非HTTP协议定义的缓存机制。</p>
<p><strong>一、非HTTP协议定义的缓存机制</strong></p>
 <figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">"Pragma"</span> <span class="attr">CONTENT</span>=<span class="string">"no-cache"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有<strong>缓存代理服务器都不支持，因为代理不解析HTML内容本身。</strong></p>
<p><strong>二、HTTP协议定义的缓存机制</strong></p>
<ol>
<li><p>Expires策略:  是Web服务器响应消息头字段，在响应http请求时告诉<strong>浏览器在过期时间前</strong>浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.41.48.png" alt="Screen Shot 2020-11-08 at 15.41.48"></p>
</li>
<li><p>Cache-control策略:Cache-Control与Expires的作用一致，都是指明当前资源的<strong>有效期</strong>，控制浏览器<strong>是否直接从浏览器缓存取数据还是重新发请求到服务器取数据</strong>。只不过Cache-Control的<strong>选择更多，设置更细致</strong>，如果同时设置的话，其<strong>优先级高于</strong>Expires。</p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.42.01.png" alt="Screen Shot 2020-11-08 at 15.42.01"></p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.42.14.png" alt="Screen Shot 2020-11-08 at 15.42.14"></p>
</li>
</ol>
<h1 id="CSRF和XSS"><a href="#CSRF和XSS" class="headerlink" title="CSRF和XSS"></a>CSRF和XSS</h1><ul>
<li><strong>CSRF(Cross-site request forgery)跨站请求伪造</strong>：<strong>网站过分信任用户</strong>，放任来自所谓通过<strong>访问控制机制</strong>的代表合法用户的请求执行网站的某个特定功能。（利用cookies进行CSRF攻击）</li>
<li><strong>XSS(Cross Site Scripting)跨站脚本攻击：用户过分信任网站</strong>，放任来自来自浏览器地址代表的那个网站代码在自己本地任意执行。如果没有浏览器的安全机制限制，XSS代码可以在用户浏览器为所欲为。</li>
</ul>
<p>CSRF重点在<strong>请求</strong>,XSS重点在<strong>脚本</strong></p>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p><strong>RPC（Remote Procedure Call Protocol）——远程过程调用协议</strong>。</p>
<p>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。<strong>RPC是一个分布式计算的CS模式，总是由Client向Server发出一个执行若干过程请求，Server接受请求，使用客户端提供的参数，计算完成之后将结果返回给客户端。</strong></p>
<p><strong>RPC是面向过程，Restful是面向资源</strong>，并且使用了Http动词。从这个维度上看，Restful风格的url在表述的精简性、可读性上都要更好。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># RPC风格</span></span><br><span class="line">/queryOrder?orderId=123</span><br><span class="line"></span><br><span class="line"><span class="comment"># Restful风格</span></span><br><span class="line">Get  </span><br><span class="line">/order/<span class="number">123</span></span><br></pre></td></tr></tbody></table></figure>
<p>RPC原理：</p>
<p>比如 A (client) 调用 B (server) 提供的<code>remoteAdd</code>方法：</p>
<ol>
<li>首先A与B之间建立一个TCP连接；</li>
<li>然后A把需要调用的方法名（这里是remoteAdd）以及方法参数（10， 20）<strong>序列化成字节流发送出去；</strong></li>
<li>B接受A发送过来的字节流，然后<strong>反序列化得到目标方法名，方法参数</strong>，接着执行相应的方法调用（可能是localAdd）并把结果30返回；</li>
<li>A接受远程调用结果,输出30。</li>
</ol>
<p><strong>进化的顺序: RPC -&gt; SOAP -&gt; RESTful</strong></p>
<h1 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h1><ol>
<li>SOAP（原为<strong>Simple Object Access Protocol</strong>的首字母缩写，即<strong>简单对象访问协议</strong>）是交换数据的一种协议规范，<strong>使用在计算机网络Web服务（web service）中</strong>，交换带结构信息。</li>
<li>SOAP为了简化<strong>网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间</strong>。不同应用程序之间按照<strong>HTTP通信协议，遵从XML格式执行资料互换</strong>，使其抽象于语言实现、平台和硬件。</li>
</ol>
<h1 id="RESTful架构-SOAP-RPC"><a href="#RESTful架构-SOAP-RPC" class="headerlink" title="RESTful架构(SOAP,RPC)"></a>RESTful架构(SOAP,RPC)</h1><p>推荐: <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>
<p>Representational State Transfer：表现层状态转移</p>
<p>RESTful架构，<strong>就是目前最流行的一种互联网软件架构</strong>。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p>
<p>总结一下什么是RESTful架构：</p>
<p>（1）<strong>每一个URI代表一种资源；</strong></p>
<p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p>
<p>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”<strong>表现层状态转化</strong>“。</p>
<h1 id="CGI和WSGI"><a href="#CGI和WSGI" class="headerlink" title="CGI和WSGI"></a>CGI和WSGI</h1><ul>
<li><p>CGI(Common Gateway Interface)是<strong>通用网关接口</strong>，是连接web服务器和应用程序的接口，用户通过CGI来获取<strong>动态数据或文件</strong>等。<br>CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。</p>
</li>
<li><p>WSGI(Web Server Gateway Interface)<strong>Web服务器网关接口</strong>，是<strong>Python应用程序或框架和Web服务器</strong>之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p>
<p>它不是服务器,也不是python模块,<strong>它是一种规范,描述Web服务器和应用之间的交互</strong>.通俗来讲, 它就是一条纽带,连接着Web服务器和应用。</p>
</li>
</ul>
<p>官方说明：<a href="https://www.python.org/dev/peps/pep-3333/">PEP-3333</a></p>
<h1 id="简述浏览器通过WSGI请求动态资源的过程"><a href="#简述浏览器通过WSGI请求动态资源的过程" class="headerlink" title="简述浏览器通过WSGI请求动态资源的过程"></a>简述浏览器通过WSGI请求动态资源的过程</h1><ul>
<li>静态服务器加载的是一个静态html页面，或是存在服务器中的静态数据。</li>
<li><p>动态服务器是，当客户端发送一个请求，<strong>服务器拿到这个请求找到相关的程序代码执行，将执行结果返回给客户端的一个过程</strong></p>
</li>
<li><p>WSGI</p>
<p>怎么在你刚刚建立的web服务器上运行一个Django应用和一个Flask应用呢。如何做不做任何改变而适应不同的web架构呢：WSGI</p>
</li>
</ul>
<ol>
<li>浏览器发送http请求动态资源给web服务器（flask）</li>
<li>web服务器收到请求后<strong>通过WSGI调用一个属性给应用程序框架</strong></li>
<li>应用程序框架通过引用WSGI调用Web服务器，<strong>设置返回的状态和头信息</strong></li>
<li>调用后返回，此时Web服务器保存了刚刚设置的信息</li>
<li><strong>应用程序查询数据库，生成动态页面的body信息</strong></li>
<li><strong>把生成的body信息返回给Web服务器</strong></li>
<li>Web服务器把数据返回给浏览器</li>
</ol>
<p><img data-src="/images/data/截屏2020-11-17 16.52.08.png" alt="截屏2020-11-17 16.52.08"></p>
<h1 id="WSGI与Flask之间的关系"><a href="#WSGI与Flask之间的关系" class="headerlink" title="WSGI与Flask之间的关系"></a>WSGI与Flask之间的关系</h1><ol>
<li>使用<code>app.run()</code>方法来启动flask应用（<code>app.run()</code>代码隐藏着创建一个服务器），<strong>app应用本身会作为参数传递到WSGI服务器中</strong>。</li>
<li>在客户端（这里就是浏览器）输入网址（发送一个请求），服务器使用WSGI 中间件来处理这个请求。</li>
<li>WSGI 处理请求对应着<code>wsgi_app(self, environ, start_response)</code>方法，<code>self</code>参数对应着<code>app</code>，即flask程序；<code>environ</code>和 <code>start_response</code>由服务器提供。</li>
<li><code>wsgi_app()</code>作用就是调用各种请求处理函数来处理请求，然后返回处理结果。即用户输入网址后，看到了网页响应。</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)  </span><br><span class="line"><span class="comment">#生成app实例，传递 __name__参数，__name__ 就是当前模块名字。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">"/"</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"2017-08-21"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://blog.csdn.net/sinat_36651044/article/details/77462831">https://blog.csdn.net/sinat_36651044/article/details/77462831</a></p>
<h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p>在<strong>GFW(Great Firewall: 中国国家防火墙)</strong>里屡见不鲜的,呵呵.</p>
<p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指<strong>攻击者与通讯的两端分别创建独立的联系</strong>，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p>
<h1 id="c10k问题"><a href="#c10k问题" class="headerlink" title="c10k问题"></a>c10k问题</h1><p>所谓<strong>c10k</strong>问题，指的是<strong>服务器同时支持成千上万个客户端</strong>的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。</p>
<p>解决方法：</p>
<ol>
<li><strong>每个连接分配一个独立的线程/进程</strong>：该思路最为直接，但是申请进程/线程是需要系统资源的，且系统需要管理这些进程/线程，所以<strong>会使资源占用过多，可扩展性差</strong></li>
<li><strong>同一个线程/进程同时处理多个连接（I/O多路复用）</strong>：select方式、poll方式、epoll方式、异步I/O以及Windows</li>
</ol>
<p><a href="https://my.oschina.net/xianggao/blog/664275">https://my.oschina.net/xianggao/blog/664275</a></p>
<p><a href="https://www.jianshu.com/p/ba7fa25d3590">C10K问题及其解决方法</a></p>
<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>AJAX(Asynchronous JavaScript and XML)（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与<strong>服务器交换数据并更新部分网页的技术</strong>。</p>
<h1 id="描述用浏览器访问www-baidu-com的过程"><a href="#描述用浏览器访问www-baidu-com的过程" class="headerlink" title="描述用浏览器访问www.baidu.com的过程"></a>描述用浏览器访问www.baidu.com的过程</h1><ol>
<li>浏览器获取用户输入的域名：www.baidu.com</li>
<li><p>浏览器<strong>向域名解析器DNS获取www.baidu.com的IP地址</strong></p>
</li>
<li><p>DNS解析出IP地址</p>
</li>
<li>浏览器与服务器<strong>建立TCP连接</strong>（默认端口号80）</li>
<li><p><strong>浏览器发出HTTP请求</strong>，请求百度页面</p>
</li>
<li><p><strong>服务器通过HTTP响应</strong>把首页内容发送给浏览器</p>
</li>
<li><p>TCP连接释放</p>
</li>
<li><strong>浏览器解析首页文件</strong>，并将WEB页面显示给用户</li>
</ol>
<h1 id="简述QQ登陆过程"><a href="#简述QQ登陆过程" class="headerlink" title="简述QQ登陆过程"></a>简述QQ登陆过程</h1><p>qq登录，在我们的项目中分为了三个接口</p>
<ul>
<li><p>第一个接口是请求qq服务器返回一个qq登录的界面;</p>
</li>
<li><p>第二个接口是通过扫码或账号登陆进行验证，qq服务器返回给浏览器一个code和state, 利用这个code通过<strong>本地服务器去向qq服务器获取access_token</strong>，凭借access_token再向qq服务器获取用户的openid(openid用户的唯一标识)</p>
</li>
<li><p>第三个接口是判断用户是否是第一次qq登录，如果不是的话直接登录返回的jwt-token给用户，对没有绑定过本网站的用户，对openid进行加密生成token进行绑定</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Computer Network</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试基础</title>
    <url>/posts/22398/</url>
    <content><![CDATA[<h1 id="软件测试理论"><a href="#软件测试理论" class="headerlink" title="软件测试理论"></a>软件测试理论</h1><h2 id="软件测试的生命周期"><a href="#软件测试的生命周期" class="headerlink" title="软件测试的生命周期"></a>软件测试的生命周期</h2><p>软件测试生命周期是指从项目计划建立到BUG提交的整个测试过程，包括：</p>
<ol>
<li>软件项目测试计划</li>
<li>测试需求分析</li>
<li>测试用例设计</li>
<li>测试用例执行</li>
<li>BUG提交</li>
</ol>
<a id="more"></a>
<h2 id="软件的三个要素是什么"><a href="#软件的三个要素是什么" class="headerlink" title="软件的三个要素是什么"></a>软件的三个要素是什么</h2><p>程序+数据+文档</p>
<h2 id="软件的产品质量"><a href="#软件的产品质量" class="headerlink" title="软件的产品质量"></a>软件的产品质量</h2><p>参考质量模型部分</p>
<h2 id="软件测试的目的"><a href="#软件测试的目的" class="headerlink" title="软件测试的目的"></a>软件测试的目的</h2><ol>
<li>验证软件是否满足软件开发合同或者项目<strong>开发计划，软件需求规格说明书，软件产品说明</strong>等规定的软件质量要求</li>
<li>通过测试，发现软件中迄今为止尚未发现的缺陷</li>
<li>为软件产品的质量测量和评价提供依据</li>
</ol>
<h2 id="软件测试过程中的四个基本活动"><a href="#软件测试过程中的四个基本活动" class="headerlink" title="软件测试过程中的四个基本活动"></a>软件测试过程中的四个基本活动</h2><ol>
<li><strong>测试策划</strong>：进行测试的需求分析和测试计划的编写</li>
<li><strong>测试设计</strong>：依据测试需求，分析并选用已有的测试用例或者设计新的测试用例，进行用例评审</li>
<li><strong>测试执行</strong>：执行测试用例，获取测试结果，分析并判定测试结果</li>
<li><strong>测试总结</strong>：整理和分析测试数据，描述测试状态，最后完成软件测试报告并通过测试评审</li>
</ol>
<h2 id="测试用例设计的基本原则"><a href="#测试用例设计的基本原则" class="headerlink" title="测试用例设计的基本原则"></a>测试用例设计的基本原则</h2><p>case的设计应该符合以下几点：</p>
<ol>
<li>一个case一个功能点：每个case都要有个测点，找准一个测点即可，不能同时覆盖很多功能点</li>
<li>case的执行粒度：粒度越小越好</li>
<li>步骤清晰：一个case多个步骤，指明怎么去操作</li>
<li>总体设计：先正常，后异常，这样可以确保正常情况下功能能够走通</li>
</ol>
<h1 id="测试的分类"><a href="#测试的分类" class="headerlink" title="测试的分类"></a>测试的分类</h1><ul>
<li>按开发阶段划分<ul>
<li>单元测试：基于软件设计文档</li>
<li>集成测试：基于软件结构设计文档</li>
<li>系统测试：基于用户需求</li>
<li>验收测试：基于软件研制合同</li>
</ul>
</li>
<li>按是否查看代码分类<ul>
<li>黑盒测试：功能测试</li>
<li>白盒测试：基于程序的测试</li>
<li>灰盒测试：黑盒 + 白盒</li>
</ul>
</li>
<li>按是否运行划分<ul>
<li>静态测试：不执行被测软件，也可以用静态分析测试工具来进行（代码扫描）。</li>
<li>动态测试：执行被测试程序。通过执行结果，分析软件可能出现的错误。执行测试用例等。</li>
</ul>
</li>
<li>按测试对象划分<ul>
<li>性能测试</li>
<li>安全测试</li>
<li>兼容性测试</li>
<li>文档测试</li>
<li>用户体验测试</li>
<li>业务测试</li>
<li>界面测试</li>
<li>安装测试</li>
<li>内存泄漏测试</li>
</ul>
</li>
<li>按测试实施的组织<ul>
<li>$\alpha$测试：初期测试，软件完成后，由<strong>程序员</strong>来测试执行查看软件功能性是否正常</li>
<li>$\beta$测试：验收测试，交给<strong>最终的用户</strong>来测试其功能性</li>
<li>第三方测试：介于开发者和用户之间，由第三方组织来进行</li>
</ul>
</li>
<li>按是否手工执行划分<ul>
<li>手工测试</li>
<li>自动化测试</li>
</ul>
</li>
<li>其他分类<ul>
<li>冒烟测试：针对不同的版本，每次需求变更之后，<strong>在正式测试之前</strong>，对产品或者系统进行一次<strong>简单的验证测试 — 自测</strong></li>
<li>回归测试：修改代码之后，需要测试下是否引起了其他的一些问题</li>
<li>A/B测试：AB测试是为<a href="https://baike.baidu.com/item/Web/150564">Web</a>或<a href="https://baike.baidu.com/item/App/6133292">App</a>界面或流程制作两个（A/B）或多个（A/B/n）版本，在同一<a href="https://baike.baidu.com/item/时间维度/6762941">时间维度</a>，分别让<strong>组成成分相同（相似）的访客群组</strong>（目标人群）<strong>随机的访问这些版本</strong>，收集各群组的用户体验数据和业务数据，最后分析、评估出最好版本，正式采用。</li>
</ul>
</li>
</ul>
<h1 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h1><p><strong>黑盒测试：功能测试</strong>，数据驱动测试或者基于规格说明书的测试。这种测试<strong>不必了解程序的内部逻辑结构</strong>，而是<strong>根据需求说明书中的功能来设计测试用例。</strong>具体方法分为：等价类划分法、边界值分析法、判定表法、因果图法、错误推测法</p>
<h2 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h2><ol>
<li>定义：等价类划分是在分析需求规格说明的基础上，把<strong>程序的输入域划分成若干个部分，然后在每部分选取代表性的数据形成测试用例</strong></li>
<li>等价类划分法的步骤如下：<ol>
<li><strong>划分有效等价类</strong>：对规格说明是有意义的、合理的输入数据所构成的集合。利用有效等价类可以检验程序是否满足规格说明所规定的<strong>功能和性能</strong>。</li>
<li><strong>划分无效等价类</strong>：不合理的输入数据所构成的集合。使用无效等价类可以<strong>测试程序/系统的容错性</strong>—对异常输入情况的处理。</li>
</ol>
</li>
</ol>
<h2 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h2><ol>
<li>定义：边界值分析法是针对边界值进行测试的，使用等于、大于或者小于边界值的数据对程序进行测试的方法</li>
<li>边界值分析法的步骤：<ol>
<li>通过分析规格说明书找出所有可能的边界条件</li>
<li>对每个边界条件给出满足和不满足的输入数据</li>
<li>设计相应的测试用例</li>
</ol>
</li>
</ol>
<h2 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h2><h1 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h1><p><strong>白盒测试：又称为结构测试</strong>、逻辑驱动测试或者基于程序的测试。这种测试应该了解软件程序的内部构造，并且根据程序的内部结构来设计测试用例。<strong>白盒测试是基于覆盖的测试，尽可能覆盖程序的结构特征和逻辑路径。</strong>其具体方法有逻辑覆盖、循环覆盖、基本路径覆盖。逻辑覆盖又可分为语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖。</p>
<p><a href="https://www.cnblogs.com/keaihaizi/p/11523683.html">https://www.cnblogs.com/keaihaizi/p/11523683.html</a></p>
<h2 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h2><h3 id="语句覆盖"><a href="#语句覆盖" class="headerlink" title="语句覆盖"></a>语句覆盖</h3><p>每条语句至少执行一次</p>
<h3 id="判定覆盖"><a href="#判定覆盖" class="headerlink" title="判定覆盖"></a>判定覆盖</h3><p>分支执行一次</p>
<h3 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h3><p>每个条件取到<strong>各种可能的值</strong></p>
<p>A=T 　　　　A=F<br>B=T 　　　　B=F</p>
<h3 id="条件组合覆盖"><a href="#条件组合覆盖" class="headerlink" title="条件组合覆盖"></a>条件组合覆盖</h3><p>每个判断语句中条件结果的所有可能组合至少出现一次</p>
<p>A= T　　　 B= T<br>A= T 　　　B= F<br>A= F　　　 B= T<br>A= F 　　　B= F </p>
<h2 id="循环覆盖"><a href="#循环覆盖" class="headerlink" title="循环覆盖"></a>循环覆盖</h2><h2 id="基本路径覆盖"><a href="#基本路径覆盖" class="headerlink" title="基本路径覆盖"></a>基本路径覆盖</h2><p>设计出的测试用例要保证在测试中程序的语句覆盖100%，条件覆盖100%。条件组合未必能覆盖到。</p>
<h1 id="静态测试、动态测试"><a href="#静态测试、动态测试" class="headerlink" title="静态测试、动态测试"></a>静态测试、动态测试</h1><ol>
<li>静态测试：又称为静态分析结束，其基本特征是不执行被测软件，根据检查列表，<strong>对需求分析说明书、软件设计说明书以及源程序做结构检查、流程图分析等找出软件错误</strong>。静态测试一般采用人工分析（针对文档），也可以用静态分析测试工具来进行（代码扫描）。</li>
<li>动态测试：其基本特征是执行被测试程序。通过执行结果，分析软件可能出现的错误 ，一般由人工设计程序测试用例，也可以由测试工具做检查和分析。</li>
</ol>
<h1 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h1><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><p>ANSI/IEEE 定义软件质量为：“与软件产品满足规定的和隐含的需求的能力有关的特征或特性的全体”。</p>
<h2 id="ISO-IEC-9126质量模型"><a href="#ISO-IEC-9126质量模型" class="headerlink" title="ISO/IEC 9126质量模型"></a>ISO/IEC 9126质量模型</h2><p>测试是对软件质量的度量，那么如何度量，从哪些角度度量。</p>
<p>我们需要一套标准，或者说模型来作参考，赋予不同指标不同的权重，通过计算软件质量的得分，便可以评判出质量的好坏。</p>
<p>ISO/IEC 9126在1991年12月发布，将软件质量归为6大特性和27个子特性。</p>
<p><img data-src="/images/data/Screen Shot 2020-11-10 at 11.44.26.png" alt="Screen Shot 2020-11-10 at 11.44.26"></p>
<p>功能性：软件产品提供满足明确和隐含需求功能的能力</p>
<ul>
<li>适合性：为规定任务提供一组合适功能的功能，即做了该做的事</li>
<li>准确性：得到正确或相符的预期结果的能力</li>
<li>互操作性：与其他系统软件交互的能力</li>
<li>保密安全性：防止对程序及数据的非授权的故意或意外访问的能力</li>
</ul>
<p>可靠性：软件产品维护规定的性能级别的能力</p>
<ul>
<li>成熟性：避免软件内部的错误扩散而导致系统失效的能力</li>
<li>容错性：防止外部接口错误扩散而导致系统失效的能力</li>
<li>易恢复性：系统失效后，重新恢复原有的功能和性能的能力</li>
</ul>
<p>易用性：软件产品被理解、学习、使用及吸引用户的能力</p>
<ul>
<li>易理解性：交互性要清晰、准确和易懂</li>
<li>易学性：用户学习软件所花努力的属性</li>
<li>易操作性：用户操作和控制软件的能力</li>
<li>吸引性：吸引用户的能力</li>
</ul>
<p><strong>性能效率</strong>：相对于所用资源的数量，软件产品可提供适当性能的能力</p>
<ul>
<li><strong>时间特性</strong>：软件执行功能时的响应、处理时间和吞吐率</li>
<li><strong>资源特性</strong>：软件执行功能时所使用的资源数量和类型</li>
</ul>
<p>维护性：软件产品可以被修改的能力，修改可能包括修改、改进或者适应环境、需求和功能规约的变化</p>
<ul>
<li>易分析性：诊断缺陷或失效原因所需努力的属性</li>
<li>易改变性：进行修改、排除错误或适应环境变化的能力</li>
<li>稳定性：避免软件修改而造成意外结果的能力</li>
<li>易测试性：提供辅助性手段帮助测试人员实现其测试意图</li>
</ul>
<p>可移植性：软件产品从一个环境迁移到另一个环境的能力</p>
<ul>
<li>适应性：无需相应变动就能适应不同环境的能力</li>
<li>易安装性：尽可能少的提供选择，方便用户直接安装</li>
<li>共存性：与其他公共软件共存</li>
<li>易替换性：同等环境下，替换其他同类产品的能力</li>
</ul>
<h2 id="GB-T-25000质量模型"><a href="#GB-T-25000质量模型" class="headerlink" title="GB/T 25000质量模型"></a>GB/T 25000质量模型</h2><p>于2016年发布，(新增兼容性和信息安全)，大方向没有改变，新增的2大特性（信息安全性、兼容性）也是从原有的功能性和可移植性中分裂出来。</p>
<p><img data-src="/images/data/Screen Shot 2020-11-10 at 11.54.54.png" alt="Screen Shot 2020-11-10 at 11.54.54"></p>
<p>信息安全性，产品或系统保护信息和数据的程序，以使用户、其他产品或系统具有与其授权和授权级别一致的数据访问度</p>
<ul>
<li>保密性，产品或系统确保数据只有在被授权时才能被访问的程度</li>
<li>完整性，系统、产品或组件防止未授权访问、篡改计算机程序或数据的程度</li>
<li>抗抵赖性，活动或事件发生后可以被证实且不可被否认的程度</li>
<li>可核查性，实体的活动可以被唯一地追溯到该实体的程度</li>
<li>真实性，对象或资源的身份标识能够被证实符合其声明的程度</li>
</ul>
<p><a href="https://juejin.im/post/6844903878354272269">从纺锤模型到金字塔模型</a></p>
<h1 id="软件开发中之敏捷开发：DevOps"><a href="#软件开发中之敏捷开发：DevOps" class="headerlink" title="软件开发中之敏捷开发：DevOps"></a>软件开发中之敏捷开发：DevOps</h1><p>DevOps是一套实践方法论和文化，提倡打破原有组织和限制，职能团队开始拥抱和接受<strong>DevOps所倡导的高度协同，研发、测试、运维及交付一体化的思维</strong>。随着DevOps和敏捷热度的不断提升，无论是互联网企业还是传统软件企业都开始拥抱<strong>敏捷</strong>，实践DevOps。<strong>持续集成CI（Continuous integration）、持续交付CD（Continuous delivery ）</strong>作为DevOps的最佳实践，越来越受到重视。</p>
<h1 id="软件开发中之微服务架构"><a href="#软件开发中之微服务架构" class="headerlink" title="软件开发中之微服务架构"></a>软件开发中之微服务架构</h1><p>微服务架构源起于DevOps意识形态和实践中，是一种软件架构风格。微服务架构带来了一系列好处，例如<strong>可部署性、可靠性、可用性</strong>等等。虽然原则上可以使用任何架构来实践DevOps，但微服务架构<strong>正在成为构建持续部署 (CD)</strong>系统的标准<strong>架构风格</strong>。由于<strong>每项服务的规模都很小</strong>，它允许通过<strong>连续重构来实现单个服务</strong>的体系结构，因此<strong>减少了对大型项目前期设计的需求，允许尽早发布软件并且持续交付</strong>。微服务和DevOps是天然的共同体，结合起来共同实现软件开发行业的变革。</p>
<h1 id="分层理论：金字塔模型"><a href="#分层理论：金字塔模型" class="headerlink" title="分层理论：金字塔模型"></a>分层理论：金字塔模型</h1><p>随着敏捷和微服务架构的引入，<strong>CI/CD成为构建和部署的标准</strong>。传统的手工测试方式在人员和效率上都存在严重不足，因此自动化测试已经成为现代软件研发过程中一个关键组成部分。<strong>自动化测试是打通持续集成和持续交付的核心</strong>，没有有效的自动化测试保证，持续集成和持续交付就仅仅是一个没有灵魂的躯壳。</p>
<p>Martin Fowler描述<strong>测试金字塔</strong>分为单元、服务和UI三个层级。</p>
<p><strong>1)单元测试</strong></p>
<p>单元测试是针对<strong>代码单元（通常是类/方法）</strong>的测试，单元测试的价值在于能提供最快的反馈，在开发过程中就可以对逻辑单元进行验证。好的单元测试可以帮助改善既有设计，在团队掌握 TDD的前提下，单元测试能辅助重构，帮助提升代码整洁度。</p>
<p><strong>2)接口（服务/API）测试</strong></p>
<p><strong>接口测试是针对业务接口进行的测试</strong>，主要测试内部接口功能实现是否完整。比如内部逻辑是否正常、异常处理是否正确。接口测试的主要价值在于接口定义相对稳定，不像界面或底层代码会经常发生变化，所以接口测试比较容易编写，用例的维护成本也相对较低。在接口层面准备测试的性价比相对较高。</p>
<p><strong>3)集成（UI）测试</strong></p>
<p><strong>集成测试从用户的角度验证产品功能的正确性，测的是端到端的流程</strong>，并且加入用户场景和数据，验证整个过程是否健康流畅。集成测试的业务价值最高，它验证的是一个完整的流程，但因为需要验证完整流程，在环境部署、准备用例及实施等方面成本较高，实施起来并不容易。</p>
<h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><h2 id="自动化测试分层及占比"><a href="#自动化测试分层及占比" class="headerlink" title="自动化测试分层及占比"></a>自动化测试分层及占比</h2><p>先来看一般的功能测试如何进行：设计并编写用例文档，描述测试步骤和预期结果；测试人员根据测试用例描述按步骤操作，然后判断实际结果与预期是否一致。如果一致，测试通过；如果不符，测试失败。</p>
<p><strong>自动化测试要做的事情与功能测试是一致的。分层理论和自动化测试方法结合，出现了三个层面的自动化：单元测试自动化、接口测试自动化和UI测试自动化。</strong>当然，不同层面的自动化关注点是不一样的。所以，从测试的行为本质上来看，功能测试与单元自动化测试、接口自动化测试和UI自动化测试并没有区别。唯一的区别是，一个由人来执行，一个由代码或工具执行。</p>
<ul>
<li>单元自动化测试</li>
</ul>
<p>单元测试关注的是代码的实现与逻辑。单元测试是最基本的测试，也是测试中的最小单元，它的对象是函数对象，也可以包含输入输出，针对的是函数功能或者函数内部的代码逻辑，并不包含业务逻辑。</p>
<p>该类测试一般由研发人员完成，需要借助单元测试框架，如java的Junit、TestNG，python的<strong>unittest</strong>等。</p>
<ul>
<li>接口自动化测试</li>
</ul>
<p>接口自动化测试，主要验证<strong>模块间的调用返回以及不同系统、服务间的数据交换</strong>。</p>
<p>根据接口文档是RESTful还是RPC，最终断言返回的结果是否等于预期结果。如果相等，测试通过；如果不相等，测试失败。</p>
<p>常见的接口测试工具有<strong>postman、jmeter、loadrunner</strong>等。</p>
<ul>
<li>集成自动化测试</li>
</ul>
<p>UI层是用户使用产品的入口，所有功能通过这一层提供给用户。</p>
<p>当UI自动化登录成功后，就去获取这个数据进行断言，断言如果相等，测试通过；如果不相等，测试失败。</p>
<p>所以，UI自动化的关注点用户操作形为，以及UI上各种组件是否可用。常见的测试工具有<strong>UFT、Robot Framework、Selenium、Appium</strong>等。</p>
<p>按照测试金字塔模型以及投入/产出比，我们得知越向下回报率越高，<strong>所以应该使用大量的单元测试和全面的接口测试来覆盖产品提供的基本逻辑和功能，使用少量的集成（UI）测试来进行前端界面的功能验证。</strong></p>
<p>都说业内最佳实践看Google，Google的自动化分层投入占比是：<strong>单元测试（Unit）：占比70%；接口测试（Service）：占比20%；集成测试（UI）：占比10%.</strong></p>
<h2 id="自动化最佳实践：纺锤模型"><a href="#自动化最佳实践：纺锤模型" class="headerlink" title="自动化最佳实践：纺锤模型"></a>自动化最佳实践：纺锤模型</h2><p><strong>对现阶段公司大部分团队来说，更符合实际测试模式是纺锤模型</strong>。新项目中，可能由于时限原因或者开发人员习惯问题，一开始并没有把单元测试准备得很完善；而某些遗留老项目，可能原本就没有多少单元测试。</p>
<p>在上述情况下，一般的做法是先将重心放在中间层的测试上，原因有以下两点：</p>
<ul>
<li>第一，中间层<strong>投入产出比较高</strong>，可以实现较高的自动化率；</li>
<li>第二，可以帮助加强<strong>开发跟测试人员之间的协作</strong>，提高测试质量。这一层需要开发跟测试人员共同定义，因为开发知道内部实现的细节，测试掌握业务场景。</li>
</ul>
<p>当项目进行一段时间以后，各层测试占比有必要向理想型的金字塔型过渡，这时需要关注以下三个方面：</p>
<ul>
<li>开发与测试互相传递能力；</li>
<li>全员关注产品设计跟代码的质量；</li>
<li>让用例逐步下沉，最后逐步过渡到理想型。</li>
</ul>
<p><img data-src="/images/data/Screen Shot 2020-11-10 at 13.09.44.png" alt="Screen Shot 2020-11-10 at 13.09.44"></p>
<h1 id="测试质量评估"><a href="#测试质量评估" class="headerlink" title="测试质量评估"></a>测试质量评估</h1><p>关于度量，不要用单一的指标去评估测试和产品质量，比如用例通过率、代码覆盖率等都无法独立地评估产品质量。</p>
<p>评估测试质量时要关心以下几个方面：</p>
<ul>
<li>第一是<strong>用例比例</strong>，即每一层的用例比例是多少。</li>
<li>第二是<strong>测试覆盖率</strong>。</li>
<li>第三是<strong>测试总运行时间</strong>，因为经过优化以后，总运行时间一定是越来越少。</li>
<li>第四是<strong>代码质量指标，反映代码的质量和整洁度</strong>。</li>
</ul>
<h1 id="Python自动化测试框架"><a href="#Python自动化测试框架" class="headerlink" title="Python自动化测试框架"></a>Python自动化测试框架</h1><ol>
<li><p>python+selenium+unittest+htmltestrunner</p>
</li>
<li><p>python+selenium+pytest+allure</p>
</li>
<li><p>robotframework+Selenium2Library</p>
</li>
</ol>
<h2 id="pytest"><a href="#pytest" class="headerlink" title="pytest"></a>pytest</h2><p>pytest是一个非常成熟的Python测试框架</p>
<ol>
<li>能够支持简单的单元测试和复杂的功能测试，还可以用来做selenium/appnium等自动化测试，接口自动化测试（pytest+request）</li>
<li>pytest具有很多第三方插件，并且可以自定义扩展，常用的插件有：<ol>
<li>pytest-selenium（集成selenium）</li>
<li>pytest-html（完美html测试报告生成）</li>
<li>pytest-rerunfailures（失败case重复执行）</li>
<li>pytest-xdist（多CPU分发）</li>
</ol>
</li>
</ol>
<p><a href="https://www.cnblogs.com/mytianying/p/12466302.html">https://www.cnblogs.com/mytianying/p/12466302.html</a></p>
<h1 id="算法测试"><a href="#算法测试" class="headerlink" title="算法测试"></a>算法测试</h1><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><h3 id="线下评估-—-准确度、查准率、召回率"><a href="#线下评估-—-准确度、查准率、召回率" class="headerlink" title="线下评估 — 准确度、查准率、召回率"></a>线下评估 — 准确度、查准率、召回率</h3><p>数据拆分：训练数据集&amp;测试数据集： 利用训练集训练模型，然后利用模型在测试集上进行测试。</p>
<p>评价分类结果：<strong>混淆矩阵、精准度、精准率、召回率、F1 Score</strong>、ROC曲线、AUC值等</p>
<p>评价回归结果：MES、RMES、MAE、R Squared</p>
<ul>
<li>Precision &amp; Recall</li>
</ul>
<p><strong>混淆矩阵：</strong>对于二分类问题来说，所有的问题被分为0和1两类。</p>
<p><strong>True Positive(TP)</strong>：正实际为正实际为正，预测对了(True)</p>
<p><strong>False Negative(FN)</strong>: 预测为负实际为正，预测错了(False)</p>
<p><strong>False Positive(FP)</strong>: 预测为负实际为正，预测错了(False)</p>
<p><strong>True Negative(TN)</strong>: 预测为负实际为负，预测对了(True)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>真实值正</th>
<th>真实值负</th>
</tr>
</thead>
<tbody>
<tr>
<td>预测值正</td>
<td>TP</td>
<td>FP</td>
</tr>
<tr>
<td>预测值负</td>
<td>FN</td>
<td>TN</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Accuracy指准确度</strong>，意味着系统误差(System Error)小，即偏差(Bias) 小，描述了的实际值与真实结果的偏离程度。</p>
<p>$accuracy = \frac{TP + TN}{TP + FP + FN + TN}$</p>
<blockquote>
<p>如果存在<strong>样本不均衡</strong>的情况下，就不能使用accuracy来进行衡量了。比如，一个总样本中，正样本占90%,负样本占10%，那么只需要将所有样本预测为正，就可以拿到90%的准确率，而这显然是无意义的。正因为如此，我们就需要精准率和召回率了。</p>
</blockquote>
<p><strong>Precision指查准率，即预测为正的样本中，实际为正的比例。</strong></p>
<p>$Precision=\frac{TP}{TP+FP}$</p>
<blockquote>
<p>为什么管它叫精准率呢？在有偏的数据中，我们<strong>通常更关注值为1的特征</strong>，比如“患病”，比如“有风险”。在100次结果为患病的预测，平均有40次预测是对的。即<strong>精准率为我们关注的那个事件，预测的有多准。</strong></p>
<p>医生预测为癌症，患者确实患癌症的比例。</p>
</blockquote>
<p><strong>Recall召回率：所有真实值为正的数据中，预测对了的个数。</strong></p>
<p>$Recall = \frac{TP}{TP + FN}$</p>
<blockquote>
<p><strong>也就是我们关注的那个事件真实的发生情况下，我们成功预测的比例是多少。</strong></p>
<p>至于两个指标如何使用，需要看具体场景，实际上这两个指标是互斥的，一个高，必有另一个低。</p>
</blockquote>
<p><strong>F1 Score: </strong>P为查准率，R为查全率。F1score就是在查准率与查全率之间寻找一个平衡点。</p>
<p>$F1 Score = 2<em>\frac{P </em> R}{P + R}$</p>
<ul>
<li>MAP</li>
</ul>
<p>在目标检测中：</p>
<p><strong>如果IoU&gt; 0.5，则认为它是True Positive，否则认为是False Positive。</strong>而COCO数据集的评估指标建议对不同的IoU阈值进行计算，但为简单起见，我们这里仅讨论一个阈值0.5，这是PASCAL VOC数据集所用的指标。</p>
<p><strong>为了计算Recall，我们需要Negatives的数量</strong>。由于图片中我们没有预测到物体的每个部分都被视为Negative，因此计算True Negatives比较难办。<strong>一般通过改变置信度的值，</strong>阈值<strong>以上的所有预测（Box + Class）都被认为是Positives，并且低于该值的都是Negatives。</strong></p>
<p>PASCAL VOC组织者推荐采用一种可以用于任何模型的评估指标，选择了11个不同的recall，可以认为是选择了11个rank，由于是按照置信度进行排序的，实际上等于选择了11个不同的置信度阈值。AP就定义为在这11个recall下precision的平均值。</p>
<p>代码见：<a href="https://zhuanlan.zhihu.com/p/37910324">https://zhuanlan.zhihu.com/p/37910324</a></p>
<ul>
<li>MES、RMES、MAE</li>
</ul>
<p>MES(Mean Squared Error)均方误差:  $\frac{1}{m} \sum<em>{i=1}^m(y</em>{test}^i - y_{test}^i)^2$</p>
<p>RMES(Root Mean Squared Error)均方根误差: $\sqrt{MES}$</p>
<p>MAE(Mean Absolute Error)平均绝对误差：$\frac{1}{m} \sum<em>{i=1}^m|y</em>{test}^i - y_{test}^i|$</p>
<h3 id="线上评估-—-A-B-testing"><a href="#线上评估-—-A-B-testing" class="headerlink" title="线上评估 — A/B testing"></a>线上评估 — A/B testing</h3><p>A/B testing</p>
<p>AB测试是为<a href="https://baike.baidu.com/item/Web/150564">Web</a>或<a href="https://baike.baidu.com/item/App/6133292">App</a>界面或流程制作两个（A/B）或多个（A/B/n）版本，在同一<a href="https://baike.baidu.com/item/时间维度/6762941">时间维度</a>，分别让<strong>组成成分相同（相似）的访客群组</strong>（目标人群）<strong>随机的访问这些版本</strong>，收集各群组的用户体验数据和业务数据，最后分析、评估出最好版本，正式采用。</p>
<h2 id="算法鲁棒性"><a href="#算法鲁棒性" class="headerlink" title="算法鲁棒性"></a>算法鲁棒性</h2><h2 id="模型安全"><a href="#模型安全" class="headerlink" title="模型安全"></a>模型安全</h2><h2 id="响应速度"><a href="#响应速度" class="headerlink" title="响应速度"></a>响应速度</h2><h1 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h1><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>WEB UI自动化：</td>
<td><strong>selenium</strong>、robotframework</td>
</tr>
<tr>
<td>接口自动化：</td>
<td>Jmeter、<strong>Postman</strong>、soapUI、requests、httprunner</td>
</tr>
<tr>
<td>App自动化：</td>
<td>Appium、Monkey、Monkeyrunner、UIautomation，UIAutomator，Robotium，macaca，airtest</td>
</tr>
<tr>
<td>PC端自动化：</td>
<td>QTP(UFT)</td>
</tr>
<tr>
<td>云测平台</td>
<td>Testin、百度云测</td>
</tr>
<tr>
<td>性能测试：</td>
<td>Jmeter、<strong>LoadRunner</strong></td>
</tr>
<tr>
<td>安全测试：</td>
<td>Appscan</td>
</tr>
<tr>
<td>持续集成：</td>
<td><strong>Jenkins</strong></td>
</tr>
</tbody>
</table>
</div>
<h1 id="测试问题汇总"><a href="#测试问题汇总" class="headerlink" title="测试问题汇总"></a>测试问题汇总</h1><h2 id="编写测试计划的目的是"><a href="#编写测试计划的目的是" class="headerlink" title="编写测试计划的目的是"></a>编写测试计划的目的是</h2><h2 id="对关键词触发模块进行测试"><a href="#对关键词触发模块进行测试" class="headerlink" title="对关键词触发模块进行测试"></a>对关键词触发模块进行测试</h2><h2 id="其他常用笔试题目网址汇总"><a href="#其他常用笔试题目网址汇总" class="headerlink" title="其他常用笔试题目网址汇总"></a>其他常用笔试题目网址汇总</h2><h2 id="测试人员在软件开发过程中的任务是什么"><a href="#测试人员在软件开发过程中的任务是什么" class="headerlink" title="测试人员在软件开发过程中的任务是什么"></a>测试人员在软件开发过程中的任务是什么</h2><h2 id="一条软件Bug记录都包含了哪些内容？"><a href="#一条软件Bug记录都包含了哪些内容？" class="headerlink" title="一条软件Bug记录都包含了哪些内容？"></a>一条软件Bug记录都包含了哪些内容？</h2><h2 id="简述黑盒测试和白盒测试的优缺点"><a href="#简述黑盒测试和白盒测试的优缺点" class="headerlink" title="简述黑盒测试和白盒测试的优缺点"></a>简述黑盒测试和白盒测试的优缺点</h2><h2 id="请列出你所知道的软件测试种类，至少5项"><a href="#请列出你所知道的软件测试种类，至少5项" class="headerlink" title="请列出你所知道的软件测试种类，至少5项"></a>请列出你所知道的软件测试种类，至少5项</h2><h2 id="Alpha测试与Beta测试的区别是什么？"><a href="#Alpha测试与Beta测试的区别是什么？" class="headerlink" title="Alpha测试与Beta测试的区别是什么？"></a>Alpha测试与Beta测试的区别是什么？</h2><h2 id="举例说明什么是Bug？一个bug-report应包含什么关键字？"><a href="#举例说明什么是Bug？一个bug-report应包含什么关键字？" class="headerlink" title="举例说明什么是Bug？一个bug report应包含什么关键字？"></a>举例说明什么是Bug？一个bug report应包含什么关键字？</h2><h2 id="在selenium自动化测试中，你一般完成什么类型的测试？自动化覆盖率？"><a href="#在selenium自动化测试中，你一般完成什么类型的测试？自动化覆盖率？" class="headerlink" title="在selenium自动化测试中，你一般完成什么类型的测试？自动化覆盖率？"></a><strong>在selenium自动化测试中，你一般完成什么类型的测试？自动化覆盖率？</strong></h2><p>主要是冒烟测试和回归测试。回归测试主要写一些功能稳定的场景，通过自动化手段去实现，节约测试时间。因为自动化测试用例也是在不断的更新和迭代，没有刻意去统计，大概在30%-40%左右！</p>
<h2 id="什么是PO模式，为什么要使用它"><a href="#什么是PO模式，为什么要使用它" class="headerlink" title="什么是PO模式，为什么要使用它"></a><strong>什么是PO模式，为什么要使用它</strong></h2><p>PO是Page Object 模式的简称，它是一种设计思想，意思是，把一个页面，当做一个对象，页面的元素和元素之间操作方法就是页面对象的属性和行为，PO模式一般使用三层架构，分别为：基础封装层BasePage，PO页面对象层，TestCase测试用例层。</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Software Test Basic</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN</title>
    <url>/posts/16452/</url>
    <content><![CDATA[<h1 id="Convolutional-Neural-Networks"><a href="#Convolutional-Neural-Networks" class="headerlink" title="Convolutional Neural Networks"></a>Convolutional Neural Networks</h1><h2 id="Edge-Detection"><a href="#Edge-Detection" class="headerlink" title="Edge Detection"></a>Edge Detection</h2><p>卷积运算是卷积神经网络最基本的组成成分，使用边缘检测作为入门样例。下面介绍卷积计算是如何实现的。</p>
<p>使用一个3✖️3的<strong>过滤器(核)</strong>与原始矩阵进行元素相乘，再相加，最后和的结果为<strong>卷积运算</strong>后的第一个元素值，然后依次计算，下面例子中，做一次卷积运算后结果为一个4✖️4的矩阵。</p>
<p>这种卷积运算可以理解成为，<strong>垂直边缘检测器。</strong></p>
<p><img data-src="/images/picturesof-4/CNN_1.png" alt="屏幕快照 2018-02-09 下午12.25.09"></p>
<p>在不同的编程环境中可以使用不同的函数来实现卷积运算。</p>
<p><img data-src="/images/picturesof-4/CNN_2.png" alt="屏幕快照 2018-02-09 下午12.38.47"></p>
<p>那么为什么这个可以用作垂直检测呢？来看下面的例子。</p>
<a id="more"></a>
<p>这是一个简单的6✖️6的图像，图像左边一半是10，右边一半是0，如果你把它看成一个图像，那么是左白右灰的，10代表比较亮的颜色，0代表比较黑的颜色。图片里，有一个特别明显的垂直边缘在图像中间，这条直线是从黑到白的过度线。<strong>所以当你使用一个3✖️3的过滤器进行卷积运算的时候，这个过滤器可视化成下面这个样子</strong>，在左边有明亮的像素，然后有一个过滤段0在中间，右边是黑色的。使用过滤器进行卷积元算，得到的是右边的矩阵，可视化样子如下，在中间有段亮一点的区域，对应检查到这个6✖️6的图像中间的垂直边缘，这里的维数似乎有点不正确，检测到的边缘太粗了，因为这个例子中的图片太小了，如果你用一个1000✖️1000的图像，而不是6✖️6的图像，你会发现，它可以很好的检测出图像中的垂直边缘。在这个例子中，在输出图像中间区域的亮出，表示在图像中间，有一个特别明显的垂直边缘。</p>
<p>从垂直边缘检测中可以得到的启发是，因为我们使用的是3✖️3的矩阵，所以垂直边缘是一个3✖️3的区域，左边是明亮的像素，中间的的并不需要考虑，右边是深色像素。在这个6✖️6图像中，明亮的像素在左边，深色的像素在右边，这样的话就会被视为一个垂直边缘。卷积运算提供了一个方便的方法，来发现图像中的垂直边缘。</p>
<p><img data-src="/images/picturesof-4/CNN_3.png" alt="屏幕快照 2018-02-09 下午1.05.04"></p>
<h2 id="More-Edge-Detection"><a href="#More-Edge-Detection" class="headerlink" title="More Edge Detection"></a>More Edge Detection</h2><p>使用相同的过滤器过滤两个颜色刚好相反的图片，可以看到，第一个是30，第二个是-30，<strong>其中正数(30)代表第一幅图是由亮向暗过度，负数(-30)代表第二张图片是由暗向亮过度。</strong></p>
<p><img data-src="/images/picturesof-4/CNN_4.png" alt="屏幕快照 2018-03-01 上午9.41.33"></p>
<p>有垂直过滤器，就会有水平过滤器。下面举一个更为复杂的例子，在下图的这个图片矩阵中，我们使用水平过滤器进行边缘检测，得到的卷积结果如右下方所示，<strong>用绿色方框圈出的”+30”，代表原始图片中用绿色圈出的3✖️3矩阵的卷积结果，可以看到，这块矩阵的水平边缘确实是由亮到暗过度的，所以卷积结果为正。</strong></p>
<p><img data-src="/images/picturesof-4/CNN_5.png" alt="屏幕快照 2018-03-01 上午9.56.15"></p>
<p>事实上，对于这个3✖️3的滤波器来说，我们只使用了其中一种数字组合，但在历史上的计算机视觉的文献中，曾经公平的争论过，怎样的数字组合才是最好的，所以你还可以使用如下图所示的过滤器，<strong>如Sobel过滤器</strong>，它的优点在于，增加了中间一行元素的权重，也就是处在图像中央的像素点，这使得结果的健壮性更高一些。<strong>Scharr过滤器。</strong></p>
<p>实际上是，当你在做复杂图像的边缘检测时，并不一定要使用刚刚我们提到的9个数字，但是你可以从中学习，把<strong>这矩阵中的9个数字当成9个参数，并且在之后可以使用反向传播算法，学习这9个参数。</strong>得到的结果与原始图片进行卷积，将会得到一个出色的边缘检测结果。</p>
<p>相比这种单纯的垂直边缘与水平边缘检测，它可以检测出45度、70度、73度，甚至是任何角度的边缘。</p>
<p><img data-src="/images/picturesof-4/CNN_6.png" alt="屏幕快照 2018-03-01 上午10.19.16"></p>
<h2 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h2><p>为了构建深度神经网络，你需要学会使用的一个基本的卷积操作就是Padding。Padding出现的原因是，当你在做卷积操作的时候，像素矩阵中，中间的矩阵是被卷积计算多次的，也就是多次使用到了这个矩阵的信息，而边缘的像素矩阵，则会被使用较少次，比如说对角的矩阵，则只是被卷积了一次。这样则会导致会忽略边缘矩阵的信息。<strong>采取的措施是使用“填充(Padding)”方法，进行像素填充。使得边缘像素矩阵信息可以被卷积多次。</strong>填充之后的矩阵再进行卷积操作后，就会得到一个和原始矩阵一样大的矩阵，而不是缩小。</p>
<p>习惯上，你可以使用”0”去填充。</p>
<p><img data-src="/images/picturesof-4/CNN_7.png" alt="屏幕快照 2018-03-01 上午11.25.36"></p>
<p>至于选择填充多少像素，通常有两个选择，<strong>分别叫做Valid卷积和Same卷积。</strong>Valid卷积：意味着不填充，所以得到的输出矩阵会比原始矩阵小。要想和原始矩阵得到的一样大，则使用Same卷积，你可以使用下面的计算公式来计算需要Pad多少个像素。<strong>n是原始图片的维数，f是过滤器的维数，最后得到的输出矩阵大小为n-f+1维。（f通常是奇数，如果为偶数，则会导致左右填充不均匀的情况）</strong></p>
<p><img data-src="/images/picturesof-4/CNN_8.png" alt="屏幕快照 2018-03-01 上午11.59.32"></p>
<h2 id="Strided-Convolutions-卷积步长"><a href="#Strided-Convolutions-卷积步长" class="headerlink" title="Strided Convolutions 卷积步长"></a>Strided Convolutions 卷积步长</h2><p>卷积中的步幅是另一个构建卷积神经网络的基本操作。每次卷积移动步长个单位，而不是我们之前提到的1个步长。这时候，计算输出函数的维数公式变成了如下情况。</p>
<p>如果求得的商不是一个整数怎么办？这里采用向下取整。</p>
<p><img data-src="/images/picturesof-4/CNN_9.png" alt="屏幕快照 2018-03-01 下午1.59.37"></p>
<h2 id="Convolutions-Over-Volume"><a href="#Convolutions-Over-Volume" class="headerlink" title="Convolutions Over Volume"></a>Convolutions Over Volume</h2><p>之前讨论的卷积操作是在二维图像上进行的，现在讨论如何在三维立体(RGB)上做卷积操作。注意，图像的通道数和过滤器的通道数需一致。</p>
<p>和一维图形中类似，使用三层过滤器依次与相对应层级中的元素相乘，每层得到9个数字，3层就是27个数字，将这27个数字相加后，就可以得到输出矩阵中的每个元素值。</p>
<p><img data-src="/images/picturesof-4/CNN_10.png" alt="屏幕快照 2018-03-01 下午2.30.40"></p>
<h2 id="One-Layer-of-a-Convolutional-Network-单层卷积网络"><a href="#One-Layer-of-a-Convolutional-Network-单层卷积网络" class="headerlink" title="One Layer of a Convolutional Network 单层卷积网络"></a>One Layer of a Convolutional Network 单层卷积网络</h2><p>下图演示了利用两个过滤器将6✖️6✖️3的矩阵转化为4✖️4✖️2的矩阵的过程，这个4✖️4✖️2的矩阵就是卷积中的一层结果。利用n个过滤器来提取特征，如垂直边缘，水平边缘或者其他特征。</p>
<p><img data-src="/images/picturesof-4/CNN_11.png" alt="屏幕快照 2018-03-01 下午3.38.38"></p>
<p>对于一些标识及每层的数量，总结如下：</p>
<p><img data-src="/images/picturesof-4/CNN_12.png" alt="屏幕快照 2018-03-01 下午4.16.42"></p>
<h2 id="Simple-Convolutional-Network-Example"><a href="#Simple-Convolutional-Network-Example" class="headerlink" title="Simple Convolutional Network Example"></a>Simple Convolutional Network Example</h2><p>下图是模拟一个卷积神经网络的计算过程。最后我们得到一个7✖️7✖️40的矩阵，也就是1960个元素值，将这1960个元素展开，使用逻辑回归或者SoftMax，进行图片的分类判断。</p>
<p>可以看到，高度和宽度会在某一时间段内保持一致，然后随着网络深度的加深而逐渐减少，而信道数量在增加。</p>
<p><img data-src="/images/picturesof-4/CNN_13.png" alt="屏幕快照 2018-03-01 下午4.50.51"></p>
<p>典型的神经网络通常由三层组成，第一个是卷积层(convolution Layer)，第二个是池化层(Pooling Layer)，最后一个是全连接层(Fully Connect Layer)。虽然仅用卷积层也有可能构建出很好的神经网络，但大部分神经网络架构师依然会添加池化层和全连接层。</p>
<p><img data-src="/images/picturesof-4/CNN_14.png" alt="屏幕快照 2018-03-01 下午5.06.05"></p>
<h2 id="Pooling-Layers"><a href="#Pooling-Layers" class="headerlink" title="Pooling Layers"></a>Pooling Layers</h2><p>除了卷积层，卷积网络也经常使用池化层，来缩减模型的大小，提高计算速度，同时提高所提取特征的健壮性。</p>
<p>所谓<strong>最大池化层</strong>，即将原始矩阵分成四个区域，输出的每个元素都是其对应颜色区域中的最大元素值。</p>
<p>最大化操作的功能就是只要在任何一个象限内提取到某个特征，他都会保留在最大池化的输出里。最大化运算的实际作用就是，如果在过滤器中提取到某个特征，那么保留其最大值。必须承认，人们使用最大池化的主要原因是，此法在很多实验中，效果都很好。<strong>其中有一个有意思的特点就是，它有一组超级参数，但是并没有参数需要学习，一旦确定了f和s，它就是一个固定运算。</strong></p>
<p><img data-src="/images/picturesof-4/CNN_15.png" alt="屏幕快照 2018-03-01 下午6.00.49"></p>
<p>下图是最大池化的演示。</p>
<p><img data-src="/images/picturesof-4/CNN_16.png" alt="屏幕快照 2018-03-01 下午6.02.50"></p>
<p>另外还有一种类型的池化，—<strong>平均池化</strong>，它不太常用。这种运算顾名思义，选取的不是每个过滤器的最大值，而是平均值。当建立一个深度很深的神经网络时，你可以利用平均池化来分解规模为7✖️7✖️1000的网络的表示层。但是在神经网络中，最大池化比平均池化用的更多。</p>
<p><img data-src="/images/picturesof-4/CNN_17.png" alt="屏幕快照 2018-03-01 下午6.18.08"></p>
<p>总结一下，池化的超级参数包括过滤器大小f和步长s。常用的参数值为f=2，s=2，或者f=3，s=3。你也可以根据自己的意愿来决定是否使用padding，<strong>但是在最大池化操作中，很少使用padding。</strong></p>
<p><strong>最大池化只是计算神经网络某一层的静态属性，它的超参是不需要学习的。</strong></p>
<p><img data-src="/images/picturesof-4/CNN_18.png" alt="屏幕快照 2018-03-01 下午6.25.52"></p>
<h2 id="CNN-Example"><a href="#CNN-Example" class="headerlink" title="CNN Example"></a>CNN Example</h2><p> 我们将卷积层和池化层有时会合并起来看作神经网络中的某一层，因为池化层是不需要权重的，它只有超参数。通过卷积和池化，我们得到一个5✖️5✖️16(=400)的矩阵，现在将POOL2平整化为一个大小为400的一维向量。然后利用这400个单元构建下一层，下一层含有120个单元，<strong>这就是我们第一个全连接层，这400个单元与120个单元紧密相连。它很像一个单神经网络层，这是一个标准的神经网络。</strong>它在120✖️400的维度上具有一个权重矩阵W，这就是全连接层。</p>
<p>然后我们对这120个单元再添加一个全连接层，这层更小，假设有84个单元。最后，用这84个单元填充一个SoftMax单元，如果你想识别0～9的数字，那么这个SoftMax输出层则会有10个输出。</p>
<p>在对于超级参数的选择问题上，建议不要自己凭空设定，而是查看文献中别人采取了哪些超级参数，选一个在别人任务重，效果很好的架构。</p>
<p><img data-src="/images/picturesof-4/CNN_19.png" alt="屏幕快照 2018-03-02 上午10.58.49"></p>
<p>还有一种在CNN中，另一种常见的模式是，一个或者多个卷积层后跟随一个池化层，然后是几个全连接层，最后是SoftMax层。从下面的表格中可以看出，第一，池化层和最大池化层没有参数。第二，卷积层的参数相对来说比较少。其实许多参数都存在于CNN中的全连接层。观察可发现，随着神经网络的加深，激活值会逐渐变小，如果激活值下降过快，也会影响网络性能。</p>
<p><strong>（parameters208来源：第一个卷积层中，过滤器维度为5✖️5，每个过滤器有1个bias，一共有8个过滤器，即5✖️5 + 1 ✖️ 8 = 208，所以第一层的weights是208）</strong></p>
<p><img data-src="/images/picturesof-4/CNN_20.png" alt="屏幕快照 2018-03-02 上午11.17.15"></p>
<h2 id="Why-Convolutions"><a href="#Why-Convolutions" class="headerlink" title="Why Convolutions?"></a>Why Convolutions?</h2><p>与传统的神经网络相比，CNN的主要两个优势在于：<strong>参数共享、稀疏连接</strong></p>
<p>参数共享：通过观察发现，特征检测如垂直边缘检测如果适用于图片的某个区域，那么它可能适用于图片的其他区域。<strong>也就是说，如果你用一个3✖️3的过滤器检测垂直边缘，那么图片的左上角区域以及旁边的各个区域都可以使用这个3✖️3的过滤器。每个特征检测器及输出都可以在输入图片的的不同区域中使用相同的参数。以便提取垂直边缘或者其他特征。</strong>它不仅适用于边缘特征这样的低阶特征，同样适用于高阶特征，例如提取脸上的眼睛，猫或者其他特征对象。</p>
<p>神经网络可以通过这两种机制减少参数，以便于我们用更小的训练集来训练它， 从而预防过度拟合。</p>
<p><img data-src="/images/picturesof-4/CNN_21.png" alt="屏幕快照 2018-03-02 下午12.04.13"></p>
<p>计算损失，使用优化算法来优化权重。</p>
<p><img data-src="/images/picturesof-4/CNN_22.png" alt="屏幕快照 2018-03-02 下午12.11.50"></p>
<h1 id="Case-studies"><a href="#Case-studies" class="headerlink" title="Case studies"></a>Case studies</h1><h2 id="Classic-Networks-经典网络"><a href="#Classic-Networks-经典网络" class="headerlink" title="Classic Networks 经典网络"></a>Classic Networks 经典网络</h2><p>下面是一些经典的网络。</p>
<p><img data-src="/images/picturesof-4/CNN_23.png" alt="屏幕快照 2018-03-07 上午10.41.57"></p>
<p><img data-src="/images/picturesof-4/CNN_24.png" alt="屏幕快照 2018-03-07 上午10.56.07"></p>
<p><img data-src="/images/picturesof-4/CNN_25.png" alt="屏幕快照 2018-03-07 上午11.02.34"></p>
<p><img data-src="/images/picturesof-4/CNN_26.png" alt="屏幕快照 2018-03-07 上午11.09.52"></p>
<h2 id="ResNets-残差网络"><a href="#ResNets-残差网络" class="headerlink" title="ResNets 残差网络"></a>ResNets 残差网络</h2><p>非常非常深的网络是很难被训练的，因为存在<strong>梯度消失</strong>和<strong>梯度爆炸</strong>的问题。下面要提到的是<strong>跳远连接</strong>(Skip Connection)，它可以从某一网络层获取激活，然后迅速反应给另外一层，甚至是神经网络的更深层。我们可以利用Skip Connection构建能够训练深度网络的ResNets，有时深度能够超过100层。</p>
<p><strong>ResNets是由残差块构建的。</strong>下面解释什么是残差块(Residual Block)。</p>
<p>在一般的神经网络系统中，激活层a[l]通常经过线性化处理，非线性化处理，再线性化处理，再非线性化，最后得到输出层a[l+2]。这被称作“主路径”(Main Path)</p>
<p><img data-src="/images/picturesof-4/CNN_27.png" alt="屏幕快照 2018-03-07 下午4.25.01"></p>
<p><strong>在ResNets中，有一点变化，我们将a[l]直接向后拷贝到神经网络的深层。</strong>在Relu非线性激活前加上a[l]，这是一条捷径(Shortcut)。也就是a[l]不再沿着主路径进行传递。这样一来a[l+2]变成了如下所示的样子，也就是加上的这个a[l]产生了一个残差块。所以a[l]插入的时机是在线性激活之后，Relu激活之前。</p>
<p><img data-src="/images/picturesof-4/CNN_28.png" alt="屏幕快照 2018-03-07 下午4.45.08"></p>
<p>除了<strong>捷径(ShortCut)</strong>，你可能还会听到另一个术语<strong>跳远连接(Skip Connection)</strong>，就是指a[l]跳过一层甚至是好几层，从而将消息传递到神经网络的更深层。</p>
<p>使用残差块能够训练更深的神经网络，所以构建一个ResNet网络就是通过将很多这样的残差块堆砌在一起，形成一个深度神经网络。</p>
<p>将一个普通的神经网络(PlainNetWork)编程一个残差网络(ResNets)的方法就是添加很多残差块，如下图所示。有5个残差块。如果我们使用标准优化算法训练一个普通网络，比如梯度下降或者其他热门的优化算法，如果没有多余的残差，没有这些捷径或者跳远连接，你会发现，随着网络深度的加深，训练错误会先减少，然后增多，而理论上，应该是随着网络深度的加深，错误应该越少越好。<strong>但事实上，对于一个普通网络来说，深度越深意味着用优化算法越难训练，训练错误就会越来越多，但是有了ResNet就不一样了。</strong>即使网络再深，训练的表现却不错，比如说错误会减少，甚至在100层，1000层的网络中也不例外。这种方式确实能有效的解决梯度消失和梯度爆炸的问题。让我们在训练更深的网络的同时，又能保证好的性能。</p>
<p><img data-src="/images/picturesof-4/CNN_29.png" alt="屏幕快照 2018-03-07 下午4.59.04"></p>
<p><img data-src="/images/picturesof-4/CNN_30.png" alt="屏幕快照 2018-03-07 下午6.31.41"></p>
<h2 id="1x1-Convolutions-1✖️1卷积"><a href="#1x1-Convolutions-1✖️1卷积" class="headerlink" title="1x1 Convolutions 1✖️1卷积"></a>1x1 Convolutions 1✖️1卷积</h2><p>使用1✖️1卷积可以根据自己的意愿来压缩或者保持、甚至增加输入层中信道的数量。</p>
<p><img data-src="/images/picturesof-4/CNN_31.png" alt="屏幕快照 2018-03-07 下午6.58.29"></p>
<p>上图中输入层中是28✖️28✖️192的维度，如果我们想要达到降维的效果，可以利用32个1✖️1的filter，因为过滤器的信道数量必须和输出层中的信道数量保持一致，所以每个filter中都有192个信道，每个过滤器进行一次卷积操作，再相加，最后生成一个28✖️28✖️32的输出层，达到了降维的效果。同样，想要达到增加或者保持维度的效果，使用1✖️1的卷积也是可以的。</p>
<p>下面介绍1✖️1卷积是如何运用到Inception网络中的。</p>
<h2 id="Inception-Network-Motivation-Inception网络"><a href="#Inception-Network-Motivation-Inception网络" class="headerlink" title="Inception Network Motivation Inception网络"></a>Inception Network Motivation Inception网络</h2><p>在做卷积网络时，你需要<strong>为过滤器的大小做决定，而Inception网络的作用就是它会自动为你做抉择</strong>，虽然网络架构因此会变得更加复杂，但网络表现却非常好。</p>
<p><strong>Inception网络不需要人为决定使用哪个过滤器，</strong>或是否需要池化，而是由网络自行确定这些参数，你可以给网络添加这些参数的所有可能值，然后把这些输出连接起来，让网络自己学习它需要什么样的参数，采用哪些过滤器组合。</p>
<p>如下图所示，输入层是一个28✖️28✖️192的矩阵，首先使用一个1✖️1的filter，输出一个28✖️28✖️64的矩阵，得到下图中的绿色块结果，以此类推，将filter的结果全部拼凑在一起，形成一个28✖️28✖️256的输出。</p>
<p><img data-src="/images/picturesof-4/CNN_32.png" alt="屏幕快照 2018-03-07 下午7.42.53"></p>
<p><strong>使用1✖️1卷积可以减少运算复杂度。</strong></p>
<p>如下，不使用1✖️1卷积计算次数为1.2亿次。</p>
<p><img data-src="/images/picturesof-4/CNN_33.png" alt="屏幕快照 2018-03-07 下午8.06.29"></p>
<p>使用1✖️1卷积，计算次数相较减少了10倍的计算量。<img data-src="/images/picturesof-4/CNN_34.png" alt="屏幕快照 2018-03-07 下午8.06.09"></p>
<p>将以上综合起来，构建自己的Inception网络。</p>
<p><img data-src="/images/picturesof-4/CNN_35.png" alt="屏幕快照 2018-03-07 下午8.36.19"></p>
<h1 id="Detection-algorithms"><a href="#Detection-algorithms" class="headerlink" title="Detection algorithms"></a>Detection algorithms</h1><h2 id="Object-Localization-对象定位"><a href="#Object-Localization-对象定位" class="headerlink" title="Object Localization 对象定位"></a>Object Localization 对象定位</h2><p><img data-src="/images/picturesof-4/CNN_36.png" alt="屏幕快照 2018-03-09 上午9.35.21"></p>
<p>首先先谈目标分类和目标定位问题。对于图片中可能的输出进行一个分类，这是分类问题，那么如何对图片中的目标物体进行定位呢？对于这个问题，<strong>我们将神经网络的输出增加一个目标标签y，用来表示目标物体的位置信息。</strong>如下所示，bx表示目标物体的中心的横坐标，by表示目标物体中心的纵坐标，bh表示目标物体的高度，bw表示物体的宽度。当然，这四个数据你在训练集中就应该构建好。<img data-src="/images/picturesof-4/CNN_37.png" alt="屏幕快照 2018-03-09 上午9.40.53"></p>
<p>那么如何表示<strong>输出呢？它是一个向量</strong>，第一个组件Pc表示是否含有对象，所以如果对象属于前3类，Pc值应该为1，<strong>也可以将Pc理解成被检测对象属于某一分类的概率。</strong>如果检测到了对象，就应该将它的位置信息也一并输出，也就是bx,by,bh,bw，还应该同时输出c1,c2,c3用来表示对象属于哪个类别。</p>
<p><img data-src="/images/picturesof-4/CNN_38.png" alt="屏幕快照 2018-03-09 上午9.59.35"></p>
<p>下面来讨论损失函数的定义。两种情况，如果检测到了物体，也就是Pc==1，那么将剩下元素做差平方相加，计算损失，如果没有检测到也就是Pc==0，那么我们只用检测第一个元素值，也就是Pc值即可。</p>
<p><img data-src="/images/picturesof-4/CNN_39.png" alt="屏幕快照 2018-03-09 上午10.02.14"></p>
<h2 id="Convolutional-Implementation-of-Sliding-Windows-卷积的滑动窗口实现"><a href="#Convolutional-Implementation-of-Sliding-Windows-卷积的滑动窗口实现" class="headerlink" title="Convolutional Implementation of Sliding Windows 卷积的滑动窗口实现"></a>Convolutional Implementation of Sliding Windows 卷积的滑动窗口实现</h2><p>如何通过卷积网络进行对象检测 —— 采用<strong>基于滑动窗口</strong>的目标检测算法。</p>
<p><img data-src="/images/picturesof-4/CNN_40.png" alt="屏幕快照 2018-03-12 上午10.06.06"></p>
<p>滑动窗口的过程在于，首先选取一个合适的窗口大小，将依据这个窗口对要预测的图片进行剪裁，将结果输入CNN，由CNN来预测窗口里是否含有目标物体。然后窗口向一个方向移动相应的步幅，由CNN再进行预测。</p>
<p><img data-src="/images/picturesof-4/CNN_41.png" alt="屏幕快照 2018-03-12 上午10.22.13"></p>
<p>滑动窗口算法带来的问题是，<strong>计算成本</strong>。如果你的窗口面积过小，那么将要多次对CNN进行输入操作，计算成本高。但是如果你将窗口调整的过大，则会带来粗粒度影响性能的问题。</p>
<p>幸运的是，上述过程所造成的计算成本问题已经得到了良好的解决。</p>
<p>为了构建滑动窗口的卷积运用，首先要知道如何把<strong>神经网络的全连接层转化为卷积层</strong>。我们<strong>使用一定大小的过滤器</strong>来将输出结果与传统意义上的全连接层输出结果保持一致。</p>
<p><img data-src="/images/picturesof-4/CNN_42.png" alt="屏幕快照 2018-03-12 上午10.40.46"></p>
<p>其次要解决的是，<strong>如何通过卷积来实现滑动窗口对象检测算法</strong>。可以看到，如果我们的输入图片从训练的14✖️14变成了16✖️16，我们在过滤器不变的情况下，对于最后这个4✖️4的输出矩阵可以理解为，左上角对应图片左上角的输出结果，右上角对应原始图片右上角的输出结果。以此类推。<strong>所以该卷积操作的原理是，我们不需要将输入图片分成四个子集，分别执行前向传播，而是把它们作为一张图片输入给卷积网络进行计算，一次得到所有的预测值。</strong>其中的公有区域可以共享很多计算。</p>
<p><img data-src="/images/picturesof-4/CNN_43.png" alt="屏幕快照 2018-03-12 上午11.16.05"></p>
<p>改进的方法大大提高了运算成本，但是也有一个缺点，就是<strong>边界框的位置不够准确</strong>。下面介绍如何解决这个问题。</p>
<h2 id="Bounding-Box-Predictions-预测边界-—-YOLO算法"><a href="#Bounding-Box-Predictions-预测边界-—-YOLO算法" class="headerlink" title="Bounding Box Predictions 预测边界 — YOLO算法"></a>Bounding Box Predictions 预测边界 — YOLO算法</h2><p>This algorithm “only looks once” at the image in the sense that it requires only one forward propagation pass through the network to make predictions. After non-max suppression, it then outputs recognized objects together with the bounding boxes.</p>
<p>如下图所示，当你在使用窗口检测目标物体时，如果窗口在移动过程中不能完全覆盖目标物体，那么怎样才能确定精准的边界框呢？</p>
<p><img data-src="/images/picturesof-4/CNN_44.png" alt="屏幕快照 2018-03-12 下午1.52.28"></p>
<p><strong>其中一个能得到更精准边界框的算法是，YOLO算法。</strong>YOLO的意思是“你只看一次”。是这么做的，比如你输入的图像是100✖️100的，然后在图像上放一个网格，将图像分类和定位算法分别应用到每个网格上，也就是有多个输出向量y，y的定义和之前一样。假如一个物体同时出现在了两个网格上，<strong>那么取物体的中心点，中心点在哪个网格上，那么物体就属于哪个网格。</strong></p>
<p><img data-src="/images/picturesof-4/CNN_45.png" alt="屏幕快照 2018-03-12 下午2.27.45"></p>
<p>再次说明一下，这个方法只对一个网格中出现一个物体的情况有效。对于出现多个物体的情况，稍后做详细的讨论。</p>
<p><img data-src="/images/picturesof-4/CNN_46.png" alt="屏幕快照 2018-03-12 下午2.34.49"></p>
<h2 id="Intersection-Over-Union-交并比函数"><a href="#Intersection-Over-Union-交并比函数" class="headerlink" title="Intersection Over Union 交并比函数"></a>Intersection Over Union 交并比函数</h2><p><strong>交并比函数可以用来评价对象检测算法。</strong>如果你希望定位到的对象是红色部分，但是你的算法却给出的是紫色部分，那么这个结果是好是坏呢？交并比的意思就是，<strong>计算两个边框交集和并集的比值(lOU)来检测结果的好坏。</strong>一般情况下，我们将lOU的阈值定义为0.5，并认为大于0.5就是一个可以接受的结果，当然你也可以定义更高。</p>
<p><img data-src="/images/picturesof-4/CNN_47.png" alt="屏幕快照 2018-03-12 下午3.11.02"></p>
<h2 id="Non-max-Suppression-非极大值抑制—检测YOLO算法"><a href="#Non-max-Suppression-非极大值抑制—检测YOLO算法" class="headerlink" title="Non-max Suppression 非极大值抑制—检测YOLO算法"></a>Non-max Suppression 非极大值抑制—检测YOLO算法</h2><p>到目前为止对象检测算法中的问题是，算法可能对同一个对象做出多次检测，所以算法不是对某一个对象检测出一次，而是检测出多次，<strong>非极大抑制这个方法可以确保你的算法对某个对象只检测出一次。</strong></p>
<p>假设下图是你需要进行检测的图片，将它用19✖️19的网格覆盖，每个车只有一个中点，也就是对于一辆覆盖到多个网格中的车来说，应该只有一个网格，也就是中点所在的网格的预测结果是1。</p>
<p>因为你要在所有网络上都跑一遍图像检测和定位算法，那么覆盖到车子的格子中输出y的PC的值都会是1，而不是所有格子中，只有两个格子会报告检测出了对象。所以最后可能会对一个对象做出多次检测。所以非最大抑制做的就是清理这些检测结果。所以每辆车只检测一次，而不是多次。当你检测出了多次时，<strong>选出输出概率最大的检测结果，对lOU值很高的其他边框进行抑制，这就是非最大值抑制的含义。</strong></p>
<p><img data-src="/images/picturesof-4/CNN_48.png" alt="屏幕快照 2018-03-12 下午3.50.54"></p>
<p>下面是Non-max Suppression算法的具体过程。</p>
<p><img data-src="/images/picturesof-4/CNN_49.png" alt="屏幕快照 2018-03-12 下午4.05.23"></p>
<h2 id="Anchor-Boxes"><a href="#Anchor-Boxes" class="headerlink" title="Anchor Boxes"></a>Anchor Boxes</h2><p><strong>如果你需要让一个格子能够检测出多个对象，那么就需要用到Anchor Boxes。</strong>如下图所示，如果你要检测的对象是人和车辆，这张图中这两者有同样一个中点，如果我们使用传统的y向量输出，会发现这两者的概率是一样的，那么我们必须从这两者中选择出一个作为结果，这是不合理的。Anchor Boxes的思路是这样的，预先定义两个不同形状的Anchor Boxes，把预测结果和这两个Anchor Boxes关联起来。</p>
<p><img data-src="/images/picturesof-4/CNN_50.png" alt="屏幕快照 2018-03-12 下午4.19.47"></p>
<p>总结一下，用Anchor Boxes之前，你做的是，对于训练图像中的每个对象，都根据那个对象中点的位置，将对象分配到某个格子中，然后输出一个3✖️3✖️8的向量，3✖️3是因为你用到9个网格，8是每个网格中的y输出(PC,bx,by,bw,bh,c1,c2,c3)。现在用到Anchor Boxes这个概念，现在每个对象都和之前一样分配到某个格子中（中点所在），但是它还分配到一个和对象形状交并比最高的Anchor Box中。所以现在的输出变成了3✖️3✖️16。</p>
<p><img data-src="/images/picturesof-4/CNN_51.png" alt="屏幕快照 2018-03-12 下午4.32.57"></p>
<p>下面举一个具体的例子。</p>
<p><img data-src="/images/picturesof-4/CNN_52.png" alt="屏幕快照 2018-03-12 下午4.40.30"></p>
<h2 id="YOLO-Algorithm"><a href="#YOLO-Algorithm" class="headerlink" title="YOLO Algorithm"></a>YOLO Algorithm</h2><p>我们将之前提到的所有组件组合在一起，<strong>构成YOLO对象检测算法</strong>。</p>
<p>y向量由Anchor Boxes组成，Anchor Boxes就可以看成y向量，下图中我们用到了两个Anchor Boxes，当我们进行检测是，假若检测到了物体，将边框画出后，与两个Anchor Boxes进行对比，发现与第二个Anchor Boxe的IOU值最高，那么车子就和向量的下半部分有关系。因为你将图片分成了9个网格，每个网格的维度是16，所以最后的输出是3✖️3✖️16。</p>
<p><img data-src="/images/picturesof-4/CNN_53.png" alt="屏幕快照 2018-03-12 下午4.53.00"></p>
<p><img data-src="/images/picturesof-4/CNN_54.png" alt="屏幕快照 2018-03-12 下午4.57.19"></p>
<p>最后你要跑一下非最大值抑制，这就是运行非最大值抑制的过程。如果你使用两个Anchor Boxes，那么对于9个格子中的任意一个都会有两个预测的边界框，其中一个的概率PC很低。<img data-src="/images/picturesof-4/CNN_55.png" alt="屏幕快照 2018-03-12 下午5.03.57"></p>
<p>接着你抛弃PC值很低的边界，连神经网络都说，这里可能什么都没有。</p>
<p><img data-src="/images/picturesof-4/CNN_56.png" alt="屏幕快照 2018-03-12 下午5.05.25"></p>
<p>最后，如果你有三个对象检测类别，对于每个类别，单独运行非最大抑制，处理预测结果是那个类别的边界框。</p>
<p><img data-src="/images/picturesof-4/CNN_57.png" alt="屏幕快照 2018-03-12 下午5.08.12"></p>
<h2 id="Region-Proposals-—-RPN网络"><a href="#Region-Proposals-—-RPN网络" class="headerlink" title="Region Proposals — RPN网络"></a>Region Proposals — RPN网络</h2><p>带区域的CNN —  这个算法尝试选出一些区域，在这些区域上运行CNN是有意义的。选出候选区域的方法是运行图像分割算法，先找出可能的多个色块，然后在各个色块上放置边界框。然后在边界框上跑CNN分类算法。这样需要处理的位置可能少得多。<img data-src="/images/picturesof-4/CNN_58.png" alt="屏幕快照 2018-03-12 下午5.24.12"></p>
<p><img data-src="/images/picturesof-4/CNN_59.png" alt="屏幕快照 2018-03-12 下午5.29.09"></p>
<p><strong>Summary:</strong></p>
<p><img data-src="/images/picturesof-4/CNN_60.png" alt="屏幕快照 2018-03-13 上午9.52.04"></p>
<p><img data-src="/images/picturesof-4/CNN_61.png" alt="屏幕快照 2018-03-13 上午9.55.50"></p>
<p><img data-src="/images/picturesof-4/CNN_62.png" alt="屏幕快照 2018-03-13 上午11.44.02"></p>
<h1 id="Face-Recognition"><a href="#Face-Recognition" class="headerlink" title="Face Recognition"></a>Face Recognition</h1><h2 id="Face-verification"><a href="#Face-verification" class="headerlink" title="Face verification"></a>Face verification</h2><p><img data-src="/images/picturesof-4/CNN_63.png" alt="屏幕快照 2018-03-13 下午3.11.41"></p>
<p><img data-src="/images/picturesof-4/CNN_64.png" alt="屏幕快照 2018-03-14 上午10.09.35"></p>
<h2 id="One-Shot-Learning-一次学习"><a href="#One-Shot-Learning-一次学习" class="headerlink" title="One Shot Learning 一次学习"></a>One Shot Learning 一次学习</h2><p>人脸识别所面临的一个挑战，就是你需要解决“一次学习”问题，即只需要单单一张图片，或者单单一个人脸样例，就能识别出一个人。现在的问题是，你的训练集中通常只有指定一个人的一张照片，如果公司新来一个人，难道要放进庞大的CNN体系中重新学习吗？</p>
<p><img data-src="/images/picturesof-4/CNN_65.png" alt="屏幕快照 2018-03-13 下午3.19.48"></p>
<p>所以要让神经网络做到一次学习，应该是学习<strong>“Similarity”函数</strong>。具体的说，你是希望<strong>神经网络能够学习这个用d表示的函数。它以两张照片作为输入，然后输出这两张照片的差异值。</strong></p>
<p><img data-src="/images/picturesof-4/CNN_66.png" alt="屏幕快照 2018-03-13 下午3.48.26"></p>
<h2 id="Siamese-Network-Siamese-网络"><a href="#Siamese-Network-Siamese-网络" class="headerlink" title="Siamese Network Siamese 网络"></a>Siamese Network Siamese 网络</h2><p><strong>实现上述d函数的一个方式就是Siamese 网络。</strong>也就是训练一组参数，使得如果输入的不是一个人的话，它的输出f(x1)会跟其他人的输出结果f(x2)产生差距，这个差距可以用诸如曼哈顿距离来衡量，如果两个输入的输出结果很相近，那么可以认为是同一个人。</p>
<p><img data-src="/images/picturesof-4/CNN_67.png" alt="屏幕快照 2018-03-13 下午4.10.16"></p>
<p><img data-src="/images/picturesof-4/CNN_68.png" alt="屏幕快照 2018-03-13 下午4.10.36"></p>
<h2 id="Triplet-Loss-—-三元组损失函数"><a href="#Triplet-Loss-—-三元组损失函数" class="headerlink" title="Triplet Loss — 三元组损失函数"></a>Triplet Loss — 三元组损失函数</h2><p>想要通过学习神经网络的参数来得到优质的人脸图片编码，方式之一就是使用<strong>三元组损失函数</strong>然后使用梯度下降。</p>
<p><strong>我们希望，相同人的图片的距离可以远远小于不相同的距离。</strong>为了防止无意义的0输出，使用一个间隔参数a。</p>
<p><img data-src="/images/picturesof-4/CNN_69.png" alt="屏幕快照 2018-03-13 下午4.58.36"></p>
<p>三元组损失函数的定义基于三张图片，样本图片A(Anchor)，相同人样本P(Positive)，不同人样本N(Negative)。<img data-src="/images/picturesof-4/CNN_70.png" alt="屏幕快照 2018-03-13 下午5.10.42"></p>
<p>在选择训练集的时候，要尽量避免使用随机的配对方式，因为随机的图片很容易满足损失函数的要求，为了达到更好的效果，<strong>建议使用比较难训练的样本</strong>，“比较难训练”是指A与N的距离，与A与P的距离非常相近。<img data-src="/images/picturesof-4/CNN_71.png" alt="屏幕快照 2018-03-13 下午5.28.22"></p>
<p><img data-src="/images/picturesof-4/CNN_72.png" alt="屏幕快照 2018-03-13 下午5.33.05"></p>
<h2 id="Face-Verification-and-Binary-Classification"><a href="#Face-Verification-and-Binary-Classification" class="headerlink" title="Face Verification and Binary Classification"></a>Face Verification and Binary Classification</h2><p>如何将人脸识别问题化作一个二分类问题？</p>
<p><img data-src="/images/picturesof-4/CNN_73.png" alt="屏幕快照 2018-03-13 下午5.50.23"></p>
<p><img data-src="/images/picturesof-4/CNN_74.png" alt="屏幕快照 2018-03-13 下午5.51.03"></p>
<p><img data-src="/images/picturesof-4/CNN_75.png" alt="屏幕快照 2018-03-14 上午11.12.29"></p>
<h1 id="Neural-Style-Transfer-神经风格迁移"><a href="#Neural-Style-Transfer-神经风格迁移" class="headerlink" title="Neural Style Transfer 神经风格迁移"></a>Neural Style Transfer 神经风格迁移</h1><p><img data-src="/images/picturesof-4/CNN_76.png" alt="屏幕快照 2018-03-13 下午7.02.31"></p>
<h2 id="What-are-deep-ConvNets-learning"><a href="#What-are-deep-ConvNets-learning" class="headerlink" title="What are deep ConvNets learning?"></a>What are deep ConvNets learning?</h2><p><img data-src="/images/picturesof-4/CNN_77.png" alt="屏幕快照 2018-03-13 下午7.09.06"></p>
<p><img data-src="/images/picturesof-4/CNN_78.png" alt="屏幕快照 2018-03-13 下午7.13.39"></p>
<h2 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h2><p>我们<strong>将损失函数定义为“内容损失➕风格损失”</strong>，内容损失是指生成的图片和原图内容的相似性，风格损失是指生成图片和原图风格的相似性。</p>
<p><img data-src="/images/picturesof-4/CNN_79.png" alt="屏幕快照 2018-03-13 下午7.22.05"></p>
<p><img data-src="/images/picturesof-4/CNN_80.png" alt="屏幕快照 2018-03-13 下午7.22.37"></p>
<h2 id="Content-Cost-Function-内容损失函数"><a href="#Content-Cost-Function-内容损失函数" class="headerlink" title="Content Cost Function 内容损失函数"></a>Content Cost Function 内容损失函数</h2><p>内容损失函数定义为某一隐藏层中与既定（如VGG网络）隐藏层激活后的值的相似程度。</p>
<p><img data-src="/images/picturesof-4/CNN_81.png" alt="屏幕快照 2018-03-13 下午7.32.08"></p>
<h2 id="Style-Cost-Function-风格损失函数"><a href="#Style-Cost-Function-风格损失函数" class="headerlink" title="Style Cost Function 风格损失函数"></a>Style Cost Function 风格损失函数</h2><p>风格损失函数定义为某一隐藏层中，通道之间的相关程度。</p>
<p><img data-src="/images/picturesof-4/CNN_82.png" alt="屏幕快照 2018-03-13 下午7.43.28"></p>
<p>这个相关程度可以理解为，比如风格图片是灰色的地方同时又出现了垂直线条。那么输入图片中，某一隐藏层，观察到了灰色和出现了垂直线条的几率，定义为通道之间的相关程度。</p>
<p><img data-src="/images/picturesof-4/CNN_83.png" alt="屏幕快照 2018-03-13 下午7.45.28"></p>
<p>损失函数定义如下：为输入图片与原图片，某一隐藏层，某一通道中激活值的相关性，使用绝对平方值来计算，还乘以了一个归一化常数。<img data-src="/images/picturesof-4/CNN_84.png" alt="屏幕快照 2018-03-13 下午8.00.14"></p>
<p>“内容损失➕风格损失  =  损失函数”</p>
<p><img data-src="/images/picturesof-4/CNN_85.png" alt="屏幕快照 2018-03-13 下午8.03.07"></p>
<p><img data-src="/images/picturesof-4/CNN_86.png" alt="屏幕快照 2018-03-14 上午9.16.13"></p>
<p><img data-src="/images/picturesof-4/CNN_87.png" alt="屏幕快照 2018-03-14 上午9.20.42"></p>
<p><img data-src="/images/picturesof-4/CNN_88.png" alt="屏幕快照 2018-03-14 上午9.40.49"></p>
<h2 id="1D-and-3D-Generalizations-一维到三维推广"><a href="#1D-and-3D-Generalizations-一维到三维推广" class="headerlink" title="1D and 3D Generalizations 一维到三维推广"></a>1D and 3D Generalizations 一维到三维推广</h2><p>许多图片不仅限于二维，有可能是1维或者3维。那么如何进行处理呢？我们一样可以使用卷积操作。<img data-src="/images/picturesof-4/CNN_89.png" alt="屏幕快照 2018-03-13 下午8.28.53"></p>
<p><img data-src="/images/picturesof-4/CNN_90.png" alt="屏幕快照 2018-03-13 下午8.29.33"></p>
]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>数据可视化基础</title>
    <url>/posts/18173/</url>
    <content><![CDATA[<h1 id="生成数据"><a href="#生成数据" class="headerlink" title="生成数据"></a>生成数据</h1><h2 id="安装matplotlib"><a href="#安装matplotlib" class="headerlink" title="安装matplotlib"></a>安装matplotlib</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ pip3 install --user matplotlib</span><br></pre></td></tr></tbody></table></figure>
<h3 id="测试matplotlib"><a href="#测试matplotlib" class="headerlink" title="测试matplotlib"></a>测试matplotlib</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ python3</span><br><span class="line">&gt;&gt; <span class="keyword">import</span> matplotlib</span><br></pre></td></tr></tbody></table></figure>
<p>如果没有出现任何错误消息，就说明你系统安装了matplotlib。</p>
<h3 id="matplotlib画廊"><a href="#matplotlib画廊" class="headerlink" title="matplotlib画廊"></a>matplotlib画廊</h3><p>要查看使用matplotlib可制作的各种图表，请访问<a href="http://matplotlib.org/的示例画廊。单击画廊中的图表，就可查看用于生成图表的代码。">http://matplotlib.org/的示例画廊。单击画廊中的图表，就可查看用于生成图表的代码。</a></p>
<h2 id="绘制简单的折线图plot"><a href="#绘制简单的折线图plot" class="headerlink" title="绘制简单的折线图plot()"></a>绘制简单的折线图plot()</h2><p>我们将使用平方数序列1、4、9、16和25来绘制这个图标。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">squares = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line">plt.plot(squares)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_1.png" alt="2017-09-19.2.15.10"></p>
<p>首先，导入了模块pyplot，并给它指定了别名plt。模块pyplot包含很多用于生成图标的函数。</p>
<p>我们创建了一个列表，在其中存储了前述平方数，再将这个列表传递给函数plot()。</p>
<p>plt.show()打开matplotlib查看器，并显示绘制的图形。</p>
<h3 id="修改标签文字和线条粗细"><a href="#修改标签文字和线条粗细" class="headerlink" title="修改标签文字和线条粗细"></a>修改标签文字和线条粗细</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">squares = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line">plt.plot(squares,linewidth=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图表标题，并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>,labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p>tick_params()设置刻度的样式，其中指定的实参将影响x轴和y轴上的刻度（axis=’both’），并将刻度标记的字号设置为14。</p>
<p><img data-src="/images/Python-base/DataView_2.png" alt="017-09-19.3.16.14"></p>
<h3 id="校正图形"><a href="#校正图形" class="headerlink" title="校正图形"></a>校正图形</h3><p>我们发现没有正确的绘制数据：折线图的终点指出4.0的平方为25！下面来修复这个问题。</p>
<a id="more"></a>
<p>当你向plot()提供一系列数字时，它假设第一个数据点对应的x坐标值为0，但我们的第一个点对应的x值为1。为改变这种默认行为，我们可以给plot()同时提供输入值和输出值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">input_values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">squares = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line">plt.plot(input_values,squares,linewidth=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图表标题，并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>,labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_3.png" alt="屏幕快照 2017-09-19 下午3.30.45"></p>
<h3 id="使用scatter-绘制散点图"><a href="#使用scatter-绘制散点图" class="headerlink" title="使用scatter()绘制散点图"></a>使用scatter()绘制散点图</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.scatter(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_4.png" alt="屏幕快照 2017-09-19 下午3.56.57"></p>
<p>向函数scatter()传递一对x和y坐标，它将在指定位置绘制一个点。</p>
<p>优化此图形：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.scatter(<span class="number">2</span>,<span class="number">4</span>,s=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>,which=<span class="string">'major'</span>,labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p>Scatter()中的实参s设置了绘制图形时使用的点的尺寸。</p>
<p><img data-src="/images/Python-base/DataView_5.png" alt="屏幕快照 2017-09-19 下午4.05.05"></p>
<h3 id="使用scatter-绘制一系列点"><a href="#使用scatter-绘制一系列点" class="headerlink" title="使用scatter()绘制一系列点"></a>使用scatter()绘制一系列点</h3><p>要绘制一系列点，可向scatter()传递两个分别包含x和y的列表。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">y_values = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span><br><span class="line"></span><br><span class="line">plt.scatter(x_values,y_values,s=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>,which=<span class="string">'major'</span>,labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p>将这些列表传递给scatter()时，matplotlib<strong>依次从每个列表中读取一个值来绘制一个点。</strong></p>
<p><img data-src="/images/Python-base/DataView_6.png" alt="屏幕快照 2017-09-19 下午4.17.41"></p>
<h3 id="自动计算数据"><a href="#自动计算数据" class="headerlink" title="自动计算数据"></a>自动计算数据</h3><p>手工计算列表要包含的值可能效率低下，需要绘制的点很多时尤其如此。可以不必手工计算包含点坐标的列表，而让Python循环来替我们完成这种事。下面绘制了1000个点。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_values = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1001</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line"></span><br><span class="line">plt.scatter(x_values,y_values,s=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>,which=<span class="string">'major'</span>,labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置每个坐标轴的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>,<span class="number">1100</span>,<span class="number">0</span>,<span class="number">1100000</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p>函数axis()要求提供四个值：x和y坐标轴的最小最大值。</p>
<p><img data-src="/images/Python-base/DataView_7.png" alt="屏幕快照 2017-09-19 下午4.38.12"></p>
<h3 id="删除数据点的轮廓"><a href="#删除数据点的轮廓" class="headerlink" title="删除数据点的轮廓"></a>删除数据点的轮廓</h3><p>matplotlib允许你给散点图中的各个点指定颜色。默认为蓝色点和黑色轮廓，在散点图不含数据不多时效果很好。但绘制很多点时，黑色轮廓可能会粘连在一起。删除轮廓,传递实参edgecolor。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">plt.scatter(x_values,y_values,edgecolor=<span class="string">'none'</span>,s=<span class="number">40</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="自定义颜色"><a href="#自定义颜色" class="headerlink" title="自定义颜色"></a>自定义颜色</h3><p>修改数据点的颜色，向scatter()传递参数c，如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">plt.scatter(x_values,y_values,c=<span class="string">'red'</span>,edgecolor=<span class="string">'none'</span>,s=<span class="number">40</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>你还可以使用RGB颜色模式自定义颜色。要指定自定义颜色，可传递参数c，并将其设置为一个元组，其中包含三个0～1之间的小数值，它们分别表示红色、绿色和蓝色分量。例如，下面代码将创建一个由淡蓝色点组成的散点图：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">plt.scatter(x_values,y_values,c=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.8</span>),edgecolor=<span class="string">'none'</span>,s=<span class="number">40</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>值越接近0，指定的颜色越深，越接近1，指定的颜色越浅。</p>
<h3 id="使用颜色映射"><a href="#使用颜色映射" class="headerlink" title="使用颜色映射"></a>使用颜色映射</h3><p>颜色映射（colormap）是一系列颜色，它们从起始颜色渐变到结束颜色。在可视化中，颜色映射用于突出数据的规律，例如，你使用颜色深的表示数值大的，浅的表示小的。</p>
<p>模块pyplot内置了一组颜色映射。要使用这些颜色映射，你需要告诉pyplot如何设置数据集中每个点的颜色。下面演示如何根据每个点的y值来设置颜色：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_values = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">1001</span>))</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line"></span><br><span class="line"><span class="comment">#change</span></span><br><span class="line">plt.scatter(x_values,y_values,c=y_values,cmap=plt.cm.Blues,</span><br><span class="line">           edgecolor=<span class="string">'none'</span>,s=<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>,which=<span class="string">'major'</span>,labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置每个坐标轴的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>,<span class="number">1100</span>,<span class="number">0</span>,<span class="number">1100000</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p>我们将参数c设置成了一个y值列表，并使用<strong>参数cmap告诉pyplot使用哪个颜色映射。</strong>将较小的点设置成浅蓝色，较深的点设置成深蓝色。</p>
<p><img data-src="/images/Python-base/DataView_8.png" alt="屏幕快照 2017-09-19 下午4.58.54"></p>
<h3 id="自动保存图表"><a href="#自动保存图表" class="headerlink" title="自动保存图表"></a>自动保存图表</h3><p>让程序自动将图表保存到文件中，可将对plt.show()的调用替换为对plt.savefig()的调用：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">plt.savefig(<span class="string">'squares_plot.png'</span>,bbox_inches=<span class="string">'tight'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>第一个实参指定要以什么样的文件名保存图表，这个文件存储到当前程序所在的目录中。第二个实参指定将图表多余的空白区域裁剪掉。如果要保留图表周围空白的区域，可省略这个实参。</p>
<h3 id="例：画Sigmoid函数图"><a href="#例：画Sigmoid函数图" class="headerlink" title="例：画Sigmoid函数图"></a>例：画Sigmoid函数图</h3><p><a href="https://zhuanlan.zhihu.com/p/40399870">参考链接</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建画布</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line"><span class="comment"># 使用axisartist.Subplot方法创建一个绘图区对象ax</span></span><br><span class="line">ax = axisartist.Subplot(fig, <span class="number">111</span>)</span><br><span class="line"><span class="comment"># 将绘图区对象添加到画布中</span></span><br><span class="line">fig.add_axes(ax)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过set_visible方法设置绘图区所有坐标轴隐藏</span></span><br><span class="line">ax.axis[:].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax.new_floating_axis代表添加新的坐标轴</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>] = ax.new_floating_axis(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 给x坐标轴加上箭头</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axisline_style(<span class="string">"-&gt;"</span>, size=<span class="number">1.0</span>)</span><br><span class="line"><span class="comment"># 添加y坐标轴，且加上箭头</span></span><br><span class="line">ax.axis[<span class="string">"y"</span>] = ax.new_floating_axis(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axisline_style(<span class="string">"-|&gt;"</span>, size=<span class="number">1.0</span>)</span><br><span class="line"><span class="comment"># 设置x、y轴上刻度显示方向</span></span><br><span class="line">ax.axis[<span class="string">"x"</span>].set_axis_direction(<span class="string">"top"</span>)</span><br><span class="line">ax.axis[<span class="string">"y"</span>].set_axis_direction(<span class="string">"right"</span>)</span><br><span class="line"><span class="comment"># 生成x步长为0.1的列表数据</span></span><br><span class="line">x = np.arange(-<span class="number">15</span>, <span class="number">15</span>, <span class="number">0.1</span>)</span><br><span class="line"><span class="comment"># 生成sigmiod形式的y数据</span></span><br><span class="line">y = <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"><span class="comment"># 设置x、y坐标轴的范围</span></span><br><span class="line">plt.xlim(-<span class="number">12</span>, <span class="number">12</span>)</span><br><span class="line">plt.ylim(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">plt.plot(x, y, c=<span class="string">'b'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_Sigmoid.png" alt="DataView_Sigmoid"></p>
<h2 id="随机漫步"><a href="#随机漫步" class="headerlink" title="随机漫步"></a>随机漫步</h2><p>我们使用python来生成随机漫步数据，再使用matplotlib以引人瞩目的方式将这些数据呈现出来。</p>
<p><strong>随机漫步数据</strong>是这样行走得到的路径：每次行走都是完全随机的，没有明确的方向，结果是由一系列随机决策决定的。在自然界、物理学、生物学、化学和经济领域，随机漫步都有其实际用途。例如，漂浮在水面上的花粉因不断受到水分子的挤压而在水面上移动。花粉在水面上的运动轨迹犹如随机漫步。</p>
<h3 id="创建RandomWalk-类"><a href="#创建RandomWalk-类" class="headerlink" title="创建RandomWalk()类"></a>创建RandomWalk()类</h3><p>为模拟随机漫步，我们将创建一个名为RandomWalk的类，它随机的选择前进方向。</p>
<p>这个类需要三个属性，其中一个是存储随机漫步的次数的变量，其他两个是列表，分别存储随机漫步经过的每个点的x和y坐标。包含两个方法：<em>_init()</em>,fill_walk(),其中后者计算随机漫步经过的所有点。</p>
<p>下面是init方法。（random_walk.py）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWalk</span>():</span></span><br><span class="line">    <span class="string">"""一个生成随机漫步数据的类"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,num_points=<span class="number">5000</span></span>):</span></span><br><span class="line">        <span class="string">"""初始化随机漫步的属性"""</span></span><br><span class="line">        self.num_points = num_points</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#所有随机漫步都始于（0，0）</span></span><br><span class="line">        self.x_values = [<span class="number">0</span>]</span><br><span class="line">        self.y_values = [<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>我们将所有的可能都存储在一个列表中，并在每次做决策时都使用choice()来决定使用哪种选择。我们将随机漫步包含的默认点数设置为5000。</p>
<h3 id="选择方向"><a href="#选择方向" class="headerlink" title="选择方向"></a>选择方向</h3><p>使用fill_walk()来生成漫步包含的点，并决定每次漫步的方向。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_walk</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">"""计算随机漫步包含的所有的点"""</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">#不断漫步，直到列表达到指定的长度</span></span><br><span class="line">       <span class="keyword">while</span> <span class="built_in">len</span>(self.x_values) &lt; self.num_points:</span><br><span class="line">            <span class="comment">#决定前进的方向以及沿这个方向前进的距离</span></span><br><span class="line">               x_direction = choice([-<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">               x_distance = choice([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">               x_step = x_direction * x_distance</span><br><span class="line">               </span><br><span class="line">               y_direction = choice([-<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">               y_distance = choice([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">               y_step = y_direction * y_distance</span><br><span class="line">               </span><br><span class="line">               <span class="comment">#拒绝原地踏步</span></span><br><span class="line">               <span class="keyword">if</span> x_step == <span class="number">0</span> <span class="keyword">and</span> y_step == <span class="number">0</span>:</span><br><span class="line">                   <span class="keyword">continue</span></span><br><span class="line">                   </span><br><span class="line">               <span class="comment">#计算下一个点的x和y值</span></span><br><span class="line">               next_x = self.x_values[-<span class="number">1</span>] + x_step</span><br><span class="line">               next_y = self.Y_values[-<span class="number">1</span>] + y_step</span><br><span class="line">               </span><br><span class="line">               self.x_values.append(next_x)</span><br><span class="line">               self.y_values.append(next_y)</span><br></pre></td></tr></tbody></table></figure>
<p> 方法choice([-1,1])将在-1，1表示在两者之间随机选择一个数。choice([0,1,2,3,4])是在这5个数中间随机选择一个数字，之所以包含0是因为可能点要沿垂直的方向行动。x_step与y_step是最终的步长，x_values[-1]，Y_values[-1]取到列表的最后一个元素，它们也用来保存最新行动的点，即append()方法。</p>
<h3 id="绘制随机漫步图"><a href="#绘制随机漫步图" class="headerlink" title="绘制随机漫步图"></a>绘制随机漫步图</h3><p>（rw_visual.py）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 　random_walk <span class="keyword">import</span> RandomWalk</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个RandomWalk实例，并将其包含的点都绘制出来</span></span><br><span class="line">rw = RandomWalk()</span><br><span class="line">rw.fill_walk()</span><br><span class="line">plt.scatter(rw.x_values,rw.y_values,s=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p>创建RandomWalk的实例rw，再调用fill_walk()。然后将实例中产生的x_values和y_values赋值给scatter()函数。</p>
<p>下图是包含5000个点的随机漫步图。</p>
<p><img data-src="/images/Python-base/DataView_9.png" alt="屏幕快照 2017-09-21 上午10.29.43"></p>
<h3 id="设置随机漫步图样式"><a href="#设置随机漫步图样式" class="headerlink" title="设置随机漫步图样式"></a>设置随机漫步图样式</h3><p>我们将定制图表，以突出每次漫步的重要特征，并让分散注意力的元素不那么显眼。最终的结果是简单的可视化表示，清楚地指出了每次漫步经过的路径。</p>
<h3 id="给点着色"><a href="#给点着色" class="headerlink" title="给点着色"></a>给点着色</h3><p>我们使用颜色映射来指出漫步中各点的先后顺序，并删除每个点的黑色轮廓。我们传递参数c，并将其设置为一个列表，其中包含各点的先后顺序。由于这些点是按照顺序绘制的，因此给参数c指定列表只需包含数字1～5000。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">point_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(rw.num_points))</span><br><span class="line">plt.scatter(rw.x_values,rw.y_values,c=point_numbers,cmap=plt.cm.Blues,edgecolor=<span class="string">'none'</span>,s=<span class="number">15</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_10.png" alt="屏幕快照 2017-09-21 上午11.14.58"></p>
<h3 id="重新绘制起点和终点"><a href="#重新绘制起点和终点" class="headerlink" title="重新绘制起点和终点"></a>重新绘制起点和终点</h3><p>除了给随机漫步的各个点着色，以指出它们的先后顺序外，如果还能呈现随机漫步的起点和终点就更好了。为此，可在绘制随机漫步图后重新绘制起点和终点。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#突出起点和终点</span></span><br><span class="line">plt.scatter(<span class="number">0</span>,<span class="number">0</span>,c=<span class="string">'green'</span>,edgecolors=<span class="string">'none'</span>,s=<span class="number">100</span>)</span><br><span class="line">plt.scatter(rw.x_values[-<span class="number">1</span>],rw.y_values[-<span class="number">1</span>],c=<span class="string">'red'</span>,edgecolors=<span class="string">'none'</span>,</span><br><span class="line">            s=<span class="number">100</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_11.png" alt="屏幕快照 2017-09-21 下午12.33.14"></p>
<h3 id="隐藏坐标轴"><a href="#隐藏坐标轴" class="headerlink" title="隐藏坐标轴"></a>隐藏坐标轴</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#隐藏坐标轴</span></span><br><span class="line">plt.axes().get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">plt.axes().get_yaxis().set_visible(<span class="literal">False</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="增加点数"><a href="#增加点数" class="headerlink" title="增加点数"></a>增加点数</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">rw = RandomWalk(<span class="number">50000</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="调整屏幕以适应屏幕"><a href="#调整屏幕以适应屏幕" class="headerlink" title="调整屏幕以适应屏幕"></a>调整屏幕以适应屏幕</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#设置绘图窗口的尺寸</span></span><br><span class="line">plt.figure(dpi=<span class="number">227</span>,figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>函数figure()用于指定图表的宽度、高度、分辨率和背景色。你需要给figsize指定一个元组，单位为英寸。Python假定屏幕的分辨率为80像素／英寸，可利用形参dip向figure()传递该分辨率，有效的利用屏幕空间。</p>
<p><img data-src="/images/Python-base/DataView_12.png" alt="屏幕快照 2017-09-21 下午1.00.20 1"></p>
<h2 id="使用Pygal模拟掷骰子"><a href="#使用Pygal模拟掷骰子" class="headerlink" title="使用Pygal模拟掷骰子"></a>使用Pygal模拟掷骰子</h2><p>我们将使用Python<strong>可视化包Pygal</strong>来生成<strong>可缩放的矢量图形文件</strong>。对于需要在尺寸不同的屏幕上显示的图表，这很有用，它们会自动缩放。如果你打算以在线方式使用图表，请考虑使用Pygal来生成它们，这样它们在任何设备上显示时都会很美观。</p>
<p>如果掷两个骰子，为确定哪些点数出现的可能性最大，我们将生成一个表示掷骰子结果的数据集，并根据结果绘制出一个图形。</p>
<h3 id="安装Pygal"><a href="#安装Pygal" class="headerlink" title="安装Pygal"></a>安装Pygal</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ pip3 install --user pygal==<span class="number">1.7</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="Pygal画廊"><a href="#Pygal画廊" class="headerlink" title="Pygal画廊"></a>Pygal画廊</h3><p>要了解使用Pygal可创建什么样的图表，可查看图表类型画廊， <a href="http://www.pygal.org/,单击Documentation，再单击Chart">http://www.pygal.org/,单击Documentation，再单击Chart</a> types。每个示例都包含源代码。</p>
<h3 id="掷单个骰子"><a href="#掷单个骰子" class="headerlink" title="掷单个骰子"></a>掷单个骰子</h3><ul>
<li><p>创建Die类</p>
<p>下面的类模拟掷一个骰子。die.py</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Die</span>():</span></span><br><span class="line">    <span class="string">"""表示一个骰子的类"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,num_sides=<span class="number">6</span></span>):</span></span><br><span class="line">        <span class="string">"""骰子默认为6面"""</span></span><br><span class="line">        self.num_sides = num_sides</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""返回一个位于1和骰子面数之间的随机值"""</span></span><br><span class="line">        <span class="keyword">return</span> randint(<span class="number">1</span>,self.num_sides)</span><br></pre></td></tr></tbody></table></figure>
<p>创建这个类的实例时，骰子默认面为6，如果指定了参数，这个值将用于设置骰子的面数，6面为D6，8面为D8，以此类推。方法roll()使用<strong>函数randint()</strong>来返回一个1和面数<strong>之间的随机数</strong>。这个函数可能返回起始值1，终止值num_sides或者这两个值之间的<strong>任何整数</strong>。（<strong>choice()返回列表列出的随机数）</strong></p>
</li>
</ul>
<ul>
<li><p>掷骰子</p>
<p>掷D6骰子，将结果打印出来，并检查结果是否合理。die_visual.py</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> die <span class="keyword">import</span> Die</span><br><span class="line"><span class="comment">#创建一个D6</span></span><br><span class="line">die = Die()</span><br><span class="line"></span><br><span class="line"><span class="comment">#掷100次骰子，并将结果存储在一个列表中</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> roll_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    result = die.roll()</span><br><span class="line">    results.append(result)</span><br><span class="line"></span><br><span class="line">print(results)</span><br><span class="line"></span><br><span class="line">[<span class="number">6</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li><p>分析结果</p>
<p>分析掷一个D6骰子的结果，我们计算每个点数出现的次数。<strong>range()为1~num_sides</strong></p>
 <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#分析结果</span></span><br><span class="line">frequencies = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,die.num_sides+<span class="number">1</span>):</span><br><span class="line">    frequency = results.count(value)</span><br><span class="line">    frequencies.append(frequency)</span><br><span class="line"></span><br><span class="line">[<span class="number">14</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">15</span>]</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li><p>绘制直方图</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> die <span class="keyword">import</span> Die</span><br><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="comment">#对结果进行可视化</span></span><br><span class="line">hist = pygal.Bar()</span><br><span class="line"></span><br><span class="line">hist.title = <span class="string">"Results of rolling one D6 100 times."</span></span><br><span class="line">hist.x_labels = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>]</span><br><span class="line">hist.x_title = <span class="string">'Result'</span></span><br><span class="line">hist.y_title = <span class="string">'Frequency of Result'</span></span><br><span class="line"></span><br><span class="line">hist.add(<span class="string">'D6'</span>,frequencies)</span><br><span class="line">hist.render_to_file(<span class="string">'die_visual.svg'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>add()将一系列值添加到图表中（向它传递要给添加的值指定的标签，还有一个列表），最后，我们将这个图表渲染为一个SVG文件，这种文件的扩展名必须为.svg。</p>
<p>要查看生成的直方图，使用浏览器，新建标签页，在其中打开文件die _visual.svg，它位于其所在的文件夹内</p>
</li>
</ul>
<p><img data-src="/images/Python-base/DataView_13.png" alt="屏幕快照 2017-09-21 下午2.24.19"></p>
<h3 id="同时掷两个骰子"><a href="#同时掷两个骰子" class="headerlink" title="同时掷两个骰子"></a>同时掷两个骰子</h3><p>同时掷两个骰子时，得到的点数更多，结果分布也不同。每次掷两个骰子时，我们将两个骰子点数相加，并将结果存在results中。(dice_visual.py)(以下是部分代码，其他自行修改)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> roll_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    result = die_1.roll() + die_2.roll()</span><br><span class="line">    results.append(result)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_14.png" alt="屏幕快照 2017-09-21 下午3.06.28"></p>
<h1 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h1><p>在本章中，将从网上下载数据，并对这些数据进行可视化。两种常见格式存储的数据：<strong>CSV 和 JSON。</strong>我们将使用Python模块csv来处理CSV数据（逗号分隔的值）。然后，使用matplotlib根据下载的数据创建一个图表。这两者我们用来分析天气数据，找出不同地区在同一时间内的最高温和最低温。</p>
<p>使用模块json来访问以JSON格式存储的人口数据，并使用Pygal绘制一幅按国别划分的人口地图。</p>
<h2 id="CSV文件格式"><a href="#CSV文件格式" class="headerlink" title="CSV文件格式"></a>CSV文件格式</h2><p>要在文本文件中存储数据，最简单的方式是将数据作为一系列<strong>以逗号分隔的值（CSV）</strong>写入文件。这样的文件称为CSV文件。例如：下面是一行CSV格式的天气数据：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">2014</span>-<span class="number">1</span>-<span class="number">5</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">6</span>,<span class="number">32</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">30</span>,<span class="number">29</span></span><br></pre></td></tr></tbody></table></figure>
<p>CSV文件对人来说阅读起来比较麻烦，但程序可轻松地提取并处理其中的值，这有助于加快数据分析过程。</p>
<p>将少量锡特卡的CSV格式的天气预报数据（sitka_weather_07-2014.csv）下载到当前文件夹中。</p>
<h3 id="分析CSV文件头"><a href="#分析CSV文件头" class="headerlink" title="分析CSV文件头"></a>分析CSV文件头</h3><p>csv模块包含在Python标准库中，可用于分析CSV文件中的数据行，让我们能快速提取感兴趣的值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = <span class="built_in">next</span>(reader)</span><br><span class="line">    print(header_row)</span><br><span class="line">    </span><br><span class="line">[<span class="string">'AKDT'</span>, <span class="string">'Max TemperatureF'</span>, <span class="string">'Mean TemperatureF'</span>, <span class="string">'Min TemperatureF'</span>, <span class="string">'Max Dew PointF'</span>, <span class="string">'MeanDew PointF'</span>, <span class="string">'Min DewpointF'</span>, <span class="string">'Max Humidity'</span>, <span class="string">' Mean Humidity'</span>, <span class="string">' Min Humidity'</span>, <span class="string">' Max Sea Level PressureIn'</span>, <span class="string">' Mean Sea Level PressureIn'</span>, <span class="string">' Min Sea Level PressureIn'</span>, <span class="string">' Max VisibilityMiles'</span>, <span class="string">' Mean VisibilityMiles'</span>, <span class="string">' Min VisibilityMiles'</span>, <span class="string">' Max Wind SpeedMPH'</span>, <span class="string">' Mean Wind SpeedMPH'</span>, <span class="string">' Max Gust SpeedMPH'</span>, <span class="string">'PrecipitationIn'</span>, <span class="string">' CloudCover'</span>, <span class="string">' Events'</span>, <span class="string">' WindDirDegrees'</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>调用csv.reader()将前面存储的文件对象作为实参传递给它，从而创建一个与该文件相关联的<strong>阅读器reader对象</strong>。将阅读器存储在reader中。<strong>模块cav包含函数next()</strong>,调用它将返回文件中的下一行。</p>
<p>reader处理文件中以逗号分隔的第一行数据，并将每个数据项都作为一个元素存储在列表中。</p>
<h3 id="打印文件头及其位置"><a href="#打印文件头及其位置" class="headerlink" title="打印文件头及其位置"></a>打印文件头及其位置</h3><p>我们将文件头及其位置打印出来。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = <span class="built_in">next</span>(reader)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> index,colum_header <span class="keyword">in</span> <span class="built_in">enumerate</span>(header_row):</span><br><span class="line">        print(index,colum_header)</span><br><span class="line">        </span><br><span class="line"><span class="number">0</span> AKDT</span><br><span class="line"><span class="number">1</span> Max TemperatureF</span><br><span class="line"><span class="number">2</span> Mean TemperatureF</span><br><span class="line"><span class="number">3</span> Min TemperatureF</span><br><span class="line"><span class="number">4</span> Max Dew PointF</span><br><span class="line">.......</span><br></pre></td></tr></tbody></table></figure>
<p>我们对列表调用了enumerate()来获取每个元素的索引及其值。从中可知，日期和最高气温分别存储在第0列和第一列。我们将处理文件中的每行数据，并提取其中索引为0和1的值。</p>
<h3 id="提取并读取数据"><a href="#提取并读取数据" class="headerlink" title="提取并读取数据"></a>提取并读取数据</h3><p>首先读取每天的最高气温。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = <span class="built_in">next</span>(reader)</span><br><span class="line">    </span><br><span class="line">    highs = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        highs.append(row[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">    print(highs)</span><br><span class="line"></span><br><span class="line">[<span class="string">'64'</span>, <span class="string">'71'</span>, <span class="string">'64'</span>, <span class="string">'59'</span>, <span class="string">'69'</span>, <span class="string">'62'</span>, <span class="string">'61'</span>, <span class="string">'55'</span>, <span class="string">'57'</span>, <span class="string">'61'</span>, <span class="string">'57'</span>, <span class="string">'59'</span>, <span class="string">'57'</span>, <span class="string">'61'</span>, <span class="string">'64'</span>, <span class="string">'61'</span>, <span class="string">'59'</span>, <span class="string">'63'</span>, <span class="string">'60'</span>, <span class="string">'57'</span>, <span class="string">'69'</span>, <span class="string">'63'</span>, <span class="string">'62'</span>, <span class="string">'59'</span>, <span class="string">'57'</span>, <span class="string">'57'</span>, <span class="string">'61'</span>, <span class="string">'59'</span>, <span class="string">'61'</span>, <span class="string">'61'</span>, <span class="string">'66'</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>阅读器对象从其停留的地方继续往下读取csv文件，每次都自动返回当前所处位置的下一行。由于我们之前已经读取了文件头，这个循环将从第二行开始。</p>
<p>我们使用int()将这些字符串转化为数字，让matplotlib能够读取它们。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"> highs.append(<span class="built_in">int</span>(row[<span class="number">1</span>])</span><br><span class="line"> </span><br><span class="line">[<span class="number">64</span>, <span class="number">71</span>, <span class="number">64</span>, <span class="number">59</span>, <span class="number">69</span>, <span class="number">62</span>, <span class="number">61</span>, <span class="number">55</span>, <span class="number">57</span>, <span class="number">61</span>, <span class="number">57</span>, <span class="number">59</span>, <span class="number">57</span>, <span class="number">61</span>, <span class="number">64</span>, <span class="number">61</span>, <span class="number">59</span>, <span class="number">63</span>, <span class="number">60</span>, <span class="number">57</span>, <span class="number">69</span>, <span class="number">63</span>, <span class="number">62</span>, <span class="number">59</span>, <span class="number">57</span>, <span class="number">57</span>, <span class="number">61</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">61</span>, <span class="number">66</span>]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="绘制气温图表"><a href="#绘制气温图表" class="headerlink" title="绘制气温图表"></a>绘制气温图表</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_name) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = <span class="built_in">next</span>(reader)</span><br><span class="line">    </span><br><span class="line">    highs = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        highs.append(<span class="built_in">int</span>(row[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据数据绘制图形</span></span><br><span class="line">fig = plt.figure(dpi=<span class="number">128</span>,figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line">plt.plot(highs,c=<span class="string">'red'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">"Daily high temperature,July 2014"</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">''</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Temperature(F),fontsize=16'</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>,which=<span class="string">'major'</span>,labelsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_15.png" alt="屏幕快照 2017-09-23 下午12.06.32"></p>
<h3 id="模块datetime"><a href="#模块datetime" class="headerlink" title="模块datetime"></a>模块datetime</h3><p>在天气数据文件中，第一个日期在第二行。地区该行时，获取的是一个字符串，因为我们需要将字符串“2014-7-1“转换为一个表示相应日期的对象。<strong>可使用模块datetime中的方法strptime()。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">first_date = datetime.strptime(<span class="string">'2014-7-1'</span>,<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">print(first_date)</span><br><span class="line"></span><br><span class="line"><span class="number">2014</span>-07-01 <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></tbody></table></figure>
<p>“%Y-“让Python将字符串中<strong>第一个连字符前面的部分</strong>视为四位的年份。strptime()可接受实参,并根据其解读日期。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">实       参</th>
<th style="text-align:center">含         义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%A</td>
<td style="text-align:center">星期的名称，如Monday</td>
</tr>
<tr>
<td style="text-align:center">%B</td>
<td style="text-align:center">月份，如January</td>
</tr>
<tr>
<td style="text-align:center">%m</td>
<td style="text-align:center">用数字表示的月份，（01～12）</td>
</tr>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">用数字表示月份中的一天，（01～31）</td>
</tr>
<tr>
<td style="text-align:center">%Y</td>
<td style="text-align:center">四位的年份，如2015</td>
</tr>
<tr>
<td style="text-align:center">%y</td>
<td style="text-align:center">两位的年份，如15</td>
</tr>
<tr>
<td style="text-align:center">%H</td>
<td style="text-align:center">24小时制的小时数（00～23）</td>
</tr>
<tr>
<td style="text-align:center">%I</td>
<td style="text-align:center">12小时制的小时数（01～12）</td>
</tr>
<tr>
<td style="text-align:center">%p</td>
<td style="text-align:center">am或pm</td>
</tr>
<tr>
<td style="text-align:center">%M</td>
<td style="text-align:center">分钟数（00～59）</td>
</tr>
<tr>
<td style="text-align:center">%S</td>
<td style="text-align:center">秒数（00～59）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="在图表中添加日期"><a href="#在图表中添加日期" class="headerlink" title="在图表中添加日期"></a>在图表中添加日期</h3><p>调用fig.autofmt_xdate()来绘制斜的日期标签，以免它们彼此重叠。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">'sitka_weather_07-2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_name) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = <span class="built_in">next</span>(reader)</span><br><span class="line">    </span><br><span class="line">    dates,highs = [],[]</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        current_date = datetime.strptime(row[<span class="number">0</span>],<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">        dates.append(current_date)</span><br><span class="line">        highs.append(<span class="built_in">int</span>(row[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据数据绘制图形</span></span><br><span class="line">fig = plt.figure(dpi=<span class="number">128</span>,figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line">plt.plot(dates,highs,c=<span class="string">'red'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">"Daily high temperature,July 2014"</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">''</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.ylabel(<span class="string">'Temperature(F),fontsize=16'</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>,which=<span class="string">'major'</span>,labelsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_16.png" alt="屏幕快照 2017-09-23 下午2.02.28"></p>
<h3 id="最高与最低气温"><a href="#最高与最低气温" class="headerlink" title="最高与最低气温"></a>最高与最低气温</h3><p>导入”sitka_weather_2014.csv”数据，它记录了sitka地区整年的气温变化，我们观察最高与最低气温。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">xiaimport csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">'sitka_weather_2014.csv'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_name) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = <span class="built_in">next</span>(reader)</span><br><span class="line">    </span><br><span class="line">    dates,highs,lows = [],[],[]</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        current_date = datetime.strptime(row[<span class="number">0</span>],<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">        dates.append(current_date)</span><br><span class="line">        highs.append(<span class="built_in">int</span>(row[<span class="number">1</span>]))</span><br><span class="line">        lows.append(<span class="built_in">int</span>(row[<span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据数据绘制图形</span></span><br><span class="line">fig = plt.figure(dpi=<span class="number">128</span>,figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line">plt.plot(dates,highs,c=<span class="string">'red'</span>)</span><br><span class="line">plt.plot(dates,lows,c=<span class="string">'blue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置图形的格式</span></span><br><span class="line">plt.title(<span class="string">"Daily high and low temperature,2014"</span>,fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">''</span>,fontsize=<span class="number">16</span>)</span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.ylabel(<span class="string">'Temperature(F),fontsize=16'</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'both'</span>,which=<span class="string">'major'</span>,labelsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_17.png" alt="屏幕快照 2017-09-23 下午2.28.54"></p>
<p>下面给图表区域着色。使用fill_between()，它接受一个x值与y值系列，并填充两个y值系列之间的空间。<strong>alpha</strong>指定颜色的透明度。Alpha=0表示完全透明，1完全不透明。fill_between()传递了一个x值系列：列表dates，还传递了两个y值系列：highs和lows。facecolor指定了填充区域的颜色。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#根据数据绘制图形</span></span><br><span class="line">fig = plt.figure(dpi=<span class="number">128</span>,figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line">plt.plot(dates,highs,c=<span class="string">'red'</span>,alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.plot(dates,lows,c=<span class="string">'blue'</span>,alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.fill_between(dates,highs,lows,facecolor=<span class="string">'blue'</span>,alpha=<span class="number">0.1</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_18.png" alt="屏幕快照 2017-09-23 下午2.39.56"></p>
<h3 id="错误检查"><a href="#错误检查" class="headerlink" title="错误检查"></a>错误检查</h3><p>数据的缺失可能引发异常，例如我们导入死亡谷的气温数据“death_valley_2014.csv”，并且运行上述代码。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">ValueError: invalid literal <span class="keyword">for</span> <span class="built_in">int</span>() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">''</span></span><br></pre></td></tr></tbody></table></figure>
<p>结果显示，无法处理文件中的一行数据，因为它无法将空字符串转化为整数。我们打开文件，发现其中没有记录2014-2-16的数据，最高气温的字符串为空。</p>
<p>我们在csv文件中读取值时执行错误检查代码，<strong>对分析数据集时可能出现的异常进行处理。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">--snip--</span><br><span class="line">dates,highs,lows = [],[],[]</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            current_date = datetime.strptime(row[<span class="number">0</span>],<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">            high = <span class="built_in">int</span>(row[<span class="number">1</span>])</span><br><span class="line">            low = <span class="built_in">int</span>(row[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            print(current_date,<span class="string">'missing data'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dates.append(current_date)</span><br><span class="line">            highs.append(high)</span><br><span class="line">            lows.append(low)</span><br><span class="line">--snip--</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_19.png" alt="屏幕快照 2017-09-23 下午3.04.05"></p>
<p>可以看到，有一个数据没有读到。其他正常显示。</p>
<!--more-->
<h2 id="制作世界人口地图：JSON格式"><a href="#制作世界人口地图：JSON格式" class="headerlink" title="制作世界人口地图：JSON格式"></a>制作世界人口地图：JSON格式</h2><p>Pygal提供了一个适合初学者使用的地图创建工具，使用它对人口数据进行可视化，以探索全球人口的分布情况。</p>
<p>文件population_data.json中包含全球大部分国家1960～2010的人口数据。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  {</span><br><span class="line">    <span class="string">"Country Name"</span>: <span class="string">"Arab World"</span>,</span><br><span class="line">    <span class="string">"Country Code"</span>: <span class="string">"ARB"</span>,</span><br><span class="line">    <span class="string">"Year"</span>: <span class="string">"1960"</span>,</span><br><span class="line">    <span class="string">"Value"</span>: <span class="string">"96388069"</span></span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    <span class="string">"Country Name"</span>: <span class="string">"Arab World"</span>,</span><br><span class="line">    <span class="string">"Country Code"</span>: <span class="string">"ARB"</span>,</span><br><span class="line">    <span class="string">"Year"</span>: <span class="string">"1961"</span>,</span><br><span class="line">    <span class="string">"Value"</span>: <span class="string">"98882541.4"</span></span><br><span class="line">  },</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>
<p>这个文件实际上就是一个很长的Python列表，其中每个元素都是一个包含4个键的字典。国家名、国别码、年份、以及人口数量。</p>
<p>我们只关心人口数量。因此先将这些信息打印出来。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#将数据加载到一个列表中</span></span><br><span class="line">file_name = <span class="string">'population_data.json'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_name) <span class="keyword">as</span> f:</span><br><span class="line">    pop_data = json.load(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印每个国家2010年的人口数量</span></span><br><span class="line"><span class="keyword">for</span> pop_dict <span class="keyword">in</span> pop_data:</span><br><span class="line">    <span class="keyword">if</span> pop_dict[<span class="string">'Year'</span>] == <span class="string">'2010'</span>:</span><br><span class="line">        country_name = pop_dict[<span class="string">'Country Name'</span>]</span><br><span class="line">        population = pop_dict[<span class="string">'Value'</span>]</span><br><span class="line">        print(country_name + <span class="string">":"</span> + population)</span><br><span class="line"></span><br><span class="line">Arab World:<span class="number">357868000</span></span><br><span class="line">Caribbean small states:<span class="number">6880000</span></span><br><span class="line">East Asia &amp; Pacific (<span class="built_in">all</span> income levels):<span class="number">2201536674</span></span><br><span class="line">East Asia &amp; Pacific (developing only):<span class="number">1961558757</span></span><br><span class="line">Euro area:<span class="number">331766000</span></span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>
<p>首先导入了json模块，以便正确的加载文件中的数据。然后将数据存储在pop_data中。函数pop_data 将数据转换为Python能够处理的格式，这里是一个列表。</p>
<p>可以看到，捕捉的数据中，并非每个都是国家名，现在将数据转换为Pygal能够处理的格式。</p>
<p>注意：将str转换为int时，若使用str(),如果数字（人口数量）为小数，则会发生错误，<strong>因为Python不能将包含小数点的字符串（如：“10.984958”）转化为整数。</strong></p>
<p><strong>应该先将其字符串转换为浮点数float()，再将浮点数转化为整数int()。</strong>Python会自动抛弃小数部分。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">population = <span class="built_in">int</span>(<span class="built_in">float</span>(pop_dict[<span class="string">'Value'</span>]))</span><br><span class="line">print(country_name + <span class="string">":"</span> + <span class="built_in">str</span>(population))</span><br></pre></td></tr></tbody></table></figure>
<h3 id="获取两个字母的国别码"><a href="#获取两个字母的国别码" class="headerlink" title="获取两个字母的国别码"></a>获取两个字母的国别码</h3><p>population_data.json中包含的是三个字母的国别码，但Pygal使用两个字母的国别码。我们需要根据国家名获取两个字母的国别码。Pygal使用的国别码存储在模块i8n中。字典COUNTRIES包含的键和值分别是两个字母的国别码和国家名。要查看，可导入。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pygal.i18n <span class="keyword">import</span> COUNTRIES</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>  country_code <span class="keyword">in</span> <span class="built_in">sorted</span>(COUNTRIES.keys()):</span><br><span class="line">    print(country_code,COUNTRIES[country_code])</span><br><span class="line"></span><br><span class="line">ad Andorra</span><br><span class="line">ae United Arab Emirates</span><br><span class="line">af Afghanistan</span><br><span class="line">al Albania</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>
<p>为获取国别码，编写一个函数，它在COUNTRIES中查找并返回国别码。（country_codes.py）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pygal.i18n <span class="keyword">import</span> COUNTRIES</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_country_code</span>(<span class="params">country_name</span>):</span></span><br><span class="line">    <span class="string">"""根据指定的国家，返回Pygal使用的两个字母的国别码"""</span></span><br><span class="line">    <span class="keyword">for</span> code,name <span class="keyword">in</span> COUNTRIES.items():</span><br><span class="line">        <span class="keyword">if</span> name == country_name:</span><br><span class="line">            <span class="keyword">return</span> code</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure>
<p>在之前的代码中导入。(world_population.py)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> country_codes <span class="keyword">import</span> get_country_code</span><br><span class="line"></span><br><span class="line"><span class="comment">#将数据加载到一个列表中</span></span><br><span class="line">file_name = <span class="string">'population_data.json'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_name) <span class="keyword">as</span> f:</span><br><span class="line">    pop_data = json.load(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印每个国家2010年的人口数量</span></span><br><span class="line"><span class="keyword">for</span> pop_dict <span class="keyword">in</span> pop_data:</span><br><span class="line">    <span class="keyword">if</span> pop_dict[<span class="string">'Year'</span>] == <span class="string">'2010'</span>:</span><br><span class="line">        country_name = pop_dict[<span class="string">'Country Name'</span>]</span><br><span class="line">        population = pop_dict[<span class="string">'Value'</span>]</span><br><span class="line">        code = get_country_code(country_name)</span><br><span class="line">        <span class="keyword">if</span> code:</span><br><span class="line">          print(code + <span class="string">":"</span> + <span class="built_in">str</span>(population))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          print(<span class="string">'ERROR -'</span> + country_name)</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">ERROR -Algeria</span><br><span class="line">ERROR -American Samoa</span><br><span class="line">ad:<span class="number">84864</span></span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>
<h3 id="制作世界地图"><a href="#制作世界地图" class="headerlink" title="制作世界地图"></a>制作世界地图</h3><p>有了国别码后，制作世界地图易如反掌。Pygal提供了图表类型WorldMap，可帮助你制作呈现世界各国数据的世界地图。为了呈现，我们来创建一个突出北美、中美和南美的简单地图。</p>
<p>我们创建了一个Worldmap实例，并设置了该地图的title属性。</p>
<p>使用add方法，它接受一个标签和一个列表，后者包含我们要突出的国家的<strong>国别码</strong>。每次调用add都将为指定的国家选择一种新颜色，并在左边显示该颜色和指定的标签。我们要以同一种颜色显示整个北美地区。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"></span><br><span class="line">wm = pygal.Worldmap()</span><br><span class="line">wm.title = <span class="string">'North,Central,and South America'</span></span><br><span class="line"></span><br><span class="line">wm.add(<span class="string">'North America'</span>,[<span class="string">'ca'</span>,<span class="string">'mx'</span>,<span class="string">'us'</span>])</span><br><span class="line">wm.add(<span class="string">'Central America'</span>,[<span class="string">'bz'</span>,<span class="string">'cr'</span>,<span class="string">'gt'</span>,<span class="string">'hn'</span>,<span class="string">'ni'</span>,<span class="string">'pa'</span>,<span class="string">'sv'</span>])</span><br><span class="line">wm.add(<span class="string">'South America'</span>,[<span class="string">'ar'</span>,<span class="string">'bo'</span>,<span class="string">'br'</span>,<span class="string">'cl'</span>,<span class="string">'co'</span>,<span class="string">'ec'</span>,<span class="string">'gf'</span>,</span><br><span class="line">                       <span class="string">'gy'</span>,<span class="string">'pe'</span>,<span class="string">'sr'</span>,<span class="string">'uy'</span>,<span class="string">'ve'</span>])</span><br><span class="line"></span><br><span class="line">wm.render_to_file(<span class="string">'americas.svg'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_20.png" alt="屏幕快照 2017-09-23 下午4.41.59"></p>
<h3 id="在世界地图上呈现数字数据"><a href="#在世界地图上呈现数字数据" class="headerlink" title="在世界地图上呈现数字数据"></a>在世界地图上呈现数字数据</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"></span><br><span class="line">wm = pygal.Worldmap()</span><br><span class="line">wm.title = <span class="string">'Population of Countries in North America'</span></span><br><span class="line">wm.add(<span class="string">'North America'</span>,{<span class="string">'ca'</span>:<span class="number">34126000</span>,<span class="string">'us'</span>:<span class="number">30934900</span>,<span class="string">'mx'</span>:<span class="number">113423000</span>})</span><br><span class="line"></span><br><span class="line">wm.render_to_file(<span class="string">'na_populations.svg'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_21.png" alt="屏幕快照 2017-09-23 下午4.52.41"></p>
<p>这次的add方法，第二个参数传递的是一个字典而不是列表。这个字典将两个字母的Pygal国别码作为键，将人口数量作为值。Pygal根据这些数字自动给不同国家着以深浅不一的颜色（人口最少的国家颜色最浅，反之最深）</p>
<h3 id="绘制完整的世界人口地图"><a href="#绘制完整的世界人口地图" class="headerlink" title="绘制完整的世界人口地图"></a>绘制完整的世界人口地图</h3><p>在之前的world_population.py中添加如下代码：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"></span><br><span class="line"><span class="comment">#将数据加载到一个列表中</span></span><br><span class="line">file_name = <span class="string">'population_data.json'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_name) <span class="keyword">as</span> f:</span><br><span class="line">    pop_data = json.load(f)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个包含人口数量的字典</span></span><br><span class="line">cc_populations = {}</span><br><span class="line"></span><br><span class="line"><span class="comment">#每个国家2010年的人口数量</span></span><br><span class="line"><span class="keyword">for</span> pop_dict <span class="keyword">in</span> pop_data:</span><br><span class="line">    <span class="keyword">if</span> pop_dict[<span class="string">'Year'</span>] == <span class="string">'2010'</span>:</span><br><span class="line">        country_name = pop_dict[<span class="string">'Country Name'</span>]</span><br><span class="line">        population = <span class="built_in">int</span>(<span class="built_in">float</span>(pop_dict[<span class="string">'Value'</span>]))</span><br><span class="line">        code = get_country_code(country_name)</span><br><span class="line">        <span class="keyword">if</span> code:</span><br><span class="line">            cc_populations[code] = population</span><br><span class="line"></span><br><span class="line">wm = pygal.Worldmap()</span><br><span class="line">wm.title = <span class="string">'World Population in 2010,by Country'</span></span><br><span class="line">wm.add(<span class="string">'2010'</span>,cc_populations)</span><br><span class="line"></span><br><span class="line">wm.render_to_file(<span class="string">'world_population.svg'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_22.png" alt="屏幕快照 2017-09-23 下午5.09.55"></p>
<p>我们将根据人口数量将国家分组，再分别给每个组着色。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> LightColorizedStyle <span class="keyword">as</span> LCS, RotateStyle <span class="keyword">as</span> RS</span><br><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> code:</span><br><span class="line">  cc_populations[code] = population</span><br><span class="line"></span><br><span class="line"><span class="comment"># Group the countries into 3 population levels.</span></span><br><span class="line">cc_pops_1, cc_pops_2, cc_pops_3 = {}, {}, {}</span><br><span class="line"><span class="keyword">for</span> cc, pop <span class="keyword">in</span> cc_populations.items():</span><br><span class="line">    <span class="keyword">if</span> pop &lt; <span class="number">10000000</span>:</span><br><span class="line">        cc_pops_1[cc] = pop</span><br><span class="line">    <span class="keyword">elif</span> pop &lt; <span class="number">1000000000</span>:</span><br><span class="line">        cc_pops_2[cc] = pop</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cc_pops_3[cc] = pop</span><br><span class="line"></span><br><span class="line"><span class="comment"># See how many countries are in each level.        </span></span><br><span class="line">print(<span class="built_in">len</span>(cc_pops_1), <span class="built_in">len</span>(cc_pops_2), <span class="built_in">len</span>(cc_pops_3))</span><br><span class="line"></span><br><span class="line">wm_style = RS(<span class="string">'# '</span>, base_style=LCS)</span><br><span class="line">wm = pygal.Worldmap(style=wm_style)</span><br><span class="line">wm.title = <span class="string">'World Population in 2010, by Country'</span></span><br><span class="line">wm.add(<span class="string">'0-10m'</span>, cc_pops_1)</span><br><span class="line">wm.add(<span class="string">'10m-1bn'</span>, cc_pops_2)</span><br><span class="line">wm.add(<span class="string">'&gt;1bn'</span>, cc_pops_3)</span><br><span class="line">    </span><br><span class="line">wm.render_to_file(<span class="string">'world_population.svg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">85</span> <span class="number">69</span> <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_23.png" alt="屏幕快照 2017-09-23 下午5.31.20"></p>
<h3 id="用Pygal设置世界地图样式"><a href="#用Pygal设置世界地图样式" class="headerlink" title="用Pygal设置世界地图样式"></a>用Pygal设置世界地图样式</h3><p>我们让Pygal使用设置指令来调整颜色。让三个分组的颜色差别更大。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> RotateStyle</span><br><span class="line"></span><br><span class="line">--snip--</span><br><span class="line">wm_style = RotateStyle(<span class="string">'# '</span>)</span><br><span class="line">wm = pygal.Worldmap(style=wm_style)</span><br><span class="line"></span><br><span class="line">--snip--</span><br></pre></td></tr></tbody></table></figure>
<p>Pygal样式存储在模块style中，我们从中导入了RotateStyle样式。创建这个类的实例时，需要提供一个参数：16进制的RGB颜色；Pygal将根据指定的颜色为每组选择颜色。前两个字符表示红色分量，然后是绿色，蓝色。取值00～FF。建议搜索hex color chooser（16进制颜色选择器）</p>
<h3 id="加亮颜色主题"><a href="#加亮颜色主题" class="headerlink" title="加亮颜色主题"></a>加亮颜色主题</h3><p>我们使用LightColorizedStyle加亮了地图。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> LightColorizedStyle</span><br></pre></td></tr></tbody></table></figure>
<p>但是使用这个类时，你不能直接控制使用的颜色，Pygal将选择默认的基色。要设置颜色，可使用RotateStyle，并将LightColorizedStyle作为基本样式。为此</p>
 <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> LightColorizedStyle <span class="keyword">as</span> LCS,RotateStyle <span class="keyword">as</span> RS</span><br></pre></td></tr></tbody></table></figure>
<p>再使用RotateStyle创建一种样式</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">wm_style = RS(<span class="string">'# '</span>, base_style=LCS)</span><br></pre></td></tr></tbody></table></figure>
<p>这设置了较亮的主题，通过实参传递的颜色给各个国家着色。</p>
<h1 id="使用API"><a href="#使用API" class="headerlink" title="使用API"></a>使用API</h1><p>编写一个独立的程序，并对其获取的数据进行可视化。这个程序将使用<strong>Web应用编程接口（API）</strong>自动请求网站的特定信息而不是整个网页，再对这些信息进行可视化。由于这样编写的程序始终使用最新的数据来生成可视化，因此即便数据瞬息万变，它呈现的信息也都是最新的。</p>
<p>我们将使用GitHub的API来请求有关该网站中Python项目的信息，然后使用Pygal生成交互式可视化，以呈现这些项目的受欢迎程度。这个程序将自动下载GitHub上星级最高的Python项目的信息，并对这些项目进行可视化。</p>
<h2 id="使用Web-API"><a href="#使用Web-API" class="headerlink" title="使用Web API"></a>使用Web API</h2><p>GitHub的API让你能够通过API调用来请求各种信息。要知道API调用是什么样的，输入以下网址：</p>
<p><a href="https://api.github.com/search/repositories?q=language:python&amp;sort=stars">https://api.github.com/search/repositories?q=language:python&amp;sort=stars</a></p>
<p>这个调用返回GitHub当前托管了多少个Python项目，还有有关最受欢迎的Python仓库的信息。仔细研究这个调用，第一部分（<a href="https://api.github.com/）将请求发送到GitHub网站中响应API调用的部分；接下来一部分（search/repositories）让API搜索GitHub上的所有仓库。">https://api.github.com/）将请求发送到GitHub网站中响应API调用的部分；接下来一部分（search/repositories）让API搜索GitHub上的所有仓库。</a></p>
<p>repositories后面的问号指出我们要传递一个实参。q表示查询，而等号能让我们开始指定的查询。通过使用language：python，我们指出只想获取主要语言为python仓库的信息，最后一部分查询&amp;sort=stars指定项目将按其获得的星级进行排序。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"total_count"</span>: <span class="number">1968718</span>,</span><br><span class="line">  <span class="string">"incomplete_results"</span>: false,</span><br><span class="line">  <span class="string">"items"</span>: [</span><br><span class="line">    {</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">21289110</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"awesome-python"</span>,</span><br><span class="line">      <span class="string">"full_name"</span>: <span class="string">"vinta/awesome-python"</span>,</span><br><span class="line">      <span class="string">"owner"</span>: {</span><br></pre></td></tr></tbody></table></figure>
<p>上面显示了响应的前几行。从中可知，GitHub总共有1968718个python项目。”incomplete_results”的值为false，据此我们知道请求是成功的（它并非不完整的）。倘若GitHub无法全面处理该API，它返回的这个值将为true。接下来的列表中显示了返回的“items”，其中包含GitHub上最受欢迎的Python项目的详细信息。</p>
<h3 id="安装requests"><a href="#安装requests" class="headerlink" title="安装requests"></a>安装requests</h3><p>requests包让python程序能够轻松地向网站请求信息以及检查返回的响应，要安装requests，执行类似于下面的命令：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ pip3 install --user requests</span><br></pre></td></tr></tbody></table></figure>
<h3 id="处理API响应"><a href="#处理API响应" class="headerlink" title="处理API响应"></a>处理API响应</h3><p>下面的程序，它执行API调用并处理结果，找出GitHub上星级最高的Python项目。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行API调用并存储响应</span></span><br><span class="line">url = <span class="string">'https://api.github.com/search/repositories?q=language:python&amp;sort=stars'</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">print(<span class="string">"Status code:"</span>,r.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将API响应存储在一个变量中</span></span><br><span class="line">response_dict = r.json()</span><br><span class="line"></span><br><span class="line"><span class="comment">#处理结果</span></span><br><span class="line">print(response_dict.keys()) </span><br><span class="line"></span><br><span class="line">Status code: <span class="number">200</span></span><br><span class="line">dict_keys([<span class="string">'total_count'</span>, <span class="string">'incomplete_results'</span>, <span class="string">'items'</span>])</span><br></pre></td></tr></tbody></table></figure>
<p>1.我们导入模块request。</p>
<p>2.使用requests来执行调用url。调用get()并将url传递给它，再将<strong>响应对象</strong>存储在变量r中。</p>
<p>3.响应对象包含了一个名为status_code的属性，它让我们知道请求是否成功了。（状态码200表示成功了）</p>
<p>4.这个API返回一个json格式的信息，因此使用方法json()将这些信息转换为一个Python字典存储在response_dict</p>
<p>5.打印response_dict中的键。</p>
<h3 id="处理响应字典"><a href="#处理响应字典" class="headerlink" title="处理响应字典"></a>处理响应字典</h3><p>将API调用返回的信息存储到字典中后，就可以处理这个字典中的数据了。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行API调用并存储响应</span></span><br><span class="line">url = <span class="string">"https://api.github.com/search/repositories?q=language:python&amp;sort=stars"</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">print(<span class="string">"status code"</span>,r.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将API响应存储在一个变量中</span></span><br><span class="line">response_dict = r.json()</span><br><span class="line">print(<span class="string">"Total repositories returned:"</span>,response_dict[<span class="string">'total_count'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#搜索有关仓库的信息</span></span><br><span class="line">repo_dict = response_dict[<span class="string">'items'</span>]</span><br><span class="line">print(<span class="string">"Repositories returned:"</span>,<span class="built_in">len</span>(repo_dict))</span><br><span class="line"></span><br><span class="line"><span class="comment">#研究第一个仓库</span></span><br><span class="line">repo_dict = repo_dict[<span class="number">0</span>]</span><br><span class="line">print(<span class="string">"\nKeys:"</span>,<span class="built_in">len</span>(repo_dict))</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(repo_dict.keys()):</span><br><span class="line">    print(key)</span><br><span class="line">    </span><br><span class="line">status code <span class="number">200</span></span><br><span class="line">Total repositories returned: <span class="number">1970122</span></span><br><span class="line">Repositories returned: <span class="number">30</span></span><br><span class="line"></span><br><span class="line">Keys: <span class="number">70</span></span><br><span class="line">archive_url</span><br><span class="line">.......</span><br></pre></td></tr></tbody></table></figure>
<p>与item相关联的值是一个列表，其中包含很多字典，而每个字典都包含有关一个Python仓库的信息。</p>
<p>我们将这个字典列表存储在repo_dicts中。</p>
<p>repo_dict[0]提取第一个字典，并将其存储在repo_dict中。</p>
<p>接下来打印第一个仓库的字典中很多键相关的值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="comment">#研究第一个仓库</span></span><br><span class="line">repo_dict = repo_dict[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nSelected information about first repository"</span>)</span><br><span class="line">print(<span class="string">"Name:"</span>,repo_dict[<span class="string">'name'</span>])</span><br><span class="line">print(<span class="string">"Stars:"</span>,repo_dict[<span class="string">'stargazers_count'</span>])</span><br><span class="line"></span><br><span class="line">Selected information about first repository</span><br><span class="line">Name: awesome-python</span><br><span class="line">Stars: <span class="number">38871</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="概述最受欢迎的仓库"><a href="#概述最受欢迎的仓库" class="headerlink" title="概述最受欢迎的仓库"></a>概述最受欢迎的仓库</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">--snip--</span><br><span class="line"></span><br><span class="line"><span class="comment">#搜索有关仓库的信息</span></span><br><span class="line">repo_dict = response_dict[<span class="string">'items'</span>]</span><br><span class="line">print(<span class="string">"Repositories returned:"</span>,<span class="built_in">len</span>(repo_dict))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nSelected information about first repository"</span>)</span><br><span class="line"><span class="keyword">for</span> repo_dict <span class="keyword">in</span> repo_dicts:</span><br><span class="line">    print(<span class="string">"Name:"</span>,repo_dict[<span class="string">'name'</span>])</span><br><span class="line">    print(<span class="string">"Stars:"</span>,repo_dict[<span class="string">'stargazers_count'</span>])</span><br><span class="line">    print(<span class="string">"Repository:"</span>,repo_dict[<span class="string">'html_url'</span>])</span><br><span class="line">    print(<span class="string">"Description:"</span>,repo_dict[<span class="string">'description'</span>])</span><br></pre></td></tr></tbody></table></figure>
<h3 id="监视API的速率限制"><a href="#监视API的速率限制" class="headerlink" title="监视API的速率限制"></a>监视API的速率限制</h3><p>大多数API都存在速率限制，即你在特定时间内可执行的请求数存在限制。要获悉你是否接近GiHub的限制，请输入<a href="https://api.github.com/rate_limit">https://api.github.com/rate_limit</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="string">"resources"</span>: {</span><br><span class="line">    <span class="string">"core"</span>: {</span><br><span class="line">      <span class="string">"limit"</span>: <span class="number">60</span>,</span><br><span class="line">      <span class="string">"remaining"</span>: <span class="number">60</span>,</span><br><span class="line">      <span class="string">"reset"</span>: <span class="number">1506236519</span></span><br><span class="line">    },</span><br><span class="line">    <span class="string">"search"</span>: {</span><br><span class="line">      <span class="string">"limit"</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="string">"remaining"</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="string">"reset"</span>: <span class="number">1506232979</span></span><br><span class="line">    },</span><br></pre></td></tr></tbody></table></figure>
<p>search中，limit代表每分钟10个请求，而在当前这一分钟，我们还可以执行10个请求。若到达配置，你必须等待配额重置。</p>
<h2 id="使用Pygal可视化仓库"><a href="#使用Pygal可视化仓库" class="headerlink" title="使用Pygal可视化仓库"></a>使用Pygal可视化仓库</h2><p>现在进行可视化，呈现GitHub上Python项目最受欢迎程度。条形的高低代表获得了多少颗星。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> LightColorizedStyle <span class="keyword">as</span> LCS,LightenStyle <span class="keyword">as</span> LS</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行API调用并存储响应</span></span><br><span class="line">url = <span class="string">"https://api.github.com/search/repositories?q=language:python&amp;sort=stars"</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">print(<span class="string">"status code"</span>,r.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将API响应存储在一个变量中</span></span><br><span class="line">response_dict = r.json()</span><br><span class="line">print(<span class="string">"Total repositories returned:"</span>,response_dict[<span class="string">'total_count'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#搜索有关仓库的信息</span></span><br><span class="line">repo_dicts = response_dict[<span class="string">'items'</span>]</span><br><span class="line"></span><br><span class="line">names,stars = [],[]</span><br><span class="line"><span class="keyword">for</span> repo_dict <span class="keyword">in</span> repo_dicts:</span><br><span class="line">    names.append(repo_dict[<span class="string">'name'</span>])</span><br><span class="line">    stars.append(repo_dict[<span class="string">'stargazers_count'</span>])</span><br><span class="line">    </span><br><span class="line"><span class="comment">#可视化</span></span><br><span class="line">my_style = LS(<span class="string">'# '</span>,base_style=LCS)</span><br><span class="line">chart = pygal.Bar(style=my_style,x_label_rotation=<span class="number">45</span>,show_legend=<span class="literal">False</span>)</span><br><span class="line">chart.title = <span class="string">"Most-Starred Python Projects on GitHub"</span></span><br><span class="line">chart.x_labels = names</span><br><span class="line"></span><br><span class="line">chart.add(<span class="string">''</span>,stars)</span><br><span class="line">chart.render_to_file(<span class="string">'python_repos.svg'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_24.png" alt="屏幕快照 2017-09-24 下午2.19.13"></p>
<p>x_label_rotation=45让标签绕x轴旋转45度，并隐藏了图例show_legend=False</p>
<h3 id="改进Pygal图表"><a href="#改进Pygal图表" class="headerlink" title="改进Pygal图表"></a>改进Pygal图表</h3><p>下面来改进这个图表的样式，创建一个配置对象，在其中包含要传递给Bar()的所有配置。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="comment">#可视化</span></span><br><span class="line">my_style = LS(<span class="string">'# '</span>,base_style=LCS)</span><br><span class="line">my_config = pygal.Config()</span><br><span class="line">my_config.x_label_rotation = <span class="number">45</span></span><br><span class="line">my_config.show_legend = <span class="literal">False</span></span><br><span class="line">my_config.title_font_size = <span class="number">14</span></span><br><span class="line">my_config.major_label_font_size = <span class="number">18</span></span><br><span class="line">my_config.truncate_label = <span class="number">15</span></span><br><span class="line">my_config.show_y_guides = <span class="literal">False</span></span><br><span class="line">my_config.width = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">chart = pygal.Bar(my_config,style=my_style)</span><br><span class="line">chart.title = <span class="string">"Most-Starred Python Projects on GitHub"</span></span><br><span class="line">chart.x_labels = names</span><br><span class="line"></span><br><span class="line">chart.add(<span class="string">''</span>,stars)</span><br><span class="line">chart.render_to_file(<span class="string">'python_repos.svg'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_25.png" alt="屏幕快照 2017-09-24 下午2.32.56"></p>
<p>我们创建了一个Pygal类Config的实例，并将其命名为my_config，通过修改my_config，可定制图表的外观。truncate_label将较长的项目名缩短为15个字符。show_y_guides为False将隐藏图表中的水平线。width为自定义宽度，让图表更充分地利用浏览器中的可用空间。</p>
<h3 id="添加自定义工具提示"><a href="#添加自定义工具提示" class="headerlink" title="添加自定义工具提示"></a>添加自定义工具提示</h3><p>在Pygal中，将鼠标指向条形将显示它表示的信息，这通常称为<strong>工具提示</strong>。在这个示例中，当前显示的是项目获得了多少个星。我们向add()传递字典列表，而不是值列表。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> LightColorizedStyle <span class="keyword">as</span> LCS,LightenStyle <span class="keyword">as</span> LS</span><br><span class="line"></span><br><span class="line">my_style = LS(<span class="string">'# '</span>,base_style=LCS)</span><br><span class="line">chart = pygal.Bar(style=my_style,x_label_rotation=<span class="number">45</span>,show_legend=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">chart.title = <span class="string">'Python Project'</span></span><br><span class="line">chart.x_labels = [<span class="string">'httpie'</span>,<span class="string">'django'</span>,<span class="string">'flask'</span>]</span><br><span class="line"></span><br><span class="line">plot_dicts = [</span><br><span class="line">    {<span class="string">'value'</span>:<span class="number">16101</span>,<span class="string">'label'</span>:<span class="string">'Description of httpie.'</span>},</span><br><span class="line">    {<span class="string">'value'</span>:<span class="number">15028</span>,<span class="string">'label'</span>:<span class="string">'Description of django.'</span>},</span><br><span class="line">    {<span class="string">'value'</span>:<span class="number">14798</span>,<span class="string">'label'</span>:<span class="string">'Description of flask'</span>}</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">chart.add(<span class="string">''</span>,plot_dicts)</span><br><span class="line">chart.render_to_file(<span class="string">'bar_description.svg'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_26.png" alt="屏幕快照 2017-09-24 下午3.06.59"></p>
<p>每个字典都包含两个键：“value”和“label”。Pygal根据与键“value”相关联的数字来确定条形的高度，并使用“label”相关联的字符串给条形创建工具。</p>
<h3 id="根据数据绘图"><a href="#根据数据绘图" class="headerlink" title="根据数据绘图"></a>根据数据绘图</h3><p>为根据数据绘图，我们将自动生成plot_dicts，其中包含API调用的30个项目的信息。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">--snip--</span><br><span class="line"><span class="comment">#搜索有关仓库的信息</span></span><br><span class="line">repo_dicts = response_dict[<span class="string">'items'</span>]</span><br><span class="line"></span><br><span class="line">names,plot_dicts = [],[]</span><br><span class="line"><span class="keyword">for</span> repo_dict <span class="keyword">in</span> repo_dicts:</span><br><span class="line">  names.append(repo_dict[<span class="string">'name'</span>])</span><br><span class="line">  </span><br><span class="line">  plot_dict = {</span><br><span class="line">      <span class="string">'value'</span>:repo_dict[<span class="string">'stargazers_count'</span>],</span><br><span class="line">      <span class="string">'label'</span>:repo_dict[<span class="string">'description'</span>],</span><br><span class="line">  }</span><br><span class="line">  plot_dicts.append(plot_dict)</span><br><span class="line"></span><br><span class="line">--snip--</span><br><span class="line"></span><br><span class="line">chart.add(<span class="string">''</span>,plot_dicts)</span><br><span class="line"></span><br><span class="line">--snip--</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="/images/Python-base/DataView_27.png" alt="屏幕快照 2017-09-24 下午3.23.21"></p>
<h3 id="在图表中添加可单击的链接"><a href="#在图表中添加可单击的链接" class="headerlink" title="在图表中添加可单击的链接"></a>在图表中添加可单击的链接</h3><p>Pygal允许你将图表中的每个条形用作网站的相应链接。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">--snip--</span><br><span class="line"> </span><br><span class="line"> plot_dict = {</span><br><span class="line">     <span class="string">'value'</span>:repo_dict[<span class="string">'stargazers_count'</span>],</span><br><span class="line">     <span class="string">'label'</span>:repo_dict[<span class="string">'description'</span>],</span><br><span class="line">     <span class="string">'xlink'</span>:repo_dict[<span class="string">'html_url'</span>],</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> --snip--</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>DataView</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>iPython</tag>
        <tag>Pygal</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>/posts/14702/</url>
    <content><![CDATA[<h1 id="Python的安装、IPython的使用"><a href="#Python的安装、IPython的使用" class="headerlink" title="Python的安装、IPython的使用"></a>Python的安装、IPython的使用</h1><ul>
<li>Python的安装参见<a href="https://stringpiggy.hpd.io/mac-osx-python3-dual-install/">https://stringpiggy.hpd.io/mac-osx-python3-dual-install/</a> ，或者《Python编程：从入门到实战》一书中也有详细的记载。</li>
<li>利用IPython可以代替传统python开发的文本编辑器，灵活的改变所写代码，快捷的生成结果代码。IPython Notebook目前已经成为用Python做教学、计算、科研的一个重要工具，很多示例都是用.ipynb文件。</li>
</ul>
<p>​        安装Ipython有两种方式，第一种是通过pip安装。第二种是安装Anaconda从而获得iPython （这个选择比较适合新手，推荐<a href="http://jupyter.readthedocs.io/en/latest/install.html#new-to-python-and-jupyter">官网教程</a>一键搞定），下面主要介绍使用pip命令来安装。</p>
<ol>
<li>iPython是由<a href="http://ipython.org/ipython-doc/stable/install/install.html">很多模块</a>组成的, 为了不漏装任何组件，我用了这个命令来安装所有组件：</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ sudo pip install ipython[<span class="built_in">all</span>]</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>安装成功后通过这命令来运行Notebook</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ ipython notebook</span><br></pre></td></tr></tbody></table></figure>
<p>之后有可能会弹出这个错误(你如果选择了用Anaconda的方式来安装也会碰到这个错误)：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">ValueError, <span class="string">'unknown locale: %s'</span> % localename</span><br></pre></td></tr></tbody></table></figure>
<p>在<a href="http://stackoverflow.com/questions/19961239/pelican-3-3-pelican-quickstart-error-valueerror-unknown-locale-utf-8">StackOverflow上已经有人提出了解决方案</a>，在命令行里找到.bash_profile 然后添加下面两行代码：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">export LC_ALL=en_US.UTF-<span class="number">8</span></span><br><span class="line">export LANG=en_US.UTF-<span class="number">8</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后别忘了重新载入.bash_profile让新添加的代码生效（注意两个点之间的空格）：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">$ . .bash_profile</span><br></pre></td></tr></tbody></table></figure>
<p>之后再运行命令”ipython notebook “就可以在浏览器里看到iPython Notebook的界面了。</p>
<p>iPython Notebook的工作原理是在本地启动一个服务器，你通过localhost:8888/tree 这个地址就可以连接到这个服务器上与之通信。从而实现在浏览器里写代码，传给本地服务器执行，然后本地服务器传回结果并在网页上呈现这个循环。</p>
<p>每次使用完Notebook，只关闭网页本身是不够的。<strong>需要在你启动Notebook的那个Terminal里输 Ctrl + c 然后确认，才能把服务器关闭。</strong>官网具体链接为：<a href="http://IPython.org/install.html">http://IPython.org/install.html</a></p>
<a id="more"></a>
<h1 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量由字母、数字、下划线组成，但是必须以字母或下划线开头，并避免大写。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;message = <span class="string">'Hello Python world!'</span></span><br><span class="line">&gt;&gt;&gt;print(message)</span><br><span class="line">Hello Python world!</span><br></pre></td></tr></tbody></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>python中，用引号括起来的就是字符串，不论是单引号还是双引号，但是必须成对，不可混用。。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span>+<span class="number">8</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'5+8'</span></span><br><span class="line"><span class="string">'5+8'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'5'</span>+<span class="string">'8'</span></span><br><span class="line"><span class="string">'58'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'let\'s go'</span></span><br><span class="line"><span class="string">"let's go"</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="修改字符串的大小写"><a href="#修改字符串的大小写" class="headerlink" title="修改字符串的大小写"></a>修改字符串的大小写</h3><ul>
<li>title()：以首字母大写的方式显示每个单词</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> name = <span class="string">"ada love alce"</span></span><br><span class="line"><span class="number">2</span> print(name.title())</span><br><span class="line">Ada Love Alce</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>upper()：将字符串全部改为大写</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> name = <span class="string">"ada love alce"</span></span><br><span class="line"><span class="number">2</span> print(name.upper())</span><br><span class="line">ADA LOVE ALCE</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>lower()：将字符串全部改为小写</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> name = <span class="string">"ada love alce"</span></span><br><span class="line"><span class="number">2</span> print(name.lower())</span><br><span class="line">ada love alce</span><br></pre></td></tr></tbody></table></figure>
<h3 id="合并字符串"><a href="#合并字符串" class="headerlink" title="合并字符串"></a>合并字符串</h3><p>python中使用 “+” 来合并字符串</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> first_name = <span class="string">"ada"</span></span><br><span class="line"><span class="number">2</span> last_name = <span class="string">"alace"</span></span><br><span class="line"><span class="number">3</span> full_name = first_name + <span class="string">" "</span> + last_name</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> message = <span class="string">"Hello,"</span> + full_name.title() + <span class="string">"!"</span></span><br><span class="line"><span class="number">5</span> print(message)</span><br><span class="line"></span><br><span class="line">Hello,Ada Alace!</span><br></pre></td></tr></tbody></table></figure>
<h3 id="制表符与换行符"><a href="#制表符与换行符" class="headerlink" title="制表符与换行符"></a>制表符与换行符</h3><p>制表符“\t”、换行符“\n ”</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> print(<span class="string">"language:\n\tPython\n\tC\n\tJavaScript"</span>)</span><br><span class="line">language:</span><br><span class="line">	Python</span><br><span class="line">	C</span><br><span class="line">	JavaScript</span><br></pre></td></tr></tbody></table></figure>
<h3 id="删除空白"><a href="#删除空白" class="headerlink" title="删除空白"></a>删除空白</h3><p> 找出字符串开头和末尾多余的空白。去末尾空白rstrip()，开头lstrip()、 开头和末尾strip()</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> favourite_language = <span class="string">" python "</span></span><br><span class="line"><span class="number">2</span> favourite_language.rstrip()</span><br><span class="line"><span class="string">' python'</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> favourite_language.lstrip()</span><br><span class="line"><span class="string">'python '</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> favourite_language.strip()</span><br><span class="line"><span class="string">'python'</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> favourite_language</span><br><span class="line"><span class="string">' python '</span></span><br></pre></td></tr></tbody></table></figure>
<p>但是当输出favourite_language的值时，发现并没有改变。要永久删除这个字符串中的空白，必须将删除结果存回到变量中。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> favourite_language =<span class="string">" python "</span></span><br><span class="line"><span class="number">2</span> favourite_language = favourite_language.strip()</span><br><span class="line"><span class="number">3</span> favourite_language</span><br><span class="line"><span class="string">'python'</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用字符串时避免语法错误"><a href="#使用字符串时避免语法错误" class="headerlink" title="使用字符串时避免语法错误"></a>使用字符串时避免语法错误</h3><p>例如，当使用单引号标明一个字符串时，如果字符串中间出现了撇号，那么python解释器可能无法识别。这时将单引号改成双引号即可。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> message = <span class="string">'One of Python'</span>s strengths <span class="keyword">is</span> its diverse community<span class="string">' message</span></span><br><span class="line"><span class="string">2 message</span></span><br><span class="line"><span class="string">File "&lt;ipython-input-24-e0db9437bcf6&gt;", line 1</span></span><br><span class="line"><span class="string">    message = '</span>One of Python<span class="string">'s strengths is its diverse community'</span> message</span><br><span class="line">                             ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> message = <span class="string">"One of Python's strengths is its diverse community"</span> </span><br><span class="line"><span class="number">2</span> message</span><br><span class="line"><span class="string">"One of Python's strengths is its diverse community"</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h3><p>原始字符串，只需在字符串前加上一个‘r’即可(用来处理字符串中若出现多个转义字符的情况)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">'C:\note'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">str</span>)</span><br><span class="line">C:</span><br><span class="line">ote</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">'C:\\note'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">str</span>)</span><br><span class="line">C:\note</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>  = <span class="string">r'C:\note\noat\rnate'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">str</span>)</span><br><span class="line">C:\note\noat\rnate</span><br></pre></td></tr></tbody></table></figure>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>(+)(-)(<em>)(/）、(*</em>)代表乘方运算</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> ** <span class="number">3</span></span><br><span class="line"><span class="number">27</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1.5e11</span></span><br><span class="line"><span class="number">150000000000.0</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="类型转换与比较"><a href="#类型转换与比较" class="headerlink" title="类型转换与比较"></a>类型转换与比较</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"520"</span>   <span class="comment">#Transfer，str-&gt;int</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">int</span>(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)</span><br><span class="line"><span class="number">520</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">23</span>   <span class="comment">#Transfer，int-&gt;str</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">"Happy "</span> + <span class="built_in">str</span>(age) +<span class="string">"rd Birthday!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message</span><br><span class="line"><span class="string">'Happy 23rd Birthday!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"520"</span>   <span class="comment">#比较类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; a = "小"</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(a,<span class="built_in">str</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>用“#”标明。</p>
<h2 id="Python常用操作符"><a href="#Python常用操作符" class="headerlink" title="Python常用操作符"></a>Python常用操作符</h2><ul>
<li>算术运算符： “+、 -、<em>、 /、 +=、-=、*</em>、//、%”</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">3</span> ** <span class="number">2</span>   //<span class="number">3</span>^<span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>比较操作符：“&gt;、&lt;、&gt;=、&lt;=”</li>
<li>逻辑运算符：not &gt; and &gt; or</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">3</span>&lt;<span class="number">4</span>&lt;<span class="number">5</span>   //等同于（<span class="number">3</span>&lt;<span class="number">4</span>）<span class="keyword">and</span> (<span class="number">4</span>&lt;<span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>优先级问题</p>
<p>幂运算&gt;正负号&gt;算数操作符&gt;比较操作符&gt;逻辑操作符</p>
</li>
</ul>
<h2 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a>Python之禅</h2><p>Python程序员笃信代码可以编写得漂亮而优雅。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">import</span> this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="keyword">is</span> better than <span class="built_in">complex</span>.</span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">'t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now <span class="keyword">is</span> better than never.</span><br><span class="line">Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it<span class="string">'s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let'</span>s do more of those!</span><br></pre></td></tr></tbody></table></figure>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>列表存储一系列元素，Python中，用“[]” 来表示列表，并用“,”来分隔其中的元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> bicycle = [<span class="string">'trek'</span>,<span class="string">'cannodale'</span>,<span class="string">'redline'</span>,<span class="string">'specialized'</span>]</span><br><span class="line"><span class="number">2</span> print(bicycle)</span><br><span class="line">[<span class="string">'trek'</span>, <span class="string">'cannodale'</span>, <span class="string">'redline'</span>, <span class="string">'specialized'</span>]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h3><p>指出该元素的索引即可。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> print(bicycle[<span class="number">0</span>])</span><br><span class="line">trek</span><br></pre></td></tr></tbody></table></figure>
<p>应该灵活的与字符串内容结合起来。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> names = [<span class="string">'jones'</span>,<span class="string">'lace'</span>,<span class="string">'grace'</span>]</span><br><span class="line"><span class="number">2</span> <span class="keyword">for</span> each <span class="keyword">in</span> names:			  <span class="comment">#“:”不可少</span></span><br><span class="line"><span class="number">3</span>   print(each.title(),end=<span class="string">' '</span>)    <span class="comment">#此处需要缩进</span></span><br><span class="line">Jones Lace Grace </span><br></pre></td></tr></tbody></table></figure>
<p>索引从“0”开始，<strong>值得注意的是，当要访问最后一个元素，可以指定索引为“-1”，索引-2返回倒数第二个列表元素，以此类推。</strong></p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ul>
<li>在列表末尾添加新元素:append()</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> names.append(<span class="string">'Benedict'</span>)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在列表中插入元素:insert()</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> names.insert(<span class="number">0</span>,<span class="string">"Angela"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ul>
<li>使用<strong>del语句</strong>删除元素（知道位置）,<strong>删除后无法继续访问</strong>。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">del</span> names[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用<strong>方法pop()</strong>删除元素，<strong>弹出后可以继续访问。</strong></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> poped_person = names.pop()   <span class="comment">#无参弹出末尾元素</span></span><br><span class="line"><span class="number">2</span> poped_person</span><br><span class="line">Benedict</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> poped_person = names.pop(<span class="number">0</span>)  <span class="comment">#带参弹出指定元素</span></span><br><span class="line"><span class="number">2</span> poped_person</span><br><span class="line">lace</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>根据值删除元素<strong>remove()</strong>。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> names</span><br><span class="line">[<span class="string">'grace'</span>, <span class="string">'benedict'</span>, <span class="string">'lace'</span>, <span class="string">'jones'</span>, <span class="string">'grace'</span>, <span class="string">'benedict'</span>, <span class="string">'lace'</span>, <span class="string">'jones'</span>]</span><br><span class="line">names.remove(<span class="string">'jones'</span>)</span><br><span class="line">names</span><br><span class="line">[<span class="string">'grace'</span>, <span class="string">'benedict'</span>, <span class="string">'lace'</span>, <span class="string">'grace'</span>, <span class="string">'benedict'</span>, <span class="string">'lace'</span>, <span class="string">'jones'</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到，remove()只删除第一个’jones’。 删除所有，使用while</p>
<h3 id="组织列表"><a href="#组织列表" class="headerlink" title="组织列表"></a>组织列表</h3><ul>
<li>使用<strong>sort()</strong>方法对列表进行<strong>永久性</strong>排序</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> cars = [<span class="string">'baoma'</span>,<span class="string">'zoka'</span>,<span class="string">'dazhong'</span>]</span><br><span class="line"><span class="number">2</span> cars.sort();				 <span class="comment">#正序</span></span><br><span class="line"><span class="number">3</span> print(cars)</span><br><span class="line">[<span class="string">'baoma'</span>, <span class="string">'dazhong'</span>, <span class="string">'zoka'</span>]</span><br><span class="line"><span class="number">4</span> cars.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="number">5</span> cars</span><br><span class="line">[<span class="string">'zoka'</span>, <span class="string">'dazhong'</span>, <span class="string">'baoma'</span>] <span class="comment">#倒序</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用<strong>sorted()</strong>方法对列表进行<strong>临时</strong>排序</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> print(<span class="built_in">sorted</span>(cars))		<span class="comment">#注意写法</span></span><br><span class="line"><span class="number">2</span> cars</span><br><span class="line">[<span class="string">'baoma'</span>, <span class="string">'dazhong'</span>, <span class="string">'zoka'</span>]</span><br><span class="line">[<span class="string">'zoka'</span>, <span class="string">'dazhong'</span>, <span class="string">'baoma'</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> print(<span class="built_in">sorted</span>(cars,reverse = <span class="literal">True</span>)) <span class="comment">#也可指定顺序</span></span><br><span class="line">[<span class="string">'zoka'</span>, <span class="string">'dazhong'</span>, <span class="string">'baoma'</span>]</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>倒序函数<strong>reverse()</strong></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> cars.reverse()</span><br><span class="line"><span class="number">2</span> cars</span><br><span class="line">[<span class="string">'zoka'</span>, <span class="string">'dazhong'</span>, <span class="string">'baoma'</span>]</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>列表长度<strong>len()</strong></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="built_in">len</span>(cars)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="操作列表"><a href="#操作列表" class="headerlink" title="操作列表"></a>操作列表</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> magicians = [<span class="string">'alace'</span>,<span class="string">'brown'</span>,<span class="string">'danny'</span>,<span class="string">'li'</span>]</span><br><span class="line"><span class="number">2</span> <span class="keyword">for</span> magician <span class="keyword">in</span> magicians:				<span class="comment">#冒号</span></span><br><span class="line"><span class="number">3</span>    print(<span class="string">"magician:"</span>+magician+<span class="string">"your trick is so amazing!\n"</span>)</span><br><span class="line"><span class="number">4</span>    print(<span class="string">"I can't wait to see your next"</span>)</span><br><span class="line"><span class="number">5</span> print(<span class="string">"Thank u,everyone.That was a great magic show!"</span>)</span><br><span class="line"></span><br><span class="line">magician:alaceyour trick <span class="keyword">is</span> so amazing!</span><br><span class="line"></span><br><span class="line">I can<span class="string">'t wait to see your next</span></span><br><span class="line"><span class="string">magician:brownyour trick is so amazing!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I can'</span>t wait to see your <span class="built_in">next</span></span><br><span class="line">magician:dannyyour trick <span class="keyword">is</span> so amazing!</span><br><span class="line"></span><br><span class="line">I can<span class="string">'t wait to see your next</span></span><br><span class="line"><span class="string">magician:liyour trick is so amazing!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I can'</span>t wait to see your <span class="built_in">next</span></span><br><span class="line">Thank u,everyone.That was a great magic show!</span><br></pre></td></tr></tbody></table></figure>
<p>注意：</p>
<ol>
<li><p>Python根据缩进来判断代码行与前一个代码行的关系。</p>
</li>
<li><p>在for循环的后面，每个缩进的代码行都是循环的一部分，没有缩进的代码都只执行一次。</p>
</li>
<li><p>for语句末尾的冒号告诉Python，下一行是循环的第一行。</p>
</li>
</ol>
<h3 id="创建数值列表-range"><a href="#创建数值列表-range" class="headerlink" title="创建数值列表:range()"></a>创建数值列表:range()</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line"><span class="number">2</span>   print(value)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>
<p>差一行为，所以并不会打印数字“5”。</p>
<p>要创建数字列表:</p>
<ol>
<li>可使用<strong>list()</strong>将<strong>range()</strong>的结果直接转换为列表。</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line"><span class="number">2</span> numbers</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>使用循环，利用列表函数</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> squares = []     <span class="comment">#输出1`10的平方</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line"><span class="number">3</span>     square = value**<span class="number">2</span></span><br><span class="line"><span class="number">4</span>     squares.append(square)</span><br><span class="line"><span class="number">5</span> print(squares)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>range()还可以设置步长，按指定步长增长。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> even_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>,<span class="number">2</span>))   <span class="comment">#设置步长为2，输出2～11之间的偶数</span></span><br><span class="line"><span class="number">2</span> print(even_numbers)</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="对数字列表进行简单的统计计算"><a href="#对数字列表进行简单的统计计算" class="headerlink" title="对数字列表进行简单的统计计算"></a>对数字列表进行简单的统计计算</h3><p><strong>min()、max()、sum()</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> digits = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="number">2</span> <span class="built_in">min</span>(digits)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="built_in">max</span>(digits)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="built_in">sum</span>(digits)</span><br><span class="line"><span class="number">28</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h3><p>更加简洁的创建列表的方式。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line"><span class="number">2</span> print(squares)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="使用列表的一部分—-列表切片"><a href="#使用列表的一部分—-列表切片" class="headerlink" title="使用列表的一部分—-列表切片"></a>使用列表的一部分—-列表切片</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> players = [<span class="string">'charles'</span>,<span class="string">'martina'</span>,<span class="string">'florence'</span>]</span><br><span class="line"><span class="number">2</span> print(players[<span class="number">0</span>:<span class="number">3</span>])    <span class="comment">#第一个元素到第三个元素，输出下标0～2的元素</span></span><br><span class="line">[<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'florence'</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>与range()一样，python在达到第二个数字“3”后<strong>停止</strong>，所以只输出三个元素。</p>
<p>负数索引返回离列表末尾相应距离的元素，因此可以输出列表末尾的任何切片。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> print(players[-<span class="number">3</span>:])    <span class="comment">#打印最后三名队员的名字</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="遍历切片"><a href="#遍历切片" class="headerlink" title="遍历切片"></a>遍历切片</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">for</span> player <span class="keyword">in</span> players[<span class="number">0</span>:<span class="number">3</span>]:</span><br><span class="line"><span class="number">2</span>  print(player.title())   <span class="comment">#打印前三名队员的名字</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="复制列表"><a href="#复制列表" class="headerlink" title="复制列表"></a>复制列表</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> my_foods = [<span class="string">'pizza'</span>,<span class="string">'falafel'</span>,<span class="string">'carrot'</span>]</span><br><span class="line"><span class="number">2</span> friend_foods = my_foods[:] <span class="comment">#这里不等同于friend_foods = my_foods</span></span><br><span class="line"><span class="number">3</span> friend_foods</span><br><span class="line">[<span class="string">'pizza'</span>, <span class="string">'falafel'</span>, <span class="string">'carrot'</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> friend_foods = my_foods[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span> friend_foods</span><br><span class="line">[<span class="string">'pizza'</span>]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注：friend_foods = my_foods[:] 与 friend_foods = my_foods的区别：</strong></p>
<p>friend_foods = my_foods[:]，是将my_foods的副本<strong>存储到</strong>friend_foods 中，因此会产生两个列表。</p>
<p>而friend_foods = my_foods，是将新变量friend_foods<strong>关联到</strong>my_foods列表，因此这两个列表都指向同一个列表</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>列表非常适合用于存储在程序运行期间可能变化的数据集。但有时你需要创建一系列<strong>不可修改的元素</strong>。不可变的列表被称为元组。</p>
<h3 id="定义元组"><a href="#定义元组" class="headerlink" title="定义元组"></a>定义元组</h3><p>元组采用圆括号而不是方括号来标识。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> dimensions = (<span class="number">200</span>,<span class="number">50</span>)   <span class="comment">#定义</span></span><br><span class="line"><span class="number">2</span> print(dimensions[<span class="number">0</span>])	 <span class="comment">#访问</span></span><br><span class="line"><span class="number">3</span> print(dimensions[<span class="number">1</span>])</span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>注</strong>：Python规定不能给元组的元素赋值。因此类似于</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> dimension[<span class="number">0</span>] = <span class="number">30</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>是禁止的。</strong></p>
<h3 id="遍历元组"><a href="#遍历元组" class="headerlink" title="遍历元组"></a>遍历元组</h3><p>同列表语法</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">for</span> dimension <span class="keyword">in</span> dimensions:</span><br><span class="line"><span class="number">2</span>   print(dimension)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="修改元组变量"><a href="#修改元组变量" class="headerlink" title="修改元组变量"></a>修改元组变量</h3><p>虽然不能修改元组的元素，但可以给存储元组的变量赋值。因此，若需要修改dimensions，可重新定义整个元组</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> dimensions = (<span class="number">400</span>,<span class="number">100</span>) <span class="comment">#重新定义</span></span><br></pre></td></tr></tbody></table></figure>
<p>元组的删除是python自动执行的。无需自动删除。</p>
<h2 id="设置代码格式"><a href="#设置代码格式" class="headerlink" title="设置代码格式"></a>设置代码格式</h2><p>  <a href="https://python.org/dev/peps/pep-0008/">PEP 8官网</a></p>
<ol>
<li><p>缩进：PEP 8建议每级缩进都使用4个空格。（或者设置制表符为4个空格）</p>
</li>
<li><p>行长：建议每行不超过80字符。</p>
</li>
<li><p>空行：使用空行将程序的不同部分分开。</p>
</li>
</ol>
<h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li>一个条件</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> cars = [<span class="string">'audi'</span>,<span class="string">'benchi'</span>,<span class="string">'bmw'</span>,<span class="string">'haha'</span>]</span><br><span class="line"><span class="number">2</span> <span class="keyword">for</span> car <span class="keyword">in</span> cars:</span><br><span class="line"><span class="number">3</span>   <span class="keyword">if</span> car == <span class="string">'bmw'</span>:      <span class="comment">#注意这里字符串比较直接用’==‘ 不相等用“！=”</span></span><br><span class="line"><span class="number">4</span>       print(car.upper())</span><br><span class="line"><span class="number">5</span>   <span class="keyword">else</span>:</span><br><span class="line"><span class="number">6</span>       print(car.title())</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意”:“的使用，注意缩行。</strong>并且，python比较相等时<strong>区分大小写</strong>。</p>
<ul>
<li>多个条件: “and””or”</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> age0 = <span class="number">0</span></span><br><span class="line"><span class="number">2</span> age1 = <span class="number">1</span></span><br><span class="line"><span class="number">3</span> age0 &gt;= <span class="number">21</span> <span class="keyword">and</span> age1 &gt;= <span class="number">21</span></span><br><span class="line">FALSE</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>检查特定值是否包含在列表中 <strong>“in、not in”</strong></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> request_toppings = [<span class="string">'mushrooms'</span>,<span class="string">'onions'</span>,<span class="string">'pineapple'</span>,]</span><br><span class="line"><span class="number">2</span> <span class="string">'mushrooms'</span> <span class="keyword">in</span> request_toppings</span><br><span class="line">TRUE</span><br></pre></td></tr></tbody></table></figure>
<h2 id="if-elif-else-与-if-if-if"><a href="#if-elif-else-与-if-if-if" class="headerlink" title="if-elif-else 与 if-if-if"></a>if-elif-else 与 if-if-if</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> age = <span class="number">12</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line"><span class="number">3</span>     price = <span class="number">0</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line"><span class="number">5</span>     price = <span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">else</span>:</span><br><span class="line"><span class="number">7</span>     price = <span class="number">10</span></span><br><span class="line"><span class="number">8</span> print(<span class="string">"Your admission cost is $"</span> + <span class="built_in">str</span>(price) +<span class="string">"."</span>)</span><br><span class="line">Your admission cost <span class="keyword">is</span> $<span class="number">5.</span></span><br></pre></td></tr></tbody></table></figure>
<p>总之，如果你只想执行一个代码块，就使用if-else-if 结构；如果要运行多个代码块，就使用一系列独立的if语句。</p>
<h2 id="确定列表是否为空"><a href="#确定列表是否为空" class="headerlink" title="确定列表是否为空"></a>确定列表是否为空</h2><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> requested_toppings = []</span><br><span class="line"><span class="number">2</span> <span class="keyword">if</span> requested_toppings:</span><br><span class="line"><span class="number">3</span>     <span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line"><span class="number">4</span>        print(<span class="string">"Adding "</span>+ requested_topping + <span class="string">"."</span>)</span><br><span class="line"><span class="number">5</span> <span class="keyword">else</span>:												<span class="comment">#缩进位置一定要正确，否则运行错误。</span></span><br><span class="line"><span class="number">6</span>     print(<span class="string">"Are u sure u want to a plain pizza?"</span>)</span><br><span class="line">Are u sure u want to a plain pizza?</span><br></pre></td></tr></tbody></table></figure>
<p><strong>注：在if语句中将列表名用在条件表达式中时，Python将在列表至少包含一个元素时返回True，并在列表为空时返回False。</strong></p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>将相关信息联系起来的字典。</p>
<h2 id="一个简单的字典"><a href="#一个简单的字典" class="headerlink" title="一个简单的字典"></a>一个简单的字典</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> alien_0 = {<span class="string">'color'</span>:<span class="string">'green'</span>,<span class="string">'points'</span>:<span class="number">5</span>}</span><br><span class="line"><span class="number">2</span> print(alien_0[<span class="string">'color'</span>])</span><br><span class="line"><span class="number">3</span> print(alien_1[<span class="string">'points'</span>])</span><br><span class="line">green</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h2><p>在Python中，字典时一系列<strong>”键-值“</strong>对。每个键都与一个值相关联，值可以是Python中的任何对象。</p>
<h3 id="访问字典中的值"><a href="#访问字典中的值" class="headerlink" title="访问字典中的值"></a>访问字典中的值</h3><p>要获取与键相关联的值，可依次指定字典名和放在方括号内的键。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> print(alien_0[<span class="string">'color'</span>])</span><br><span class="line">green</span><br></pre></td></tr></tbody></table></figure>
<h3 id="添加键-值对"><a href="#添加键-值对" class="headerlink" title="添加键-值对"></a>添加键-值对</h3><p>依次指定字典名、键、值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> alien_0[<span class="string">'x_position'</span>] = <span class="number">0</span></span><br><span class="line"><span class="number">2</span> alien_0[<span class="string">'y_position'</span>] = <span class="number">25</span></span><br><span class="line"><span class="number">3</span> print(alien_0)</span><br><span class="line">{<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>, <span class="string">'x_position'</span>: <span class="number">0</span>, <span class="string">'y_position'</span>: <span class="number">25</span>}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="创建空字典"><a href="#创建空字典" class="headerlink" title="创建空字典"></a>创建空字典</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> alien_0 = {}        <span class="comment">#定义空字典</span></span><br><span class="line"><span class="number">2</span> alien_0[<span class="string">'color'</span>] = <span class="string">'green'</span></span><br><span class="line"><span class="number">3</span> alien_0[<span class="string">'points'</span>] = <span class="string">'5'</span></span><br><span class="line"><span class="number">4</span> print(alien_0)</span><br><span class="line">{<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="string">'5'</span>}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="修改字典中的值"><a href="#修改字典中的值" class="headerlink" title="修改字典中的值"></a>修改字典中的值</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> alien_0[<span class="string">'color'</span>] = <span class="string">'yellow'</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="删除键-值对"><a href="#删除键-值对" class="headerlink" title="删除键-值对"></a>删除键-值对</h3><p><strong>使用del语句</strong>将相应的键-值对彻底删除。使用del语句时，必须指定字典名和要删除的键。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> alien_0 = {<span class="string">'color'</span> : <span class="string">'green'</span>,<span class="string">'points'</span>: <span class="number">5</span>}</span><br><span class="line"><span class="number">2</span> print(alien_0)</span><br><span class="line">{<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>}</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">del</span> alien_0[<span class="string">'points'</span>]        <span class="comment">#删除键值对</span></span><br><span class="line"><span class="number">2</span> print(alien_0)</span><br><span class="line">{<span class="string">'color'</span>: <span class="string">'green'</span>}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="由类似对象组成的字典"><a href="#由类似对象组成的字典" class="headerlink" title="由类似对象组成的字典"></a>由类似对象组成的字典</h3><p>请注意下面字典的定义<strong>格式</strong>，还有print输出格式。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> favourite_languages = {					   <span class="comment">#将一个较大的字典放在了多行中，用',隔开</span></span><br><span class="line"><span class="number">2</span>    <span class="string">'jen'</span>: <span class="string">'python'</span>,</span><br><span class="line"><span class="number">3</span>     <span class="string">'sarah'</span>: <span class="string">'c'</span>,</span><br><span class="line"><span class="number">4</span>     <span class="string">'edward'</span>: <span class="string">'ruby'</span>,</span><br><span class="line"><span class="number">5</span>     <span class="string">'phil'</span>:<span class="string">'python'</span>,</span><br><span class="line"><span class="number">6</span> }</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span> print(<span class="string">"Sarah's favourite language is"</span> +      <span class="comment">#太长的print()可以用‘+’逻辑性的隔成多行。</span></span><br><span class="line"><span class="number">9</span>      favourite_languages[<span class="string">'sarah'</span>].title() +</span><br><span class="line"><span class="number">10</span>       <span class="string">'.'</span>)</span><br><span class="line">Sarah<span class="string">'s favourite language isC.</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h2><h3 id="遍历所有的键-值对-items"><a href="#遍历所有的键-值对-items" class="headerlink" title="遍历所有的键-值对:items()"></a>遍历所有的键-值对:items()</h3><p>现有字典</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> user_0 = {</span><br><span class="line"><span class="number">2</span>     <span class="string">'username'</span>:<span class="string">'efermi'</span>,</span><br><span class="line"><span class="number">3</span>     <span class="string">'first'</span>:<span class="string">'enrico'</span>,</span><br><span class="line"><span class="number">4</span>     <span class="string">'last'</span>:<span class="string">'femi'</span>,</span><br><span class="line"><span class="number">5</span> }</span><br></pre></td></tr></tbody></table></figure>
<p>使用for循环遍历字典</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">or</span> key,value <span class="keyword">in</span> user_0.items():</span><br><span class="line"><span class="number">2</span>     print(<span class="string">"\nkey:"</span> + key)</span><br><span class="line"><span class="number">3</span>     print(<span class="string">"Value:"</span> + value)</span><br></pre></td></tr></tbody></table></figure>
<p>item()方法返回一个键值对列表。注意，即使遍历字典时，键-值对的返回顺序也与存储顺序不同。Python不关系键-值对的存储顺序，而只跟踪键值之间的关联关系。</p>
<h3 id="遍历所有的键-keys"><a href="#遍历所有的键-keys" class="headerlink" title="遍历所有的键:keys()"></a>遍历所有的键:keys()</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">for</span> name <span class="keyword">in</span> user_0.keys():   <span class="comment">#方法keys()返回一个列表，包含字典中的所有键。</span></span><br><span class="line"><span class="number">2</span>     print(name.title())</span><br><span class="line">Username</span><br><span class="line">First</span><br><span class="line">Last</span><br></pre></td></tr></tbody></table></figure>
<p>遍历字典时，会默认遍历所有的键，因此，将’user0.keys(‘)改为’user_0’,输出不变。</p>
<p>这种循环中，<strong>可以使用当前键来访问与之相关联的值。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> favourite_languages = {				<span class="comment">#字典</span></span><br><span class="line"><span class="number">2</span>     <span class="string">'jen'</span>: <span class="string">'python'</span>,</span><br><span class="line"><span class="number">3</span>     <span class="string">'sarah'</span>: <span class="string">'c'</span>,</span><br><span class="line"><span class="number">4</span>     <span class="string">'edward'</span>: <span class="string">'ruby'</span>,</span><br><span class="line"><span class="number">5</span>     <span class="string">'phil'</span>:<span class="string">'python'</span>,</span><br><span class="line"><span class="number">6</span> }</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span> friends = [<span class="string">'phil'</span>,<span class="string">'sarah'</span>]			<span class="comment">#列表</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">for</span> name <span class="keyword">in</span> favourite_languages.keys():</span><br><span class="line"><span class="number">10</span>     print(name.title())</span><br><span class="line"><span class="number">11</span>    </span><br><span class="line"><span class="number">12</span>    <span class="keyword">if</span> name <span class="keyword">in</span> friends:</span><br><span class="line"><span class="number">13</span>        print(<span class="string">"Hi"</span> + name.title() +<span class="string">", I see your favourite_language is"</span> +</span><br><span class="line"><span class="number">14</span>             favourite_languages[name].title() + <span class="string">"!"</span>)     			<span class="comment">#访问字典的值</span></span><br></pre></td></tr></tbody></table></figure>
<p>字典总是明确地记录键和值之间的关联关系，但获取字典的元素时，获取顺序是不可预测的。要以特定的顺序返回元素，一种方法是在for循环中对返回的键进行排序。</p>
<h3 id="顺序遍历所有键-sorted"><a href="#顺序遍历所有键-sorted" class="headerlink" title="顺序遍历所有键:sorted()"></a>顺序遍历所有键:sorted()</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">sorted</span>(favourite_language.keys()):</span><br><span class="line"><span class="number">2</span>     print(name.title() + <span class="string">',thank u for taking the poll'</span>)</span><br><span class="line">Edward,thank u <span class="keyword">for</span> taking the poll</span><br><span class="line">Jen,thank u <span class="keyword">for</span> taking the poll</span><br><span class="line">Phil,thank u <span class="keyword">for</span> taking the poll</span><br><span class="line">Sarah,thank u <span class="keyword">for</span> taking the poll</span><br></pre></td></tr></tbody></table></figure>
<h3 id="遍历所有值-values"><a href="#遍历所有值-values" class="headerlink" title="遍历所有值:values()"></a>遍历所有值:values()</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">for</span> language <span class="keyword">in</span> favourite_languages.values():</span><br><span class="line"><span class="number">2</span>     print(<span class="string">"the favourite languages is "</span> + language.title())</span><br><span class="line">the favourite languages <span class="keyword">is</span> Python</span><br><span class="line">the favourite languages <span class="keyword">is</span> C</span><br><span class="line">the favourite languages <span class="keyword">is</span> Ruby</span><br><span class="line">the favourite languages <span class="keyword">is</span> Python</span><br></pre></td></tr></tbody></table></figure>
<p><strong>为剔除重复项，可使用集合set，集合类似于列表，但每个元素都必须是独一无二的。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">for</span> language <span class="keyword">in</span> <span class="built_in">set</span>(favourite_languages.values()):</span><br><span class="line"><span class="number">2</span>     print(<span class="string">"the favourite languages is "</span> + language.title())</span><br><span class="line">the favourite languages <span class="keyword">is</span> C</span><br><span class="line">the favourite languages <span class="keyword">is</span> Ruby</span><br><span class="line">the favourite languages <span class="keyword">is</span> Python</span><br></pre></td></tr></tbody></table></figure>
<h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>有时候，需要将一系列<strong>字典</strong>存储在列表中，或将<strong>列表</strong>作为值存储在字典中，这称为<strong>嵌套</strong>。</p>
<h3 id="字典列表"><a href="#字典列表" class="headerlink" title="字典列表"></a>字典列表</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> alien_0 = {<span class="string">'color'</span>:<span class="string">'green'</span>,<span class="string">'points'</span>:<span class="string">'5'</span>}     <span class="comment">#alien字典</span></span><br><span class="line"><span class="number">2</span> alien_1 = {<span class="string">'color'</span>:<span class="string">'yellow'</span>,<span class="string">'points'</span>:<span class="string">'10'</span>}</span><br><span class="line"><span class="number">3</span> alien_2 = {<span class="string">'color'</span>:<span class="string">'red'</span>,<span class="string">'points'</span>:<span class="string">'15'</span>}</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span> aliens = [alien_0,alien_1,alien_2]           <span class="comment">#aliens列表</span></span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">7</span> <span class="keyword">for</span> alien <span class="keyword">in</span> aliens:</span><br><span class="line"><span class="number">8</span>    print(alien)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="列表字典"><a href="#列表字典" class="headerlink" title="列表字典"></a>列表字典</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">#存储此pizza的信息</span></span><br><span class="line"><span class="number">1</span> pizza = {</span><br><span class="line"><span class="number">2</span>   <span class="string">'crust'</span>: <span class="string">'thick'</span>,</span><br><span class="line"><span class="number">3</span>   <span class="string">'toppings'</span>: [<span class="string">'mushrooms'</span>,<span class="string">'extra cheese'</span>],</span><br><span class="line"><span class="number">4</span> }</span><br><span class="line"><span class="number">5</span> <span class="comment">#概述所点的pizza</span></span><br><span class="line"><span class="number">6</span> print(<span class="string">"You ordered a "</span> + pizza[<span class="string">'crust'</span>] + <span class="string">'-crust pizza '</span> +</span><br><span class="line"><span class="number">7</span>      <span class="string">"with the following toppings:"</span>)</span><br><span class="line"><span class="number">8</span> </span><br><span class="line"><span class="number">9</span> <span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">'toppings'</span>]:</span><br><span class="line"><span class="number">10</span>    print(<span class="string">"\t"</span> + topping)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="字典字典"><a href="#字典字典" class="headerlink" title="字典字典"></a>字典字典</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> users = {</span><br><span class="line"><span class="number">2</span>     <span class="string">'GK'</span>: {</span><br><span class="line"><span class="number">3</span>       <span class="string">'first'</span>:<span class="string">'Grace'</span>,</span><br><span class="line"><span class="number">4</span>         <span class="string">'last'</span>: <span class="string">'Koo'</span>,</span><br><span class="line"><span class="number">5</span>         <span class="string">'location'</span>:<span class="string">'6Lanzhou'</span>,</span><br><span class="line"><span class="number">6</span>     },                            <span class="comment">#这是一个键值对，‘，’莫忘记</span></span><br><span class="line"><span class="number">7</span>     <span class="string">'BJ'</span>:{</span><br><span class="line"><span class="number">8</span>         <span class="string">'first'</span>:<span class="string">'Benedict'</span>,</span><br><span class="line"><span class="number">9</span>         <span class="string">'last'</span>:<span class="string">'Jin'</span>,</span><br><span class="line"><span class="number">10</span>        <span class="string">'location'</span>:<span class="string">'Yangzhou'</span>,</span><br><span class="line"><span class="number">11</span>     },</span><br><span class="line"><span class="number">12</span> } </span><br><span class="line"><span class="number">13</span> <span class="keyword">for</span> username,user_info <span class="keyword">in</span> users.items():</span><br><span class="line"><span class="number">14</span>        print(<span class="string">"\nUsername:"</span> + username)</span><br><span class="line"><span class="number">15</span>        full_name = user_info[<span class="string">'first'</span>] + <span class="string">" "</span> + user_info[<span class="string">"last"</span>]</span><br><span class="line"><span class="number">16</span>        location = user_info[<span class="string">'location'</span>]</span><br><span class="line"><span class="number">17</span>        </span><br><span class="line"><span class="number">18</span>        print(<span class="string">"\tFull name:"</span> + full_name.title())</span><br><span class="line"><span class="number">19</span>        print(<span class="string">"\tlocation: "</span> + location.title())</span><br><span class="line"></span><br><span class="line">Username:GK</span><br><span class="line">	Full name:Grace Koo</span><br><span class="line">	location: 6Lanzhou</span><br><span class="line"></span><br><span class="line">Username:BJ</span><br><span class="line">	Full name:Benedict Jin</span><br><span class="line">	location: Yangzhou</span><br></pre></td></tr></tbody></table></figure>
<h2 id="使用标准库中的Collection优化字典"><a href="#使用标准库中的Collection优化字典" class="headerlink" title="使用标准库中的Collection优化字典"></a>使用标准库中的Collection优化字典</h2><p>字典不记输入顺序，要记录键-值输入顺序，可使用模块collections中的OrderedDict类。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">favourite_languages = OrderedDict()</span><br><span class="line"></span><br><span class="line">favourite_languages[<span class="string">'jen'</span>] = <span class="string">'python'</span></span><br><span class="line">favourite_languages[<span class="string">'sarah'</span>] = <span class="string">'C'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name,language <span class="keyword">in</span> favourite_languages.items():</span><br><span class="line">  print(name.title() + <span class="string">"'s favourite language is"</span> +</span><br><span class="line">       language.title() + <span class="string">"."</span>)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="用户输入和while循环"><a href="#用户输入和while循环" class="headerlink" title="用户输入和while循环"></a>用户输入和while循环</h1><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> message = <span class="built_in">input</span>(<span class="string">"Tell me something,and I will repeat it back to u:"</span>)</span><br><span class="line"><span class="number">2</span> print(message)</span><br><span class="line">Tell me something,<span class="keyword">and</span> I will repeat it back to u:hello,python</span><br><span class="line">hello,python</span><br></pre></td></tr></tbody></table></figure>
<p>input接受一个参数，即向用户显示的信息。程序等待用户输入，并在用户按回车键后继续执行。输入存储变量在message中。</p>
<p>出于清晰考虑，若提示信息太长，可以使用以下方法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> prompt = <span class="string">"If you tell us who u are,we can personalize the message you see."</span></span><br><span class="line"><span class="number">2</span> prompt += <span class="string">"\nwhat is your first name?"</span>      <span class="comment">#在字符串末尾添加一个字符串</span></span><br><span class="line"><span class="number">3</span> name = <span class="built_in">input</span>(prompt)</span><br><span class="line"><span class="number">4</span> print(<span class="string">"\nHello,"</span> + name +<span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line">If you tell us who u are,we can personalize the message you see.</span><br><span class="line">what is your first name?Grace</span><br><span class="line"></span><br><span class="line">Hello,Grace!</span><br></pre></td></tr></tbody></table></figure>
<h2 id="用户输入input"><a href="#用户输入input" class="headerlink" title="用户输入input()"></a>用户输入input()</h2><h3 id="使用int-来获取数值输入"><a href="#使用int-来获取数值输入" class="headerlink" title="使用int()来获取数值输入"></a>使用int()来获取数值输入</h3><p>input()将用户输入的内容解释成字符串，但是如果用户只是想输入数值，就会遇到麻烦。对此，使用int()函数来将<strong>字符串转化为数值</strong>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> height = <span class="built_in">input</span>(<span class="string">"How tall are u,in inches?"</span>)</span><br><span class="line"><span class="number">2</span> height = <span class="built_in">int</span>(height)</span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="keyword">if</span> height  &gt;= <span class="number">36</span>:</span><br><span class="line"><span class="number">5</span>     print(<span class="string">"You are old enough to ride!"</span>)</span><br><span class="line"><span class="number">6</span> <span class="keyword">else</span>:</span><br><span class="line"><span class="number">7</span>     print(<span class="string">"\nYou'll be able to ride when you're a little older."</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="求模运算符“-”"><a href="#求模运算符“-”" class="headerlink" title="求模运算符“%”"></a>求模运算符“%”</h3><p>返回余数。可用来求奇偶性。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">4</span>%<span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="While循环简介"><a href="#While循环简介" class="headerlink" title="While循环简介"></a>While循环简介</h2><p>while循环不断的运行，直到指定的条件不满足为止。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> current_number = <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">while</span> current_number &lt;= <span class="number">5</span>:</span><br><span class="line"><span class="number">3</span>     print(current_number)</span><br><span class="line"><span class="number">4</span>     current_number += <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#获取用户输入，输入“quit”退出程序</span></span><br><span class="line"><span class="number">1</span> prompt = <span class="string">"\nTell me something,and I will repeat it back to u:"</span></span><br><span class="line"><span class="number">2</span> prompt += <span class="string">"\nEnter 'quit' to end the program."</span></span><br><span class="line"><span class="number">3</span> message = <span class="string">""</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">while</span> message != <span class="string">"quit"</span>:</span><br><span class="line"><span class="number">5</span>     message = <span class="built_in">input</span>(prompt)</span><br><span class="line"><span class="number">6</span>     <span class="keyword">if</span> message != <span class="string">'quit'</span>	        <span class="comment">#选择不打印quit</span></span><br><span class="line"><span class="number">7</span>     print(message)</span><br><span class="line"></span><br><span class="line">Tell me something,<span class="keyword">and</span> I will repeat it back to u:</span><br><span class="line">Enter <span class="string">'quit'</span> to end the program.ui</span><br><span class="line">ui</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用标志"><a href="#使用标志" class="headerlink" title="使用标志"></a>使用标志</h3><p><strong>在要求很多条件都必须满足才能继续运行的程序中</strong>，可定义一个变量，用于判断整个程序是否处于活跃状态。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#标志</span></span><br><span class="line"><span class="number">1</span> prompt = <span class="string">"\nTell me something,and I will repeat it back to u:"</span></span><br><span class="line"><span class="number">2</span> prompt += <span class="string">"\nEnter 'quit' to end the program."</span></span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> active = <span class="literal">True</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">while</span> active:</span><br><span class="line"><span class="number">6</span>     message = <span class="built_in">input</span>(prompt)</span><br><span class="line"><span class="number">7</span>     <span class="keyword">if</span> message == <span class="string">'quit'</span>:</span><br><span class="line"><span class="number">8</span>         active = <span class="literal">False</span></span><br><span class="line"><span class="number">9</span>     <span class="keyword">else</span>:</span><br><span class="line"><span class="number">10</span>         print(message)</span><br></pre></td></tr></tbody></table></figure>
<p>简化了while语句，因为<strong>不需要在其中作任何比较</strong>。</p>
<h3 id="使用break跳出循环"><a href="#使用break跳出循环" class="headerlink" title="使用break跳出循环"></a>使用break跳出循环</h3><p>使用break立即跳出while循环。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> prompt = <span class="string">"\nTell me something,and I will repeat it back to u:"</span></span><br><span class="line"><span class="number">2</span> prompt += <span class="string">"\nEnter 'quit' to end the program."</span></span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="number">5</span>     city = <span class="built_in">input</span>(prompt)</span><br><span class="line"><span class="number">6</span>     </span><br><span class="line"><span class="number">7</span>     <span class="keyword">if</span> city == <span class="string">"quit"</span>:</span><br><span class="line"><span class="number">8</span>         <span class="keyword">break</span></span><br><span class="line"><span class="number">9</span>     <span class="keyword">else</span>:</span><br><span class="line"><span class="number">10</span>        print(<span class="string">"I'd love to go to"</span> + city.title() + <span class="string">"!"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="在循环中使用continue"><a href="#在循环中使用continue" class="headerlink" title="在循环中使用continue"></a>在循环中使用continue</h3><p>返回到循环开头。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#打印奇数</span></span><br><span class="line"><span class="number">1</span> current_number = <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">while</span> current_number &lt;<span class="number">10</span>:</span><br><span class="line"><span class="number">3</span>     current_number += <span class="number">1</span></span><br><span class="line"><span class="number">4</span>     <span class="keyword">if</span> current_number %<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line"><span class="number">5</span>         <span class="keyword">continue</span></span><br><span class="line"><span class="number">6</span>     print(current_number)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="用while循环来处理列表和字典"><a href="#用while循环来处理列表和字典" class="headerlink" title="用while循环来处理列表和字典"></a>用while循环来处理列表和字典</h2><p><strong>通过将while循环同列表和字典结合起来使用，可收集、存储并组织大量输入</strong>，供以后查看和显示。</p>
<h3 id="在列表之间移动元素"><a href="#在列表之间移动元素" class="headerlink" title="在列表之间移动元素"></a>在列表之间移动元素</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> unconfirmed_users = [<span class="string">'alice'</span>,<span class="string">'brian'</span>,<span class="string">'cadace'</span>]     <span class="comment">#未验证用户</span></span><br><span class="line"><span class="number">2</span> confirmed_users = []								 <span class="comment">#已验证用户</span></span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="keyword">while</span> unconfirmed_users:</span><br><span class="line"><span class="number">5</span>     current_user = unconfirmed_users.pop()         <span class="comment">#删除未验证用户</span></span><br><span class="line"><span class="number">6</span>     print(<span class="string">"Verifying user:"</span> + current_user.title())</span><br><span class="line"><span class="number">7</span>     confirmed_users.append(current_user)			 <span class="comment">#添加到已验证用户</span></span><br><span class="line"><span class="number">8</span>     </span><br><span class="line"><span class="number">9</span> print(<span class="string">"\nThe following users have been confirmed:"</span>)</span><br><span class="line">10for confirmed_user <span class="keyword">in</span> confirmed_users:</span><br><span class="line"><span class="number">11</span>    print(confirmed_user.title())</span><br><span class="line"></span><br><span class="line">Verifying user:Cadace</span><br><span class="line">Verifying user:Brian</span><br><span class="line">Verifying user:Alice</span><br><span class="line"></span><br><span class="line">The following users have been confirmed:</span><br><span class="line">Cadace</span><br><span class="line">Brian</span><br><span class="line">Alice</span><br></pre></td></tr></tbody></table></figure>
<h3 id="删除包含特定值的所有列表元素"><a href="#删除包含特定值的所有列表元素" class="headerlink" title="删除包含特定值的所有列表元素"></a>删除包含特定值的所有列表元素</h3><p>函数remove()只删除一个特定元素，想要删除所有，使用while。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> pets = [<span class="string">'dog'</span>,<span class="string">'cat'</span>,<span class="string">'dog'</span>,<span class="string">'goldfish'</span>,<span class="string">'cat'</span>,<span class="string">'rabbit'</span>,<span class="string">'cat'</span>]</span><br><span class="line"><span class="number">2</span> print(pets)</span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="keyword">while</span> <span class="string">'cat'</span> <span class="keyword">in</span> pets:         <span class="comment">#使用while找到元素，再remove()一个。</span></span><br><span class="line"><span class="number">5</span>     pets.remove(<span class="string">'cat'</span>)</span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">7</span> print(pets)</span><br><span class="line"></span><br><span class="line">[<span class="string">'dog'</span>, <span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'goldfish'</span>, <span class="string">'cat'</span>, <span class="string">'rabbit'</span>, <span class="string">'cat'</span>]</span><br><span class="line">[<span class="string">'dog'</span>, <span class="string">'dog'</span>, <span class="string">'goldfish'</span>, <span class="string">'rabbit'</span>]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用用户输入来填充字典"><a href="#使用用户输入来填充字典" class="headerlink" title="使用用户输入来填充字典"></a>使用用户输入来填充字典</h3><p>可使用while循环提示用户输入任意数量的信息。将收集的信息存储在一个字典中，将回答同被调查者联系起来。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> responses = {}       				<span class="comment">#问卷字典</span></span><br><span class="line"><span class="number">2</span> polling_active = <span class="literal">True</span> 			<span class="comment">#标记</span></span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> <span class="keyword">while</span> polling_active:</span><br><span class="line"><span class="number">5</span>     name = <span class="built_in">input</span>(<span class="string">"\nWhat's your name?"</span>)</span><br><span class="line"><span class="number">6</span>     response = <span class="built_in">input</span>(<span class="string">"Which mountain would you like to climb someday?"</span>)</span><br><span class="line"><span class="number">7</span>     </span><br><span class="line"><span class="number">8</span>     responses[name] = response    <span class="comment">#将信息存储在字典中</span></span><br><span class="line"><span class="number">9</span>     </span><br><span class="line"><span class="number">10</span>    repeat = <span class="built_in">input</span>(<span class="string">"Would u like to let another person respond?(yes/no)"</span>)</span><br><span class="line"><span class="number">11</span>    <span class="keyword">if</span> repeat == <span class="string">'no'</span>:</span><br><span class="line"><span class="number">12</span>        polling_active = <span class="literal">False</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> print(<span class="string">"\n------Polling Results-------"</span>)</span><br><span class="line"><span class="number">15</span> <span class="keyword">for</span> name,response <span class="keyword">in</span> responses.items():</span><br><span class="line"><span class="number">16</span>    print(name + <span class="string">"would like to climb "</span> + response)</span><br><span class="line"></span><br><span class="line">What<span class="string">'s your name?grace</span></span><br><span class="line"><span class="string">Which mountain would you like to climb someday?huangshan</span></span><br><span class="line"><span class="string">Would u like to let another person respond?(yes/no)y</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">What's your name?benedict</span><br><span class="line">Which mountain would you like to climb someday?huangshan</span><br><span class="line">Would u like to let another person respond?(yes/no)no</span><br><span class="line"></span><br><span class="line">------Polling Results-------</span><br><span class="line">gracewould like to climb huangshan</span><br><span class="line">benedictwould like to climb huangshan</span><br></pre></td></tr></tbody></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>每个函数都应只负责一项具体的工作，这有助于将复杂的任务划分成一系列的步骤。</p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">greet_user</span>(<span class="params">username</span>):</span>     <span class="comment">#函数定义</span></span><br><span class="line"><span class="number">2</span>     print(<span class="string">"Hello，"</span> + username + <span class="string">"！"</span>)</span><br><span class="line"><span class="number">3</span> greet_user(<span class="string">"Grace"</span>)</span><br><span class="line">Hello,Grace!</span><br></pre></td></tr></tbody></table></figure>
<h2 id="传递实参"><a href="#传递实参" class="headerlink" title="传递实参"></a>传递实参</h2><h3 id="位置实参"><a href="#位置实参" class="headerlink" title="位置实参"></a>位置实参</h3><p>位置实参的顺序很重要，每个实参都必须关联到函数定义的一个形参。</p>
<h3 id="关键字实参"><a href="#关键字实参" class="headerlink" title="关键字实参"></a>关键字实参</h3><p>关键字实参是传递给函数的名称-值对。直接在实参中将名称和值关联起来了。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type,pet_name</span>):</span></span><br><span class="line"><span class="number">2</span>     print(<span class="string">"My pet is "</span> + animal_type + <span class="string">" It's name is "</span> + pet_name)</span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> describe_pet(pet_name = <span class="string">'harry'</span>,animal_type = <span class="string">'hamster'</span>)</span><br><span class="line">My pet <span class="keyword">is</span> hamster It<span class="string">'s name is harry</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type,pet_name = <span class="string">'harry'</span></span>):</span></span><br><span class="line"><span class="number">2</span>   print(<span class="string">"My pet is "</span> + animal_type + <span class="string">" It's name is "</span> + pet_name)</span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> describe_pet(animal_type = <span class="string">'hamster'</span>)</span><br><span class="line">My pet <span class="keyword">is</span> hamster It<span class="string">'s name is harry</span></span><br></pre></td></tr></tbody></table></figure>
<p>需要注意的是，如果实参中只提供了一个参数，Python依然将这个实参视为位置实参，即将把这个实参关联到函数中的第一个形参中。所以，下面的写法会导致错误。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type = <span class="string">'khah'</span>,pet_name</span>):</span></span><br><span class="line"><span class="number">2</span>     print(<span class="string">"My pet is "</span> + animal_type + <span class="string">" It's name is "</span> + pet_name)</span><br><span class="line"><span class="number">3</span>  </span><br><span class="line"><span class="number">4</span> describe_pet(pet_name = <span class="string">'hamster'</span>)</span><br><span class="line"></span><br><span class="line">File <span class="string">"&lt;ipython-input-13-1f3b75aa0373&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span>(<span class="params">animal_type = <span class="string">'khah'</span>,pet_name</span>):</span></span><br><span class="line">                    ^</span><br><span class="line">SyntaxError: non-default argument follows default argument</span><br></pre></td></tr></tbody></table></figure>
<p><strong>使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的形参。让python能够正确的解读出位置实参。</strong></p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span>(<span class="params">first_name,last_name</span>):</span></span><br><span class="line"><span class="number">2</span>     full_name = first_name + <span class="string">" "</span> + last_name</span><br><span class="line"><span class="number">3</span>     <span class="keyword">return</span> full_name.title()</span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">5</span> musician = get_formatted_name(<span class="string">"jimi"</span>,<span class="string">"hendrix"</span>)</span><br><span class="line"><span class="number">6</span> print(musician)</span><br><span class="line"></span><br><span class="line">Jimi Hendrix</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#检查名字，并输出</span></span><br><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">get_full_name</span>(<span class="params">first_name,last_name,middle_name = <span class="string">""</span></span>):</span></span><br><span class="line"><span class="number">2</span>     full_name = first_name + <span class="string">" "</span> + middle_name +<span class="string">" "</span>+ last_name</span><br><span class="line"><span class="number">3</span>     <span class="keyword">return</span> full_name.title()</span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">5</span> musician  = get_full_name(<span class="string">"jin"</span>,<span class="string">"hen"</span>)</span><br><span class="line"><span class="number">6</span> print(musician)</span><br><span class="line"><span class="number">7</span>     </span><br><span class="line"><span class="number">8</span> musician = get_full_name(<span class="string">"jin"</span>,<span class="string">"hen"</span>,<span class="string">"lee"</span>)</span><br><span class="line"><span class="number">9</span> print(musician)</span><br><span class="line"></span><br><span class="line">Jin  Hen</span><br><span class="line">Jin Lee Hen</span><br></pre></td></tr></tbody></table></figure>
<h3 id="返回字典"><a href="#返回字典" class="headerlink" title="返回字典"></a>返回字典</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">build_person</span>(<span class="params">first_name,last_name,age = <span class="string">''</span></span>):</span></span><br><span class="line"><span class="number">2</span>     person = {<span class="string">"first"</span>:first_name,<span class="string">"last"</span>:last_name}</span><br><span class="line"><span class="number">3</span>	  <span class="keyword">if</span> age:</span><br><span class="line"><span class="number">4</span>        person[<span class="string">'age'</span>] = age</span><br><span class="line"><span class="number">5</span>     <span class="keyword">return</span> person</span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">7</span> musician = build_person(<span class="string">"jimi"</span>,<span class="string">"hendix"</span>,age = <span class="number">27</span>)</span><br><span class="line"><span class="number">8</span> print(musician)</span><br><span class="line"></span><br><span class="line">{<span class="string">'first'</span>: <span class="string">'jimi'</span>, <span class="string">'last'</span>: <span class="string">'hendix'</span>,<span class="string">'age'</span>: <span class="number">27</span>}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="传递列表"><a href="#传递列表" class="headerlink" title="传递列表"></a>传递列表</h2><p>假设有一个用户列表，我们要问候其中的每位用户。下面示例将一个名字列表传递给一个名为greet_users()的函数</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">greet_users</span>(<span class="params">names</span>):</span></span><br><span class="line"><span class="number">2</span>     <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line"><span class="number">3</span>         msg = <span class="string">"Hello,"</span> + name.title() + <span class="string">"!"</span></span><br><span class="line"><span class="number">4</span>         print(msg)</span><br><span class="line"><span class="number">5</span> usernames = [<span class="string">'hannah'</span>,<span class="string">'ty'</span>,<span class="string">'margot'</span>]</span><br><span class="line"><span class="number">6</span> greet_users(usernames)</span><br><span class="line"></span><br><span class="line">Hello,Hannah!</span><br><span class="line">Hello,Ty!</span><br><span class="line">Hello,Margot!</span><br></pre></td></tr></tbody></table></figure>
<h3 id="禁止函数修改列表"><a href="#禁止函数修改列表" class="headerlink" title="禁止函数修改列表"></a>禁止函数修改列表</h3><p>可向函数传递列表的副本而不是原件，这样函数所做的任何修改都只影响副本，而丝毫不影响原件。</p>
<p><strong>切片表示法[:]创建列表的副本。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> function_name(list_name[:])</span><br></pre></td></tr></tbody></table></figure>
<p>以上的list调用方法将调用list_name的副本，保留原始的内容，除非有充分的理由需要传递副本，否则还是应该将原始列表传递给函数，因为副本将花费时间和内存，降低效率，在处理大型列表时尤其如此。</p>
<h2 id="传递任意数量的实参"><a href="#传递任意数量的实参" class="headerlink" title="传递任意数量的实参"></a>传递任意数量的实参</h2><p>有时候，你预先不知道函数需要接受多少个实参，好在Python允许函数从调用语句中收集任意数量的实参。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span>(<span class="params">*toppings</span>):</span></span><br><span class="line"><span class="number">2</span>     print(toppings)</span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span> make_pizza(<span class="string">'pepperoni'</span>)</span><br><span class="line"><span class="number">5</span> make_pizza(<span class="string">'mushrooms'</span>,<span class="string">'green peppers'</span>,<span class="string">'extra cheese'</span>)</span><br><span class="line"></span><br><span class="line">(<span class="string">'pepperoni'</span>,)</span><br><span class="line">(<span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>形参名toppings中的”<em>“让Python创建一个名为toppings的<strong>空元组</strong>，并将收到的所有值都封装到这个元组中。<em>*注意：Python将实参封装到一个元组中，即便函数只收到一个值也如此。</em></em></p>
<h3 id="结合使用位置实参和任意数量的实参"><a href="#结合使用位置实参和任意数量的实参" class="headerlink" title="结合使用位置实参和任意数量的实参"></a>结合使用位置实参和任意数量的实参</h3><p>Python先匹配位置实参和关键字实参，再<strong>将余下的实参都收集到最后一个形参中</strong>。</p>
<p>如前面的函数还需要一个size的实参，必须将该形参放在形参*toppings的前面。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span>(<span class="params">size,*toppings</span>):</span></span><br><span class="line"><span class="number">2</span>     print(<span class="string">"Making a"</span> + <span class="built_in">str</span>(size) + </span><br><span class="line"><span class="number">3</span>             <span class="string">"-inch pizza with the following toppings:"</span>)</span><br><span class="line"><span class="number">4</span>	  <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line"><span class="number">5</span>    	  print(<span class="string">"-"</span> + topping)</span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">7</span> make_pizza(<span class="string">'pepperoni'</span>)</span><br><span class="line"><span class="number">8</span> make_pizza(<span class="string">'mushrooms'</span>,<span class="string">'green peppers'</span>,<span class="string">'extra cheese'</span>)</span><br><span class="line"></span><br><span class="line">Making a16-inch pizza <span class="keyword">with</span> the following toppings:</span><br><span class="line">-pepperoni</span><br><span class="line">Making a12-inch pizza <span class="keyword">with</span> the following toppings:</span><br><span class="line">-mushrooms</span><br><span class="line">-green peppers</span><br><span class="line">-extra cheese</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用任意数量的关键字实参"><a href="#使用任意数量的关键字实参" class="headerlink" title="使用任意数量的关键字实参"></a>使用任意数量的关键字实参</h3><p>预先不知道传递给函数的会是什么样的信息。可将函数编写成能够接受任意数量的“键-值”对————调用语句提供多少就接受多少。（<strong>匹配成字典</strong>）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_profile</span>(<span class="params">first,last,**user_info</span>):</span></span><br><span class="line">    profile = {}</span><br><span class="line">    profile[<span class="string">'first_name'</span>] = first</span><br><span class="line">    profile[<span class="string">'last_name'</span>] = last</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> user_info.items():</span><br><span class="line">        profile[key] = value</span><br><span class="line">    <span class="keyword">return</span> profile</span><br><span class="line"></span><br><span class="line">  <span class="comment">#传递两个键值对，location='princeton',filed='physics'</span></span><br><span class="line">user_profile = build_profile(<span class="string">'albert'</span>,<span class="string">'einstein'</span>,location=<span class="string">'princeton'</span>,filed=<span class="string">'physics'</span>)</span><br><span class="line">print(user_profile)</span><br><span class="line"></span><br><span class="line">{<span class="string">'first_name'</span>: <span class="string">'albert'</span>, <span class="string">'last_name'</span>: <span class="string">'einstein'</span>, <span class="string">'location'</span>: <span class="string">'princeton'</span>, <span class="string">'filed'</span>: <span class="string">'physics'</span>}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="将函数存储在模块中"><a href="#将函数存储在模块中" class="headerlink" title="将函数存储在模块中"></a>将函数存储在模块中</h2><p>将函数存储在被称为<strong>模块</strong>的<em>独立文件</em>中，再将模块导入到主程序中，<strong>import</strong>语句允许在当前运行的程序文件中使用模块中的代码。</p>
<h3 id="导入整个模块"><a href="#导入整个模块" class="headerlink" title="导入整个模块"></a>导入整个模块</h3><p>要让函数是可导入的，得先创建模块。模块是扩展名为<em>.py</em>的文件，包含要导入到程序中的代码。</p>
<p>首先创建pizza.py文件，然后在pizza.py所在的目录中创建另一个名为making_pizza.py的文件，这个文件导入刚创建的模块，调用里面的函数两次。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pizza</span><br><span class="line"></span><br><span class="line">pizza.make_pizza(<span class="number">16</span>,<span class="string">'pepperoni'</span>)</span><br><span class="line">pizza.make_pizza(<span class="number">12</span>,<span class="string">'mushrooms'</span>,<span class="string">'green peppers'</span>,<span class="string">'extra cheese'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>Python读取这个文件时，<strong>代码行import pizza让Python打开文件pizza.py，并将其中的所有函数都复制到这个程序中。</strong></p>
<h3 id="导入特定的函数"><a href="#导入特定的函数" class="headerlink" title="导入特定的函数"></a>导入特定的函数</h3><p>导入模块中特定的函数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_name1,function_name2</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza</span><br><span class="line"></span><br><span class="line">make_pizza(<span class="number">16</span>,<span class="string">'pepperoni'</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>,<span class="string">'mushrooms'</span>,<span class="string">'green peppers'</span>,<span class="string">'extra cheese'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>由于在import中显式的使用了函数名，因此调用它无需只需指定其名称。</p>
<h3 id="使用as给函数指定别名"><a href="#使用as给函数指定别名" class="headerlink" title="使用as给函数指定别名"></a>使用as给函数指定别名</h3><p><strong>如果要导入的函数名称可能与程序中现有的名称冲突，或者函数名称太长，可指定别名。</strong>关键字<strong>as</strong>将函数重命名为你提供的别名。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line">mp(<span class="number">16</span>,<span class="string">'pepperoni'</span>)</span><br><span class="line">mp(<span class="number">12</span>,<span class="string">'mushrooms'</span>,<span class="string">'green peppers'</span>,<span class="string">'extra cheese'</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用as给模块指定别名"><a href="#使用as给模块指定别名" class="headerlink" title="使用as给模块指定别名"></a>使用as给模块指定别名</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pizza <span class="keyword">as</span> p</span><br><span class="line"></span><br><span class="line">p.make_pizza(<span class="number">16</span>,<span class="string">'pepperoni'</span>)</span><br><span class="line">p.make_pizza(<span class="number">12</span>,<span class="string">'mushrooms'</span>,<span class="string">'green peppers'</span>,<span class="string">'extra cheese'</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="导入模块中的所有函数"><a href="#导入模块中的所有函数" class="headerlink" title="导入模块中的所有函数"></a>导入模块中的所有函数</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">make_pizza(<span class="number">16</span>,<span class="string">'pepperoni'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>但是这种方法不推荐。最佳做法，要么只导入你需要的函数，要么导入整个模块并使用句点表示法。这能让代码更清晰。</p>
<h2 id="函数编写指南"><a href="#函数编写指南" class="headerlink" title="函数编写指南"></a>函数编写指南</h2><ol>
<li>函数起名描述性名称，且只使用小写字母和下划线。</li>
<li>注释应紧跟在函数定义后面。</li>
<li>给形参指定默认值时，等号两边不要有空格。</li>
<li>函数调用中的关键字实参，也不要有空格。</li>
</ol>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>在<strong>面向对象编程</strong>中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。基于类创建对象时，每个对象都自动具备这种通用的行为，然后可根据需要赋予每个对象独特的个性。根据类来创建对象被称为实例化。</p>
<h2 id="创建和使用类"><a href="#创建和使用类" class="headerlink" title="创建和使用类"></a>创建和使用类</h2><h3 id="创建Dog类"><a href="#创建Dog类" class="headerlink" title="创建Dog类"></a>创建Dog类</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>():</span></span><br><span class="line">    <span class="string">"""一次模拟小狗的简单尝试"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span> </span><br><span class="line">      <span class="string">"""特殊的方法，初始化,两个下划线"""</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sit</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.name.title() + <span class="string">"is now sitting."</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll_over</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.name.title() + <span class="string">"rolled over!"</span>)</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>定义了一个名为Dog的类。<strong>在Python中，首字母大写的名称指的是类。</strong></li>
<li>方法 <em>init</em>()，类中的函数称为方法。<strong>init方法是一个特殊的方法，每当根据Dog类创建对象新实例时，Python都会自动执行它。</strong>这个方法中，开头和末尾有两个下划线，这是约定。</li>
<li><strong>注意！！！方法init 是以两个下划线开始和结束的。</strong></li>
<li><strong>形参self必不可少，</strong>还必须位于其他形参的前面。Python调用这个init方法来创建Dog实例时，将自动传入实参self。每个与类相关联的方法调用都自动传递实参self，<strong>它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。</strong>我们创建Dog类实例时，Python将调用Dog类的方法init()。我们通过实参传递名字和方法，self会自动传递，因此我们不需要给self提供值。</li>
<li>通过类的构造函数中的参数传入的这些数据也想在各个方法中被使用，就需要在类中长久保存并能随时调用这些数据，为解决这个问题，<strong>在类中，所有传入的数据都赋给了一个变量，就是self。</strong>它接收实例化过程中传入的所有数据。</li>
<li><strong>以self为前缀的变量都可供类中的所有方法使用。</strong>self.name = name获取存储在形参name中的值，并将其存储到变量name中，然后该变量被关联到当前创建的实例。想这样可以通过实例访问的变量称为<strong>属性</strong>。</li>
<li>sit和roll_over方法。<strong>由于这些方法不需要额外的信息，如名字或年龄，因此它们只有一个形参self。</strong></li>
</ol>
<h3 id="根据类创建实例，访问类"><a href="#根据类创建实例，访问类" class="headerlink" title="根据类创建实例，访问类"></a>根据类创建实例，访问类</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">my_dog = Dog(<span class="string">"willie"</span>,<span class="number">6</span>)</span><br><span class="line"><span class="string">"""在类中这两个参数被传给了self参数"""</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"My Dog's name is "</span> + my_dog.name.title() + <span class="string">"."</span>)</span><br><span class="line"><span class="string">"""访问类属性"""</span></span><br><span class="line"></span><br><span class="line">my_dog.sit()</span><br><span class="line"><span class="string">"""访问类方法"""</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>在类中访问name属性时，使用self.name；在类外使用my_dog.name。</strong></p>
<h3 id="修改属性的值"><a href="#修改属性的值" class="headerlink" title="修改属性的值"></a>修改属性的值</h3><p>1.直接在类外修改属性的值</p>
<p>2.通过方法修改属性的值</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>():</span></span><br><span class="line">  --snip--</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update_name</span>(<span class="params">self,new_name</span>):</span></span><br><span class="line">    <span class="string">"""更新姓名"""</span></span><br><span class="line">    self.name = new_name</span><br><span class="line">    </span><br><span class="line">my_dog = Dog(<span class="string">"willie"</span>,<span class="number">6</span>)</span><br><span class="line">my_dog.update_name(<span class="string">"hahaha"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>一个类继承另一个类时，它将自动获得另一个类的所有属性和方法。同时还可以定义自己的属性和方法。</p>
<h3 id="子类的方法-init"><a href="#子类的方法-init" class="headerlink" title="子类的方法__init__()"></a>子类的方法<strong>__</strong>init__()</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>():</span></span><br><span class="line">    <span class="string">"""汽车"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,make,model,year</span>):</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        long_name = <span class="built_in">str</span>(self.year) + <span class="string">' '</span> + self.make + <span class="string">' '</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span>(<span class="params">Car</span>):</span></span><br><span class="line">    <span class="string">"""电动汽车,集成父类Car"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,make,model,year</span>):</span></span><br><span class="line">        <span class="string">"""初始化父类的属性"""</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make,model,year)</span><br><span class="line">        </span><br><span class="line">        <span class="string">"""子类特有的属性"""</span></span><br><span class="line">        self.battery_size = <span class="number">70</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">"this car has a"</span> + <span class="built_in">str</span>(self.battery_size) + <span class="string">"-kWh battery"</span>)</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>,<span class="string">'model s'</span>,<span class="number">2016</span>)</span><br><span class="line"><span class="string">"""调用父类的方法"""</span></span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.describe_battery()</span><br><span class="line"></span><br><span class="line"><span class="number">2016</span> Tesla Model S</span><br><span class="line">this car has a <span class="number">70</span>-kWh battery </span><br></pre></td></tr></tbody></table></figure>
<p><strong>创建子类时，父类必须包含在当前文件中，且位于子类的前面。（在子类模块中，必须导入父类来实现继承。）</strong>定义子类时，必须在括号内指定父类的名称。super()调用父类方法<strong>init</strong>()。可以在子类中创建新的属性和方法。</p>
<h3 id="重写父类的方法"><a href="#重写父类的方法" class="headerlink" title="重写父类的方法"></a>重写父类的方法</h3><p>在子类中定义一个与父类方法同名的方法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span>(<span class="params">Car</span>):</span></span><br><span class="line">  --snip--</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fill</span>-<span class="title">gas_tank</span>():</span></span><br><span class="line">    <span class="string">"""重写父类方法，直接覆盖"""</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="类的实例作为另个类的属性"><a href="#类的实例作为另个类的属性" class="headerlink" title="类的实例作为另个类的属性"></a>类的实例作为另个类的属性</h3><p>如上例中，将电瓶划分出来作为一个新类，作为电瓶车类的一个属性。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>():</span></span><br><span class="line">  --snip--</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Battery</span>():</span></span><br><span class="line">  <span class="string">"""电瓶"""</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,battery_size=<span class="number">70</span></span>):</span></span><br><span class="line">    self.battery_size = battery_size</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">battery</span>.<span class="title">describe_battery</span>():</span></span><br><span class="line">    print(<span class="string">"haha"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Electricity</span>(<span class="params">Car</span>):</span></span><br><span class="line">  --snip--</span><br><span class="line">  <span class="string">"""类Battery作为属性出现在init()中"""</span></span><br><span class="line">  self.battery = Battery()</span><br><span class="line">  </span><br><span class="line">my_tesla = ElectricCar(<span class="string">'tesla'</span>,<span class="string">'model'</span>s<span class="string">',2016)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""引用 属性（类）的方法"""</span></span><br><span class="line"><span class="string">my_tesla.battery.describe_battery()</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="导入类"><a href="#导入类" class="headerlink" title="导入类"></a>导入类</h2><p>将类存储在模块中，然后在主程序中导入所需的模块。</p>
<h3 id="导入单个类"><a href="#导入单个类" class="headerlink" title="导入单个类"></a>导入单个类</h3><p>创建Car类，并保存为car.py。创建另一个文件my_car.py，其中导入Car类并创建其实例。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""my_car.py"""</span></span><br><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car</span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">'audi'</span>,<span class="string">'a4'</span>,<span class="number">2016</span>)</span><br><span class="line">my_new_car.get_descriptive_name()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="在一个模块中存储多个类"><a href="#在一个模块中存储多个类" class="headerlink" title="在一个模块中存储多个类"></a>在一个模块中存储多个类</h3><p>也可以将多个类存储在同一个模块中，导入方法和上节相同。</p>
<h3 id="从一个模块中导入多个类"><a href="#从一个模块中导入多个类" class="headerlink" title="从一个模块中导入多个类"></a>从一个模块中导入多个类</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car,ElectricCar</span><br></pre></td></tr></tbody></table></figure>
<h3 id="导入整个模块-1"><a href="#导入整个模块-1" class="headerlink" title="导入整个模块"></a>导入整个模块</h3><p>你可以导入整个模块，再使用句点表示法访问需要的类。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> car</span><br><span class="line"></span><br><span class="line"><span class="string">"""句点表示法"""</span></span><br><span class="line">my_tesla = car.ElectricCar(<span class="string">'tesla'</span>,<span class="string">'model'</span>s<span class="string">',2016)</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-3-5-导入模块中所有的类"><a href="#8-3-5-导入模块中所有的类" class="headerlink" title="8.3.5 导入模块中所有的类"></a>8.3.5 导入模块中所有的类</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> *</span><br></pre></td></tr></tbody></table></figure>
<p>但是不推荐这种方法，需要从一个模块中导入很多类时，最好导入整个模块，并使用<em>module.class_name</em>语法来访问类。这样做你可以清楚的知道程序中使用了哪些导入的类。还避免了导入模块中的每个类可能引发的名称冲突。</p>
<h2 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h2><ol>
<li>类名采用驼峰命名法，类中每个单词首字母大写，而不适用下划线。</li>
</ol>
<p>​       实例名和模块名采用小写格式，在单词间加上下划线。</p>
<ol>
<li>在类后加上文档字符串作为说明。模块也是，在开头。</li>
</ol>
<ol>
<li>import先导入标准库中的。再导入你自己写的。两者用一个空行隔开。</li>
</ol>
<h1 id="文件和异常"><a href="#文件和异常" class="headerlink" title="文件和异常"></a>文件和异常</h1><h2 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h2><h3 id="读取整个文件"><a href="#读取整个文件" class="headerlink" title="读取整个文件"></a>读取整个文件</h3><p>打开并读取文件，并将内容显示到屏幕上。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'pi_digits.txt'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    contents = file_object.read()</span><br><span class="line">    print(contents)</span><br></pre></td></tr></tbody></table></figure>
<p>1.<strong>函数open()返回一个表示文件的对象</strong>。在这里open(‘pi_digits.txt’)返回一个表示文件pi_digits.txt的对象，Python将这个对象存储在我们将在后面使用的变量中。</p>
<p>2.<strong>关键字with在不再需要访问文件后将其关闭。</strong>注意我们使用了open(),但没有使用close(),你也可以用open和close来打开和关闭文件，但这样做时，如果程序存在bug，导致close未执行，文件将不会关闭，未妥善的关闭文件可能导致数据丢失或受损。并非在任何情况下都能轻松的确定关闭文件的恰当时机，但通过使用前面使用的结构，可让python 去确定：你只管打开文件，并在需要时使用它，<strong>Python自会在合适的时候自动将其关闭</strong>。</p>
<p>3.有了表示pi_digits.txt的文件对象后，我们使用方法read()，读取文件文件的全部内容。</p>
<p>4.read()到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除末尾的空行，可在print中使用rstrip()</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">print(contents.rstrip())</span><br></pre></td></tr></tbody></table></figure>
<h3 id="逐行读取"><a href="#逐行读取" class="headerlink" title="逐行读取"></a>逐行读取</h3><p>要以每次一行的方式检查文件，可对文件对象使用for循环。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">filename = <span class="string">'pi_digits.txt'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file_object:</span><br><span class="line">        print(line.rstrip())</span><br></pre></td></tr></tbody></table></figure>
<h3 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h3><p>相对文件路径：相对当前的工作目录。</p>
<p>在LInux和OS X中：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'text_files/filename.txt'</span>) <span class="keyword">as</span> file_object:</span><br></pre></td></tr></tbody></table></figure>
<p>在Windows中：使用反斜杠</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'text_files\filename.txt'</span>) <span class="keyword">as</span> file_object:</span><br></pre></td></tr></tbody></table></figure>
<p>绝对文件路径：无需关心，给出完整目录。</p>
<p>在LInux和OS X中：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">file_path = <span class="string">'/home/ehmatthes/other_files/text_files/filename.txt'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path) <span class="keyword">as</span> file_object:</span><br></pre></td></tr></tbody></table></figure>
<p>在Windows中：使用反斜杠</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">file_path = <span class="string">'C:\Users\ehmatthes\other_files\text_files\filename.txt'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path) <span class="keyword">as</span> file_object:</span><br></pre></td></tr></tbody></table></figure>
<h3 id="建包含文件各行内容的列表"><a href="#建包含文件各行内容的列表" class="headerlink" title="建包含文件各行内容的列表"></a>建包含文件各行内容的列表</h3><p>使用关键字with时，open()返回的文件对象只在with代码块内可用。如果要在with代码块外访问文件的内容，可在with代码块内将文件的各行存储在一个列表中，并在with代码块外使用该列表。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">filename = <span class="string">'pi_digits.txt'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    print(line.rstrip())</span><br></pre></td></tr></tbody></table></figure>
<p><strong>readlines()从文件中读取每一行，并将其存储在一个列表中。</strong></p>
<p>如果要将文件作为一个字符串打印出来，可以使用下面的方法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""以字符串形式打印文件的前499个字符"""</span></span><br><span class="line">filename = <span class="string">'pi_digits.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> file_object:</span><br><span class="line">    lines = file_object.readlines()</span><br><span class="line"></span><br><span class="line">pi_string = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    pi_string += line.strip()</span><br><span class="line"></span><br><span class="line">print(pi_string[:<span class="number">500</span>] + <span class="string">"......"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="字符串是否包含在文件中"><a href="#字符串是否包含在文件中" class="headerlink" title="字符串是否包含在文件中"></a>字符串是否包含在文件中</h3><p>先将文件整理成字符串，在上节代码最后添加：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">--snip--</span><br><span class="line">input_str = <span class="built_in">input</span>(<span class="string">"Input your string that you want to check:"</span>)</span><br><span class="line"><span class="keyword">if</span> input_str <span class="keyword">in</span> pi_string:</span><br><span class="line"><span class="string">"""检查是否包含字符串"""</span></span><br><span class="line">  print(<span class="string">"Yes"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">"No"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><h3 id="写入空文件"><a href="#写入空文件" class="headerlink" title="写入空文件"></a>写入空文件</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">filename = <span class="string">'writef.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">'w'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">"I love programming."</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>注：1.<strong>open()</strong>提供了两个参数，第一个是要打开的文件名称，第二个是<strong>打开模式</strong>。</p>
<p>​    2.可以以<strong>只读模式”r“、写入模式“w”、附加模式“a”</strong>打开文件。或让你能够读取和写入文件的模式<strong>“r+”</strong>，如果你省略了模式参数，<strong>Python将默认为只读模式</strong>。</p>
<p>​    3.如果你要打开的文件不存在，函数open()将自动创建它。然而，以写入模式打开文件时千万要小心，因为如果<strong>指定的文件已经存在，Python将在返回文件对象前清空文件</strong>。</p>
<p>​    4.Python只能将字符串写入文本文件。要将<strong>数值存储，需使用str()转化为String</strong>。</p>
<h3 id="写入多行"><a href="#写入多行" class="headerlink" title="写入多行"></a>写入多行</h3><p>函数write()不会在你写入的文本末尾添加换行符。要写多行，使用换行符。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">file_object.write(<span class="string">"I love programming.\n"</span>)</span><br><span class="line">file_object.write(<span class="string">"I love programming very much.\n"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="附加到文件"><a href="#附加到文件" class="headerlink" title="附加到文件"></a>附加到文件</h3><p>给文件添加内容，而不是覆盖。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">'a'</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    file_object.write(<span class="string">"I love programming.\n"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>每当发生让Python不知所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行，否则会停止，并显示一个traceback，其中包含异常的报告。</p>
<p>异常使用<strong>try-except</strong>代码块处理。</p>
<h3 id="ZeroDivisionError异常"><a href="#ZeroDivisionError异常" class="headerlink" title="ZeroDivisionError异常"></a>ZeroDivisionError异常</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="number">5</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">"You can't divide by zero!"</span>)</span><br><span class="line"></span><br><span class="line">You can<span class="string">'t divide by zero!</span></span><br></pre></td></tr></tbody></table></figure>
<p>try代码块中的代码运行起来没有问题，Python将跳过except代码块；如果有问题，Python将会查找Except代码块</p>
<p><strong>依赖于try代码块成功执行的代码都应该放到else代码块中：</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    answer = <span class="number">5</span>/<span class="number">3</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">"you can't divide 0!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(answer)</span><br><span class="line"></span><br><span class="line"><span class="number">1.6666666666666667</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="FileNotFoundError异常"><a href="#FileNotFoundError异常" class="headerlink" title="FileNotFoundError异常"></a>FileNotFoundError异常</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">filename = <span class="string">'alice.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">        contents = f_obj.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    print(<span class="string">"your file is not exisit"</span>)</span><br><span class="line"></span><br><span class="line">your file <span class="keyword">is</span> <span class="keyword">not</span> exisit</span><br></pre></td></tr></tbody></table></figure>
<h3 id="分析文本split"><a href="#分析文本split" class="headerlink" title="分析文本split()"></a>分析文本split()</h3><p><strong>split()，根据一个字符串创建一个单词列表。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">title = <span class="string">"Alice in Wonderland"</span></span><br><span class="line">title.split()</span><br><span class="line"></span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'in'</span>, <span class="string">'Wonderland'</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>split()以空格为分隔符将字符串分拆成多个部分，并将这些部分都存储到一个列表中。</p>
<h3 id="失败时一声不吭"><a href="#失败时一声不吭" class="headerlink" title="失败时一声不吭"></a>失败时一声不吭</h3><p>如果你想让try代码块在发生异常后医生不吭，Python有一个pass语句，可在代码块中使用它来让Python“沉默”</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    answer = <span class="number">5</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(answer)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><p>程序需要把用户提供的信息存储在列表和字典等数据结构中。用户关闭程序时，你几乎总是要保存他们提供的信息。一种简单的方式是<strong>使用模块json来存储数据</strong>。【 JSON(JavaScript Object Notation) 】</p>
<h3 id="使用json-dump-和json-load"><a href="#使用json-dump-和json-load" class="headerlink" title="使用json.dump()和json.load()"></a>使用json.dump()和json.load()</h3><p>函数json.dump()接受两个实参：1.要存储的数据 2.可用于存储数据的文件对象。下面展示用其存储数字列表。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""使用json.dump()写入数据"""</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'number.json'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">    json.dump(numbers,f_obj)</span><br></pre></td></tr></tbody></table></figure>
<p>json.load()参数与上面一样。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""使用json.load()读取数据"""</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'number.json'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">    numbers = json.load(f_obj)</span><br><span class="line"></span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="为什么使用json"><a href="#为什么使用json" class="headerlink" title="为什么使用json"></a>为什么使用json</h3><p>对于用户生成的数据，使用json保存它们大有裨益，因为如果不以某种方式进行存储，等程序停止运行时用户的信息将丢失。下面看个例子，<strong>用户首次运行被提示输入自己的名字，这样再次运行程序就记住他了</strong>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""存储用户的名字"""</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">username = <span class="built_in">input</span>(<span class="string">"what's your name?"</span>)</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'username.json'</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">    json.dump(username,f_obj)</span><br><span class="line">    print(<span class="string">"we'll remember you when you come back,"</span> + username + <span class="string">"!"</span>)</span><br><span class="line">    </span><br><span class="line">what<span class="string">'s your name?GraceKoo</span></span><br><span class="line"><span class="string">we'</span>ll remember you when you come back,GraceKoo!</span><br></pre></td></tr></tbody></table></figure>
<p>再来编写一个程序，向其名字被存储的用户发出问候。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'username.json'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">    username = json.load(f_obj)</span><br><span class="line">    print(<span class="string">"welcome back,"</span> + username +<span class="string">"!"</span>)</span><br><span class="line">   </span><br><span class="line">welcome back,GraceKoo!</span><br></pre></td></tr></tbody></table></figure>
<p>将以上两个程序进行合并：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果以前存储了用户名，就加载它，否则，就提示用户输入用户名并存储它</span></span><br><span class="line">filename = <span class="string">'username.json'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">        username = json.load(f_obj)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">"what's your name?"</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">        json.dump(username,f_obj)</span><br><span class="line">        print(<span class="string">"we'll remember you when you come back,"</span> + username + <span class="string">"!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Welcome back,"</span> + username + <span class="string">"!"</span>)</span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>代码能正确运行，但可做进一步的改进————-将代码划分为一系列完成具体工作的函数。这样的过程叫做重构。重构让代码更清晰、更易于理解、更容易扩展。</p>
<p>假若重构上列代码，可将其大部分逻辑放到一个或多个函数中。比如:<strong>get_stored_username()用于获取存储了的用户名，get_new_username()用于存储新的用户名,greet_user()相当于主函数，在三个函数外部首先被调用，它进行判断，调用相应的函数，对不同的用户显示不同的信息。</strong>这样三个<strong>函数分工明确，代码结构也清晰明了。</strong></p>
<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p>在本章中，将学习如何用Python模块unittest中的工具来测试代码。将学习编写测试用例。</p>
<h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><p>测试代码为：(name_function.py)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span>(<span class="params">first,last</span>):</span></span><br><span class="line">  <span class="string">"""返回整洁的名字"""</span></span><br><span class="line">    full_name = first + <span class="string">''</span> + last</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></tbody></table></figure>
<p>为测试上例代码，编写一个使用这个函数的程序，下例让用户输入名和姓。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Enter 'q' at any time to quit"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    first = <span class="built_in">input</span>(<span class="string">"\nPlease give me a first name:"</span>)</span><br><span class="line">    <span class="keyword">if</span> first == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    last = <span class="built_in">input</span>(<span class="string">"\nPlease give me a last name:"</span>)</span><br><span class="line">    <span class="keyword">if</span> last == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    format_name = get_formatted_name(first,last)</span><br><span class="line">    print(<span class="string">"\tNeatly formatted name:"</span> + format_name + <span class="string">'.'</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="单元测试和测试用例"><a href="#单元测试和测试用例" class="headerlink" title="单元测试和测试用例"></a>单元测试和测试用例</h3><p>Python标准库中的模块<strong>unittest</strong>提供了代码测试工具。<strong>单元测试</strong>用于核实函数的某个方面没有问题；<strong>测试用例</strong>是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。</p>
<p>创建测试用例的语法需要一段时间才能习惯，但测试用例创建后，再添加针对函数的单元测试就很简单了。</p>
<p>编写测试用例, 1.可先导入模块unittest以及要测试的函数。</p>
<p>​             2.再创建一个继承unittest.TestCase的类。并编写一系列方法对函数行为的不用方面进行测试。</p>
<p>下面是一个只包含一个方法的测试用例，它检查函数get_formatted_name()在给定名和姓时能否正常工作。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line"><span class="string">"""1.导入模块unittest和要测试的函数get_formatted_name()"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameTestCase</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"><span class="string">"""2.创建测试类，继承自TestCase"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_first_last_name</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="string">"""3.测试name_function.py"""</span></span><br><span class="line">        <span class="string">"""能够正确地处理像Janis Joplin这样的姓名吗？"""</span></span><br><span class="line">        formatted_name = get_formatted_name(<span class="string">'janis'</span>,<span class="string">'joplin'</span>)</span><br><span class="line"><span class="string">"""4.一个断言方法"""</span></span><br><span class="line">        self.assertEqual(formatted_name,<span class="string">'Janis Joplin'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="string">"""5.运行这个文件中的测试"""</span>        </span><br><span class="line">unittest.main()</span><br></pre></td></tr></tbody></table></figure>
<p><strong>我们运行测试用例时，所有以test_打头的方法都将自动运行。</strong></p>
<p><strong>这个断言方法用来核实得到的结果是否与期望的结果一致。</strong>asserEqual()意思是说，进行比较，如果它们相等，就万事大吉，如果不等，跟我说一声！</p>
<h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><h3 id="各种断言方法"><a href="#各种断言方法" class="headerlink" title="各种断言方法"></a>各种断言方法</h3><p>unittest <strong>Module中的断言方法</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">assertEqual(a,b)</td>
<td style="text-align:center">核实 a==b</td>
</tr>
<tr>
<td style="text-align:center">assertNotEqual(a,b)</td>
<td style="text-align:center">核实 a!=b</td>
</tr>
<tr>
<td style="text-align:center">assertTrue(x)</td>
<td style="text-align:center">核实x为True</td>
</tr>
<tr>
<td style="text-align:center">assertFalse(x)</td>
<td style="text-align:center">核实x为False</td>
</tr>
<tr>
<td style="text-align:center">assertIn(item.list)</td>
<td style="text-align:center">核实item在list中</td>
</tr>
<tr>
<td style="text-align:center">assertNotIn(item.list)</td>
<td style="text-align:center">核实item不在list中</td>
</tr>
</tbody>
</table>
</div>
<h3 id="一个要测试的类"><a href="#一个要测试的类" class="headerlink" title="一个要测试的类"></a>一个要测试的类</h3><p>Survey.py</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnonymousSurvey</span>():</span></span><br><span class="line">    <span class="string">"""收集匿名调查问卷的答案"""</span> </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,question</span>):</span></span><br><span class="line">        <span class="string">"""存储一个问题，并未存储答案做准备"""</span></span><br><span class="line">        self.question = question</span><br><span class="line">        self.responses = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_question</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""显示调查问卷"""</span></span><br><span class="line">        print(self.question)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_response</span>(<span class="params">self,new_response</span>):</span></span><br><span class="line">        <span class="string">"""存储单份调查问卷"""</span></span><br><span class="line">        self.responses.append(new_response)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_results</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""显示收集到的所有答案"""</span></span><br><span class="line">        print(<span class="string">"Survey results:"</span>)</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            print(<span class="string">'-'</span> + response)</span><br></pre></td></tr></tbody></table></figure>
<p>再来编写一个使用它的程序：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个问题，并创建一个表示调查的AnonymousSurvey对象</span></span><br><span class="line">question = <span class="string">'what language did you first learn to speak?'</span></span><br><span class="line">my_survey = AnonymousSurvey(question)</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示问题并存储答案</span></span><br><span class="line">my_survey.show_question()</span><br><span class="line">print(<span class="string">"Enter 'q' at any time to quit.\n"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    response = <span class="built_in">input</span>(<span class="string">"language:"</span>)</span><br><span class="line">    <span class="keyword">if</span> response == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    my_survey.store_response(response)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#显示调查结果</span></span><br><span class="line">print(<span class="string">"\nThank you to everyone who participated in the survey!"</span>)</span><br><span class="line">my_survey.show_results()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="测试AnonymousSurvey"><a href="#测试AnonymousSurvey" class="headerlink" title="测试AnonymousSurvey"></a>测试AnonymousSurvey</h3><p>下面来编写一个测试，对AnonymousSurvey类的行为的一个方面进行验证：如果用户对面对调查问题时只提供了一个答案，这个答案也能被妥善的存储。为此，我们将在这个答案被存储后，使用方法assertIn()来核实它包含在答案列表中。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAnonymousSurvey</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"><span class="string">"""针对AnonymousSurvey类的测试"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_single_response</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""测试单个答案会被妥善的存储"""</span></span><br><span class="line">        question = <span class="string">"what language did you first learn to speak?"</span></span><br><span class="line">        my_survey = AnonymousSurvey(question)</span><br><span class="line">        my_survey.store_response(<span class="string">"English"</span>)</span><br><span class="line">        </span><br><span class="line">        self.assertIn(<span class="string">'English'</span>,my_survey.response)</span><br><span class="line"></span><br><span class="line">unittest.main()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="方法setUp"><a href="#方法setUp" class="headerlink" title="方法setUp()"></a>方法setUp()</h2><p>unittest.TestCase类包含方法SetUp(),让我们只需创建这些对象一次，并在每个测试方法中使用它们。如果你在TestCase类中包含了方法setUp(),Python将先运行它，在运行各个以test_打头的方法。<strong>这样，你在编写的每个测试方法中都可以使用在方法setUp()中创建的对象了。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAnonymousSurvey</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        创建一个调查对象和一组答案，供使用的测试方法使用</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        question = <span class="string">"What language did you first learn to speak?"</span></span><br><span class="line">        self.my_survey = AnonymousSurvey(question)</span><br><span class="line">        self.responses = [<span class="string">'English'</span>,<span class="string">'Spanish'</span>,<span class="string">'Mandarin'</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_single_response</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""测试单个答案会被妥善的存储"""</span></span><br><span class="line">        self.my_survey.store_response(self.response[<span class="number">0</span>])</span><br><span class="line">        self.assertIn(self.responses[<span class="number">0</span>],self.my_survey.responses)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_three_response</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""测试三个答案会被妥善的存储"""</span></span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">                self.my_survey.store_response(response)</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            self.assertIn(response,self.my_survey.responses)</span><br><span class="line"></span><br><span class="line">unittest.main()</span><br></pre></td></tr></tbody></table></figure>
<p>包含self，即存储在类的属性中。测试自己写的类时，在setUp()中创建一系列实例并设置它们的属性，在测试方法中直接使用这些实例。</p>
<p><strong>每完成一个单元测试，Python打印一个字符：测试通过打印一个句点；测试引发错误打印一个E；测试导致断言失败打印一个F。</strong></p>
<h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><ul>
<li>《Python编程：从入门到实践》</li>
</ul>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>iPython</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面试题</title>
    <url>/posts/22488/</url>
    <content><![CDATA[<h1 id="Python语言特性"><a href="#Python语言特性" class="headerlink" title="Python语言特性"></a>Python语言特性</h1><h2 id="Python的函数参数传递"><a href="#Python的函数参数传递" class="headerlink" title="Python的函数参数传递"></a>Python的函数参数传递</h2><p>看两个例子:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a</span>):</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="built_in">print</span> a  <span class="comment"># 1</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a</span>):</span></span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line">fun(a)</span><br><span class="line"><span class="built_in">print</span> a  <span class="comment"># [1]</span></span><br></pre></td></tr></tbody></table></figure>
<p>所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。</p>
<a id="more"></a>
<p>通过<code>id</code>来看引用<code>a</code>的内存地址可以比较理解：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"func_in"</span>,<span class="built_in">id</span>(a)   <span class="comment"># func_in 41322472</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"re-point"</span>,<span class="built_in">id</span>(a), <span class="built_in">id</span>(<span class="number">2</span>)   <span class="comment"># re-point 41322448 41322448</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">"func_out"</span>,<span class="built_in">id</span>(a), <span class="built_in">id</span>(<span class="number">1</span>)  <span class="comment"># func_out 41322472 41322472</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="built_in">print</span> a  <span class="comment"># 1</span></span><br></pre></td></tr></tbody></table></figure>
<p>注：具体的值在不同电脑上运行时可能不同。</p>
<p>可以看到，在执行完<code>a = 2</code>之后，<code>a</code>引用中保存的值，即内存地址发生变化，由原来<code>1</code>对象的所在的地址变成了<code>2</code>这个实体对象的内存地址。</p>
<p>而第2个例子<code>a</code>引用保存的内存值就不会发生变化：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"func_in"</span>,<span class="built_in">id</span>(a)  <span class="comment"># func_in 53629256</span></span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">"func_out"</span>,<span class="built_in">id</span>(a)     <span class="comment"># func_out 53629256</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="built_in">print</span> a  <span class="comment"># [1]</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里记住的是<strong>类型是属于对象的，而不是变量</strong>。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。<strong>在python中，strings, tuples, 和numbers是不可更改的对象，而 list, dict, set 等则是可以修改的对象。</strong>(这就是这个问题的重点)</p>
<p><strong>当一个引用传递给函数的时候,函数自动复制一份引用,</strong>这个函数里的引用和外边的引用没有半毛关系了。所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改。</p>
<p>如果还不明白的话,这里有更好的解释: <a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p>
<h3 id="my-conclusion"><a href="#my-conclusion" class="headerlink" title="my conclusion"></a>my conclusion</h3><p><a href="https://blog.csdn.net/hohaizx/article/details/78427406">参考链接</a></p>
<p>Python中一切事物皆对象，变量是对对象在内存中的存储和地址的抽象。</p>
<p>“=”(赋值号)是将右侧对象的内存地址赋值给左侧的变量。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = <span class="string">"abc"</span> <span class="comment"># 将“abc”的地址保存到“a”中</span></span><br></pre></td></tr></tbody></table></figure>
<p>这样我们就能通过操作“a”而改变内存中的“abc”。<br>所以执行下面语句</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = <span class="string">"123"</span></span><br><span class="line">b = a</span><br><span class="line">a = <span class="string">"xyz"</span></span><br></pre></td></tr></tbody></table></figure>
<p>第一句Python解释器创建字符串“123”和变量“a”,并把“a”指向“123”。</p>
<p><img data-src="./data/Screen Shot 2020-11-06 at 16.04.27.png" alt="Screen Shot 2020-11-06 at 16.04.27"></p>
<p>执行第二句，因为“a”已经存在，并不会创建新的对象，但会创建变量“b”, 并把“b”指向“a”指向的字符串“123“。</p>
<p><img data-src="./data/Screen Shot 2020-11-06 at 16.04.32.png" alt="Screen Shot 2020-11-06 at 16.04.32"></p>
<p>因为Python对象分为可变对象<strong>(list,dict,set</strong>等)和不可变对象(<strong>number,string,tuple</strong>等)。</p>
<ol>
<li><p>当进行修改操作时，可变类型传递的是内存中的地址，也就是说，直接修改内存中的值，并没有开辟新的内存。</p>
</li>
<li><p>不可变类型被改变时，并没有改变原内存地址中的值，而是开辟一块新的内存，将原地址中的值复制过去，对这块新开辟的内存中的值进行操作。</p>
</li>
</ol>
<p><strong>没有指针，但是所有对象均为指针</strong></p>
<p><strong>python中的函数，如果是传递的tuple，那么是值传递；如果传递的参数类型是list，那么是引用传递。</strong></p>
<h2 id="Python中的元类-metaclass"><a href="#Python中的元类-metaclass" class="headerlink" title="Python中的元类(metaclass)"></a>Python中的元类(metaclass)</h2><p><a href="https://lotabout.me/2018/Understanding-Python-MetaClass/">https://lotabout.me/2018/Understanding-Python-MetaClass/</a></p>
<p>对象的类型叫作类(class)，<strong>类的类型就称作元类 <code>meta-class</code></strong>。是不是很像“爸爸的爸爸叫爷爷”？换句话说，<strong>“普通类(class)”可以用来生成实例(instance)，同样的，元类 (meta-class)也可以生成实例，生成的实例就是“普通类”了。</strong></p>
<p>可以使用type()动态的创建类以外，<strong>要控制类的行为</strong>，还可以使用metaclass。</p>
<p>这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看:<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p>
<h2 id="staticmethod和-classmethod"><a href="#staticmethod和-classmethod" class="headerlink" title="@staticmethod和@classmethod"></a>@staticmethod和@classmethod</h2><p>Python其实有3个方法,即<strong>静态方法(staticmethod), 类方法(classmethod)和实例方法</strong>,如下:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"executing foo(%s)"</span>%(x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">"executing foo(%s,%s)"</span>%(self,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span>(<span class="params">cls,x</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">"executing class_foo(%s,%s)"</span>%(cls,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span>(<span class="params">x</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">"executing static_foo(%s)"</span>%x</span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道<strong>在类里每次定义方法的时候都需要绑定这个实例,</strong>就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p>
<p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">\</th>
<th style="text-align:left">实例方法</th>
<th style="text-align:left">类方法</th>
<th style="text-align:left">静态方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a = A()</td>
<td style="text-align:left">a.foo(x)</td>
<td style="text-align:left">a.class_foo(x)</td>
<td style="text-align:left">a.static_foo(x)</td>
</tr>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">不可用</td>
<td style="text-align:left">A.class_foo(x)</td>
<td style="text-align:left">A.static_foo(x)</td>
</tr>
</tbody>
</table>
</div>
<p>更多关于这个问题:</p>
<ol>
<li><a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></li>
<li><a href="https://realpython.com/blog/python/instance-class-and-static-methods-demystified/">https://realpython.com/blog/python/instance-class-and-static-methods-demystified/</a><h3 id="my-conclusion-1"><a href="#my-conclusion-1" class="headerlink" title="my conclusion"></a>my conclusion</h3></li>
</ol>
<p>1、self表示一个<strong>具体的实例本身</strong>。如果用了staticmethod，那么就可以无视这个self，将这个方法当成一个普通的函数使用。</p>
<p>2、<strong>cls表示这个类本身</strong>。</p>
<p>python类里会出现这三个单词，self和cls<strong>都可以用别的单词</strong>代替，类的方法有三种。有利于组织代码，有利于命名空间的整洁。</p>
<p>一、<strong>类实例方法</strong>：是通过def定义的 普通的一般的，需要至少传递一个参数，一般用<strong>self</strong>，这样的方法必须通过<strong>一个类的实例去访问</strong>，类似于c++中通过对象去访问；</p>
<p>二、<strong>类方法：</strong>是在def前面加上<strong>@classmethod</strong>，形参为cls，表示类对象，<strong>类对象和实例对象都可调用。cls表示这个类本身</strong>。(可以使用<strong>类名和对象</strong>调用）</p>
<p>三、<strong>静态方法：</strong>是在def前面加上<strong>@staticmethod</strong>，这种类方法是静态的类方法，他的一个特点是<strong>参数可以为空</strong>，形参为self, <strong>指代对象本身</strong>; 可以无视这个self，将这个方法当成一个普通的函数使用。（可以使用<strong>类名和对象</strong>调用）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    bar = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self</span>):</span> <span class="comment"># 普通方法，用类的实例去访问</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">'foo'</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span>():</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">'static_foo'</span></span><br><span class="line">        <span class="built_in">print</span> A.bar <span class="comment"># 调用属性方法用"类名.属性""</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">'class_foo'</span></span><br><span class="line">        <span class="built_in">print</span> cls.bar</span><br><span class="line">        cls().foo() <span class="comment"># 调用属性方法用"cls.属性"</span></span><br><span class="line">        </span><br><span class="line">a = A()</span><br><span class="line">a.static_foo()</span><br><span class="line">A.static_foo()  <span class="comment">#类名、对象直接调用</span></span><br><span class="line"></span><br><span class="line">A.class_foo() <span class="comment"># 类名直接调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">static_foo</span><br><span class="line"><span class="number">1</span></span><br><span class="line">class_foo</span><br><span class="line"><span class="number">1</span></span><br><span class="line">foo</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="类变量和实例变量"><a href="#类变量和实例变量" class="headerlink" title="类变量和实例变量"></a>类变量和实例变量</h2><p><strong>类变量：</strong></p>
<blockquote>
<p>​    是可在类的<strong>所有实例之间共享的值</strong>（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。</p>
</blockquote>
<p><strong>实例变量：</strong></p>
<blockquote>
<p>实例化之后，每个实例单独拥有的变量。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span></span>):</span>  </span><br><span class="line">    num_of_instance = <span class="number">0</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        Test.num_of_instance += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    <span class="built_in">print</span> Test.num_of_instance   <span class="comment"># 0</span></span><br><span class="line">    t1 = Test(<span class="string">'jack'</span>)  </span><br><span class="line">    <span class="built_in">print</span> Test.num_of_instance   <span class="comment"># 1</span></span><br><span class="line">    t2 = Test(<span class="string">'lucy'</span>)  </span><br><span class="line">    <span class="built_in">print</span> t1.name , t1.num_of_instance  <span class="comment"># jack 2</span></span><br><span class="line">    <span class="built_in">print</span> t2.name , t2.num_of_instance  <span class="comment"># lucy 2</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>补充的例子</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=<span class="string">"aaa"</span></span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=<span class="string">"bbb"</span></span><br><span class="line"><span class="built_in">print</span> p1.name  <span class="comment"># bbb</span></span><br><span class="line"><span class="built_in">print</span> p2.name  <span class="comment"># aaa</span></span><br><span class="line"><span class="built_in">print</span> Person.name  <span class="comment"># aaa</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里<code>p1.name="bbb"</code>是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,<code>p1.name</code>一开始是指向的类变量<code>name="aaa"</code>,但是<strong>在实例的作用域里把类变量的引用改变了,就变成了一个实例变量</strong>, self.name不再引用Person的类变量name了.</p>
<p>可以看看下面的例子:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=[]</span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name.append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> p1.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="built_in">print</span> p2.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="built_in">print</span> Person.name  <span class="comment"># [1]</span></span><br></pre></td></tr></tbody></table></figure>
<p>参考:<a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></p>
<h2 id="Python自省"><a href="#Python自省" class="headerlink" title="Python自省"></a>Python自省</h2><p>这个也是python彪悍的特性.</p>
<p>自省就是面向对象的语言所写的程序<strong>在运行时,所能知道对象的类型</strong>。简单一句就是<strong>运行时能够获得对象的类型</strong>。比如type(),dir(),getattr(),hasattr(),isinstance()。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = {<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>}</span><br><span class="line">c = <span class="literal">True</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(a),<span class="built_in">type</span>(b),<span class="built_in">type</span>(c) <span class="comment"># &lt;type 'list'&gt; &lt;type 'dict'&gt; &lt;type 'bool'&gt;</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">isinstance</span>(a,<span class="built_in">list</span>)  <span class="comment"># True</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><p>可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">d = {key: value <span class="keyword">for</span> (key, value) <span class="keyword">in</span> iterable}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Python中单下划线和双下划线"><a href="#Python中单下划线和双下划线" class="headerlink" title="Python中单下划线和双下划线"></a>Python中单下划线和双下划线</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>            self.__superprivate = <span class="string">"Hello"</span></span><br><span class="line"><span class="meta">... </span>            self._semiprivate = <span class="string">", world!"</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mc = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> mc.__superprivate</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: myClass instance has no attribute <span class="string">'__superprivate'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> mc._semiprivate</span><br><span class="line">, world!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> mc.__dict__</span><br><span class="line">{<span class="string">'_MyClass__superprivate'</span>: <span class="string">'Hello'</span>, <span class="string">'_semiprivate'</span>: <span class="string">', world!'</span>}</span><br></pre></td></tr></tbody></table></figure>
<p><code>__foo__</code>:一种约定,<strong>Python内部的名字</strong>,用来区别其他用户自定义的命名,以防冲突，就是例如<code>__init__()</code>,<code>__del__()</code>,<code>__call__()</code>这些特殊方法</p>
<p><code>_foo</code>:一种约定,<strong>用来指定变量私有</strong>.程序员用来指定私有变量的一种方式.<strong>不能用from module import * 导入</strong>，其他方面和公有一样访问；</p>
<p><code>__foo</code>:这个有真正的意义:解析器用<code>_classname__foo</code>来代替这个名字,<strong>以区别和其他类相同的命名</strong>,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问.</p>
<p>详情见:<a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></p>
<p>或者: <a href="http://www.zhihu.com/question/19754941">http://www.zhihu.com/question/19754941</a></p>
<h2 id="字符串格式化-和-format"><a href="#字符串格式化-和-format" class="headerlink" title="字符串格式化:%和.format"></a>字符串格式化:%和.format</h2><p>.format在许多方面看起来更便利.<strong>对于<code>%</code>最烦人的是它无法同时传递一个变量和元组</strong>.你可能会想下面的代码不会有什么问题:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">"hi there %s" % name</span><br></pre></td></tr></tbody></table></figure>
<p>但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">"hi there %s" % (name,)   # 提供一个单元素的数组而不是一个参数</span><br></pre></td></tr></tbody></table></figure>
<p>但是有点丑。.<strong>format就没有这些问题</strong>。你给的第二个问题也是这样，.format好看多了。</p>
<p>你为什么不用它?</p>
<ul>
<li>不知道它(在读这个之前)</li>
<li>为了和Python2.5兼容(譬如logging库建议使用<code>%</code>(<a href="https://github.com/taizilongxu/interview_python/issues/4">issue #4</a>))</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">sub1 = <span class="string">"python string!"</span></span><br><span class="line">sub2 = <span class="string">"an arg"</span></span><br><span class="line"></span><br><span class="line">arg_a = <span class="string">"with %(kwarg)s!"</span> % {<span class="string">'kwarg'</span>:sub2}</span><br><span class="line">arg_b = <span class="string">"with {kwarg}!"</span>.<span class="built_in">format</span>(kwarg=sub2)</span><br></pre></td></tr></tbody></table></figure>
<p><a href="http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format">http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format</a></p>
<h2 id="args-and-kwargs"><a href="#args-and-kwargs" class="headerlink" title="*args and **kwargs"></a><code>*args</code> and <code>**kwargs</code></h2><p>用<code>*args</code>和<code>**kwargs</code>只是为了方便并没有强制使用它们.</p>
<p><strong>当你不确定你的函数里将要传递多少参数时你可以用`*args</strong>`.例如,它可以传递任意数量的参数:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_everything</span>(<span class="params">*args</span>):</span></span><br><span class="line">        <span class="keyword">for</span> count, thing <span class="keyword">in</span> <span class="built_in">enumerate</span>(args):</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span> <span class="string">'{0}. {1}'</span>.<span class="built_in">format</span>(count, thing)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_everything(<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'cabbage'</span>)</span><br><span class="line"><span class="number">0.</span> apple</span><br><span class="line"><span class="number">1.</span> banana</span><br><span class="line"><span class="number">2.</span> cabbage</span><br></pre></td></tr></tbody></table></figure>
<p>相似的,<strong><code>kwargs</code>允许你使用没有事先定义的参数名</strong>:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">table_things</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span> <span class="string">'{0} = {1}'</span>.<span class="built_in">format</span>(name, value)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>table_things(apple = <span class="string">'fruit'</span>, cabbage = <span class="string">'vegetable'</span>)</span><br><span class="line">cabbage = vegetable</span><br><span class="line">apple = fruit</span><br></pre></td></tr></tbody></table></figure>
<p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<code>*args</code>和<code>**kwargs</code>.命名参数在列表的最前端.例如:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">def table_things(titlestring, **kwargs)</span><br></pre></td></tr></tbody></table></figure>
<p><code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中,<strong>但是<code>*args</code>必须在<code>kwargs</code>前面</strong>.</p>
<p>当调用函数时你也可以用<code>*</code>和<code>**</code>语法.例如:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_three_things</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span> <span class="string">'a = {0}, b = {1}, c = {2}'</span>.<span class="built_in">format</span>(a,b,c)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="string">'aardvark'</span>, <span class="string">'baboon'</span>, <span class="string">'cat'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_three_things(*mylist)</span><br><span class="line"></span><br><span class="line">a = aardvark, b = baboon, c = cat</span><br></pre></td></tr></tbody></table></figure>
<p>就像你看到的一样,<strong>它可以传递列表(或者元组)的每一项并把它们解包</strong>.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.</p>
<p><a href="http://stackoverflow.com/questions/3394835/args-and-kwargs">http://stackoverflow.com/questions/3394835/args-and-kwargs</a></p>
<h2 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h2><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p>
<p><strong>我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。</strong></p>
<p>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。</p>
<p>又比如<strong>list.extend()方法中</strong>,我们并不关心它的参数是不是list,<strong>只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.</strong></p>
<p>鸭子类型在动态语言中经常使用，非常灵活，使得python不像java那样专门去弄一大堆的设计模式。</p>
<h2 id="Python中重载"><a href="#Python中重载" class="headerlink" title="Python中重载"></a>Python中重载</h2><p>引自知乎:<a href="http://www.zhihu.com/question/20053359">http://www.zhihu.com/question/20053359</a></p>
<p>函数重载主要是为了解决两个问题。</p>
<ol>
<li><strong>可变参数类型。</strong></li>
<li><strong>可变参数个数。</strong></li>
</ol>
<p>另外，一个基本的设计原则是，<strong>仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</strong></p>
<p>好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p>
<p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，<strong>答案就是缺省参数</strong>。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。</p>
<p>好了，鉴于情况 1 跟 情况 2 都有了解决方案，<strong>python 自然就不需要函数重载了。</strong></p>
<h2 id="新式类和旧式类"><a href="#新式类和旧式类" class="headerlink" title="新式类和旧式类"></a>新式类和旧式类</h2><p>这个面试官问了,我说了老半天,不知道他问的真正意图是什么.</p>
<p><a href="http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python">stackoverflow</a></p>
<p>这篇文章很好的介绍了新式类的特性: <a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a></p>
<p>新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,<strong>Python3里的类全部都是新式类</strong>.这里有一个<strong>MRO问题</strong>可以了解下(<strong>新式类继承是根据C3算法,旧式类是深度优先</strong>),<python核心编程>里讲的也很多.</python核心编程></p>
<blockquote>
<p>一个旧式类的深度优先的例子</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">"A"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo2</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">"C"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B, C</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.foo1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>按照经典类的查找顺序<code>从左到右深度优先</code>的规则，在访问<code>d.foo1()</code>的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过</strong></p>
<p>新式类中特殊的只读属性<code>__mro__</code>，类型是一个元组，保存着解析顺序信息。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><ol>
<li>使用方法</li>
</ol>
<p>想在<strong>子类中调用父类的某个已经被覆盖</strong>的方法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">'B.spam'</span>)</span><br><span class="line">        <span class="built_in">super</span>().spam()  <span class="comment"># Call parent spam()</span></span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>使用场景</li>
</ol>
<p>(1) <code>super()</code> 函数的一个常见用法是在 <code>__init__()</code> 方法中确保父类被正确的初始化了，<strong>保证相同的基类只初始化一次</strong>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.y = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>(2) 解决多重继承中,<strong>子类重复调用父类方法</strong>的问题</p>
<p>super()使您避免显式引用基类。但是主要优势来自<strong>多重继承</strong>（直接用类名调用父类方法在使用单继承的时候没问题，<strong>但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）</strong>等种种问题。）</p>
<p>对于你定义的<strong>每一个类</strong>，Python会计算出一个所谓的<strong>方法解析顺序(MRO)列表</strong>。如果对于下一个类存在两个合法的选择，选择第一个父类。</p>
<p>只要每个重定义的方法统一使用 <code>super()</code> 并只调用它一次， 那么控制流最终会遍历完整个MRO列表，<strong>每个方法也只会被调用一次</strong>。 </p>
<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p07_calling_method_on_parent_class.html">https://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p07_calling_method_on_parent_class.html</a></p>
<p><a href="http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods">http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods</a></p>
<p><a href="http://blog.csdn.net/mrlevo520/article/details/51712440">Python2.7中的super方法浅见</a></p>
<h2 id="new-和-init-的区别"><a href="#new-和-init-的区别" class="headerlink" title="__new__和__init__的区别"></a><code>__new__</code>和<code>__init__</code>的区别</h2><p>这个<code>__new__</code>确实很少见到,先做了解吧.</p>
<ol>
<li><p><strong>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</strong></p>
</li>
<li><p><code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</p>
</li>
<li><p><code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</p>
</li>
<li><p>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才能被调用.</p>
</li>
</ol>
<p><a href="http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init">stackoverflow</a></p>
<p>ps: <code>__metaclass__</code>是创建类时起作用.所以我们可以分别使用<code>__metaclass__</code>,<code>__new__</code>和<code>__init__</code>来分别在类创建,实例创建和实例初始化的时候做一些小手脚.</p>
<h2 id="Python中的作用域"><a href="#Python中的作用域" class="headerlink" title="Python中的作用域"></a>Python中的作用域</h2><p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p>
<p>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：</p>
<p>函数作用域的<strong>LEGB</strong>顺序</p>
<p><strong>本地作用域（Local）→ 函数内部与内嵌函数之间（Enclosing locals）→全局/模块作用域（Global）→内建作用域（Built-in）</strong></p>
<h2 id="GIL线程全局锁"><a href="#GIL线程全局锁" class="headerlink" title="GIL线程全局锁"></a>GIL线程全局锁</h2><p>线程全局锁(Global Interpreter Lock), 即Python为了保证线程安全而采取的独立线程运行的限制, 说白了就是<strong>一个核只能在同一时间运行一个线程</strong>.<strong>对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。</strong></p>
<p>见<a href="http://www.oschina.net/translate/pythons-hardest-problem">Python 最难的问题</a></p>
<p>解决办法就是<strong>多进程的协程</strong>(协程也只是单CPU,但是能减小切换代价提升性能).</p>
<h2 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h2><p>lambda函数是<strong>匿名函数</strong>，使用lambda函数能<strong>创建小型匿名函数</strong>，这种函数<strong>得名于省略了用def声明函数的标准步骤</strong></p>
<p>1.lambda函数比较轻便，即用即仍，<strong>很适合需要完成一项功能，但是此功能只在此一处使用，连名字都很随意的情况下</strong></p>
<p>2.匿名函数，一般用来给filter，map这样的函数式编程服务</p>
<p>3.作为回调函数，传递给某些应用，比如消息处理</p>
<p>其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关.</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x, y: x + y </span><br><span class="line">print(add(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># Output: 8</span></span><br></pre></td></tr></tbody></table></figure>
<p>推荐: <a href="http://www.zhihu.com/question/20125256">知乎</a></p>
<h2 id="Python函数式编程（filter…）"><a href="#Python函数式编程（filter…）" class="headerlink" title="Python函数式编程（filter…）"></a>Python函数式编程（filter…）</h2><p>这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用.</p>
<p>推荐: <a href="http://coolshell.cn/articles/10822.html">酷壳</a></p>
<p><strong>python中函数式编程支持:</strong></p>
<p><strong>filter 函数</strong>的功能相当于过滤器。调用一个布尔函数<code>bool_func</code>来迭代遍历每个seq中的元素；返回一个使<code>bool_seq</code>返回值为true的元素的序列。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">&gt;&gt;&gt;b = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">5</span>, a)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span> b</span><br><span class="line">&gt;&gt;&gt;[<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>map函数</strong>是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x*<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(a)</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>reduce函数</strong>是对一个序列的每个项迭代调用函数，下面是求3的阶乘：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x*y,<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Python里的拷贝"><a href="#Python里的拷贝" class="headerlink" title="Python里的拷贝"></a>Python里的拷贝</h2><p>引用和copy(),deepcopy()的区别</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]  <span class="comment">#原始对象</span></span><br><span class="line"></span><br><span class="line">b = a  <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)  <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)  <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>)  <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>)  <span class="comment">#修改对象a中的['a', 'b']数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">'a = '</span>, a</span><br><span class="line"><span class="built_in">print</span> <span class="string">'b = '</span>, b</span><br><span class="line"><span class="built_in">print</span> <span class="string">'c = '</span>, c</span><br><span class="line"><span class="built_in">print</span> <span class="string">'d = '</span>, d</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Python中的赋值：</strong></p>
<p>赋值的本质就是将一个对象的内存空间地址赋值给一个变量，让变量指向该内存空间地址。</p>
<p><strong>Python浅拷贝：</strong></p>
<p>只拷贝父对象（不可变对象）的地址，子对象（可变对象）的地址还是原来的。</p>
<p>浅拷贝是拷贝了源对象的引用，<strong>并创建了一个新的内存空间地址</strong>。<strong>但是引用的对象的子对象的地址仍然是源对象的</strong>，所以当源对象的子对象发生改变时，拷贝对象内的子对象同时也跟着改变。</p>
<p><strong>Python深拷贝：</strong></p>
<p>拷贝父对象和子对象。</p>
<p>深拷贝就是彻底的拷贝，<strong>完全的拷贝了父对象及子对象，同时指向一个新的内存空间地址</strong>。源对象与拷贝对象之间的修改互不影响。</p>
<h2 id="Python垃圾回收机制"><a href="#Python垃圾回收机制" class="headerlink" title="Python垃圾回收机制"></a>Python垃圾回收机制</h2><p>Python GC主要使用<strong>引用计数（reference counting）来跟踪和回收垃圾</strong>。在引用计数的基础上，通过<strong>“标记-清除”</strong>（mark and sweep）解决容器对象可能产生的循环引用问题，通过<strong>“分代回收”（generation collection）以空间换时间</strong>的方法提高垃圾回收效率。</p>
<h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1 引用计数"></a>1 引用计数</h3><p>PyObject是每个对象必有的内容，其中<code>ob_refcnt</code>就是做为引用计数。<strong>当一个对象有新的引用时，它的<code>ob_refcnt</code>就会增加，当引用它的对象被删除，它的<code>ob_refcnt</code>就会减少.引用计数为0时，该对象生命就结束了。</strong></p>
<p>优点:</p>
<ol>
<li>简单</li>
<li>实时性</li>
</ol>
<p>缺点:</p>
<ol>
<li>维护引用计数消耗资源</li>
<li>循环引用</li>
</ol>
<h3 id="2-标记-清除机制"><a href="#2-标记-清除机制" class="headerlink" title="2 标记-清除机制"></a>2 标记-清除机制</h3><p>基本思路是<strong>先按需分配</strong>，等到没有空闲内存的时候<strong>从寄存器和程序栈上的引用</strong>出发，<strong>遍历以对象为节点、以引用为边构成的图</strong>，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p>
<h3 id="3-分代回收"><a href="#3-分代回收" class="headerlink" title="3 分代回收"></a>3 分代回收</h3><p>分代回收的整体思想是：<strong>将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</strong></p>
<p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。</p>
<p>举例：<br>当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。</p>
<h2 id="Python的List"><a href="#Python的List" class="headerlink" title="Python的List"></a>Python的List</h2><p>推荐: <a href="http://www.jianshu.com/p/J4U6rR">http://www.jianshu.com/p/J4U6rR</a></p>
<h2 id="Python的is和"><a href="#Python的is和" class="headerlink" title="Python的is和=="></a>Python的is和==</h2><p>is是对比地址(id())</p>
<p> ==是对比值(eql())</p>
<h2 id="read-readline和readlines"><a href="#read-readline和readlines" class="headerlink" title="read,readline和readlines"></a>read,readline和readlines</h2><ul>
<li>read        读取整个文件</li>
<li>readline    读取下一行,使用生成器方法；从文件读取整行，包括 “\n” 字符。如果指定了一个非负数的参数，则返回指定大小的字节数，包括 “\n” 字符。</li>
<li>readlines   读取整个文件到一个迭代器以供我们遍历</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fo.readlines():                         <span class="comment">#依次读取每行  </span></span><br><span class="line">    line = line.strip()                             <span class="comment">#去掉每行头尾空白  </span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"读取的数据为: %s"</span> % (line)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Python2和3的区别"><a href="#Python2和3的区别" class="headerlink" title="Python2和3的区别"></a>Python2和3的区别</h2><p>推荐：<a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/">Python 2.7.x 与 Python 3.x 的主要差异</a></p>
<ol>
<li><p>python2中可以使用<code>__future__</code>模块，来导入python3的特性</p>
</li>
<li><p>print函数</p>
</li>
<li>Python2 的默认编码是 <strong>asscii</strong>，这也是导致 Python2 中经常遇到编码问题的原因之一。Python 3 默认采用了 <strong>UTF-8</strong> 作为默认编码。</li>
<li>整除</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Python2</span></span><br><span class="line"><span class="number">3</span> / <span class="number">2</span> = <span class="number">1</span></span><br><span class="line"><span class="number">3</span> // <span class="number">2.0</span> = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python3</span></span><br><span class="line"><span class="number">3</span> / <span class="number">2</span> = <span class="number">1.5</span></span><br><span class="line"><span class="number">3</span> // <span class="number">2.0</span> = <span class="number">1.0</span></span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>在 Python 3 中已经解决了把用户的输入存储为一个 str 对象的问题(input())。为了避免在 <strong>Python 2 中的读取非字符串类型的危险行为</strong>，我们不得不使用 raw_input() 代替。</li>
</ol>
<h2 id="range-and-xrange"><a href="#range-and-xrange" class="headerlink" title="range and xrange"></a>range and xrange</h2><p><strong>都在循环时使用，xrange内存性能更好。</strong><br>for i in range(0, 20):<br>for i in xrange(0, 20):</p>
<p><strong>range创建一个列表</strong>，因此，如果执行range（1，10000000），它将在内存中创建一个包含9999999个元素的列表。<br><strong>xrange是一个延迟计算的序列对象，类似于生成器。</strong></p>
<p><a href="http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x">http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x</a></p>
<h2 id="python新式类和经典类的区别"><a href="#python新式类和经典类的区别" class="headerlink" title="python新式类和经典类的区别"></a>python新式类和经典类的区别</h2><p>a. <strong>在python里凡是继承了object的类，都是新式类</strong></p>
<p>b. <strong>Python3里只有新式类</strong></p>
<p>c. Python2里面继承object的是新式类，没有写父类的是经典类</p>
<p>d. 经典类目前在Python里基本没有应用</p>
<p>e. 保持class与type的统一对新式类的实例执行a.class与type(a)的结果是一致的，对于旧式类来说就不一样了。</p>
<p>f.<strong>对于多重继承的属性搜索顺序不一样新式类是采用广度优先搜索，旧式类采用深度优先搜索。</strong></p>
<h2 id="python中内置的数据结构有几种"><a href="#python中内置的数据结构有几种" class="headerlink" title="python中内置的数据结构有几种"></a>python中内置的数据结构有几种</h2><p>a. 整型 int、 长整型 long、浮点型 float、 复数 complex</p>
<p>b. 字符串 str、 列表 list、 元祖 tuple</p>
<p>c. 字典 dict 、 集合 set</p>
<p>d. <strong>Python3 中没有 long，只有无限精度的 int</strong></p>
<h2 id="编写函数的4个原则"><a href="#编写函数的4个原则" class="headerlink" title="编写函数的4个原则"></a>编写函数的4个原则</h2><ol>
<li><p>函数设计要尽量短小</p>
</li>
<li><p>函数声明要做到合理、简单、易于使用</p>
</li>
<li><p><strong>函数参数设计应该考虑向下兼容</strong></p>
</li>
<li><p><strong>一个函数只做一件事情，尽量保证函数语句粒度的一致性</strong></p>
</li>
</ol>
<h2 id="hasattr-getattr-setattr-函数使用详解？"><a href="#hasattr-getattr-setattr-函数使用详解？" class="headerlink" title="hasattr() getattr() setattr() 函数使用详解？"></a>hasattr() getattr() setattr() 函数使用详解？</h2><p>hasattr(object,name)函数:</p>
<p><strong>判断一个对象里面是否有name属性或者name方法</strong>，返回bool值，有name属性（方法）返回True，否则返回False。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function_demo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    name = <span class="string">'demo'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello function"</span></span><br><span class="line">functiondemo = function_demo()</span><br><span class="line">res = <span class="built_in">hasattr</span>(functiondemo, <span class="string">"name"</span>) <span class="comment"># 判断对象是否有name属性，True</span></span><br><span class="line">res = <span class="built_in">hasattr</span>(functiondemo, <span class="string">"run"</span>) <span class="comment"># 判断对象是否有run方法，True</span></span><br><span class="line">res = <span class="built_in">hasattr</span>(functiondemo, <span class="string">"age"</span>) <span class="comment"># 判断对象是否有age属性，False</span></span><br><span class="line">print(res)</span><br></pre></td></tr></tbody></table></figure>
<p>getattr(object, name[,default])函数：</p>
<p><strong>获取对象object的属性或者方法，如果存在则打印出来</strong>，如果不存在，打印默认值，默认值可选。注意：如果返回的是对象的方法，则打印结果是：方法的内存地址，如果需要运行这个方法，可以在后面添加括号().</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">functiondemo = function_demo()</span><br><span class="line"><span class="built_in">getattr</span>(functiondemo, <span class="string">"name"</span>)<span class="comment"># 获取name属性，存在就打印出来 --- demo</span></span><br><span class="line"><span class="built_in">getattr</span>(functiondemo, <span class="string">"run"</span>) <span class="comment"># 获取run 方法，存在打印出方法的内存地址</span></span><br><span class="line"><span class="built_in">getattr</span>(functiondemo, <span class="string">"age"</span>) <span class="comment"># 获取不存在的属性，报错</span></span><br><span class="line"><span class="built_in">getattr</span>(functiondemo, <span class="string">"age"</span>, <span class="number">18</span>)<span class="comment"># 获取不存在的属性，返回一个默认值</span></span><br></pre></td></tr></tbody></table></figure>
<p>setattr(object, name, values)函数：</p>
<p><strong>给对象的属性赋值，若属性不存在，先创建再赋值</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function_demo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    name = <span class="string">"demo"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello function"</span></span><br><span class="line">functiondemo = function_demo()</span><br><span class="line">res = <span class="built_in">hasattr</span>(functiondemo, <span class="string">"age"</span>) <span class="comment"># 判断age属性是否存在，False</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="built_in">setattr</span>(functiondemo, <span class="string">"age"</span>, <span class="number">18</span>) <span class="comment"># 对age属性进行赋值，无返回值</span></span><br><span class="line">res1 = <span class="built_in">hasattr</span>(functiondemo, <span class="string">"age"</span>) <span class="comment"># 再次判断属性是否存在，True</span></span><br></pre></td></tr></tbody></table></figure>
<p>综合使用</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function_demo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    name = <span class="string">"demo"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello function"</span></span><br><span class="line">functiondemo = function_demo()</span><br><span class="line">res = <span class="built_in">hasattr</span>(functiondemo, <span class="string">"addr"</span>) <span class="comment"># 先判断是否存在</span></span><br><span class="line"><span class="keyword">if</span> res:</span><br><span class="line">    addr = <span class="built_in">getattr</span>(functiondemo, <span class="string">"addr"</span>)</span><br><span class="line">    print(addr)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    addr = <span class="built_in">getattr</span>(functiondemo, <span class="string">"addr"</span>, <span class="built_in">setattr</span>(functiondemo, <span class="string">"addr"</span>, <span class="string">"北京首都"</span>))</span><br><span class="line">    print(addr)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="对缺省参数"><a href="#对缺省参数" class="headerlink" title="对缺省参数"></a>对缺省参数</h2><p>缺省参数指在调用函数的时候没有传入参数的情况下，调用默认的参数，在调用函数的同时赋值时，所传入的参数会替代默认参数。</p>
<p><strong>*args是不定长参数</strong>，它可以表示输入参数是不确定的，可以是任意多个。</p>
<p><code>**kwargs</code>是关键字参数，<strong>赋值的时候是以键值对的方式</strong>，参数可以是任意多对在定义函数的时候不确定会有多少参数会传入时，就可以使用两个参数</p>
<h2 id="为什么函数名字可以当做参数用"><a href="#为什么函数名字可以当做参数用" class="headerlink" title="为什么函数名字可以当做参数用"></a>为什么函数名字可以当做参数用</h2><p>Python中一切皆对象，<strong>函数名是函数在内存中的空间，也是一个对象</strong></p>
<h2 id="Python中pass语句的作用是什么"><a href="#Python中pass语句的作用是什么" class="headerlink" title="Python中pass语句的作用是什么"></a>Python中pass语句的作用是什么</h2><p>在编写代码时<strong>只写框架思路</strong>，具体实现还未编写就可以<strong>用pass进行占位</strong>，是程序不报错，不会进行任何操作。</p>
<h1 id="Python高级"><a href="#Python高级" class="headerlink" title="Python高级"></a>Python高级</h1><h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><h3 id="遍历一个object的所有属性，并print每一个属性名？"><a href="#遍历一个object的所有属性，并print每一个属性名？" class="headerlink" title="遍历一个object的所有属性，并print每一个属性名？"></a>遍历一个object的所有属性，并print每一个属性名？</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,loss</span>):</span> <span class="comment"># loss [价格，油耗，公里数]</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.loss = loss</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPrice</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 获取汽车价格</span></span><br><span class="line">        <span class="keyword">return</span> self.loss[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLoss</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 获取汽车损耗值</span></span><br><span class="line">        <span class="keyword">return</span> self.loss[<span class="number">1</span>] * self.loss[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">Bmw = Car(<span class="string">"宝马"</span>,[<span class="number">60</span>,<span class="number">9</span>,<span class="number">500</span>]) <span class="comment"># 实例化一个宝马车对象</span></span><br><span class="line">print(<span class="built_in">getattr</span>(Bmw,<span class="string">"name"</span>)) <span class="comment"># 使用getattr()传入对象名字,属性值。</span></span><br><span class="line">print(<span class="built_in">dir</span>(Bmw)) <span class="comment"># 获Bmw所有的属性和方法</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="写一个类，并让它尽可能多的支持操作符"><a href="#写一个类，并让它尽可能多的支持操作符" class="headerlink" title="写一个类，并让它尽可能多的支持操作符?"></a>写一个类，并让它尽可能多的支持操作符?</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>:</span></span><br><span class="line">    __list = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">"constructor"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">"destruct"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this self-defined array class"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self,key</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__list[key]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.__list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span>(<span class="params">self,value</span>):</span></span><br><span class="line">        self.__list.append(value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Remove</span>(<span class="params">self,index</span>):</span></span><br><span class="line">        <span class="keyword">del</span> self.__list[index]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DisplayItems</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">"show all items---"</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.__list:</span><br><span class="line">            <span class="built_in">print</span> item</span><br></pre></td></tr></tbody></table></figure>
<h3 id="介绍Cython，Pypy-Cpython-Numba各有什么缺点"><a href="#介绍Cython，Pypy-Cpython-Numba各有什么缺点" class="headerlink" title="介绍Cython，Pypy Cpython Numba各有什么缺点"></a>介绍Cython，Pypy Cpython Numba各有什么缺点</h3><ol>
<li>Pypy最重要的一点就是Pypy集成了JIT。同时针对CPython的缺点进行了各方面的改良，性能得到很大的提升（官方宣称为6.3倍）。<strong>缺点是对很多C语言库支持性不好</strong>。</li>
<li>Cython：Cython是让Python脚本支持C语言扩展的<strong>编译器</strong>，Cython能够将Python+C混合编码的.pyx脚本转换为C代码，主要用于优化Python脚本性能或Python调用C函数库。</li>
<li>Numba：Numba是一个库，可以<strong>在运行时将Python代码编译为本地机器指令</strong>，而不会强制大幅度的改变普通的Python代码。</li>
</ol>
<p>Pypy是非常理想的Python解释器，<strong>最大的瑕疵就是对部分库的兼容问题</strong>。Cython是一种Python + C的便利性组合，<strong>转为C编译的扩展执行效率非常高，但使用相对麻烦，移植CPython项目代价较高</strong>。Numba更适合针对性优化，效率高，<strong>并且不会大幅度的改变普通的Python代码</strong>。</p>
<h3 id="请描述抽象类和接口类的区别和联系"><a href="#请描述抽象类和接口类的区别和联系" class="headerlink" title="请描述抽象类和接口类的区别和联系"></a>请描述抽象类和接口类的区别和联系</h3><p>从设计层面来说，抽象是对类的抽象，是一种<strong>模板设计</strong>，接口是行为的抽象，是一种<strong>行为的规范</strong>。</p>
<p>1.抽象类： <strong>规定了一系列的方法，并规定了必须由继承类实现的方法。由于有抽象方法的存在，所以抽象类不能实例化。</strong></p>
<p>2.接口类：与抽象类很相似，表现在接口中定义的方法，必须由引用类实现。</p>
<p>区别和关联：</p>
<p>1.接口是抽象类的变体，<strong>接口中所有的方法都是抽象的</strong>，而抽象类中可以有非抽象方法，而抽象类可以实现部分方法</p>
<p>2.<strong>抽象类可以继承，接口不行</strong></p>
<p>3.接口中基本数据类型为static而抽象类不是</p>
<p>具体使用的场景</p>
<ul>
<li>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</li>
<li>如果<strong>你想实现多重继承，那么你必须使用接口</strong>。由于<strong>Java不支持多继承</strong>，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</li>
<li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li>
<li>多用组合，少用继承。</li>
</ul>
<h3 id="Python中如何动态获取和设置对象的属性？"><a href="#Python中如何动态获取和设置对象的属性？" class="headerlink" title="Python中如何动态获取和设置对象的属性？"></a>Python中如何动态获取和设置对象的属性？</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">hasattr</span>(Parent, <span class="string">'x'</span>):</span><br><span class="line">    print(<span class="built_in">getattr</span>(Parent, <span class="string">'x'</span>))</span><br><span class="line">    <span class="built_in">setattr</span>(Parent, <span class="string">'x'</span>,<span class="number">3</span>)</span><br><span class="line">print(<span class="built_in">getattr</span>(Parent,<span class="string">'x'</span>))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="内存管理与垃圾回收机制"><a href="#内存管理与垃圾回收机制" class="headerlink" title="内存管理与垃圾回收机制"></a>内存管理与垃圾回收机制</h2><h3 id="哪些操作会导致Python内存溢出，怎么处理？"><a href="#哪些操作会导致Python内存溢出，怎么处理？" class="headerlink" title="哪些操作会导致Python内存溢出，怎么处理？"></a>哪些操作会导致Python内存溢出，怎么处理？</h3><p>内存溢出原因：</p>
<ol>
<li>内存中加载的数据量过于庞大，如一次从数据库中取出过多数据。</li>
<li>代码中存在死循环，或循环过多重复的对象实体。</li>
<li>使用的第三方软件中的BUG。</li>
</ol>
<p>内存溢出的解决方案：</p>
<ol>
<li>修改JVM启动参数，直接增加内存。</li>
<li>检查错误日志，查看“OutOfMemory”错误前是否有其他异常错误。</li>
<li>对代码进行走查和分析，找出可能发生内存溢出的位置。</li>
</ol>
<h3 id="内存泄露是什么？如何避免？"><a href="#内存泄露是什么？如何避免？" class="headerlink" title="内存泄露是什么？如何避免？"></a>内存泄露是什么？如何避免？</h3><p><strong>内存泄漏</strong>指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致<strong>在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</strong></p>
<p>避免手段：</p>
<ol>
<li><p>有<code>__del__()</code>函数的对象间的循环引用是导致内存泄露的主凶。<strong>不使用一个对象时使用: del object 来删除一个对象的引用计数</strong>就可以有效防止内存泄露问题。</p>
</li>
<li><p>通过<strong>Python扩展模块gc</strong> 来查看不能回收的对象的详细信息。</p>
</li>
<li><p>可以通过 <strong>sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为0来判断是否内存泄露。</strong></p>
</li>
</ol>
<h3 id="关于Python内存管理-下列说法错误的是-B"><a href="#关于Python内存管理-下列说法错误的是-B" class="headerlink" title="关于Python内存管理,下列说法错误的是  B"></a>关于Python内存管理,下列说法错误的是  B</h3><p>A,变量不必事先声明                                   B,变量无须先创建和赋值而直接使用</p>
<p>C,变量无须指定类型                                   D,可以使用del释放资源</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="Python的魔法方法"><a href="#Python的魔法方法" class="headerlink" title="Python的魔法方法"></a>Python的魔法方法</h3><p>魔法方法就是可以给你的类增加魔力的特殊方法，如果你的<strong>对象实现（重载）了这些方法中的某一个</strong>，那么这个方法就会在特殊的情况下被Python所调用，你可以定义自己想要的行为，而这一切都是自动发生的，它们经常是两个下划线包围来命名的（比如<code>__init___</code>,<code>__len__</code>),Python的魔法方法是非常强大的所以了解其使用方法也变得尤为重要!</p>
<p><code>__init__</code>构造器，当一个实例被创建的时候初始化的方法，但是它并不是实例化调用的第一个方法。</p>
<p><code>__new__</code>才是实例化对象调用的第一个方法，它只取下cls参数，并把其他参数传给<code>__init___</code>.</p>
<p><code>___new__</code>很少使用，但是也有它适合的场景，尤其是当类继承自一个像元祖或者字符串这样不经常改变的类型的时候。</p>
<p><code>__call__</code>让一个类的实例像函数一样被调用</p>
<p><code>__getitem__</code>定义获取容器中指定元素的行为，相当于self[key]</p>
<p><code>__getattr__</code>定义当用户试图访问一个不存在属性的时候的行为。</p>
<p><code>__setattr__</code>定义当一个属性被设置的时候的行为</p>
<p><code>__getattribute___</code>定义当一个属性被访问的时候的行为</p>
<h3 id="面向对象中怎么实现只读属性"><a href="#面向对象中怎么实现只读属性" class="headerlink" title="面向对象中怎么实现只读属性?"></a>面向对象中怎么实现只读属性?</h3><p>将对象私有化，通过共有方法提供一个读取数据的接口</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.__age = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line">t = person(<span class="number">22</span>)</span><br><span class="line"><span class="comment"># t.__age =100</span></span><br><span class="line">print(t.age())</span><br></pre></td></tr></tbody></table></figure>
<p>最好的方法</p>
<p>Python内置的<code>@property</code>装饰器就是<strong>负责把一个方法变成属性调用的</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCls</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    __weight = <span class="number">50</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__weight  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="谈谈你对面向对象的理解？"><a href="#谈谈你对面向对象的理解？" class="headerlink" title="谈谈你对面向对象的理解？"></a>谈谈你对面向对象的理解？</h3><p>面向对象是相当于面向过程而言的，面向过程语言是一种<strong>基于功能分析的，以算法为中心</strong>的程序设计方法，而<strong>面向对象是一种基于结构分析的，以数据为中心的程序设计思想</strong>。在面向对象语言中有一个很重要的东西，叫做类。<strong>面向对象有三大特性：封装、继承、多态。</strong></p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="对设计模式的理解，简述你了解的设计模式？"><a href="#对设计模式的理解，简述你了解的设计模式？" class="headerlink" title="对设计模式的理解，简述你了解的设计模式？"></a>对设计模式的理解，简述你了解的设计模式？</h2><p>设计模式是指面向对象的设计模式，<strong>是有经验的程序员对代码开放的经验总结。解决特定问题的一系列套路。</strong>目的是用来提高代码可复用性、可维护性、可读性、稳健型及安全性。</p>
<p>所以设计模式不是什么理论，也不是什么语法规定，<strong>没有对错只有适不适合或者</strong>好与不好。</p>
<p>不能为了使用设计模式而去做架构，而是有了<strong>特定架构需求，这种架构层次在进行基本展开后发现它符合某一类设计模式的结构，再将两者相结合。</strong></p>
<p>设计模式按使用场景可以分为三大类</p>
<ul>
<li>创建型模式：对象实例化的模式，用于<strong>对象的创建对业务或应用逻辑是强依赖</strong></li>
<li>结构型模式：把类或对象结合在一起形成一个更大的结构。<strong>一般是解决不同的类之间有不同关系的情况</strong></li>
<li>行为型模式：<strong>类和对象如何交互</strong>，及划分责任和算法</li>
</ul>
<p><img data-src="/Users/koograce/Desktop/data/截屏2020-11-15 17.15.45.png" alt="截屏2020-11-15 17.15.45"></p>
<p>常见的是工厂模式和单例模式</p>
<p><a href="https://www.zhihu.com/question/23757906">https://www.zhihu.com/question/23757906</a></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>​    单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。<strong>通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。</strong>如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p>
<p><code>__new__()</code>在<code>__init__()</code>之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例<br><strong>这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.</strong></p>
</blockquote>
<h3 id="1-import方法"><a href="#1-import方法" class="headerlink" title="1 import方法"></a>1 import方法</h3><p>作为python的模块是天然的单例模式</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># mysingleton.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">my_singleton = My_Singleton()</span><br><span class="line"></span><br><span class="line"><span class="comment"># to use</span></span><br><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-使用-new-方法"><a href="#2-使用-new-方法" class="headerlink" title="2 使用__new__方法"></a>2 使用<code>__new__</code>方法</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, name, age</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.instance:</span><br><span class="line">            cls.instance = <span class="built_in">super</span>(Student, cls).__new__(cls)  </span><br><span class="line">        <span class="keyword">return</span> cls.instance  </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">s1 = Student(<span class="string">'张三'</span>,<span class="number">23</span>)</span><br><span class="line">s2 = Student(<span class="string">'李四'</span>,<span class="number">24</span>)</span><br><span class="line">print((s1==s2))</span><br><span class="line">print(s1 <span class="keyword">is</span> s2)</span><br><span class="line">print(<span class="built_in">id</span>(s1),<span class="built_in">id</span>(s2),sep=<span class="string">'   '</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-装饰器版本"><a href="#3-装饰器版本" class="headerlink" title="3 装饰器版本"></a>3 装饰器版本</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Singleton</span>(<span class="params">cls</span>):</span>   </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    cls:表示一个类名，即所要设计的单例类名称，</span></span><br><span class="line"><span class="string">        因为python一切皆对象，故而类名同样可以作为参数传递</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    instance = {}</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleton</span>(<span class="params">*args, **kargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instance:</span><br><span class="line">            instance[cls] = cls(*args, **kargs)   </span><br><span class="line">        <span class="keyword">return</span> instance[cls]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> singleton</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line"> </span><br><span class="line">s1 = Student(<span class="string">'张三'</span>,<span class="number">23</span>)</span><br><span class="line">s2 = Student(<span class="string">'李四'</span>,<span class="number">24</span>)</span><br><span class="line">print((s1==s2))</span><br><span class="line">print(s1 <span class="keyword">is</span> s2)</span><br><span class="line">print(<span class="built_in">id</span>(s1),<span class="built_in">id</span>(s2),sep=<span class="string">'   '</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><strong><a href="http://python.jobbole.com/87294/">单例模式伯乐在线详细解释</a></strong></p>
<h2 id="单例模式的应用场景有那些？"><a href="#单例模式的应用场景有那些？" class="headerlink" title="单例模式的应用场景有那些？"></a>单例模式的应用场景有那些？</h2><p>单例模式应用的场景一般发生在以下条件下：<br>控制资源的情况下，方便资源之间的互相通信。</p>
<p>如<strong>数据库连接池（因为数据库连接的创建和销毁很耗时）、线程池、日志对象、打印机等场景下。</strong></p>
<h2 id="装饰器和面向切面编程AOP"><a href="#装饰器和面向切面编程AOP" class="headerlink" title="装饰器和面向切面编程AOP"></a>装饰器和面向切面编程AOP</h2><p>对装饰器的理解，并写出一个计时器记录方法执行性能的装饰器？</p>
<p>装饰器(给原有对象添加新的功能)是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有<strong>鉴权、插入日志、性能测试、事务处理</strong>等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，<strong>装饰器的作用就是为已经存在的对象添加额外的功能。装饰器的返回值也是一个函数的对象</strong></p>
<p>中文: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a></p>
<p>详细参考：<a href="https://manjusaka.itscoder.com/2018/02/23/something-about-decorator/">https://manjusaka.itscoder.com/2018/02/23/something-about-decorator/</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        start = time.clock()</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        end = time.clock()</span><br><span class="line">        print(<span class="string">'used:'</span>,end-start)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="string">'in foo()'</span>foo())</span><br></pre></td></tr></tbody></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p>
<p><strong>当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包.</strong> 总结一下,创建一个闭包必须满足以下几点:</p>
<ol>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数中的变量</li>
<li>外部函数的返回值必须是内嵌函数</li>
</ol>
<p>感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料.</p>
<p><strong>重点是函数运行后并不会被撤销</strong>,就像单例模式-装饰器版本中的instance字典一样<strong>（装饰器）</strong>,<strong>当函数运行完后,instance并不被销毁,而是继续留在内存空间里</strong>.这个功能类似类里的类变量,只不过迁移到了函数上.</p>
<p>闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.</p>
<h2 id="迭代器-生成器的区别？"><a href="#迭代器-生成器的区别？" class="headerlink" title="迭代器,生成器的区别？"></a>迭代器,生成器的区别？</h2><ul>
<li><p><strong>迭代器</strong>(iterator)是遵循迭代协议的对象。用户可以使用 iter() 以从任何序列得到迭代器（如 list, tuple, dictionary, set 等）。另一个方法则是创建一个另一种形式的迭代器 —— generator 。要获取下一个元素，则使用函数 <code>__next()__</code> （Python 3）。当没有元素时，则引发 StopIteration 此例外。</p>
</li>
<li><p>生成器（Generator），<strong>只是在需要返回数据的时候使用yield语句（yield就是保存当前程序执行状态）</strong>。每次next()被调用时，生成器会返回它脱离的位置（<strong>它记忆语句最后一次执行的位置和所有的数据值</strong>）</p>
</li>
</ul>
<p>区别： 生成器也是一种迭代器，但<strong>只使用一次迭代</strong>。这是因为它们并没有把所有的值存在内存中，<strong>而是在运行时生成值</strong>。</p>
<p>这里有个关于生成器的创建问题面试官有考：<br>问：  将列表生成式中[]改成() 之后数据结构是否改变？<br>答案：<strong>是，从列表变为生成器</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x0000028F8B774200</span>&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。<strong>在Python中，我们可以采用生成器：边循环，边计算的机制—&gt;generator</strong></p>
<p>官方介绍：<a href="https://docs.python.org/3/tutorial/classes.html#iterators">https://docs.python.org/3/tutorial/classes.html#iterators</a></p>
<h2 id="请用一行代码-实现将1-N-的整数列表以3为单位分组"><a href="#请用一行代码-实现将1-N-的整数列表以3为单位分组" class="headerlink" title="请用一行代码 实现将1-N 的整数列表以3为单位分组"></a>请用一行代码 实现将1-N 的整数列表以3为单位分组</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">N =<span class="number">100</span></span><br><span class="line"><span class="built_in">print</span> ([[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>)] [i:i+<span class="number">3</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">100</span>,<span class="number">3</span>)])</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Python中yield的用法"><a href="#Python中yield的用法" class="headerlink" title="Python中yield的用法?"></a>Python中yield的用法?</h2><p><strong>yield就是保存当前程序执行状态</strong>。你用for循环的时候，每次取一个元素的时候就会计算一次。用yield的函数叫generator,和iterator一样，它的好处是不用一次计算所有元素，而是用一次算一次，可以节省很多空间，generator每次计算需要上一次计算结果，所以用yield,否则一return，上次计算结果就没了</p>
<h1 id="NIX"><a href="#NIX" class="headerlink" title="*NIX"></a>*NIX</h1><h2 id="unix进程间通信方式-IPC"><a href="#unix进程间通信方式-IPC" class="headerlink" title="unix进程间通信方式(IPC)"></a>unix进程间通信方式(IPC)</h2><ol>
<li><strong>管道（Pipe）</strong>：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li>
<li><strong>命名管道</strong>（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li>
<li><strong>信号（Signal）</strong>：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li>
<li><strong>信号量</strong>（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li>
<li><strong>共享内存</strong>：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li>
<li><strong>内存映射</strong>（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>
<li><strong>套接口</strong>（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li>
<li><strong>消息（Message）队列</strong>：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。</li>
</ol>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> root,dirs,files <span class="keyword">in</span> os.walk(<span class="built_in">dir</span>): <span class="comment"># 返回目录下所有目录及其文件</span></span><br><span class="line">name, suf = os.path.splitext(filename) <span class="comment"># 拆分文件的名与后缀</span></span><br><span class="line"></span><br><span class="line">os.listdir()</span><br><span class="line">os.path.join()</span><br><span class="line">os.path.isdir()</span><br><span class="line">os.path.isfile()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="有一个jsonline格式的文件file-txt大小约为10K"><a href="#有一个jsonline格式的文件file-txt大小约为10K" class="headerlink" title="有一个jsonline格式的文件file.txt大小约为10K"></a>有一个jsonline格式的文件file.txt大小约为10K</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_lines</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'file.txt'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.readlines()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> get_lines():</span><br><span class="line">        process(e) <span class="comment"># 处理每一行数据</span></span><br></pre></td></tr></tbody></table></figure>
<p>现在要处理一个大小为10G的文件，但是内存只有4G，如果在只修改get_lines 函数而其他代码保持不变的情况下，应该如何实现？需要考虑的问题都有那些？</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_lines</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'file.txt'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">            <span class="keyword">yield</span> i</span><br></pre></td></tr></tbody></table></figure>
<p>个人认为：还是设置下每次返回的行数较好，否则读取次数太多。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_lines</span>():</span></span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'file.txt'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">      data = f.readline(<span class="number">60000</span>)</span><br><span class="line">    	l.append(data)</span><br><span class="line">    	<span class="keyword">yield</span> l</span><br></pre></td></tr></tbody></table></figure>
<p>Pandaaaa906提供的方法</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mmap <span class="keyword">import</span> mmap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_lines</span>(<span class="params">fp</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fp,<span class="string">"r+"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        m = mmap(f.fileno(), <span class="number">0</span>)</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(m):</span><br><span class="line">            <span class="keyword">if</span> char==<span class="string">b"\n"</span>:</span><br><span class="line">                <span class="keyword">yield</span> m[tmp:i+<span class="number">1</span>].decode()</span><br><span class="line">                tmp = i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> get_lines(<span class="string">"fp_some_huge_file"</span>):</span><br><span class="line">        print(i)</span><br></pre></td></tr></tbody></table></figure>
<p>要考虑的问题有：内存只有4G无法一次性读入10G文件，需要分批读入分批读入数据要记录每次读入数据的位置。分批每次读取数据的大小，太小会在读取操作花费过多时间。<br><a href="https://stackoverflow.com/questions/30294146/python-fastest-way-to-process-large-file">https://stackoverflow.com/questions/30294146/python-fastest-way-to-process-large-file</a></p>
<h2 id="设计实现遍历目录与子目录，抓取-pyc文件"><a href="#设计实现遍历目录与子目录，抓取-pyc文件" class="headerlink" title="设计实现遍历目录与子目录，抓取.pyc文件"></a>设计实现遍历目录与子目录，抓取.pyc文件</h2><p>第一种方法：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_files</span>(<span class="params"><span class="built_in">dir</span>,suffix</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> root,dirs,files <span class="keyword">in</span> os.walk(<span class="built_in">dir</span>):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">            name,suf = os.path.splitext(filename)</span><br><span class="line">            <span class="keyword">if</span> suf == suffix:</span><br><span class="line">                res.append(os.path.join(root,filename))</span><br><span class="line"></span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">get_files(<span class="string">"./"</span>,<span class="string">'.pyc'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>第二种方法：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pick</span>(<span class="params">obj</span>):</span></span><br><span class="line">    <span class="keyword">if</span> obj.endswith(<span class="string">".pyc"</span>):</span><br><span class="line">        print(obj)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan_path</span>(<span class="params">ph</span>):</span></span><br><span class="line">    file_list = os.listdir(ph)</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> file_list:</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(obj):</span><br><span class="line">            pick(obj)</span><br><span class="line">        <span class="keyword">elif</span> os.path.isdir(obj):</span><br><span class="line">            scan_path(obj)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    path = <span class="built_in">input</span>(<span class="string">'输入目录'</span>)</span><br><span class="line">    scan_path(path)</span><br></pre></td></tr></tbody></table></figure>
<p>第三种方法</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> iglob</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">fp, postfix</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> iglob(<span class="string">f"<span class="subst">{fp}</span>/**/*<span class="subst">{postfix}</span>"</span>, recursive=<span class="literal">True</span>):</span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    postfix = <span class="string">".pyc"</span></span><br><span class="line">    func(<span class="string">"K:\Python_script"</span>, postfix)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="补充缺失的代码"><a href="#补充缺失的代码" class="headerlink" title="补充缺失的代码"></a>补充缺失的代码</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_directory_contents</span>(<span class="params">sPath</span>):</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">这个函数接收文件夹的名称作为输入参数</span></span><br><span class="line"><span class="string">返回该文件夹中文件的路径</span></span><br><span class="line"><span class="string">以及其包含文件夹中文件的路径</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> s_child <span class="keyword">in</span> os.listdir(s_path):</span><br><span class="line">    s_child_path = os.path.join(s_path, s_child)</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(s_child_path):</span><br><span class="line">        print_directory_contents(s_child_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(s_child_path)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h1><h2 id="输入日期，-判断这一天是这一年的第几天？"><a href="#输入日期，-判断这一天是这一年的第几天？" class="headerlink" title="输入日期， 判断这一天是这一年的第几天？"></a>输入日期， 判断这一天是这一年的第几天？</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">datetime.date(year=<span class="built_in">int</span>(year),month=<span class="number">1</span>,day=<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dayofyear</span>():</span></span><br><span class="line">    year = <span class="built_in">input</span>(<span class="string">"请输入年份: "</span>)</span><br><span class="line">    month = <span class="built_in">input</span>(<span class="string">"请输入月份: "</span>)</span><br><span class="line">    day = <span class="built_in">input</span>(<span class="string">"请输入天: "</span>)</span><br><span class="line">    date1 = datetime.date(year=<span class="built_in">int</span>(year),month=<span class="built_in">int</span>(month),day=<span class="built_in">int</span>(day))</span><br><span class="line">    date2 = datetime.date(year=<span class="built_in">int</span>(year),month=<span class="number">1</span>,day=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> (date1-date2).days+<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="打乱一个排好序的list对象alist？"><a href="#打乱一个排好序的list对象alist？" class="headerlink" title="打乱一个排好序的list对象alist？"></a>打乱一个排好序的list对象alist？</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">random.shuffle(alist)</span><br><span class="line">print(alist)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="Python后端架构演进"><a href="#Python后端架构演进" class="headerlink" title="Python后端架构演进"></a><a href="https://zhu327.github.io/2018/07/19/python%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/">Python后端架构演进</a></h3><p>这篇文章几乎涵盖了python会用的架构，在面试可以手画架构图，根据自己的项目谈下技术选型和优劣，遇到的坑等。绝对加分</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="请写出一段代码用正则匹配出ip？"><a href="#请写出一段代码用正则匹配出ip？" class="headerlink" title="请写出一段代码用正则匹配出ip？"></a>请写出一段代码用正则匹配出ip？</h2><h2 id="a-“abbbccc”，用正则匹配为abccc-不管有多少b，就出现一次？"><a href="#a-“abbbccc”，用正则匹配为abccc-不管有多少b，就出现一次？" class="headerlink" title="a = “abbbccc”，用正则匹配为abccc,不管有多少b，就出现一次？"></a>a = “abbbccc”，用正则匹配为abccc,不管有多少b，就出现一次？</h2><pre><code>思路：不管有多少个b替换成一个

re.sub(r'b+', 'b', a)
</code></pre><h2 id="Python字符串查找和替换？"><a href="#Python字符串查找和替换？" class="headerlink" title="Python字符串查找和替换？"></a>Python字符串查找和替换？</h2><pre><code>a、str.find()：正序字符串查找函数
函数原型：
str.find(substr [,pos_start [,pos_end ] ] )
返回str中第一次出现的substr的第一个字母的标号，如果str中没有substr则返回-1，也就是说从左边算起的第一次出现的substr的首字母标号。

参数说明：
str：代表原字符串
substr：代表要查找的字符串
pos_start：代表查找的开始位置，默认是从下标0开始查找
pos_end：代表查找的结束位置

例子：
'aabbcc.find('bb')' # 2

b、str.index()：正序字符串查找函数
index()函数类似于find()函数，在Python中也是在字符串中查找子串第一次出现的位置，跟find()不同的是，未找到则抛出异常。

函数原型：
str.index(substr [, pos_start, [ pos_end ] ] )

参数说明：
str：代表原字符串
substr：代表要查找的字符串
pos_start：代表查找的开始位置，默认是从下标0开始查找
pos_end：代表查找的结束位置

例子：
'acdd l1 23'.index(' ') # 4

c、str.rfind()：倒序字符串查找函数

函数原型：
str.rfind( substr [, pos_start [,pos_ end ] ])
返回str中最后出现的substr的第一个字母的标号，如果str中没有substr则返回-1，也就是说从右边算起的第一次出现的substr的首字母标号。

参数说明：
str：代表原字符串
substr：代表要查找的字符串
pos_start：代表查找的开始位置，默认是从下标0开始查找
pos_end：代表查找的结束位置

例子：
'adsfddf'.rfind('d') # 5

d、str.rindex()：倒序字符串查找函数
rindex()函数类似于rfind()函数，在Python中也是在字符串中倒序查找子串最后一次出现的位置，跟rfind()不同的是，未找到则抛出异常。

函数原型：
str.rindex(substr [, pos_start, [ pos_end ] ] )

参数说明：
str：代表原字符串
substr：代表要查找的字符串
pos_start：代表查找的开始位置，默认是从下标0开始查找
pos_end：代表查找的结束位置

例子：
 'adsfddf'.rindex('d') # 5

e、使用re模块进行查找和替换：
</code></pre><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>re.match(pat, s)</td>
<td>只从字符串s的头开始匹配，比如(‘123’, ‘12345’)匹配上了，而(‘123’,’01234’)就是没有匹配上，没有匹配上返回None，匹配上返回matchobject</td>
</tr>
<tr>
<td>re.search(pat, s)</td>
<td>从字符串s的任意位置都进行匹配，比如(‘123’,’01234’)就是匹配上了，只要s只能存在符合pat的连续字符串就算匹配上了，没有匹配上返回None，匹配上返回matchobject</td>
</tr>
<tr>
<td>re.sub(pat,newpat,s)</td>
<td>re.sub(pat,newpat,s)    对字符串中s的包含的所有符合pat的连续字符串进行替换，如果newpat为str,那么就是替换为newpat,如果newpat是函数，那么就按照函数返回值替换。sub函数两个有默认值的参数分别是count表示最多只处理前几个匹配的字符串，默认为0表示全部处理；最后一个是flags，默认为0</td>
</tr>
</tbody>
</table>
</div>
<pre><code>f、使用replace()进行替换：
基本用法：对象.replace(rgExp,replaceText,max)

其中，rgExp和replaceText是必须要有的，max是可选的参数，可以不加。
rgExp是指正则表达式模式或可用标志的正则表达式对象，也可以是 String 对象或文字；
replaceText是一个String 对象或字符串文字；
max是一个数字。
对于一个对象，在对象的每个rgExp都替换成replaceText，从左到右最多max次。

s1='hello world'
s1.replace('world','liming')
</code></pre><h2 id="用Python匹配HTML-tag的时候，-lt-gt-和-lt-gt-有什么区别"><a href="#用Python匹配HTML-tag的时候，-lt-gt-和-lt-gt-有什么区别" class="headerlink" title="用Python匹配HTML tag的时候，<.> 和 <.?> 有什么区别"></a>用Python匹配HTML tag的时候，&lt;.<em>&gt; 和 &lt;.</em>?&gt; 有什么区别</h2><pre><code>第一个代表贪心匹配，第二个代表非贪心；
?在一般正则表达式里的语法是指的"零次或一次匹配左边的字符或表达式"相当于{0,1}
而当?后缀于*,+,?,{n},{n,},{n,m}之后，则代表非贪心匹配模式，也就是说，尽可能少的匹配左边的字符或表达式，这里是尽可能少的匹配.(任意字符)

所以：第一种写法是，尽可能多的匹配，就是匹配到的字符串尽量长，第二中写法是尽可能少的匹配，就是匹配到的字符串尽量短。
比如&lt;tag&gt;tag&gt;tag&gt;end，第一个会匹配&lt;tag&gt;tag&gt;tag&gt;,第二个会匹配&lt;tag&gt;。
</code></pre><h2 id="正则表达式贪婪与非贪婪模式的区别？"><a href="#正则表达式贪婪与非贪婪模式的区别？" class="headerlink" title="正则表达式贪婪与非贪婪模式的区别？"></a>正则表达式贪婪与非贪婪模式的区别？</h2><pre><code>贪婪模式：
定义：正则表达式去匹配时，会尽量多的匹配符合条件的内容
标识符：+，?，*，{n}，{n,}，{n,m}
匹配时，如果遇到上述标识符，代表是贪婪匹配，会尽可能多的去匹配内容

非贪婪模式：
定义：正则表达式去匹配时，会尽量少的匹配符合条件的内容 也就是说，一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去(除非有g，开启下一组匹配)
标识符：+?，??，*?，{n}?，{n,}?，{n,m}?
可以看到，非贪婪模式的标识符很有规律，就是贪婪模式的标识符后面加上一个?

参考文章：https://dailc.github.io/2017/07/06/regularExpressionGreedyAndLazy.html
</code></pre><h2 id="写出开头匹配字母和下划线，末尾是数字的正则表达式？"><a href="#写出开头匹配字母和下划线，末尾是数字的正则表达式？" class="headerlink" title="写出开头匹配字母和下划线，末尾是数字的正则表达式？"></a>写出开头匹配字母和下划线，末尾是数字的正则表达式？</h2><pre><code>s1='_aai0efe00'
res=re.findall('^[a-zA-Z_]?[a-zA-Z0-9_]{1,}\d$',s1)
print(res)
</code></pre><h2 id="正则表达式操作"><a href="#正则表达式操作" class="headerlink" title="正则表达式操作"></a>正则表达式操作</h2><h2 id="请匹配出变量A-中的json字符串。"><a href="#请匹配出变量A-中的json字符串。" class="headerlink" title="请匹配出变量A 中的json字符串。"></a>请匹配出变量A 中的json字符串。</h2><h2 id="怎么过滤评论中的表情？"><a href="#怎么过滤评论中的表情？" class="headerlink" title="怎么过滤评论中的表情？"></a>怎么过滤评论中的表情？</h2><pre><code>思路：主要是匹配表情包的范围，将表情包的范围用空替换掉
</code></pre><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">pattern = re.compile(u'[\uD800-\uDBFF][\uDC00-\uDFFF]')</span><br><span class="line">pattern.sub('',text)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="简述Python里面search和match的区别"><a href="#简述Python里面search和match的区别" class="headerlink" title="简述Python里面search和match的区别"></a>简述Python里面search和match的区别</h2><pre><code>match()函数只检测字符串开头位置是否匹配，匹配成功才会返回结果，否则返回None；
search()函数会在整个字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。
</code></pre><h2 id="请写出匹配ip的Python正则表达式"><a href="#请写出匹配ip的Python正则表达式" class="headerlink" title="请写出匹配ip的Python正则表达式"></a>请写出匹配ip的Python正则表达式</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Python Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode_&amp;_Algorithm</title>
    <url>/posts/55663/</url>
    <content><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">题目类型</th>
<th style="text-align:left">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Hash">Hash</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#twoSum">twoSum</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#valid-sudoku">valid-sudoku</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#first-missing-positive">first-missing-positive</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#LinkNode">LinkNode</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#add-two-numbers">add-two-numbers</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#merge-two-sorted-lists">merge-two-sorted-lists</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#swap-nodes-in-pairs">swap-nodes-in-pairs</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#reverse-nodes-in-k-group">reverse-nodes-in-k-group</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#rotate-list">rotate-list</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#remove-duplicates-from-sorted-list-ii">remove-duplicates-from-sorted-list-ii</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#remove-duplicates-from-sorted-list">remove-duplicates-from-sorted-list</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#partition-list">partition-list</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#reverse-linked-list-ii">reverse-linked-list-ii</a></td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">题目类型</th>
<th style="text-align:left">题目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Hash">Hash</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#twoSum">twoSum</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#valid-sudoku">valid-sudoku</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#first-missing-positive">first-missing-positive</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#LinkNode">LinkNode</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#add-two-numbers">add-two-numbers</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#merge-two-sorted-lists">merge-two-sorted-lists</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#swap-nodes-in-pairs">swap-nodes-in-pairs</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#reverse-nodes-in-k-group">reverse-nodes-in-k-group</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#rotate-list">rotate-list</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#remove-duplicates-from-sorted-list-ii">remove-duplicates-from-sorted-list-ii</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#remove-duplicates-from-sorted-list">remove-duplicates-from-sorted-list</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#partition-list">partition-list</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#reverse-linked-list-ii">reverse-linked-list-ii</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#BackTrack">BackTrack</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#find-median-sorted-array">find-median-sorted-array</a> — Recursion</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#sudoku-solver">sudoku-solver</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#combination-sum">combination-sum</a> — Recursion</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#permutations">permutations</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#permutations-ii">permutations-ii</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#powx-n">powx-n</a> — Recursion</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#n-queens">n-queens</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#n-queens-ii">n-queens-ii</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://leetcode-cn.com/problems/combinations/">combinations</a>— Recursion</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#subsets">subsets</a>— Recursion</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#subsets-ii">subsets-ii</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#word-search">word-search</a>— Recursion</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#gray-code">gray-code</a>— Recursion</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#restore-ip-addresses">restore-ip-addresses</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#scramble-string">scramble-string</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#different-ways-to-add-parentheses">different-ways-to-add-parentheses</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#letter-case-permutation">letter-case-permutation</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#palindrome-partitioning">palindrome-partitioning</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#2DMatric">2DMatric</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#longest-palindrome">longest-palindrome</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#rotate-image">rotate-image</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#spiral-matrix">spiral-matrix</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#spiral-matrix-ii">spiral-matrix-ii</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#set-matrix-zeroes">set-matrix-zeroes</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Regular Expression">Regular Expression</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#string-to-integer-atoi">string-to-integer-atoi</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#regular-expression-matchin">regular-expression-matchin</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#valid-number">valid-number</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Stack">Stack</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#valid-parentheses">valid-parentheses</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#largest-rectangle-in-histogram">largest-rectangle-in-histogram</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#maximal-rectangle">maximal-rectangle</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#BinaryTree">BinaryTree</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#generate-parentheses">generate-parentheses</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Queue">Queue</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#merge-k-sorted-lists">merge-k-sorted-lists</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Bit Operation">Bit Operation</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#divide-two-integers">divide-two-integers</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#gray-code">gray-code</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#convert-a-number-to-hexadecimal">convert-a-number-to-hexadecimal</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#binary-watch">binary-watch</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Binary Search">Binary Search</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#find-first-and-last-position-of-element-in-sorted-array">find-first-and-last-position-of-element-in-sorted-array</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#sqrtx">sqrtx</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#search-a-2d-matrix">search-a-2d-matrix</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#search-in-rotated-sorted-array-ii">search-in-rotated-sorted-array</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Double Pointer">Double Pointer</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#trapping-rain-water">trapping-rain-water</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#sort-colors">sort-colors</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#minimum-window-substring">minimum-window-substring</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#remove-duplicates-from-sorted-array-ii">remove-duplicates-from-sorted-array-ii</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#merge-sorted-array">merge-sorted-array</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Dynamic Programming">Dynamic Programming</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#wildcard-matching">wildcard-matching</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#maximum-subarray">maximum-subarray</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#jump-game">jump-game</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#unique-paths">unique-paths</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#unique-paths-ii">unique-paths-ii</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#minimum-path-sum">minimum-path-sum</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#climbing-stairs">climbing-stairs</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#edit-distance">edit-distance</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#decode-ways">decode-ways</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interleaving-string">interleaving-string</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#split-array-with-equal-sum">split-array-with-equal-sum</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Greedy Algorithm">Greedy Algorithm</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#jump-game-ii">jump-game-ii</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#maximum-subarray">maximum-subarray</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#merge-intervals">merge-intervals</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#insert-interval">insert-interval</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#queue-reconstruction-by-height">queue-reconstruction-by-height</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#String">String</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#valid-number">valid-number</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#text-justification">text-justification</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#simplify-path">simplify-path</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Tree">Tree</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#binary-tree-inorder-traversal">binary-tree-inorder-traversal</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#unique-binary-search-trees-ii">unique-binary-search-trees-ii</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#unique-binary-search-trees">unique-binary-search-trees</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#validate-binary-search-tree">validate-binary-search-tree</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#recover-binary-search-tree">recover-binary-search-tree</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#same-tree">same-tree</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#sort">sort</a></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#largest-number">largest-number</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#kth-largest-element-in-an-array">kth-largest-element-in-an-array</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#sort-an-array">sort-an-array</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#contains-duplicate-iii">contains-duplicate-iii</a> — bucket</td>
</tr>
</tbody>
</table>
</div>
<!--more-->
<h1 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h1><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th style="text-align:left">题目</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_1">二维数组中的查找</a></td>
<td>数组、查找</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_7">斐波那契数列</a></td>
<td>数组</td>
</tr>
<tr>
<td>13</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_13">调整数组顺序使奇数位于偶数前面</a></td>
<td>数组</td>
</tr>
<tr>
<td>19</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_19">顺时针打印矩阵</a></td>
<td>数组</td>
</tr>
<tr>
<td>29</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_29">最小的K个数</a></td>
<td>数组、高级算法</td>
</tr>
<tr>
<td>32</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_32">把数组排成最小的数</a></td>
<td>数组</td>
</tr>
<tr>
<td>35</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_35">数组中的逆序对</a></td>
<td>数组</td>
</tr>
<tr>
<td>37</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_37">数字在排序数组中出现的次数</a></td>
<td>数组、二分</td>
</tr>
<tr>
<td>42</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_42">和为S的两个数字</a></td>
<td>数组、双指针</td>
</tr>
<tr>
<td>49</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_49">把字符串转换成整数</a></td>
<td>数组</td>
</tr>
<tr>
<td>50</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_50">数组中重复的数字</a></td>
<td>数组</td>
</tr>
<tr>
<td>51</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_51">构建乘积数组</a></td>
<td>数组</td>
</tr>
<tr>
<td>66</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_66">机器人的运动范围</a></td>
<td>数组</td>
</tr>
<tr>
<td>67</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_67">剪绳子</a></td>
<td>数组、贪心、高级算法</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_2">替换空格</a></td>
<td>字符串</td>
</tr>
<tr>
<td>27</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_27">字符串的排列</a></td>
<td>字符串、动态规划</td>
</tr>
<tr>
<td>34</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_34">第一个只出现一次的字符位置</a></td>
<td>字符串</td>
</tr>
<tr>
<td>43</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_43">左旋转字符串</a></td>
<td>字符串</td>
</tr>
<tr>
<td>44</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_44">翻转单词顺序列</a></td>
<td>字符串</td>
</tr>
<tr>
<td>45</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_45">扑克牌顺子</a></td>
<td>字符串</td>
</tr>
<tr>
<td>48</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_48">不用加减乘除做加法</a></td>
<td>字符串、数学</td>
</tr>
<tr>
<td>52</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_52">正则表达式匹配</a></td>
<td>字符串</td>
</tr>
<tr>
<td>53</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_53">表示数值的字符串</a></td>
<td>字符串</td>
</tr>
<tr>
<td>54</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_54">字符流中第一个不重复的字符</a></td>
<td>字符串</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_3">从尾到头打印链表</a></td>
<td>链表</td>
</tr>
<tr>
<td>14</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_14">链表中倒数第K个结点</a></td>
<td>链表、双指针</td>
</tr>
<tr>
<td>15</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_15">反转链表</a></td>
<td>链表</td>
</tr>
<tr>
<td>25</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_25">复杂链表的复制</a></td>
<td>链表</td>
</tr>
<tr>
<td>36</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_36">两个链表的第一个公共结点</a></td>
<td>链表</td>
</tr>
<tr>
<td>46</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_46">圆圈中最后剩下的元素</a></td>
<td>链表</td>
</tr>
<tr>
<td>55</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_55">链表中环的入口结点</a></td>
<td>链表</td>
</tr>
<tr>
<td>56</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_56">删除链表中重复的结点</a></td>
<td>链表</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_4">重建二叉树</a></td>
<td>树、dfs、数组</td>
</tr>
<tr>
<td>17</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_17">树的子结构</a></td>
<td>树</td>
</tr>
<tr>
<td>18</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_18">二叉树的镜像</a></td>
<td>树</td>
</tr>
<tr>
<td>22</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_22">从上往下打印二叉树</a></td>
<td>树、队列</td>
</tr>
<tr>
<td>23</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_23">二叉搜索树的后序遍历序列</a></td>
<td>树、栈</td>
</tr>
<tr>
<td>24</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_24">二叉树中和为某一值的路径</a></td>
<td>树</td>
</tr>
<tr>
<td>38</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_38">二叉树的深度</a></td>
<td>树</td>
</tr>
<tr>
<td>39</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_39">平衡二叉树</a></td>
<td>树、dfs</td>
</tr>
<tr>
<td>57</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_57">二叉树的下一个结点</a></td>
<td>树</td>
</tr>
<tr>
<td>58</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_58">对称的二叉树</a></td>
<td>树</td>
</tr>
<tr>
<td>59</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_59">按之字形顺序打印二叉树</a></td>
<td>树、栈</td>
</tr>
<tr>
<td>60</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_60">把二叉树打印成多行</a></td>
<td>树、bfs</td>
</tr>
<tr>
<td>61</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_61">序列化二叉树</a></td>
<td>树、队列</td>
</tr>
<tr>
<td>62</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_62">二叉搜索树的第K个结点</a></td>
<td>树</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_5">用两个栈实现队列</a></td>
<td>栈</td>
</tr>
<tr>
<td>20</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_20">包含min函数的栈</a></td>
<td>栈</td>
</tr>
<tr>
<td>21</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_21">栈的压入、弹出序列</a></td>
<td>栈</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_6">旋转数组的最小数字</a></td>
<td>二分</td>
</tr>
<tr>
<td>8</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_8">跳台阶</a></td>
<td>递归</td>
</tr>
<tr>
<td>10</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_10">矩形覆盖</a></td>
<td>递归</td>
</tr>
<tr>
<td>9</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_9">变态跳台阶</a></td>
<td>贪心</td>
</tr>
<tr>
<td>11</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_11">二进制中1的个数</a></td>
<td>数学</td>
</tr>
<tr>
<td>12</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_12">数值的整数次方</a></td>
<td>数学</td>
</tr>
<tr>
<td>33</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_33">丑数</a></td>
<td>数学、动态规划</td>
</tr>
<tr>
<td>47</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_47">求1+2+….+n</a></td>
<td>数学</td>
</tr>
<tr>
<td>16</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_16">合并两个排序的链表</a></td>
<td>分治</td>
</tr>
<tr>
<td>26</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_26">二叉搜索树与双向链表</a></td>
<td>分治</td>
</tr>
<tr>
<td>28</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_28">数组中出现次数超过一半的数字</a></td>
<td>分治、位运算</td>
</tr>
<tr>
<td>30</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_30">连续子数组的最大和</a></td>
<td>分治、动态规划</td>
</tr>
<tr>
<td>31</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_31">整数中1出现的次数（从1到n）</a></td>
<td>查找</td>
</tr>
<tr>
<td>40</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_40">数组中只出现一次的数字</a></td>
<td>位运算、哈希</td>
</tr>
<tr>
<td>41</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_41">和为S的连续正数序列</a></td>
<td>穷举、滑动窗口</td>
</tr>
<tr>
<td>63</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_63">数据流中的中位数</a></td>
<td>堆、排序</td>
</tr>
<tr>
<td>64</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_64">滑动窗口的最大值</a></td>
<td>堆、双指针</td>
</tr>
<tr>
<td>65</td>
<td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_65">矩阵中的路径</a></td>
<td>dfs、回溯</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><h2 id="1-twoSum"><a href="#1-twoSum" class="headerlink" title="1_twoSum"></a>1_twoSum</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2019/9/106:55 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File:  1_twoSum.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/two-sum/</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        hashmap = {}</span><br><span class="line">        <span class="keyword">for</span> loc, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> hashmap.get(target - num) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> [hashmap.get(target - num), loc]</span><br><span class="line">            hashmap[num] = loc</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line">so = Solution()</span><br><span class="line">start = timeit.default_timer()</span><br><span class="line">print(so.twoSum(nums, <span class="number">8</span>))</span><br><span class="line">end = timeit.default_timer()</span><br><span class="line">print(<span class="built_in">str</span>((end - start) * <span class="number">1000</span>), <span class="string">"s"</span>)  <span class="comment"># 0.052050003432668746 s</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="valid-sudoku"><a href="#valid-sudoku" class="headerlink" title="valid-sudoku"></a>valid-sudoku</h2><p>解题思路：</p>
<ul>
<li>行中没有重复的数字。</li>
<li>列中没有重复的数字。</li>
<li><code>3 x 3</code> 子数独内没有重复的数字。<ul>
<li>可以使用 <code>box_index = (row // 3) * 3 + columns // 3</code>作为子数独的索引号</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/3 11:18 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 36_valid-sudoku.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/valid-sudoku/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span>(<span class="params">self, board</span>) -&gt; bool:</span></span><br><span class="line">        rows = [{} <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">9</span>)]  <span class="comment"># rows记录每行的数据情况</span></span><br><span class="line">        columns = [{} <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">9</span>)]  <span class="comment"># rows记录每列的数据情况</span></span><br><span class="line">        boxes = [{} <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">9</span>)]  <span class="comment"># rows记录每个3*3子块的数据情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">9</span>):</span><br><span class="line">                number = board[row][column]</span><br><span class="line">                <span class="keyword">if</span> number != <span class="string">"."</span>:</span><br><span class="line">                    number = <span class="built_in">int</span>(number)</span><br><span class="line">                    box_index = (row // <span class="number">3</span>) * <span class="number">3</span> + column // <span class="number">3</span>  <span class="comment"># 对应(0,1,2,3,4,5,6,7,8,9)个子单元</span></span><br><span class="line">                    rows[row][number] = rows[row].get(number, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    columns[column][number] = columns[column].get(number, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    boxes[box_index][number] = boxes[box_index].get(number, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> rows[row][number] &gt; <span class="number">1</span> <span class="keyword">or</span> columns[column][number] &gt; <span class="number">1</span> <span class="keyword">or</span> boxes[box_index][number] &gt; <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isValidSudoku([</span><br><span class="line">    [<span class="string">"8"</span>, <span class="string">"3"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"7"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"1"</span>, <span class="string">"9"</span>, <span class="string">"5"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"3"</span>],</span><br><span class="line">    [<span class="string">"4"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"3"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"1"</span>],</span><br><span class="line">    [<span class="string">"7"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"2"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"2"</span>, <span class="string">"8"</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"4"</span>, <span class="string">"1"</span>, <span class="string">"9"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"5"</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"7"</span>, <span class="string">"9"</span>]</span><br><span class="line">]))</span><br><span class="line">print(so.isValidSudoku([</span><br><span class="line">    [<span class="string">"5"</span>, <span class="string">"3"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"7"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"1"</span>, <span class="string">"9"</span>, <span class="string">"5"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"3"</span>],</span><br><span class="line">    [<span class="string">"4"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"3"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"1"</span>],</span><br><span class="line">    [<span class="string">"7"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"2"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"2"</span>, <span class="string">"8"</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"4"</span>, <span class="string">"1"</span>, <span class="string">"9"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"5"</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"7"</span>, <span class="string">"9"</span>]</span><br><span class="line">]</span><br><span class="line">))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="first-missing-positive"><a href="#first-missing-positive" class="headerlink" title="first-missing-positive"></a>first-missing-positive</h2><p>解题思路：使用索引作为哈希键 以及 元素的符号作为哈希值 来实现是否存在的检测。</p>
<blockquote>
<p>例如，<code>nums[2]</code> 元素的负号意味着数字 <code>2</code> 出现在 <code>nums</code> 中。<code>nums[3]</code>元素的正号表示 <code>3</code> 没有出现在 <code>nums</code> 中。</p>
</blockquote>
<p>解题步骤：</p>
<ul>
<li>检查 1 是否存在于数组中。如果没有，则已经完成，1 即为答案。</li>
<li>如果 nums = [1]，答案即为 2 。</li>
<li>第一次遍历：将负数，零，和大于 n 的数替换为 1 。</li>
<li>第二次遍历：遍历数组。当读到数字 a 时，替换第 a 个元素的符号。注意重复元素：只能改变一次符号。由于没有下标 n ，使用下标 0 的元素保存是否存在数字 n。</li>
<li>第三次遍历：返回第一个正数元素的下标。</li>
<li>如果 nums[0] &gt; 0，则返回 n 。<br>如果之前的步骤中没有发现 nums 中有正数元素，则返回n + 1。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/11 8:36 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 41_first-missing-positive.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/first-missing-positive/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> len_nums == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一次遍历：将所有非法数字置为1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, len_nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= <span class="number">0</span> <span class="keyword">or</span> nums[i] &gt;= len_nums:</span><br><span class="line">                nums[i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二次遍历：更改对应位置的符号</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, len_nums):</span><br><span class="line">            val = <span class="built_in">abs</span>(nums[i])</span><br><span class="line">            nums[val] = -<span class="built_in">abs</span>(nums[val])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三次遍历：遍历数组符号</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len_nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最后检查nums[0]</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> len_nums</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> len_nums + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.firstMissingPositive([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>]))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-28"><a href="#interview-28" class="headerlink" title="interview_28"></a>interview_28</h2><ol>
<li>Hash法：时间复杂度O(n)</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/28 19:45 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_28.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/</span></span><br><span class="line"><span class="comment"># shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count_dict = <span class="built_in">dict</span>()</span><br><span class="line">        len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_nums):</span><br><span class="line">            count_dict[nums[i]] = count_dict.setdefault(nums[i], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        result_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> count_dict.keys():</span><br><span class="line">            <span class="keyword">if</span> count_dict[key] &gt; result_count:</span><br><span class="line">                result_count, result_key = count_dict[key], key</span><br><span class="line">        <span class="keyword">if</span> result_count &gt;= (len_nums // <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">return</span> result_key</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.majorityElement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>摩尔投票法</li>
</ol>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/mian-shi-ti-39-shu-zu-zhong-chu-xian-ci-shu-chao-3/">解题思路</a></p>
<p><img data-src="/images/algorithm/interview_28.png" alt="vote"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/28 19:45 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File:interview_28.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/</span></span><br><span class="line"><span class="comment"># shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        votes = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> votes == <span class="number">0</span>:</span><br><span class="line">                x = num</span><br><span class="line">            votes += <span class="number">1</span> <span class="keyword">if</span> num == x <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># &nbsp;验证x是否为众数</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> _ == x:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> count &gt; <span class="built_in">len</span>(nums) // <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.majorityElement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-34"><a href="#interview-34" class="headerlink" title="interview_34"></a>interview_34</h2><ol>
<li>遍历字符串 <code>s</code> ，使用哈希表统计 “各字符数量是否 &gt;1 ”。</li>
<li>再遍历字符串 <code>s</code> ，在哈希表中找到首个 “数量为 1 的字符”，并返回。</li>
</ol>
<blockquote>
<p>Python 3.6 后，默认字典就是有序的，因此无需使用 <code>OrderedDict()</code></p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/7 10:56 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_34.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        result_dict = {}</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">            result_dict[item] = item <span class="keyword">not</span> <span class="keyword">in</span> result_dict</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> result_dict.items():</span><br><span class="line">            <span class="keyword">if</span> v:</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.firstUniqChar(<span class="string">"NXWtnzyoHoBhUJaPauJaAitLWNMlkKwDYbbigdMMaYfkVPhGZcrEwp"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="LinkNode"><a href="#LinkNode" class="headerlink" title="LinkNode"></a>LinkNode</h1><h2 id="2-add-two-numbers"><a href="#2-add-two-numbers" class="headerlink" title="2_add_two_numbers"></a>2_add_two_numbers</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2019/9/1111:11 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File:  2_add_two_numbers.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/add-two-numbers/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">elif</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        tmp = ListNode(<span class="number">0</span>)</span><br><span class="line">        res = tmp</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            tmp_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                tmp_sum += l1.val</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                tmp_sum += l2.val</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            flag = (tmp_sum + flag) // <span class="number">10</span></span><br><span class="line">            tmp_sum = (tmp_sum + flag) % <span class="number">10</span></span><br><span class="line">            res.<span class="built_in">next</span> = ListNode(tmp_sum)</span><br><span class="line">            res = res.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            res.mext = ListNode(<span class="number">1</span>)</span><br><span class="line">        res = tmp.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">del</span> tmp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="merge-two-sorted-lists"><a href="#merge-two-sorted-lists" class="headerlink" title="merge-two-sorted-lists"></a>merge-two-sorted-lists</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/1 9:04 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 21_merge-two-sorted-lists.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/merge-two-sorted-lists/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        head_pre = ListNode(-<span class="number">1</span>)</span><br><span class="line">        pre = head_pre</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.value &lt; l2.value:</span><br><span class="line">                pre.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># pre指向当前计算节点的上一个节点，运算结束后需指向下一个</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> l2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head_pre.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="swap-nodes-in-pairs"><a href="#swap-nodes-in-pairs" class="headerlink" title="swap-nodes-in-pairs"></a>swap-nodes-in-pairs</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/6 5:15 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 24_swap-nodes-in-pairs.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/swap-nodes-in-pairs/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        head_pre = ListNode(-<span class="number">1</span>)</span><br><span class="line">        head_pre.<span class="built_in">next</span> = head</span><br><span class="line">        tmp = head_pre</span><br><span class="line">        <span class="keyword">while</span> tmp.<span class="built_in">next</span> <span class="keyword">and</span> tmp.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            a, b = tmp.<span class="built_in">next</span>, tmp.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            tmp.<span class="built_in">next</span>, a.<span class="built_in">next</span> = b, b.<span class="built_in">next</span></span><br><span class="line">            b.<span class="built_in">next</span> = a</span><br><span class="line">            tmp = tmp.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head_pre.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="reverse-nodes-in-k-group"><a href="#reverse-nodes-in-k-group" class="headerlink" title="reverse-nodes-in-k-group"></a>reverse-nodes-in-k-group</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/8 10:03 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 25_reverse-nodes-in-k-group.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        tmp_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp_head.<span class="built_in">next</span> = head</span><br><span class="line">        pre = tail = tmp_head</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            count = k</span><br><span class="line">            <span class="comment"># 将tail移动k个节点</span></span><br><span class="line">            <span class="keyword">while</span> count <span class="keyword">and</span> tail:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">                tail = tail.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 如果tail为空，则当前的这组节点数量小于k个，跳出，不进行反转</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 否则反转这k个节点</span></span><br><span class="line">            head = pre.<span class="built_in">next</span>  <span class="comment"># head 用于记录当前这组翻转节点的第一个节点</span></span><br><span class="line">            <span class="keyword">while</span> pre.<span class="built_in">next</span> != tail:</span><br><span class="line">                current_node = pre.<span class="built_in">next</span>  <span class="comment"># current_node 指向当前正在准备移动的节点</span></span><br><span class="line">                pre.<span class="built_in">next</span> = current_node.<span class="built_in">next</span></span><br><span class="line">                current_node.<span class="built_in">next</span> = tail.<span class="built_in">next</span></span><br><span class="line">                tail.<span class="built_in">next</span> = current_node</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">            pre, tail = head  <span class="comment"># 指向上组移动的第一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmp_head.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="rotate-list"><a href="#rotate-list" class="headerlink" title="rotate-list"></a>rotate-list</h2><p>解题思路：</p>
<ol>
<li>先需旋转链表，假设旋转的步长k=2，首先循环链表得到链表的长度length_of_nodes</li>
</ol>
<pre class="mermaid">graph LR
id2((1)) --&gt; id3((2))
id3((2)) --&gt; id4((3))
id4((3)) --&gt; id5((4))
id5((4)) --&gt; id6((5))
id6((5)) --&gt; id7((6))</pre>



<ol>
<li><p>得到倒数第二个节点的索引为length_of_nodes - k，即为新的头节点</p>
<p>新的尾节点的索引为length_of_nodes - k - 1</p>
<p>如果k&gt;n：</p>
<p>那么新的头节点的索引为length_of_nodes - k % length_of_nodes</p>
<p>新的尾节点的索引为length_of_nodes - k % length_of_nodes - 1</p>
</li>
</ol>
<pre class="mermaid">graph LR
id2((1)) --&gt; id3((2))
id3((2)) --&gt; id4((3))
id4((3)) --&gt; id5((4))
id5((4)) -.end.-&gt; id6((5))
id6((5)) --&gt; id7((6))
id7((6)) --&gt; id2((1))</pre>

<ol>
<li>串联成新的链表</li>
</ol>
<pre class="mermaid">graph LR
id2((1)) --&gt; id3((2))
id3((2)) --&gt; id4((3))
id4((3)) --&gt; id5((4))
id6((5)) --&gt; id7((6))
id7((6)) --&gt; id2((1))</pre>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/4 11:55</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 61_rotate-list.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/rotate-list/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        length_of_nodes = <span class="number">1</span></span><br><span class="line">        old_tail = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.compute the length of nodes</span></span><br><span class="line">        <span class="keyword">while</span> old_tail.<span class="built_in">next</span>:</span><br><span class="line">            length_of_nodes += <span class="number">1</span></span><br><span class="line">            old_tail = old_tail.<span class="built_in">next</span></span><br><span class="line">        old_tail.<span class="built_in">next</span> = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2.find the length_of_nodes - k % length_of_nodes -1 node,which is the last node</span></span><br><span class="line">        new_tail = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length_of_nodes - k % length_of_nodes - <span class="number">1</span>):</span><br><span class="line">            new_tail = new_tail.<span class="built_in">next</span></span><br><span class="line">        new_head = new_tail.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="remove-duplicates-from-sorted-list-ii"><a href="#remove-duplicates-from-sorted-list-ii" class="headerlink" title="remove-duplicates-from-sorted-list-ii"></a>remove-duplicates-from-sorted-list-ii</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/26 19:29 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 82_remove-duplicates-from-sorted-list-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        tmp_head = ListNode(<span class="string">"head"</span>)</span><br><span class="line">        tmp_head.<span class="built_in">next</span> = head</span><br><span class="line">        pre, cur = <span class="literal">None</span>, tmp_head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            pre = cur  <span class="comment"># pre指向不重复的节点， cur指向当前节点</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>  <span class="comment"># cur指向pre的下一个节点</span></span><br><span class="line">            <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.val == cur.val:</span><br><span class="line">                value = cur.val</span><br><span class="line">                <span class="comment"># 找到不重复的节点</span></span><br><span class="line">                <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val == value:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = cur</span><br><span class="line">        <span class="keyword">return</span> tmp_head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">first_node = ListNode(<span class="number">0</span>)</span><br><span class="line">first_node.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">first_node.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">print(first_node.val, first_node.<span class="built_in">next</span>.val, first_node.<span class="built_in">next</span>.<span class="built_in">next</span>.val)</span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">last_node = so.deleteDuplicates(first_node)</span><br><span class="line"><span class="keyword">while</span> last_node:</span><br><span class="line">    print(last_node.val)</span><br><span class="line">    last_node = last_node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="remove-duplicates-from-sorted-list"><a href="#remove-duplicates-from-sorted-list" class="headerlink" title="remove-duplicates-from-sorted-list"></a>remove-duplicates-from-sorted-list</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/26 23:28 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 83_remove-duplicates-from-sorted-list.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        tmp = head</span><br><span class="line">        <span class="keyword">while</span> tmp <span class="keyword">and</span> tmp.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> tmp.val == tmp.<span class="built_in">next</span>.val:</span><br><span class="line">                tmp.<span class="built_in">next</span> = tmp.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = tmp.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">first_node = ListNode(<span class="number">0</span>)</span><br><span class="line">first_node.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">first_node.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">print(first_node.val, first_node.<span class="built_in">next</span>.val, first_node.<span class="built_in">next</span>.<span class="built_in">next</span>.val)</span><br><span class="line">so = Solution()</span><br><span class="line">last_node = so.deleteDuplicates(first_node)</span><br><span class="line"><span class="keyword">while</span> last_node:</span><br><span class="line">    print(last_node.val)</span><br><span class="line">    last_node = last_node.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="partition-list"><a href="#partition-list" class="headerlink" title="partition-list"></a>partition-list</h2><p>解题思路：</p>
<ol>
<li><p>before，after分别指向链表中值小于x的节点</p>
</li>
<li><p>创建before，after的哑节点：before_node、after_node</p>
</li>
<li><p>遍历链表，最后进行合并</p>
</li>
</ol>
<blockquote>
<p>after.next = None<br>before.next = after_node.next</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, head: ListNode, x: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># before_node、after_node是哑节点</span></span><br><span class="line">        before = before_node = ListNode(<span class="number">0</span>)</span><br><span class="line">        after = after_node = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val &gt; x:</span><br><span class="line">                after.<span class="built_in">next</span> = head</span><br><span class="line">                after = after.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                before.<span class="built_in">next</span> = head</span><br><span class="line">                before = before.<span class="built_in">next</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        after.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        before.<span class="built_in">next</span> = after_node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> before_node.<span class="built_in">next</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="reverse-linked-list-ii"><a href="#reverse-linked-list-ii" class="headerlink" title="reverse-linked-list-ii"></a>reverse-linked-list-ii</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/6 00:06 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 92_reverse-linked-list-ii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/reverse-linked-list-ii/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head, m, n</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> m == n:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        a, d = dummy, dummy</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m - <span class="number">1</span>):</span><br><span class="line">            a = a.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            d = d.<span class="built_in">next</span></span><br><span class="line">        b, c = a.<span class="built_in">next</span>, d.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># pre, cur, next用于遍历子链表</span></span><br><span class="line">        pre = b</span><br><span class="line">        cur = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> cur != c:</span><br><span class="line">            cur.<span class="built_in">next</span>, pre, cur = pre, cur, cur.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 以上写法等价于</span></span><br><span class="line">            <span class="comment"># next = cur.next</span></span><br><span class="line">            <span class="comment"># cur.next = pre</span></span><br><span class="line">            <span class="comment"># pre = cur</span></span><br><span class="line">            <span class="comment"># cur = next</span></span><br><span class="line">        <span class="comment">#  首尾相接</span></span><br><span class="line">        a.<span class="built_in">next</span> = d</span><br><span class="line">        b.<span class="built_in">next</span> = c</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">head = ListNode(<span class="number">1</span>)</span><br><span class="line">head.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">head_tmp = head</span><br><span class="line"><span class="keyword">while</span> head_tmp:</span><br><span class="line">    print(head_tmp.val)</span><br><span class="line">    head_tmp = head_tmp.<span class="built_in">next</span></span><br><span class="line">so = Solution()</span><br><span class="line">return_head = so.reverseBetween(head, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">return_head_tmp = return_head</span><br><span class="line"><span class="keyword">while</span> return_head_tmp:</span><br><span class="line">    print(return_head_tmp.val)</span><br><span class="line">    return_head_tmp = return_head_tmp.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="从头到尾打印链表"><a href="#从头到尾打印链表" class="headerlink" title="从头到尾打印链表"></a>从头到尾打印链表</h2><ul>
<li>解题思路：从头到尾打印，考虑使用栈结构，也可以进行递归，但是当数据量比较大时，<strong>可能出现栈溢出</strong>，所以直接使用栈更合适。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/9 23:22 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: printListFromTailToHead.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="comment"># 链表的构造 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span>(<span class="params">self, list_node: ListNode</span>):</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> list_node:</span><br><span class="line">            stack.append(list_node.val)</span><br><span class="line">            list_node = list_node.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 将栈进行弹出</span></span><br><span class="line">        <span class="comment"># return stack[::-1]</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            print(stack.pop())</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-25"><a href="#interview-25" class="headerlink" title="interview_25"></a>interview_25</h2><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/lian-biao-de-shen-kao-bei-by-z1m/">解题思路</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">“”“第一部分”“”</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">head</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> visited[head]</span><br><span class="line">            <span class="comment"># 创建新结点</span></span><br><span class="line">            copy = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            visited[head] = copy</span><br><span class="line">            copy.<span class="built_in">next</span> = dfs(head.<span class="built_in">next</span>)</span><br><span class="line">“”“第二部分”“”</span><br><span class="line">            copy.random = dfs(head.random)</span><br><span class="line">            <span class="keyword">return</span> copy</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>首先反复运行第一部分，copy.next = dfs(head.next) 会递归得越来越深，，当 碰到 head == None 时，开始运行第二部分，准备从尾结点回溯；</li>
<li>回溯时，先从尾结点开始回溯：调用dfs(head.ranom)时，由于结点都保存在了哈希表中，因此 return visited[head]，这时完成random指针，完成了最后一个结点，故return copy。再进行倒数第二个结点的回溯：调用dfs(head.random)，return visited[head]，return copy…….</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/19 10:28 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_25.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x: <span class="built_in">int</span>, <span class="built_in">next</span>: <span class="string">'Node'</span> = <span class="literal">None</span>, random: <span class="string">'Node'</span> = <span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = <span class="built_in">int</span>(x)</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        self.random = random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">'Node'</span></span>) -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">head</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> visited[head]</span><br><span class="line">            copy = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            visited[head] = copy</span><br><span class="line">            copy.<span class="built_in">next</span> = dfs(head.<span class="built_in">next</span>)</span><br><span class="line">            copy.random = dfs(head.random)</span><br><span class="line">            <span class="keyword">return</span> copy</span><br><span class="line">        visited = {}</span><br><span class="line">        <span class="keyword">return</span> dfs(head)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-3"><a href="#interview-3" class="headerlink" title="interview_3"></a>interview_3</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/9 23:22</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_3.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;</span></span><br><span class="line"><span class="comment"># qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="comment"># 链表的构造 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span>(<span class="params">self, list_node: ListNode</span>):</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> list_node:</span><br><span class="line">            stack.append(list_node.val)</span><br><span class="line">            list_node = list_node.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 将栈进行弹出</span></span><br><span class="line">        <span class="comment"># return stack[::-1]</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            print(stack.pop())</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-14"><a href="#interview-14" class="headerlink" title="interview_14"></a>interview_14</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 16:28</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_14.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span>(<span class="params">self, head, k</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 让p，q相隔k个</span></span><br><span class="line">        p = head</span><br><span class="line">        q = head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># count至少大于等于2的时候才p才走</span></span><br><span class="line">            <span class="keyword">if</span> count &gt;= k + <span class="number">1</span>:</span><br><span class="line">                q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 当k的长度比链表都长时，直接返回None</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; count:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-15"><a href="#interview-15" class="headerlink" title="interview_15"></a>interview_15</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 16:29 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_15.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pre_node = <span class="literal">None</span></span><br><span class="line">        current_node = head</span><br><span class="line">        <span class="keyword">while</span> current_node:</span><br><span class="line">            current_node.<span class="built_in">next</span>, pre_node, current_node = (</span><br><span class="line">                pre_node,</span><br><span class="line">                current_node,</span><br><span class="line">                current_node.<span class="built_in">next</span>,</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> pre_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">first_node = ListNode(<span class="number">0</span>)</span><br><span class="line">first_node.<span class="built_in">next</span> = ListNode(<span class="number">1</span>)</span><br><span class="line">first_node.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">print(first_node.val, first_node.<span class="built_in">next</span>.val, first_node.<span class="built_in">next</span>.<span class="built_in">next</span>.val)</span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">last_node = so.reverseList(first_node)</span><br><span class="line">print(last_node.val, last_node.<span class="built_in">next</span>.val, last_node.<span class="built_in">next</span>.<span class="built_in">next</span>.val)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-16"><a href="#interview-16" class="headerlink" title="interview_16"></a>interview_16</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 16:41 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_16.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        head_pre = ListNode(-<span class="number">1</span>)</span><br><span class="line">        pre = head_pre</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                pre.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># pre指向当前计算节点的上一个节点，运算结束后需指向下一个</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span> = l1 <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> l2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head_pre.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-25-1"><a href="#interview-25-1" class="headerlink" title="interview_25"></a>interview_25</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/19 10:28</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_25.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x: <span class="built_in">int</span>, <span class="built_in">next</span>: <span class="string">"Node"</span> = <span class="literal">None</span>, random: <span class="string">"Node"</span> = <span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = <span class="built_in">int</span>(x)</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        self.random = random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">"Node"</span></span>) -&gt; "Node":</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">head</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> visited[head]</span><br><span class="line">            copy = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            visited[head] = copy</span><br><span class="line">            copy.<span class="built_in">next</span> = dfs(head.<span class="built_in">next</span>)</span><br><span class="line">            copy.random = dfs(head.random)</span><br><span class="line">            <span class="keyword">return</span> copy</span><br><span class="line"></span><br><span class="line">        visited = {}</span><br><span class="line">        <span class="keyword">return</span> dfs(head)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-36"><a href="#interview-36" class="headerlink" title="interview_36"></a>interview_36</h2><p>直观思路：先统计出两个链表的长度；然后让长度较长的那个链表先走Len个节点，Len表示长度差。<br>然后让两个指针同时向后走，如果有共同节点，那么一定会让这两个指针指向同一个节点。—  <a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/shuang-zhi-zhen-tong-ji-chang-du-by-bai-ye-5/">from this</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        temphead = headA</span><br><span class="line">        lenA = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> temphead:</span><br><span class="line">            temphead = temphead.<span class="built_in">next</span></span><br><span class="line">            lenA += <span class="number">1</span></span><br><span class="line">        temphead = headB</span><br><span class="line">        lenB = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> temphead:</span><br><span class="line">            temphead = temphead.<span class="built_in">next</span></span><br><span class="line">            lenB += <span class="number">1</span></span><br><span class="line">        dLen = <span class="built_in">abs</span>(lenA-lenB)</span><br><span class="line">        <span class="keyword">if</span> lenA - lenB &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#分别表示较长的链表和较短的链表</span></span><br><span class="line">            headl,heads = headA,headB</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            headl,heads = headB,headA</span><br><span class="line">        <span class="keyword">while</span> dLen &gt; <span class="number">0</span>:</span><br><span class="line">            headl = headl.<span class="built_in">next</span></span><br><span class="line">            dLen -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> headl <span class="keyword">and</span> heads:</span><br><span class="line">            <span class="keyword">if</span> headl == heads:</span><br><span class="line">                <span class="keyword">return</span> headl</span><br><span class="line">            headl = headl.<span class="built_in">next</span></span><br><span class="line">            heads = heads.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure>
<p>进阶思路：两个链表长度分别为L1+C、L2+C， C为公共部分的长度。node1走了L1+C步后，回到node2起点走L2步；node2走了L2+C步后，回到node1起点走L1步。 当两个node走的步数都为L1+L2+C时就两个node就相遇了。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/8/24 19:56 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_36.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        node1, node2 = headA, headB</span><br><span class="line">        <span class="keyword">while</span> node1 != node2:</span><br><span class="line">            node1 = node1.<span class="built_in">next</span> <span class="keyword">if</span> node1 <span class="keyword">else</span> headB</span><br><span class="line">            node2 = node2.<span class="built_in">next</span> <span class="keyword">if</span> node2 <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> node1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-55"><a href="#interview-55" class="headerlink" title="interview_55"></a>interview_55</h2><p>两个结论：(<a href="https://zhuanlan.zhihu.com/p/103626709">参考链接</a>)</p>
<ol>
<li>设置快慢指针，假如有环，他们最后一定相遇在环中。</li>
<li>两个指针相遇后，让两个指针分别从链表头和相遇点重新出发，每次走一步，最后一定相遇于环入口。</li>
</ol>
<p><strong>证明结论1</strong>：设置快慢指针fast和slow，fast每次走两步，low每次走一步。假如有环，两者一定在环中相遇。（因为low指针一旦进环，可以看作是fast指针在追slow指针，因为fast指针每次走两步，slow指针每次走一步，所以最后一定能追上（相遇））。</p>
<p><strong>证明结论2</strong>：</p>
<p>假设</p>
<p>链表头到环入口长度为——a，</p>
<p>环入口到相遇点长度为——b，</p>
<p>相遇点到环入口长度为——c，如图所示：</p>
<p><img data-src="/images/algorithm/interview_55.png" alt="快慢指针"></p>
<p>则相遇时，</p>
<p><strong>快指针路程=a+（b+c）k+b，k&gt;=1</strong>，其中b+c为环的长度，k为环的圈数（k&gt;=1，即最少一圈，不能是0圈，不然快慢指针走的路程一样，矛盾）。</p>
<p><strong>慢指针路程=a+b</strong>。</p>
<p>因为快指针的路程是慢指针的路程的两倍，所以：<strong>（a+b）*2=a+（b+c）k+b</strong>。</p>
<p>化简得：</p>
<p><strong>a=（k-1）（b+c）+c</strong>，这个式子的意思是：<strong>链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈数环长度</strong>。其中k&gt;=1，所以k-1&gt;=0圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 16:16</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_55.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span> <span class="keyword">and</span> pHead.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        onestep = pHead</span><br><span class="line">        twostep = pHead</span><br><span class="line">        <span class="comment"># 之所以不用写twostep.next.next， 是因为如果twostep.next.next为None，则下次循环twostep就为None了，就会退出</span></span><br><span class="line">        <span class="keyword">while</span> twostep <span class="keyword">and</span> twostep.<span class="built_in">next</span>:</span><br><span class="line">            onestep = onestep.<span class="built_in">next</span></span><br><span class="line">            twostep = twostep.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> onestep == twostep:</span><br><span class="line">                onestep = pHead</span><br><span class="line">                <span class="keyword">while</span> onestep != twostep:</span><br><span class="line">                    onestep = onestep.<span class="built_in">next</span></span><br><span class="line">                    twostep = twostep.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> onestep</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-56"><a href="#interview-56" class="headerlink" title="interview_56"></a>interview_56</h2><p>解题思路：因为重复的节点都要删除，因此需要标记重复开始前的上一个节点，又因为头结点有可能是重复的节点，为了操作方便，我们可以再链表前面设置一个空节点作为头结点，因此需要设置3个指针，第一个head指向头结点。第二个p用来标记重复节点的前面一个节点，第三个cur用来寻找重复的节点，一旦找到p就不移动了，cur继续往后寻找直到不是重复的节点。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 16:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_56.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;</span></span><br><span class="line"><span class="comment"># qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        head = ListNode(-<span class="number">1</span>)  <span class="comment"># 指向头节点</span></span><br><span class="line">        p = head  <span class="comment"># 指向不重复的结点</span></span><br><span class="line">        p.<span class="built_in">next</span> = pHead</span><br><span class="line">        cur = pHead  <span class="comment"># 负责找到重复结点</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val != cur.<span class="built_in">next</span>.val:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_val = cur.val</span><br><span class="line">                <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val == cur_val:</span><br><span class="line">                    cur = cur.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 不相同则令p指向不重复的元素,如果cur不存在，则p指向None就好了</span></span><br><span class="line">                p.<span class="built_in">next</span> = cur</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="BackTrack"><a href="#BackTrack" class="headerlink" title="BackTrack"></a>BackTrack</h1><p>回溯思想的模板为：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-find-median-sorted-array"><a href="#4-find-median-sorted-array" class="headerlink" title="4_find_median_sorted_array"></a>4_find_median_sorted_array</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/4 12:14 上午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 4_find_median_sorted_array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/median-of-two-sorted-arrays/</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1, nums2</span>) -&gt; float:</span></span><br><span class="line">        m = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        k = (m + n) % <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.find_k(nums1, nums2, (m + n) // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                self.find_k(nums1, nums2, (m + n) // <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">                + self.find_k(nums1, nums2, (m + n) // <span class="number">2</span>)</span><br><span class="line">            ) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_k</span>(<span class="params">self, nums1, nums2, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums1:</span><br><span class="line">            <span class="keyword">return</span> nums2[k]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums2:</span><br><span class="line">            <span class="keyword">return</span> nums1[k]</span><br><span class="line">        <span class="comment"># print("len nums1:", len(nums1), "len nums2:", len(nums2))</span></span><br><span class="line">        i = <span class="built_in">len</span>(nums1) // <span class="number">2</span></span><br><span class="line">        j = <span class="built_in">len</span>(nums2) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># print(i, j, k)</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; i + j:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                <span class="keyword">return</span> self.find_k(nums1, nums2[j + <span class="number">1</span> :], k - j - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.find_k(nums1[i + <span class="number">1</span> :], nums2, k - i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                <span class="keyword">return</span> self.find_k(nums1[:i], nums2, k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.find_k(nums1, nums2[:j], k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    so = Solution()</span><br><span class="line">    nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    nums2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    start = timeit.default_timer()</span><br><span class="line">    print(so.findMedianSortedArrays(nums1, nums2))</span><br><span class="line">    end = timeit.default_timer()</span><br><span class="line">    print(<span class="built_in">str</span>((end - start) * <span class="number">1000</span>), <span class="string">"s"</span>)</span><br><span class="line">    nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    nums2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    print(so.findMedianSortedArrays(nums1, nums2))</span><br><span class="line">    nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    nums2 = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    print(so.findMedianSortedArrays(nums1, nums2))</span><br><span class="line">    nums1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">    nums2 = [<span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">    print(so.findMedianSortedArrays(nums1, nums2))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="sudoku-solver"><a href="#sudoku-solver" class="headerlink" title="sudoku-solver"></a>sudoku-solver</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/5 9:44 上午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 37_sudoku-solver.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/sudoku-solver/</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span>(<span class="params">self, board</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        rows_available = [<span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)] <span class="comment"># 行剩余可用数字</span></span><br><span class="line">        columns_available = [<span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]  <span class="comment"># 列剩余可用数字</span></span><br><span class="line">        boxes_available = [<span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]  <span class="comment"># 块剩余可用数字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据board数据统计每行每列可用的数字</span></span><br><span class="line">        empty = []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[row][column] == <span class="string">"."</span>:</span><br><span class="line">                    empty.append((row, column))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    num = <span class="built_in">int</span>(board[row][column])</span><br><span class="line">                    rows_available[row].remove(num)</span><br><span class="line">                    columns_available[column].remove(num)</span><br><span class="line">                    boxes_available[(row // <span class="number">3</span>) * <span class="number">3</span> + column // <span class="number">3</span>].remove(num)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 回溯函数，如果当前添加的数字个数已经等于空格的个数，则证明已添加到最后一个空格，即找到答案</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">interation = <span class="number">0</span></span>):</span></span><br><span class="line">            <span class="keyword">if</span> interation == <span class="built_in">len</span>(empty):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            i, j = empty[interation]  <span class="comment"># 依次取出待填入空格的坐标</span></span><br><span class="line">            <span class="keyword">for</span> value <span class="keyword">in</span> rows_available[i] &amp; columns_available[j] &amp; boxes_available[(i // <span class="number">3</span>) * <span class="number">3</span> + j // <span class="number">3</span>]:</span><br><span class="line">                rows_available[i].remove(value)</span><br><span class="line">                columns_available[j].remove(value)</span><br><span class="line">                boxes_available[(i // <span class="number">3</span>) * <span class="number">3</span> + j // <span class="number">3</span>].remove(value)</span><br><span class="line">                board[i][j] = value</span><br><span class="line">                <span class="keyword">if</span> backtrack(interation + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="comment"># 如果没找到答案，则进行回溯</span></span><br><span class="line">                rows_available[i].add(value)</span><br><span class="line">                columns_available[j].add(value)</span><br><span class="line">                boxes_available[(i // <span class="number">3</span>) * <span class="number">3</span> + j // <span class="number">3</span>].add(value)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="keyword">return</span> board</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.solveSudoku([</span><br><span class="line">    [<span class="string">"5"</span>, <span class="string">"3"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"7"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"1"</span>, <span class="string">"9"</span>, <span class="string">"5"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"3"</span>],</span><br><span class="line">    [<span class="string">"4"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"3"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"1"</span>],</span><br><span class="line">    [<span class="string">"7"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"2"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"2"</span>, <span class="string">"8"</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"4"</span>, <span class="string">"1"</span>, <span class="string">"9"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"5"</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"7"</span>, <span class="string">"9"</span>]</span><br><span class="line">]</span><br><span class="line">))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="combination-sum"><a href="#combination-sum" class="headerlink" title="combination-sum"></a>combination-sum</h2><p>解题思路：（注：<a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">参考链接</a>）</p>
<ul>
<li>以 <code>target = 7</code> 为根结点，每一个分支做减法。减到 00 或者负数的时候，剪枝。其中，减到 0的时候添加结果。</li>
<li>为了能够去重：把候选数组排个序，即后面选取的数不能比前面选的数还要小。</li>
</ul>
<p><img data-src="/images/algorithm/leetcode-39.png" alt="leetcode-39"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/9 11:55 上午 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 39_combination-sum.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/combination-sum/solution/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates <span class="keyword">or</span> <span class="keyword">not</span> target:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        output_list = []</span><br><span class="line">        path = []</span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line">        size = <span class="built_in">len</span>(candidates)</span><br><span class="line">        self._dfs(candidates, begin, size, path, output_list, target)</span><br><span class="line">        <span class="keyword">return</span> output_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span>(<span class="params">self, candidates, begin, size, path, output_list, target</span>):</span></span><br><span class="line">        <span class="comment"># 递归终止的条件</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            output_list.append(path[:])</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(begin, size):</span><br><span class="line">            residue = target - candidates[index]</span><br><span class="line">            <span class="keyword">if</span> residue &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            path.append(candidates[index])</span><br><span class="line">            self._dfs(candidates, index, size, path, output_list, residue)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    candidates = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">    target = <span class="number">7</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    result = solution.combinationSum(candidates, target)</span><br><span class="line">    print(result)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="permutations"><a href="#permutations" class="headerlink" title="permutations"></a>permutations</h2><p><img data-src="/images/algorithm/permutations.png" alt="permutations"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/13 6:40 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 46_permutations.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/permutations/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums, num</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                output_list.append(num)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                backtrack(nums[:i] + nums[i + <span class="number">1</span> :], num + [nums[i]])</span><br><span class="line"></span><br><span class="line">        output_list = []</span><br><span class="line">        backtrack(nums, [])</span><br><span class="line">        <span class="keyword">return</span> output_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.permute([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="permutations-ii"><a href="#permutations-ii" class="headerlink" title="permutations-ii"></a>permutations-ii</h2><p>去除重复元素，两个要点</p>
<ul>
<li>排序</li>
<li>去重</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/18 6:40 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 47_permutations-ii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/permutations/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums, num</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                output_list.append(num)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:  </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                backtrack(nums[:i] + nums[i + <span class="number">1</span>:], num + [nums[i]])</span><br><span class="line"></span><br><span class="line">        nums.sort()  <span class="comment"># 数组先排序</span></span><br><span class="line">        output_list = []</span><br><span class="line">        backtrack(nums, [])</span><br><span class="line">        <span class="keyword">return</span> output_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.permuteUnique([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-27"><a href="#interview-27" class="headerlink" title="interview_27"></a>interview_27</h2><p><img data-src="/images/algorithm/interview_27.png" alt="permutations"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/27 14:35 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_27.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/</span></span><br><span class="line"><span class="comment"># zi-fu-chuan-de-pai-lie-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># nums存放需要继续遍历的字符，tmp存放当前遍历的结果</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums, tmp</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                result.add(tmp)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                backtrack(nums[:i] + nums[i+<span class="number">1</span>:], tmp+nums[i])</span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">set</span>()</span><br><span class="line">        backtrack(s, <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.permutation(<span class="string">"ryawrowv"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="powx-n"><a href="#powx-n" class="headerlink" title="powx-n"></a>powx-n</h2><p>解题思路</p>
<ul>
<li>若n为偶数：$x^n = x^{\frac{n}{2}} \, \dot \, x^{\frac{n}{2}}$</li>
<li>若n为奇数：$x ^ n = x ^ {\frac{n}{2}} \, \dot \, x^ {\frac{n}{2}} \, \dot \, x$</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/21 23:37</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 50_powx-n.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/powx-n/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x: <span class="built_in">float</span>, n: <span class="built_in">int</span></span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / x</span><br><span class="line">        half = self.myPow(x, n // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> half * half</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> half * half * x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.myPow(<span class="number">2.00000</span>, -<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="n-queens"><a href="#n-queens" class="headerlink" title="n-queens"></a>n-queens</h2><p>一、因为：</p>
<blockquote>
<p>对于所有的主对角线有 <code>行号 + 列号 = 常数</code></p>
<p>对于所有的次对角线有 <code>行号 - 列号 = 常数</code></p>
</blockquote>
<p>所以，所有的主对象线元素可以用<code>2 * n  - 1</code>个元素来表示，比如<code>main_diagonals[0]</code>就可以表示待解queen_map中，第<code>queen_map[0][0]</code>个元素的<strong>所有</strong>主对角线元素。</p>
<p>二、解题思路 （注：<a href="https://leetcode-cn.com/problems/n-queens/solution/nhuang-hou-by-leetcode/">参考链接</a>）</p>
<ul>
<li>从第一个 row = 0 开始.</li>
<li>循环列并且试图在每个 column 中放置皇后.<ul>
<li>如果方格 (row, column) 不在攻击范围内<ul>
<li>在 (row, column) 方格上放置皇后。</li>
<li>排除对应行，列和两个对角线的位置。</li>
<li>If 所有的行被考虑过，row == N<br>意味着我们找到了一个解</li>
<li>Else<br>继续考虑接下来的皇后放置 backtrack(row + 1).</li>
<li>回溯：将在 (row, column) 方格的将皇后移除。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img data-src="/images/algorithm/leetcode-51.png" alt="leetcode-51"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/24 13:55</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 51_n-queens.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/n-queens/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="comment"># 判断当前位置是否可用，由当前列，主对角线，副对角线共同决定</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">could_place</span>(<span class="params">row, col</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> cols[col] + main_diagonals[row - col] + counter_diagonals[row + col]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 放置皇后</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">place_queen</span>(<span class="params">row, col</span>):</span></span><br><span class="line">            queens_position.add((row, col))</span><br><span class="line">            cols[col] = <span class="number">1</span></span><br><span class="line">            main_diagonals[row - col] = <span class="number">1</span></span><br><span class="line">            counter_diagonals[row + col] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 消除皇后</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">remove_queen</span>(<span class="params">row, col</span>):</span></span><br><span class="line">            queens_position.remove((row, col))</span><br><span class="line">            cols[col] = <span class="number">0</span></span><br><span class="line">            main_diagonals[row - col] = <span class="number">0</span></span><br><span class="line">            counter_diagonals[row + col] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 增加解</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add_solution</span>():</span></span><br><span class="line">            solution = []</span><br><span class="line">            <span class="keyword">for</span> _, col <span class="keyword">in</span> <span class="built_in">sorted</span>(queens_position):</span><br><span class="line">                solution.append(<span class="string">'.'</span> * col + <span class="string">'Q'</span> + <span class="string">'.'</span> * (n - col - <span class="number">1</span>))</span><br><span class="line">            output.append(solution)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">row=<span class="number">0</span></span>):</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> could_place(row, col):</span><br><span class="line">                    place_queen(row, col)</span><br><span class="line">                    <span class="keyword">if</span> row + <span class="number">1</span> == n:</span><br><span class="line">                        add_solution()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        backtrack(row + <span class="number">1</span>)</span><br><span class="line">                    remove_queen(row, col)</span><br><span class="line">        cols = [<span class="number">0</span>] * n  <span class="comment"># 每列的Queen</span></span><br><span class="line">        main_diagonals = [<span class="number">0</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)  <span class="comment"># 共需要7个元素可以表示全部的主对角线元素</span></span><br><span class="line">        counter_diagonals = [<span class="number">0</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)  <span class="comment"># 共需要7个元素可以表示全部的副对角线元素</span></span><br><span class="line">        queens_position = <span class="built_in">set</span>() <span class="comment"># 用于记录当前已经摆放的位置</span></span><br><span class="line">        output = []</span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.solveNQueens(<span class="number">4</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="n-queens-ii"><a href="#n-queens-ii" class="headerlink" title="n-queens-ii"></a>n-queens-ii</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/24 19:35</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 52_n-queens-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/n-queens-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 判断当前位置是否可用，由当前列，主对角线，副对角线共同决定</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">could_place</span>(<span class="params">row, col</span>):</span></span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                <span class="keyword">not</span> cols[col] + main_diagonals[row - col] + counter_diagonals[row + col]</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 放置皇后</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">place_queen</span>(<span class="params">row, col</span>):</span></span><br><span class="line">            cols[col] = <span class="number">1</span></span><br><span class="line">            main_diagonals[row - col] = <span class="number">1</span></span><br><span class="line">            counter_diagonals[row + col] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 消除皇后</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">remove_queen</span>(<span class="params">row, col</span>):</span></span><br><span class="line">            cols[col] = <span class="number">0</span></span><br><span class="line">            main_diagonals[row - col] = <span class="number">0</span></span><br><span class="line">            counter_diagonals[row + col] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">row=<span class="number">0</span>, output = <span class="number">0</span></span>):</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> could_place(row, col):</span><br><span class="line">                    place_queen(row, col)</span><br><span class="line">                    <span class="keyword">if</span> row + <span class="number">1</span> == n:</span><br><span class="line">                        output += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        output = backtrack(row + <span class="number">1</span>, output)</span><br><span class="line">                    remove_queen(row, col)</span><br><span class="line">            <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">        cols = [<span class="number">0</span>] * n  <span class="comment"># 每列的Queen</span></span><br><span class="line">        main_diagonals = [<span class="number">0</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)  <span class="comment"># 共需要7个元素可以表示全部的主对角线元素</span></span><br><span class="line">        counter_diagonals = [<span class="number">0</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)  <span class="comment"># 共需要7个元素可以表示全部的副对角线元素</span></span><br><span class="line">        <span class="keyword">return</span> backtrack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.totalNQueens(<span class="number">4</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="combinations"><a href="#combinations" class="headerlink" title="combinations"></a>combinations</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/22 22:32</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 77_combinations.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/combinations/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> n &lt; k:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        self.__dfs(<span class="number">1</span>, k, n, [], result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dfs</span>(<span class="params">self, index, k, n, pre, result</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pre) == k:</span><br><span class="line">            result.append(pre[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, n + <span class="number">1</span>):</span><br><span class="line">            pre.append(i)</span><br><span class="line">            self.__dfs(i + <span class="number">1</span>, k, n, pre, result)</span><br><span class="line">            pre.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.combine(<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="subsets"><a href="#subsets" class="headerlink" title="subsets"></a>subsets</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/24 11:57</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 78_subsets.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/subsets/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, result_tmp</span>):</span></span><br><span class="line">            result.append(result_tmp)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                backtrack(i + <span class="number">1</span>, result_tmp + [nums[i]])</span><br><span class="line"></span><br><span class="line">        backtrack(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.subsets([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="subsets-ii"><a href="#subsets-ii" class="headerlink" title="subsets-ii"></a>subsets-ii</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/4 22:57</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 90_subsets-ii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/subsets-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">track_back</span>(<span class="params">i, tmp</span>):</span></span><br><span class="line">            res.append(tmp)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                <span class="keyword">if</span> j &gt; i <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                track_back(j + <span class="number">1</span>, tmp + [nums[j]])</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        track_back(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.subsetsWithDup([<span class="number">0</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="word-search"><a href="#word-search" class="headerlink" title="word-search"></a>word-search</h2><p>可以参考<a href="https://unknown.yuzhouwan.com/posts/55663/#interview_65">interview_65</a>写法更清楚明了。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/24 21:06 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 79_word-search.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/word-search/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    derections = [(<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        rows = <span class="built_in">len</span>(board)</span><br><span class="line">        cols = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        marked = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(cols)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> self.__search_word(board, word, <span class="number">0</span>, row, col, marked, rows, cols):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__search_word</span>(<span class="params">self, board, word, index_word, row, col, marked, rows, cols</span>):</span></span><br><span class="line">        <span class="comment"># 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(word) - <span class="number">1</span> == index_word:</span><br><span class="line">            <span class="keyword">return</span> board[row][col] == word[index_word]</span><br><span class="line">        <span class="keyword">if</span> board[row][col] == word[index_word]:</span><br><span class="line">            marked[row][col] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> derection <span class="keyword">in</span> self.derections:</span><br><span class="line">                next_x, next_y = row + derection[<span class="number">0</span>], col + derection[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= next_x &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= next_y &lt; cols <span class="keyword">and</span> <span class="keyword">not</span> marked[next_x][next_y] \</span><br><span class="line">                    <span class="keyword">and</span> self.__search_word(board, word,</span><br><span class="line">                                           index_word + <span class="number">1</span>,</span><br><span class="line">                                           next_x, next_y,</span><br><span class="line">                                           marked, rows, cols):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            marked[row][col] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.exist([</span><br><span class="line">    [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'E'</span>],</span><br><span class="line">    [<span class="string">'S'</span>, <span class="string">'F'</span>, <span class="string">'C'</span>, <span class="string">'S'</span>],</span><br><span class="line">    [<span class="string">'A'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>]</span><br><span class="line">], <span class="string">"ABCCED"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-65"><a href="#interview-65" class="headerlink" title="interview_65"></a>interview_65</h2><p>此题同<a href="https://unknown.yuzhouwan.com/posts/55663/#word-search">word_search</a></p>
<p>对比<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/">参考链接</a>，其方法更加简洁。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:58</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_65.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board: List[List[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j, k</span>):</span></span><br><span class="line">            <span class="comment"># 递归异常退出的条件：索引超出范围或者与当前字母不匹配</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; <span class="built_in">len</span>(board) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; <span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">or</span> word[k] != board[i][j] <span class="keyword">or</span> board[i][j] == <span class="string">"*"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 递归成功退出的条件</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="built_in">len</span>(word)-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 继续向上下左右进行遍历</span></span><br><span class="line">            tmp = board[i][j]</span><br><span class="line">            board[i][j] = <span class="string">"*"</span>  <span class="comment"># *表示已经遍历过</span></span><br><span class="line"></span><br><span class="line">            result = dfs(i-<span class="number">1</span>, j, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(i+<span class="number">1</span>, j, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(i, j-<span class="number">1</span>, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(i, j+<span class="number">1</span>, k+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            board[i][j] = tmp  <span class="comment"># 不管遍历结果如何，都需要恢复相应字符</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从不同的起点出发, k代表当前遍历到的单词字母的索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>牛客网上的要求略有不同。</p>
<ol>
<li>给出的是字符串，需要将<code>matrix[row][col]</code>写成<code>matrix[row*cols+col]</code>来定位</li>
<li>字符串是不可变变量，需要将matrix先转化为list(matrix)</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span>(<span class="params">self, matrix, rows, cols, path</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">row, col, k</span>):</span></span><br><span class="line">            <span class="comment"># 递归异常退出的出口</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;= row &lt; rows <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= col &lt; cols <span class="keyword">or</span> k &gt;= <span class="built_in">len</span>(path) <span class="keyword">or</span> path[k] != matrix[row*cols + col] <span class="keyword">or</span> matrix[row*cols + col] == <span class="string">"*"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 递归正常退出的出口</span></span><br><span class="line">            <span class="keyword">if</span> matrix[row*cols + col] == path[k] <span class="keyword">and</span> k == <span class="built_in">len</span>(path) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 继续递归</span></span><br><span class="line">            tmp = matrix[row*cols + col]</span><br><span class="line">            matrix[row*cols + col] = <span class="string">"*"</span> <span class="comment"># 先把已经遍历的字母赋值为"*"</span></span><br><span class="line">            <span class="keyword">if</span> dfs(row+<span class="number">1</span>, col, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(row, col+<span class="number">1</span>, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(row-<span class="number">1</span>, col, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(row, col-<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">                matrix[row*cols + col] = tmp</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            matrix[row*cols + col] = tmp</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">        matrix = <span class="built_in">list</span>(matrix)</span><br><span class="line">        <span class="comment"># 起点是matrix的每个点</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> dfs(row, col, <span class="number">0</span>):</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-66"><a href="#interview-66" class="headerlink" title="interview_66"></a>interview_66</h2><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/bfs-by-z1m/">参考链接</a></p>
<p>广度优先搜索：一般使用<strong>队列</strong>来实现</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:58</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_66.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount_BFS</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 用于计算数位和</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sum_step</span>(<span class="params">row, col</span>):</span></span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> row &gt; <span class="number">0</span>:</span><br><span class="line">                result += row % <span class="number">10</span></span><br><span class="line">                row = row // <span class="number">10</span></span><br><span class="line">            <span class="keyword">while</span> col &gt; <span class="number">0</span>:</span><br><span class="line">                result += col % <span class="number">10</span></span><br><span class="line">                col = col // <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 广度优先搜索</span></span><br><span class="line">        de = deque()  <span class="comment"># 用于广度优先搜索格子的坐标</span></span><br><span class="line">        de.append((<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        marked = <span class="built_in">set</span>()  <span class="comment"># 用于记录已经走过的坐标</span></span><br><span class="line">        <span class="keyword">while</span> de:</span><br><span class="line">            x, y = de.popleft()</span><br><span class="line">            <span class="comment"># 如果当前坐标还没有走过，并且数位和小于等于k</span></span><br><span class="line">            <span class="keyword">if</span> (x, y) <span class="keyword">not</span> <span class="keyword">in</span> marked <span class="keyword">and</span> sum_step(x, y) &lt;= k:</span><br><span class="line">                marked.add((x, y))</span><br><span class="line">                <span class="comment"># 只考虑向下和向右即可</span></span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)]:</span><br><span class="line">                    <span class="keyword">if</span> x + dx &lt; m <span class="keyword">and</span> y + dy &lt; n:</span><br><span class="line">                        de.append((x+dx, y+dy))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(marked)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>深度优先搜索：一般使用<strong>栈</strong>来实现</p>
<p>定义一个递归函数 <code>dfs()</code>，如果坐标不满足条件，结束递归状态，否则将下一步满足条件的坐标代入递归函数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:58</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_66.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 用于计算数位和</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sum_step</span>(<span class="params">row, col</span>):</span></span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> row &gt; <span class="number">0</span>:</span><br><span class="line">                result += row % <span class="number">10</span></span><br><span class="line">                row = row // <span class="number">10</span></span><br><span class="line">            <span class="keyword">while</span> col &gt; <span class="number">0</span>:</span><br><span class="line">                result += col % <span class="number">10</span></span><br><span class="line">                col = col // <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">x, y</span>):</span></span><br><span class="line">            <span class="comment"># 递归退出的条件</span></span><br><span class="line">            <span class="comment"># 坐标超出范围、数位和大于k、当前坐标已经走过</span></span><br><span class="line">            <span class="keyword">if</span> x &gt;= m <span class="keyword">or</span> y &gt;= n <span class="keyword">or</span> sum_step(x, y) &gt; k <span class="keyword">or</span> (x, y) <span class="keyword">in</span> marked:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            marked.add((x, y))</span><br><span class="line">            dfs(x + <span class="number">1</span>, y)  <span class="comment"># 向下走</span></span><br><span class="line">            dfs(x, y + <span class="number">1</span>)  <span class="comment"># 向右走</span></span><br><span class="line"></span><br><span class="line">        marked = <span class="built_in">set</span>()  <span class="comment"># 记录已经走过的坐标</span></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(marked)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="restore-ip-addresses"><a href="#restore-ip-addresses" class="headerlink" title="restore-ip-addresses"></a>restore-ip-addresses</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/7 23:22 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 93_restore-ip-addresses.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/restore-ip-addresses/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        r = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">restore</span>(<span class="params">count=<span class="number">0</span>, ip=<span class="string">''</span>, s=<span class="string">''</span></span>):</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> s == <span class="string">''</span>:</span><br><span class="line">                    r.append(ip[:-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span>:</span><br><span class="line">                restore(count+<span class="number">1</span>, ip+s[<span class="number">0</span>]+<span class="string">'.'</span>, s[<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">1</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">'0'</span>:</span><br><span class="line">                restore(count+<span class="number">1</span>, ip+s[:<span class="number">2</span>]+<span class="string">'.'</span>, s[<span class="number">2</span>:])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">2</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">'0'</span> <span class="keyword">and</span> <span class="built_in">int</span>(s[<span class="number">0</span>:<span class="number">3</span>]) &lt; <span class="number">256</span>:</span><br><span class="line">                restore(count+<span class="number">1</span>, ip+s[:<span class="number">3</span>]+<span class="string">'.'</span>, s[<span class="number">3</span>:])</span><br><span class="line">        restore(<span class="number">0</span>, <span class="string">''</span>, s)</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.restoreIpAddresses(<span class="string">"25525511135"</span>))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="scramble-string"><a href="#scramble-string" class="headerlink" title="scramble-string"></a>scramble-string</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/9 23:07 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 87_scramble-string.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/scramble-string/</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="meta">    @functools.lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s1) != <span class="built_in">len</span>(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s1 == s2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sorted</span>(s1) != <span class="built_in">sorted</span>(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s1)):</span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i], s2[:i]) <span class="keyword">and</span> self.isScramble(s1[i:], s2[i:]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i], s2[-i:]) <span class="keyword">and</span> self.isScramble(s1[i:], s2[:-i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isScramble(<span class="string">"great"</span>, <span class="string">"rgtae"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="different-ways-to-add-parentheses"><a href="#different-ways-to-add-parentheses" class="headerlink" title="different-ways-to-add-parentheses"></a>different-ways-to-add-parentheses</h2><p> 分治三步法：</p>
<ul>
<li>分解：按运算符分成左右两部分，分别求解</li>
<li>解决：实现一个递归函数，输入算式，返回算式解</li>
<li>合并：根据运算符合并左右两部分的解，得出最终解</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/17 12:40</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 241_different-ways-to-add-parentheses.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/different-ways-to-add-parentheses/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">input</span>.isdigit():</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">int</span>(<span class="built_in">input</span>)]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">input</span>):</span><br><span class="line">            <span class="keyword">if</span> value <span class="keyword">in</span> [<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>]:</span><br><span class="line">                left = self.diffWaysToCompute(<span class="built_in">input</span>[:index])</span><br><span class="line">                right = self.diffWaysToCompute(<span class="built_in">input</span>[index + <span class="number">1</span> :])</span><br><span class="line">                <span class="comment"># 合并结果</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        <span class="keyword">if</span> value == <span class="string">"+"</span>:</span><br><span class="line">                            res.append(l + r)</span><br><span class="line">                        <span class="keyword">elif</span> value == <span class="string">"-"</span>:</span><br><span class="line">                            res.append(l - r)</span><br><span class="line">                        <span class="keyword">elif</span> value == <span class="string">"*"</span>:</span><br><span class="line">                            res.append(l * r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.diffWaysToCompute(<span class="string">"2*3-4*5"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="letter-case-permutation"><a href="#letter-case-permutation" class="headerlink" title="letter-case-permutation"></a>letter-case-permutation</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/21 20:38</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 784_letter-case-permutation.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/letter-case-permutation/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCasePermutation</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">s, pre</span>):</span></span><br><span class="line">            <span class="comment"># 递归退出条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                result.append(<span class="string">""</span>.join(pre))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>].isalpha():</span><br><span class="line">                helper(s[<span class="number">1</span>:], pre + [s[<span class="number">0</span>].upper()])</span><br><span class="line">                helper(s[<span class="number">1</span>:], pre + [s[<span class="number">0</span>].lower()])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                helper(s[<span class="number">1</span>:], pre + [s[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">        helper(S, [])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.letterCasePermutation(<span class="string">"a1b2"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="palindrome-partitioning"><a href="#palindrome-partitioning" class="headerlink" title="palindrome-partitioning"></a>palindrome-partitioning</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/23 00:22</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 131_palindrome-partitioning.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/palindrome-partitioning/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">s, tmp</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                result.append(tmp)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[:i] == s[:i][::-<span class="number">1</span>]:</span><br><span class="line">                    backtrack(s[i:], tmp + [s[:i]])</span><br><span class="line"></span><br><span class="line">        backtrack(s, [])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.partition(<span class="string">"aab"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="fibonacci-number"><a href="#fibonacci-number" class="headerlink" title="fibonacci-number"></a>fibonacci-number</h2><p>方法一：递归（递归树如下）</p>
<p><img data-src="/images/algorithm/fibonacci-number.png" alt="fibonacci-number"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/14 12:38 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 509_fibonacci-number.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/fibonacci-number/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, N: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.fib(N-<span class="number">1</span>) + self.fib(N-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.fib(<span class="number">5</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>递归虽然有简洁的优点，但是递归是函数调用自身，而函数调用是有时间和空间消耗的，每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而往栈里压入数据和弹出数据都需要时间。另外，递归中有可能很多计算都是重复的，从而也会对性能产生影响。</p>
<p>方法二：记忆化自底向上的方法</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/14 12:38 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 509_fibonacci-number.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/fibonacci-number/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, N: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        f_dict = {<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>}</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, N):</span><br><span class="line">            f_dict[i] = f_dict[i - <span class="number">1</span>] + f_dict[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> f_dict[N - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.fib(<span class="number">4</span>))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Interview-10"><a href="#Interview-10" class="headerlink" title="Interview_10"></a>Interview_10</h2><p>解题思路：</p>
<p>类似于青蛙跳台阶,当n=1时，只有一种横向排列的方式。</p>
<p>当n等于二时，2*2有两种选择，横向或者是竖向。</p>
<p>当n等于3的时候对于2*3来说,如果选择的是竖向排列，则剩下的就是2*2排列。</p>
<p>如果选择的是横向,则对于2*n剩下的则只有1*n的一种选择。</p>
<p>2*n的大矩形就相当于“跳台阶“问题中的台阶，大矩形的长度n相当于台阶的个数n；从左至右的去覆盖，<strong>把小矩形竖着放相当于跳一个台阶，把小矩阵横着放相当于跳两个台阶</strong>。故：当前n的覆盖种数 = 当前n-1的覆盖总数 + 当前n-2的覆盖总数。即：f (n) = f (n-1) + f (n-2)</p>
<p><img data-src="/images/algorithm/rectCover.png" alt="rectCover"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/27 12:48 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: rectCover.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> self.rectCover(number-<span class="number">1</span>) + self.rectCover(number-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.rectCover(<span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>或着使用自底向上的方法，节省空间</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(number)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, number):</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>
<h1 id="2DMatric"><a href="#2DMatric" class="headerlink" title="2DMatric"></a>2DMatric</h1><h2 id="5-longest-palindrome"><a href="#5-longest-palindrome" class="headerlink" title="5_longest_palindrome"></a>5_longest_palindrome</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/17 9:07 上午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 5_longest_palindrome.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/longest-palindromic-substring/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        longest_str = <span class="string">""</span></span><br><span class="line">        longestLen = <span class="number">0</span></span><br><span class="line">        matrics = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s))] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, j + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - i &lt;= <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                        matrics[i][j] = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> longestLen &lt; j - i + <span class="number">1</span>:</span><br><span class="line">                            longestLen = j - i + <span class="number">1</span></span><br><span class="line">                            longest_str = s[i : j + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> matrics[i + <span class="number">1</span>][j - <span class="number">1</span>]:</span><br><span class="line">                        matrics[i][j] = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> longestLen &lt; j - i + <span class="number">1</span>:</span><br><span class="line">                            longestLen = j - i + <span class="number">1</span></span><br><span class="line">                            longest_str = s[i : j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> longest_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">"abccba"</span></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.longestPalindrome(s))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="rotate-image"><a href="#rotate-image" class="headerlink" title="rotate-image"></a>rotate-image</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/19 15:23</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 48_rotate-image.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/rotate-image/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ero_matrics</span>(<span class="params">self, matric</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matric:</span><br><span class="line">            <span class="keyword">return</span> matric</span><br><span class="line">        <span class="comment"># 先转置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(matric)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(matric)):</span><br><span class="line">                tmp = matric[i][j]</span><br><span class="line">                matric[i][j] = matric[j][i]</span><br><span class="line">                matric[j][i] = tmp</span><br><span class="line">        <span class="comment"># 再反转每一行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(matric)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(matric) // <span class="number">2</span>):</span><br><span class="line">                tmp = matric[i][j]</span><br><span class="line">                matric[i][j] = matric[i][<span class="built_in">len</span>(matric) - j - <span class="number">1</span>]</span><br><span class="line">                matric[i][<span class="built_in">len</span>(matric) - j - <span class="number">1</span>] = tmp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matric</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.ero_matrics([[<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>],</span><br><span class="line">                      [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">                      [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">14</span>],</span><br><span class="line">                      [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">13</span>]]))</span><br><span class="line">print(so.ero_matrics([</span><br><span class="line">                      [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>],</span><br><span class="line">                      [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">                      [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>]]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="spiral-matrix"><a href="#spiral-matrix" class="headerlink" title="spiral-matrix"></a>spiral-matrix</h2><p>解题思路来源于leetcode官网：按层模拟（注：<a href="https://leetcode-cn.com/problems/spiral-matrix/solution/luo-xuan-ju-zhen-by-leetcode/">参考链接</a>）</p>
<p><img data-src="/images/algorithm/leetcode-54.png" alt="leetcode-54"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/26 14:27</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 54_spiral-matrix.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/spiral-matrix/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">spiral_matrix</span>(<span class="params">r1, c1, r2, c2</span>):</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(c1, c2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">yield</span> r1, c</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(r1 + <span class="number">1</span>, r2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">yield</span> r, c2</span><br><span class="line">            <span class="keyword">if</span> r1 &lt; r2 <span class="keyword">and</span> c1 &lt; c2:</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(c2 - <span class="number">1</span>, c1, -<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">yield</span> r2, c</span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(r2, r1, -<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">yield</span> r, c1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        output = []</span><br><span class="line">        r1, r2 = <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">        c1, c2 = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r1 &lt;= r2 <span class="keyword">and</span> c1 &lt;= c2:</span><br><span class="line">            <span class="keyword">for</span> r, c <span class="keyword">in</span> spiral_matrix(r1, c1, r2, c2):</span><br><span class="line">                output.append(matrix[r][c])</span><br><span class="line">            r1 += <span class="number">1</span></span><br><span class="line">            r2 -= <span class="number">1</span></span><br><span class="line">            c1 += <span class="number">1</span></span><br><span class="line">            c2 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.spiralOrder([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="spiral-matrix-ii"><a href="#spiral-matrix-ii" class="headerlink" title="spiral-matrix-ii"></a>spiral-matrix-ii</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/1 18:14</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 59_spiral-matrix-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/spiral-matrix-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">spiral_matrix</span>(<span class="params">r1, c1, r2, c2</span>):</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(c1, c2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">yield</span> r1, c</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(r1 + <span class="number">1</span>, r2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">yield</span> r, c2</span><br><span class="line">            <span class="keyword">if</span> r1 &lt; r2 <span class="keyword">and</span> c1 &lt; c2:</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(c2 - <span class="number">1</span>, c1, -<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">yield</span> r2, c</span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(r2, r1, -<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">yield</span> r, c1</span><br><span class="line"></span><br><span class="line">        output_matrix = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        r1, r2 = <span class="number">0</span>, <span class="built_in">len</span>(output_matrix) - <span class="number">1</span></span><br><span class="line">        c1, c2 = <span class="number">0</span>, <span class="built_in">len</span>(output_matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        number = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r1 &lt;= r2 <span class="keyword">and</span> c1 &lt;= c2:</span><br><span class="line">            <span class="keyword">for</span> r, c <span class="keyword">in</span> spiral_matrix(r1, c1, r2, c2):</span><br><span class="line">                output_matrix[r][c] = number</span><br><span class="line">                number += <span class="number">1</span></span><br><span class="line">            r1 += <span class="number">1</span></span><br><span class="line">            r2 -= <span class="number">1</span></span><br><span class="line">            c1 += <span class="number">1</span></span><br><span class="line">            c2 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output_matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.generateMatrix(<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="set-matrix-zeroes"><a href="#set-matrix-zeroes" class="headerlink" title="set-matrix-zeroes"></a>set-matrix-zeroes</h2><p>解题思路如下：</p>
<blockquote>
<p>matrics第一行与第一列用于存储对应行或列是否有0</p>
<p>flag用于存储第一行或者第一列是否存在0</p>
</blockquote>
<ul>
<li>首先遍历第一行与第一列是否存在0，若存在将flag置为0</li>
<li>再遍历其他行，若存在0，将相应第一行和第一列的元素置为0</li>
<li>再次遍历第一行与第一列，将0所在的行和列中的所有元素置为0</li>
<li>最后，若flag为0，则把第一行和第一列的所有元素置为0。否则直接退出</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/17 12:08</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 73_set-matrix-zeroes.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/set-matrix-zeroes/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; List:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        flag_col = <span class="literal">False</span></span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">if</span> matrix[row][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                flag_col = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[row][col] == <span class="number">0</span>:</span><br><span class="line">                    matrix[row][<span class="number">0</span>] = matrix[<span class="number">0</span>][col] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(rows - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(cols - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> matrix[row][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> matrix[<span class="number">0</span>][col] == <span class="number">0</span>:</span><br><span class="line">                    matrix[row][col] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> flag_col:</span><br><span class="line">                matrix[row][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.setZeroes([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-1"><a href="#interview-1" class="headerlink" title="interview_1"></a>interview_1</h2><p>如果从左上角开始找，“从上到下”和“从左到右”，遇到的数字都是逐渐增大的；</p>
<p>如果从右下角开始找，“从下到上”和“从右到左”，遇到的数字都是逐渐减小的；</p>
<p>所以，可以从左下或者右上开始搜索，以保证不走“回头路”</p>
<p><img data-src="/images/algorithm/er-wei-shu-zu-zhong-de-cha-zhao-lcof.png" alt="er-wei-shu-zu-zhong-de-cha-zhao-lcof"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/7 12:31 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> target <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> rows == <span class="number">0</span> <span class="keyword">or</span> cols == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从右上角开始搜索</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        y = cols - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> x &lt; rows <span class="keyword">and</span> y &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[x][y] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 从matrix[x][y]的左下角部分进行搜索</span></span><br><span class="line">            <span class="keyword">if</span> matrix[x][y] &gt; target:</span><br><span class="line">                y -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findNumberIn2DArray([</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">  [<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">  [<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">  [<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line">], <span class="number">21</span></span><br><span class="line">))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-19"><a href="#interview-19" class="headerlink" title="interview_19"></a>interview_19</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 17:32</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_19.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 生成器</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">spiral_matrix</span>(<span class="params">r1, c1, r2, c2</span>):</span></span><br><span class="line">            <span class="comment"># 先输出r1行的坐标</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(c1, c2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">yield</span> r1, c</span><br><span class="line">            <span class="comment"># 再输出c2列的坐标</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(r1 + <span class="number">1</span>, r2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">yield</span> r, c2</span><br><span class="line">            <span class="comment"># 判断r1与r2，c1与c2是否重合</span></span><br><span class="line">            <span class="keyword">if</span> r1 &lt; r2 <span class="keyword">and</span> c1 &lt; c2:</span><br><span class="line">                <span class="comment"># 先输出r2行的坐标</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(c2 - <span class="number">1</span>, c1, -<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">yield</span> r2, c</span><br><span class="line">                <span class="comment"># 再输出c1列的坐标</span></span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(r2, r1, -<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">yield</span> r, c1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        output = []</span><br><span class="line">        r1, r2 = <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">        c1, c2 = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 控制大局（矩形范围）：r1、r2、c1、c2</span></span><br><span class="line">        <span class="keyword">while</span> r1 &lt;= r2 <span class="keyword">and</span> c1 &lt;= c2:</span><br><span class="line">            <span class="comment"># 用for去遍历这个生成器</span></span><br><span class="line">            <span class="keyword">for</span> r, c <span class="keyword">in</span> spiral_matrix(r1, c1, r2, c2):</span><br><span class="line">                output.append(matrix[r][c])</span><br><span class="line">            r1 += <span class="number">1</span></span><br><span class="line">            r2 -= <span class="number">1</span></span><br><span class="line">            c1 += <span class="number">1</span></span><br><span class="line">            c2 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.spiralOrder([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-51"><a href="#interview-51" class="headerlink" title="interview_51"></a>interview_51</h2><p><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/mian-shi-ti-66-gou-jian-cheng-ji-shu-zu-biao-ge-fe/">参考链接</a></p>
<p><img data-src="/images/algorithm/interview_51_1.png" alt="计算下三角"></p>
<p><img data-src="/images/algorithm/interview_51.png" alt="计算上三角"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/25 14:37 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_51.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArr</span>(<span class="params">self, a: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        b, tmp = [<span class="number">1</span>] * <span class="built_in">len</span>(a), <span class="number">1</span></span><br><span class="line">        <span class="comment"># 先计算下三角</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(a)):</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 再计算上三角</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            tmp *= a[i + <span class="number">1</span>]</span><br><span class="line">            b[i] *= tmp</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.constructArr([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-35"><a href="#interview-35" class="headerlink" title="interview_35"></a>interview_35</h2><p>方法一：暴力法</p>
<p>时间复杂度$O(n^2)$</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/8/24 20:27</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_35.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> len_nums &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 冒泡排序，寻找逆序数对</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_nums):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, len_nums):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    result += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reversePairs([<span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>方法二：归并排序</p>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/">解题思路</a></p>
<p>归并排序的时间复杂度是$O(NlogN)$</p>
<p>首先复习下归并排序：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">用于分解</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 递归的出口</span></span><br><span class="line">    <span class="keyword">if</span> len_nums &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = len_nums // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 分解成两个更小的数组</span></span><br><span class="line">    nums1 = mergeSort(nums[:mid])</span><br><span class="line">    nums2 = mergeSort(nums[mid:]</span><br><span class="line">    <span class="keyword">return</span> merge(nums1, nums2)</span><br><span class="line">                      </span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">用于合并:将产生一个排好序的数组</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">nums1, nums2</span>):</span></span><br><span class="line">    sum_nums = []  <span class="comment"># 用于存储两个列表合并后的结果</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 两个列表，逐个元素进行对比，较小的元素将添加到结果中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums1) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(nums2):</span><br><span class="line">        <span class="keyword">if</span> nums1[i] &lt;= nums2[j]:</span><br><span class="line">            sum_nums.append(nums1[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sum_nums.append(nums2[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将未添加完的元素增加到result_list后面，</span></span><br><span class="line">    <span class="comment"># 因为每次都要移动已经添加好的元素。此方法的时间复杂度是O(n^2)，下段代码会改进。这里为了便于理解</span></span><br><span class="line">    sum_nums += nums1[i:]</span><br><span class="line">    sum_nums += nums2[j:]</span><br><span class="line">    <span class="keyword">return</span> sum_nums</span><br></pre></td></tr></tbody></table></figure>
<p>在合并部分，归并是利用一个sum_nums逐个<strong>将较小</strong>的元素添加至尾部，从而得到一个顺序数组。如果<strong>现在要从数组尾部开始遍历，同样产生一个顺序数组</strong>，要怎么做呢。</p>
<p>可以看到，改动点只是在merge函数里，将两个列表每次比较后较大的元素，从后往前的添加到sum_nums里即可。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">用于分解</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">nums</span>):</span></span><br><span class="line">    len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 递归的出口</span></span><br><span class="line">    <span class="keyword">if</span> len_nums &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = len_nums // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 分解成两个更小的数组</span></span><br><span class="line">    nums1 = mergeSort(nums[:mid])</span><br><span class="line">    nums2 = mergeSort(nums[mid:]</span><br><span class="line">    <span class="keyword">return</span> merge(nums1, nums2)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">用于合并:将产生一个排好序的数组</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">nums1, nums2</span>):</span></span><br><span class="line">    i, j = <span class="built_in">len</span>(nums1) - <span class="number">1</span>, <span class="built_in">len</span>(nums2) - <span class="number">1</span></span><br><span class="line">    sum_nums = [<span class="number">0</span>] * (i + j + <span class="number">2</span>)  <span class="comment"># 用于存储两个列表合并后的结果</span></span><br><span class="line">    sum_nums_index = <span class="built_in">len</span>(sum_nums) - <span class="number">1</span>  <span class="comment"># 当前临时列表的索</span></span><br><span class="line">    <span class="comment"># 两个列表，逐个元素进行对比，大的元素将添加到结果中</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">            sum_nums[sum_nums_index] = nums1[i]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            sum_nums_index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sum_nums[sum_nums_index] = nums2[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            sum_nums_index -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将未添加完的元素增加到sum_nums前面，时间复杂度O(1)</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        sum_nums[sum_nums_index] = nums1[i]</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">        sum_nums_index -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        sum_nums[sum_nums_index] = nums2[j]</span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">        sum_nums_index -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sum_num</span><br><span class="line">mergeSort(nums)</span><br></pre></td></tr></tbody></table></figure>
<p>现在应该一目了然了，接下来只要增加一个变量，将每次合并过程中的逆序对进行统计就可以了。因为在每次的合并过程中，nums1与nums2都是有序的，且 i，j分别指向两个数组。假如：</p>
<blockquote>
<p>nums1 = [3, 6] nums2 = [2, 4]</p>
</blockquote>
<p>对于6而言，6小于4( nums1[ i ] &lt; nums2[ j ]  )，构成一对逆序数。又因为两个数组都是有序的，所以我们知道，6大于nums2里 j 指向的当前最大的元素4，当然也会大于比4小的2。所以对于6而言，它能构成的逆序数对为 j + 1 == 2。( j = 0,……, len(nums2) - 1）</p>
<p>可以这样想，sum_nums只是保存了当前数组里的大小关系，这种顺序关系是为了便于逆序对个数的快速计算，它并没有改变原数组的顺序。</p>
<p>完整代码如下：利用全局变量count来记录合并过程中逆序对的个数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/8/24 20:27</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_35.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.count = <span class="number">0</span>  <span class="comment"># 用于记录逆序对的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用于分解</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">nums</span>):</span></span><br><span class="line"></span><br><span class="line">            len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="comment"># 递归的出口</span></span><br><span class="line">            <span class="keyword">if</span> len_nums &lt;= <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> nums</span><br><span class="line">            mid = len_nums // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 分解成两个更小的数组</span></span><br><span class="line">            nums1 = mergeSort(nums[:mid])</span><br><span class="line">            nums2 = mergeSort(nums[mid:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> merge(nums1, nums2)</span><br><span class="line"></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用于合并:将产生一个排好序的数组</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">nums1, nums2</span>):</span></span><br><span class="line">            i, j = <span class="built_in">len</span>(nums1) - <span class="number">1</span>, <span class="built_in">len</span>(nums2) - <span class="number">1</span></span><br><span class="line">            sum_nums = [<span class="number">0</span>] * (i + j + <span class="number">2</span>)  <span class="comment"># 用于存储两个列表合并后的结果</span></span><br><span class="line">            sum_nums_index = <span class="built_in">len</span>(sum_nums) - <span class="number">1</span>  <span class="comment"># 当前临时列表的索引</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 两个列表，逐个元素进行对比，大的元素将添加到结果中</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 存在一对逆序</span></span><br><span class="line">                <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                    self.count += (j + <span class="number">1</span>) <span class="comment"># 记录逆序对的个数，取决于当前的j</span></span><br><span class="line">                    sum_nums[sum_nums_index] = nums1[i]</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                    sum_nums_index -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sum_nums[sum_nums_index] = nums2[j]</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                    sum_nums_index -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将未添加完的元素增加到sum_nums后面</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">                sum_nums[sum_nums_index] = nums1[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                sum_nums_index -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                sum_nums[sum_nums_index] = nums2[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                sum_nums_index -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> sum_nums</span><br><span class="line"></span><br><span class="line">        mergeSort(nums)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reversePairs([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Regular-Expression"><a href="#Regular-Expression" class="headerlink" title="Regular Expression"></a>Regular Expression</h1><h2 id="string-to-integer-atoi"><a href="#string-to-integer-atoi" class="headerlink" title="string-to-integer-atoi"></a>string-to-integer-atoi</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/20 1:20 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 8_string-to-integer-atoi.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/string-to-integer-atoi/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span>:</span><br><span class="line">            pattern = <span class="string">r"[+-]?\d+"</span></span><br><span class="line">            number = re.match(pattern, s)</span><br><span class="line">            <span class="keyword">if</span> number:</span><br><span class="line">                number = <span class="built_in">int</span>(number[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">if</span> number &lt; -<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">int</span>(-<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>))</span><br><span class="line">                <span class="keyword">elif</span> number &gt; <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> number</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.myAtoi(<span class="string">"+123"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="10-regular-expression-matchin"><a href="#10-regular-expression-matchin" class="headerlink" title="10_regular-expression-matchin"></a>10_regular-expression-matchin</h2><p>方法一：暴力求解， offer再见法</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> (re.fullmatch(p, s) != <span class="literal">None</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>方法二：回溯求解</p>
<p><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/">参考链接</a></p>
<p>首先，考虑只有“.”的情况。这种情况下只需要从左到右依次判断s[i]与p[i]是否匹配即可。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">      <span class="comment"># 如果p已经匹配完了，匹配结果取决于s是否为空</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">      </span><br><span class="line">      first_match = s <span class="keyword">and</span> (s[<span class="number">0</span>] == p[<span class="number">0</span>] <span class="keyword">or</span> p[<span class="number">0</span>] == <span class="string">"."</span>)</span><br><span class="line">      <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></tbody></table></figure>
<p>如果有“*”，它会出现在p[1]的位置，这时有两种情况：</p>
<ul>
<li>“<em>”匹配了0次前面的元素：这时直接比较”\</em>​”后面的元素即可。如“##”与“a*##”，即self.isMatch(s, p[2:])</li>
<li>“<em>”匹配了1次或多次前面的元素：这时忽略s的第一个元素，继续与p进行比较。如“aaab”与“a\</em>b”，继续比较“aab”与“a*b”，可以理解为逐步走到了第一种情况。即self.isMatch(s[1:], p)</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p) &gt; <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">"*"</span>:</span><br><span class="line">  <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> \</span><br><span class="line">			(first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p))</span><br></pre></td></tr></tbody></table></figure>
<p>完整代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/21 7:46 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 10_regular-expression-matchin.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/regular-expression-matching/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> s  <span class="comment"># 结束条件</span></span><br><span class="line"></span><br><span class="line">        first_match = s <span class="keyword">and</span> (s[<span class="number">0</span>] == p[<span class="number">0</span>] <span class="keyword">or</span> p[<span class="number">0</span>] == <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">          <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> \</span><br><span class="line">          (first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        	<span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line"><span class="keyword">assert</span> so.isMatch(<span class="string">"mississippi"</span>, <span class="string">"mis*is*ip*."</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>方法三：动态规划</p>
<p><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/">参考链接</a></p>
<h2 id="interview-52"><a href="#interview-52" class="headerlink" title="interview_52"></a>interview_52</h2><p>同<a href="https://unknown.yuzhouwan.com/posts/55663/#regular-expression-matchi">regular-expression-matchin</a></p>
<h2 id="valid-number"><a href="#valid-number" class="headerlink" title="valid-number"></a>valid-number</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/8 00:41</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 65_valid-number.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/valid-number/</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># return bool(re.match(r' *[+-]?([0-9]+(\.[0-9]*)?|\.[0-9]+)(e[+-]?[0-9]+)? *$', s))</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="comment"># 去除s两边的空白符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 去除"+"、"-"</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">"+"</span>, <span class="string">"-"</span>]:</span><br><span class="line">            s = s[<span class="number">1</span>:]</span><br><span class="line">        <span class="comment"># 判断是否含有e</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"e"</span> <span class="keyword">in</span> s:</span><br><span class="line">            s_list = s.split(<span class="string">"e"</span>)</span><br><span class="line">            <span class="comment"># 说明有两个e</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s_list) &gt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 去掉e前面的"."</span></span><br><span class="line">            s_list[<span class="number">0</span>] = s_list[<span class="number">0</span>].replace(<span class="string">"."</span>, <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 去掉e后面的"+、"-"</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s_list[<span class="number">1</span>]) &gt; <span class="number">0</span> <span class="keyword">and</span> s_list[<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">"+"</span>, <span class="string">"-"</span>]:</span><br><span class="line">                s_list[<span class="number">1</span>] = s_list[<span class="number">1</span>].replace(s_list[<span class="number">1</span>][<span class="number">0</span>], <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 判断是否为数字</span></span><br><span class="line">            <span class="keyword">if</span> s_list[<span class="number">0</span>].isnumeric() <span class="keyword">and</span> s_list[<span class="number">1</span>].isnumeric():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = s.replace(<span class="string">"."</span>, <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> s.isnumeric():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isNumber(<span class="string">"53.5e93"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-53"><a href="#interview-53" class="headerlink" title="interview_53"></a>interview_53</h2><p>解法一：暴力法（面试慎用）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 16:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_53.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">float</span>(s)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>解法二：正则表达式</p>
<p>依次来看下面的正则表达式：</p>
<ul>
<li>从E、e来划分，先看<strong>前半部分</strong>： </li>
</ul>
<p>匹配字符串开头^，可以有多个空格\s​，且+-号只能出现一次</p>
<blockquote>
<p><code>^\s*[+-]{0,1}</code></p>
</blockquote>
<p>用于匹配诸如10.111、10.1、10等数字（小数点后面必须出现数字）</p>
<blockquote>
<p><code>(\d)+((\.)(\d)+){0,1}</code></p>
</blockquote>
<p>用于匹配.1、.111111等数字</p>
<blockquote>
<p><code>((\.)(\d)+)</code></p>
</blockquote>
<p>用于匹配10.、1.等数字（小数点后面没有数字）</p>
<blockquote>
<p><code>((\d)+(\.))</code></p>
</blockquote>
<ul>
<li>再看<strong>后半部分</strong>：</li>
</ul>
<p>e或E后面可以跟+-号，且后面必须跟数字。整个指数部分可以出现0-1次。</p>
<blockquote>
<p><code>([eE][+-]{0,1}(\d)+){0,1}</code></p>
</blockquote>
<p>整个字符串结束前可以跟0或多个空格</p>
<blockquote>
<p><code>\s*$</code></p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 16:16</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_53.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        matchObj = re.match(<span class="string">"^\s*[+-]{0,1}((\d)+((\.)(\d)+){0,1}|((\.)(\d)+)|((\d)+(\.)))([eE][+-]{0,1}(\d)+){0,1}\s*$"</span>,s)</span><br><span class="line">        <span class="keyword">if</span> matchObj:</span><br><span class="line">            print(<span class="string">"match --&gt; matchObj.group() : "</span>, matchObj.group())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"No match!!"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串"+100"、"5e2"、"-123"、"3.1416"、"-1E-16"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"及"12e+5.4"都不是。</span></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isNumber(<span class="string">"13.e2"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>解法三：<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/">有限状态自动机</a></p>
<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><h2 id="valid-parentheses"><a href="#valid-parentheses" class="headerlink" title="valid-parentheses"></a>valid-parentheses</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/26 11:53 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 20_valid-parentheses.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        stack = []</span><br><span class="line">        dic = {<span class="string">"{"</span>: <span class="string">"}"</span>, <span class="string">"["</span>: <span class="string">"]"</span>, <span class="string">"("</span>: <span class="string">")"</span>}</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> dic:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> dic[stack.pop()] != c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isValid(<span class="string">"()[]{}"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="largest-rectangle-in-histogram"><a href="#largest-rectangle-in-histogram" class="headerlink" title="largest-rectangle-in-histogram"></a>largest-rectangle-in-histogram</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/29 16:24 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 84_largest-rectangle-in-histogram.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                tmp = stack.pop()</span><br><span class="line">                res = <span class="built_in">max</span>(res, (i - stack[-<span class="number">1</span>] - <span class="number">1</span>) * heights[tmp])</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.largestRectangleArea([<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="maximal-rectangle"><a href="#maximal-rectangle" class="headerlink" title="maximal-rectangle"></a>maximal-rectangle</h2><p>注：<a href="https://leetcode-cn.com/problems/maximal-rectangle/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-8/">参考链接</a></p>
<p><img data-src="/images/algorithm/leetcode-85.png" alt="leetcode-85"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/30 22:22 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 85_maximal-rectangle.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/maximal-rectangle/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span>(<span class="params">self, matrix: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(matrix)):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>])):</span><br><span class="line">                dp[col] = dp[col] + <span class="number">1</span> <span class="keyword">if</span> matrix[row][col] == <span class="string">"1"</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, self.largestRectangleArea(dp))</span><br><span class="line">        <span class="keyword">return</span> max_area</span><br><span class="line"></span><br><span class="line">    <span class="comment"># from 84_largest-rectangle-in-histogram</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">                tmp = stack.pop()</span><br><span class="line">                res = <span class="built_in">max</span>(res, (i - stack[-<span class="number">1</span>] - <span class="number">1</span>) * heights[tmp])</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.maximalRectangle([</span><br><span class="line">    [<span class="string">"1"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"0"</span>, <span class="string">"0"</span>],</span><br><span class="line">    [<span class="string">"1"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>],</span><br><span class="line">    [<span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>],</span><br><span class="line">    [<span class="string">"1"</span>, <span class="string">"0"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"0"</span>]</span><br><span class="line">]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="implement-queue-using-stacks"><a href="#implement-queue-using-stacks" class="headerlink" title="implement-queue-using-stacks"></a>implement-queue-using-stacks</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/12 12:40 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 232_implement-queue-using-stacks.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/implement-queue-using-stacks/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack1.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 把stack1里面的元素全部pop至stack2</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.stack1) != <span class="number">0</span>:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.stack1) != <span class="number">0</span>:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack1) == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-20"><a href="#interview-20" class="headerlink" title="interview_20"></a>interview_20</h2><p>解题思路：除了一个常规列表实现栈的操作外，再开一个<strong>辅助栈</strong>用于保存当前的最小信息：</p>
<ul>
<li>入栈操作：当辅助栈为空或者新元素小于等于辅助栈顶元素时，辅助栈入栈；否则无视</li>
<li>出栈操作：当常规栈中待出栈的元素等于辅助栈顶元素时，辅助栈出栈一个元素，代表当前的最小值出队或者次数减1</li>
<li>栈顶操作：仅需从常规栈顶取元素即可</li>
<li>最小值操作：因为辅助栈中维护的都是当前状态下的最小值，所以从辅助栈顶取元素即可</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/7 21:36 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_20.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/</span></span><br><span class="line"><span class="comment"># bao-han-minhan-shu-de-zhan-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.mins = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.mins <span class="keyword">or</span> x &lt;= self.mins[-<span class="number">1</span>]:</span><br><span class="line">            self.mins.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x = self.stack.pop()</span><br><span class="line">        <span class="keyword">if</span> self.mins <span class="keyword">and</span> self.mins[-<span class="number">1</span>] == x:</span><br><span class="line">            self.mins.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack <span class="keyword">and</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.mins <span class="keyword">and</span> self.mins[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.min()</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-21"><a href="#interview-21" class="headerlink" title="interview_21"></a>interview_21</h2><p><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/tan-xin-by-z1m/">解题思路</a></p>
<p>我们使用一个<strong>辅助栈</strong> 来模拟该操作。将 pushed 数组中的每个数依次入栈，同时判断这个数是不是 popped 数组中下一个要 pop 的值，如果是就把它 pop 出来。最后检查栈是否为空。</p>
<p>算法</p>
<ul>
<li><p>初始化栈 stack，j = 0；</p>
</li>
<li><p>遍历 pushed 中的元素 x；</p>
<ul>
<li>当 j &lt; popped.size() 且栈顶元素等于 popped[j]：弹出栈顶元素；j += 1；</li>
</ul>
</li>
<li><p>如果栈为空，返回 True，否则返回 False。</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span>(<span class="params">self, pushed: List[<span class="built_in">int</span>], popped: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        i_pop = <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> pushed:</span><br><span class="line">            stack.append(value)</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> popped[i_pop] == stack[-<span class="number">1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                i_pop += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.validateStackSequences(pushed=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], popped=[<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-5"><a href="#interview-5" class="headerlink" title="interview_5"></a>interview_5</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 11:33 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_5.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack1.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 把stack1里面的元素全部pop至stack2</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.stack1) != <span class="number">0</span>:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(self.stack1) != <span class="number">0</span>:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack1) == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="BinaryTree"><a href="#BinaryTree" class="headerlink" title="BinaryTree"></a>BinaryTree</h1><h2 id="generate-parentheses"><a href="#generate-parentheses" class="headerlink" title="generate-parentheses"></a>generate-parentheses</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/2 12:06 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 22_generate-parentheses.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/generate-parentheses/</span></span><br><span class="line"><span class="comment">#       (</span></span><br><span class="line"><span class="comment">#     (    )</span></span><br><span class="line"><span class="comment">#   )        (</span></span><br><span class="line"><span class="comment"># )            )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span></span><br><span class="line">        output_li = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_Parenthesis</span>(<span class="params">s=<span class="string">""</span>, left=<span class="number">0</span>, right=<span class="number">0</span></span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">2</span> * n:</span><br><span class="line">                output_li.append(s)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                find_Parenthesis(s + <span class="string">"("</span>, left + <span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">if</span> right &lt; left:</span><br><span class="line">                find_Parenthesis(s + <span class="string">")"</span>, left, right + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        find_Parenthesis()</span><br><span class="line">        <span class="keyword">return</span> output_li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.generateParenthesis(<span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-4"><a href="#interview-4" class="headerlink" title="interview_4"></a>interview_4</h2><p>解题思路:</p>
<ul>
<li>前序遍历的第一个节点为根节点</li>
<li>根据前序遍历确定的根节点，可以在中序遍历中确定其左右子树</li>
</ul>
<p><img data-src="/images/algorithm/rebuildbinarytree.png" alt="rebuildbinarytree"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/10 22:47 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_4.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder, inorder</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 前序遍历第一个肯定为根节点</span></span><br><span class="line">        root_value = preorder[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(root_value)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据中序遍历结果确定根节点的左右子树</span></span><br><span class="line">        root_index = inorder.index(root_value)</span><br><span class="line">        <span class="comment"># 在中序列表中的左右子树</span></span><br><span class="line">        left_in_inorder = inorder[:root_index]</span><br><span class="line">        right_in_inorder = inorder[root_index+<span class="number">1</span>:]</span><br><span class="line">        <span class="comment"># 在前序列表中的左右子树</span></span><br><span class="line">        left_in_preorder = preorder[<span class="number">1</span>:root_index+<span class="number">1</span>]  <span class="comment"># 左子树数量就是root_index的个数</span></span><br><span class="line">        right_in_preorder = preorder[root_index+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归创建子树</span></span><br><span class="line">        root.left = self.buildTree(left_in_preorder, left_in_inorder)</span><br><span class="line">        root.right = self.buildTree(right_in_preorder, right_in_inorder)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-57"><a href="#interview-57" class="headerlink" title="interview_57"></a>interview_57</h2><p>输入一个节点，分析该节点的下一个节点，一共有以下情况：</p>
<ol>
<li><p>二叉树为空，则返回空；</p>
</li>
<li><p>该节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；</p>
</li>
<li><p>该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</p>
</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/11 19:47</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_57.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 中序遍历序列的下一个节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span>(<span class="params">self, pNode</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pNode:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 如果当前节点有右节点，则下一个节点为其右节点的最左侧的节点</span></span><br><span class="line">        <span class="keyword">if</span> pNode.right:</span><br><span class="line">            pNode = pNode.right</span><br><span class="line">            <span class="keyword">while</span> pNode.left:</span><br><span class="line">                pNode = pNode.left</span><br><span class="line">            <span class="keyword">return</span> pNode</span><br><span class="line">        <span class="comment"># 如果当前节点没有右节点</span></span><br><span class="line">        <span class="keyword">while</span> pNode.<span class="built_in">next</span>:</span><br><span class="line">            <span class="comment"># 如果当前节点位于左子树上</span></span><br><span class="line">            <span class="keyword">if</span> pNode.<span class="built_in">next</span>.left == pNode:  <span class="comment"># pNode.next为父节点</span></span><br><span class="line">                <span class="keyword">return</span> pNode.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 否则循环找，直到当前节点为其父节点的左子树</span></span><br><span class="line">            pNode = pNode.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="longest-univalue-path"><a href="#longest-univalue-path" class="headerlink" title="longest-univalue-path"></a>longest-univalue-path</h2><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/solution/zui-chang-tong-zhi-lu-jing-by-leetcode/">参考链接</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/19 23:48 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 687_longest-univalue-path.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/longest-univalue-path/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestUnivaluePath</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">arrow_length</span>(<span class="params">node: TreeNode</span>):</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left_length = arrow_length(node.left)</span><br><span class="line">            right_length = arrow_length(node.right)</span><br><span class="line">            left_arrow = right_arrow = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">and</span> node.val == node.left.val:</span><br><span class="line">                left_arrow = left_length + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">and</span> node.val == node.right.val:</span><br><span class="line">                right_arrow = right_length + <span class="number">1</span></span><br><span class="line">            self.ans = <span class="built_in">max</span>(self.ans, left_arrow+right_arrow)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_arrow, right_arrow)</span><br><span class="line">        arrow_length(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-17"><a href="#interview-17" class="headerlink" title="interview_17"></a>interview_17</h2><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/">解题思路</a></p>
<p>若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：</p>
<ol>
<li>先序遍历树 A中的每个节点 A。（对应函数 isSubStructure(A, B)）</li>
<li>判断树 A 中 以A为根节点的子树 是否包含树 B 。（对应函数 recur(A, B)）</li>
</ol>
<ul>
<li>isSubStructure(A, B) 函数：</li>
</ul>
<p>特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false ；<br>返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<br>以 节点 A 为根节点的子树 包含树 B ，对应 recur(A, B)；<br>树 B 是 树 A 左子树 的子结构，对应 isSubStructure(A.left, B)；<br>树 B 是 树 A 右子树 的子结构，对应 isSubStructure(A.right, B)；</p>
<ul>
<li>recur(A, B) 函数：</li>
</ul>
<ol>
<li>终止条件：<br>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true；<br>当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；<br>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li>
<li>返回值：<br>判断 A 和 B 的左子节点是否相等，即 recur(A.left, B.left) ；<br>判断 A 和 B 的右子节点是否相等，即 recur(A.right, B.right) ；</li>
</ol>
<p><img data-src="/images/algorithm/interview_17.png" alt="interview_17"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/2 12:32 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_17.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span>(<span class="params">self, A: TreeNode, B: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.recure(A, B) <span class="keyword">or</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recure</span>(<span class="params">self, A: TreeNode, B: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.recure(A.left, B.left) <span class="keyword">and</span> self.recure(A.right, B.right)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="invert-binary-tree"><a href="#invert-binary-tree" class="headerlink" title="invert-binary-tree"></a>invert-binary-tree</h2><ul>
<li>递归解法</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/3 12:28 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 226_invert-binary-tree.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/invert-binary-tree/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.invertTree(root.left)</span><br><span class="line">        right = self.invertTree(root.right)</span><br><span class="line">        root.left = right</span><br><span class="line">        root.right = left</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>迭代解法</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/3 12:28 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 226_invert-binary-tree.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/invert-binary-tree/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="comment"># 广度优先搜索</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">          temp_root = queue.pop()</span><br><span class="line">          temp_root.left, temp_root.right = temp_root.right, temp_root.left</span><br><span class="line">          <span class="comment"># 继续把子孩子入队</span></span><br><span class="line">          <span class="keyword">if</span> temp_root.left:</span><br><span class="line">            queue.append(temp_root.left)</span><br><span class="line">          <span class="keyword">if</span> temp_root.right:</span><br><span class="line">            queue.append(temp_root.right) </span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-22-i"><a href="#interview-22-i" class="headerlink" title="interview_22_i"></a>interview_22_i</h2><p>利用队列，广度优先遍历二叉树</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/8 19:19 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_32_i.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque()</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            node = deque.popleft()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                deque.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                deque.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-22-ii"><a href="#interview-22-ii" class="headerlink" title="interview_22_ii"></a>interview_22_ii</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/8 19:28 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_32_ii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque()</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            tem = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(deque)):</span><br><span class="line">                node = deque.popleft()</span><br><span class="line">                tem.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    deque.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    deque.append(node.right)</span><br><span class="line">            res.append(tem)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-22-iii"><a href="#interview-22-iii" class="headerlink" title="interview_22_iii"></a>interview_22_iii</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/8 19:48 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_32_iii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque()</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            tem = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(deque)):</span><br><span class="line">                node = deque.popleft()</span><br><span class="line">                tem.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    deque.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    deque.append(node.right)</span><br><span class="line">            res.append(tem[::-<span class="number">1</span>] <span class="keyword">if</span> <span class="built_in">len</span>(res) % <span class="number">2</span> <span class="keyword">else</span> tem)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-59"><a href="#interview-59" class="headerlink" title="interview_59"></a>interview_59</h2><p>此题同<a href="https://unknown.yuzhouwan.com/posts/55663/#interview_22_iii">interview_22_iii</a></p>
<h2 id="interview-23"><a href="#interview-23" class="headerlink" title="interview_23"></a>interview_23</h2><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/">解题思路</a></p>
<p><img data-src="/images/algorithm/interview_23.png" alt="interview_23"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/15 22:18</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_23.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 待分析的区间</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="comment">#  已经对比完毕，返回True</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 根结点在最右边，左子树应该都比它小</span></span><br><span class="line">            p = i</span><br><span class="line">            <span class="keyword">while</span> postorder[p] &lt; postorder[j]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            left_end = p</span><br><span class="line">            <span class="comment"># 右子树应该都比它小</span></span><br><span class="line">            <span class="keyword">while</span> postorder[p] &gt; postorder[j]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 若是后序遍历序列，那p应该已经和j相等了; 并且遍历左右子树序列也应该是后序遍历序列</span></span><br><span class="line">            <span class="keyword">return</span> p == j <span class="keyword">and</span> recur(i, left_end - <span class="number">1</span>) <span class="keyword">and</span> recur(left_end, j - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="built_in">len</span>(postorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.verifyPostorder([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-24"><a href="#interview-24" class="headerlink" title="interview_24"></a>interview_24</h2><p>本问题是典型的二叉树方案搜索问题，使用<strong>回溯法解决</strong>，其包含 <strong>先序遍历 + 路径记录</strong> 两部分。</p>
<p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/">参考链接</a></p>
<p><img data-src="/images/algorithm/interview_24.png" alt="interview_24"></p>
<blockquote>
<p>res.append(list(path))：记录路径时若直接执行 res.append(path) ，则是将 <code>path 列表对象</code> 加入了 res ；后续 path 对象改变时， <code>res 中的 path 对象</code> 也会随之改变（因此肯定是不对的，本来存的是正确的路径 path ，后面又 append 又 pop 的，就破坏了这个正确路径）。<code>list(path)</code> 相当于新建并复制了一个 path 列表，因此不会受到 path 变化的影响。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/15 23:03</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_24.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res, path = [], []  <span class="comment"># 用于存放最终的结果，与当前遍历的路径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输入当前的遍历的节点，与当前的目标值</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">root, tar</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            path.append(root.val)</span><br><span class="line">            tar -= root.val</span><br><span class="line">            <span class="keyword">if</span> tar == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res.append(<span class="built_in">list</span>(path))</span><br><span class="line">            <span class="comment"># 如果已经找到了一条路径，那么下面两行会直接return，所以这样写也没关系</span></span><br><span class="line">            recur(root.left, tar)</span><br><span class="line">            recur(root.right, tar)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        recur(root, <span class="built_in">sum</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-26"><a href="#interview-26" class="headerlink" title="interview_26"></a>interview_26</h2><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/">参考链接</a></p>
<p>算法流程：<br><code>dfs(cur):</code> 递归法中序遍历；</p>
<ol>
<li><p><strong>终止条件</strong>： 当节点 cur为空，代表越过叶节点，直接返回；</p>
</li>
<li><p>递归左子树，即 <code>dfs(cur.left)</code>；</p>
</li>
<li><p><strong>构建链表</strong>：</p>
<ol>
<li><strong>当 pre 为空时</strong>： 代表正在访问链表头节点，记为 head 。</li>
<li><p><strong>当 pre 不为空时</strong>： 修改双向节点引用，即 pre.right = cur ,cur.left = pre；</p>
</li>
<li><p><strong>保存 cur</strong> ： 更新 pre = cur ，即节点 cur 是后继节点的 pre；</p>
</li>
</ol>
</li>
<li>递归右子树，即 dfs(cur.right) ；</li>
</ol>
<p><code>treeToDoublyList(root)：</code></p>
<ol>
<li><strong>特例处理</strong>： 若节点 root为空，则直接返回；</li>
<li><strong>初始化</strong>： 空节点 pre；</li>
<li><strong>转化为双向链表</strong>： 调用 dfs(root) ；</li>
<li><strong>构建循环链表</strong>： 中序遍历完成后，head指向头节点， pre指向尾节点，因此修改 head 和 pre的双向节点引用即可。</li>
<li><strong>返回值</strong>： 返回链表的头节点 head 即可。</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/22 22:33</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_26.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, left=None, right=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span>(<span class="params">self, pRootOfTree</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">current_node</span>):</span></span><br><span class="line">            <span class="comment"># 递归出口：代表到达尾结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> current_node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(current_node.left)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果pre是空，证明当前访问的是第一个结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.pre:</span><br><span class="line">                self.head = current_node</span><br><span class="line">            <span class="comment"># 如果不是空，则证明当前结点不是头结点，可进行修改</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.pre.right, current_node.left = current_node, self.pre</span><br><span class="line">            <span class="comment"># 保存当前结点为pre</span></span><br><span class="line">            self.pre = current_node</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 再去递归右子树</span></span><br><span class="line">            dfs(current_node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dfs(pRootOfTree)</span><br><span class="line">        <span class="comment"># 最后将头结点和尾结点进行连接</span></span><br><span class="line">        self.pre.right, self.head.left = self.head, self.pre</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-18"><a href="#interview-18" class="headerlink" title="interview_18"></a>interview_18</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 16:43 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_18.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 递归</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.mirrorTree(root.left)</span><br><span class="line">        self.mirrorTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree_diedai</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 广度优先，将节点依次插入</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 先交换</span></span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-22"><a href="#interview-22" class="headerlink" title="interview_22"></a>interview_22</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/8 19:19</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_22.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque()</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            node = deque.popleft()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                deque.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                deque.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="maximum-depth-of-binary-tree"><a href="#maximum-depth-of-binary-tree" class="headerlink" title="maximum-depth-of-binary-tree"></a>maximum-depth-of-binary-tree</h2><h2 id="interview-38"><a href="#interview-38" class="headerlink" title="interview_38"></a>interview_38</h2><p>此题同<a href="https://unknown.yuzhouwan.com/posts/55663/#maximum-depth-of-binary-tree">maximum-depth-of-binary-tree</a></p>
<ol>
<li>深度优先遍历DFS</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/8/26 20:27 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_38.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>广度优先遍历BFS</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/8/26 20:27 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_38.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 遍历每层的结点</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line">            <span class="comment"># 将每层的元素重新赋值给queue</span></span><br><span class="line">            queue = tmp</span><br><span class="line">            result += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-39"><a href="#interview-39" class="headerlink" title="interview_39"></a>interview_39</h2><p><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/solution/mian-shi-ti-55-ii-ping-heng-er-cha-shu-cong-di-zhi/">思路参考</a></p>
<ul>
<li>方法一：从顶至底</li>
</ul>
<p>思路是构造一个获取当前子树的深度的函数 <strong>depth(root)</strong> ，通过比较某子树的左右子树的深度差 <strong>abs(depth(root.left) - depth(root.right)) &lt;= 1</strong> 是否成立，来判断某子树是否是二叉平衡树。若所有子树都平衡，则此树平衡。</p>
<p><strong>算法流程：</strong><br>isBalanced(root) 函数： 判断树 root 是否平衡</p>
<p>特例处理： 若树根节点 root 为空，则直接返回 true ；<br>返回值： 所有子树都需要满足平衡树性质，因此以下三者使用与逻辑 &amp;&amp; 连接；</p>
<ol>
<li>abs(self.depth(root.left) - self.depth(root.right)) &lt;= 1 ：判断 当前子树 是否是平衡树；</li>
<li>self.isBalanced(root.left) ： 先序遍历递归，判断 当前子树的左子树 是否是平衡树；</li>
<li>self.isBalanced(root.right) ： 先序遍历递归，判断 当前子树的右子树 是否是平衡树；</li>
<li>depth(root) 函数： 计算树 root 的深度</li>
</ol>
<p>终止条件： 当 root 为空，即越过叶子节点，则返回高度 0 ；<br>返回值： 返回左 / 右子树的深度的最大值 +1。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 判断以root为根的二叉树是否平衡</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(self.depth(root.left) - self.depth(root.right)) &lt;= <span class="number">1</span> \</span><br><span class="line">               <span class="keyword">and</span> self.isBalanced(root.left) \</span><br><span class="line">               <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算以root为根的二叉树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.depth(root.left), self.depth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>方法二：从底至顶（见思路参考）</li>
</ul>
<h2 id="interview-58"><a href="#interview-58" class="headerlink" title="interview_58"></a>interview_58</h2><p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/solution/mian-shi-ti-28-dui-cheng-de-er-cha-shu-di-gui-qing/">解题思路参考</a></p>
<ul>
<li><p>对称二叉树定义： 对于树中 任意两个对称节点 L和 R ，一定有：<br>L.val = R.val：即此两对称节点值相等。<br>L.left.val = R.right.val：即 L 的 左子节点 和 R 的 右子节点 对称；<br>L.right.val = R.left.val：即 L 的 右子节点 和 R 的 左子节点 对称。<br>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。</p>
</li>
<li><p>算法流程：</p>
<ul>
<li><p>isSymmetric(root) ：</p>
<p>特例处理<strong>：</strong> 若根节点 root 为空，则直接返回 true。<br>返回值： 即 recur(root.left, root.right) ;</p>
</li>
<li><p>recur(L, R) ：</p>
<p>终止条件：</p>
<ol>
<li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；</li>
<li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；</li>
<li>当节点 L 值 = 节点 R 值： 此树不对称，因此返回 false；</li>
</ol>
</li>
<li><p>递推工作：<br>判断两节点 L.left 和 R.right是否对称，即 recur(L.left, R.right) ；<br>判断两节点 L.right 和 R.left是否对称，即 recur(L.right, R.left) ；<br>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp;&amp; 连接。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 20:42 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_58.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">LeftNode, RightNode</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> LeftNode <span class="keyword">and</span> <span class="keyword">not</span> RightNode:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> LeftNode <span class="keyword">or</span> <span class="keyword">not</span> RightNode <span class="keyword">or</span> LeftNode.val != RightNode.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 不满足直接退出的条件，则继续向下递归</span></span><br><span class="line">            <span class="keyword">return</span> recur(LeftNode.left, RightNode.right) <span class="keyword">and</span> recur(LeftNode.right, RightNode.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(root.left, root.right) <span class="keyword">if</span> root <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-61"><a href="#interview-61" class="headerlink" title="interview_61"></a>interview_61</h2><p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/mian-shi-ti-37-xu-lie-hua-er-cha-shu-ceng-xu-bian-/">参考链接</a></p>
<p>序列化操作：类似于BFS，不同之处则是需要增加空结点的处理。</p>
<p>反序列化操作：由于序列化时建立了一颗“满二叉树”，则可<strong>基于叶结点和父结点之间的关系</strong>，对已序列化的结果进行反序列化。关系见下：</p>
<ul>
<li>如果从下标bai从1开始存储，则编号为i的结点的主要关系为：<br>双亲：向下取整 （i/2）<br>左孩子：2i<br>右孩子：2i+1</li>
<li>如果从下标从0开始存储，则编号为i的结点的主要关系为：<br>双亲：向下取整 （(i-1)/2）<br>左孩子：2i+1<br>右孩子：2i+2</li>
</ul>
<p>反序列化算法逻辑为：</p>
<ol>
<li>特例处理： 若 data为空，直接返回 null；</li>
<li>初始化： 序列化列表 vals（先去掉首尾中括号，再用逗号隔开），指针 i = 1 ，根节点 root（值为 vals[0] ），队列 queue(包含 root）；</li>
<li>按层构建： 当 queue 为空时跳出；<ol>
<li>节点出队，记为 node；</li>
<li>构建 node的左子节点：node.left 的值为 vals[i]，并将 node.left入队；</li>
<li>执行 i+=1；</li>
<li>构建 node的右子节点：node.left的值为 vals[i]，并将 node.left入队；</li>
<li>执行 i+=1；</li>
</ol>
</li>
<li>返回值： 返回根节点root即可。</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 20:43 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_61.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[]"</span></span><br><span class="line">        <span class="comment"># 广度优先搜索</span></span><br><span class="line">        result, de = [], deque()</span><br><span class="line">        de.append(root)</span><br><span class="line">        <span class="keyword">while</span> de:</span><br><span class="line">            <span class="comment"># for _ in range(len(de)):</span></span><br><span class="line">            <span class="comment">#     node = de.popleft()</span></span><br><span class="line">            <span class="comment">#     result.append(node.val)</span></span><br><span class="line">            <span class="comment">#     if node.left:</span></span><br><span class="line">            <span class="comment">#         de.append(node.left)</span></span><br><span class="line">            <span class="comment">#     else:</span></span><br><span class="line">            <span class="comment">#         result.append("null")</span></span><br><span class="line">            <span class="comment">#     if node.right:</span></span><br><span class="line">            <span class="comment">#         de.append(node.right)</span></span><br><span class="line">            <span class="comment">#     else:</span></span><br><span class="line">            <span class="comment">#         result.append("null")</span></span><br><span class="line">            <span class="comment"># 以上可简化为</span></span><br><span class="line">            node = de.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                result.append(<span class="built_in">str</span>(node.val))</span><br><span class="line">                de.append(node.left)</span><br><span class="line">                de.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(<span class="string">"null"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span>+<span class="string">","</span>.join(result)+<span class="string">"]"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">"[]"</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        values, i = data[<span class="number">1</span>:-<span class="number">1</span>].split(<span class="string">","</span>), <span class="number">1</span>  <span class="comment"># vals存放所有结点</span></span><br><span class="line">        root = TreeNode(values[<span class="number">0</span>])</span><br><span class="line">        de = deque()  <span class="comment"># 存放各个结点</span></span><br><span class="line">        de.append(root)</span><br><span class="line">        <span class="comment"># 类广度优先遍历，建立结点之间的关系</span></span><br><span class="line">        <span class="keyword">while</span> de:</span><br><span class="line">            node = de.popleft()</span><br><span class="line">            <span class="keyword">if</span> values[i] != <span class="string">"null"</span>:</span><br><span class="line">                node.left = TreeNode(<span class="built_in">int</span>(values[i]))</span><br><span class="line">                de.append(node.left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> values[i] != <span class="string">"null"</span>:</span><br><span class="line">                node.right = TreeNode(<span class="built_in">int</span>(values[i]))</span><br><span class="line">                de.append(node.right)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-62"><a href="#interview-62" class="headerlink" title="interview_62"></a>interview_62</h2><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d/">参考链接</a></p>
<p>二叉搜索树的<strong>中序遍历为递增序列</strong>。因此求二叉搜索树的第K大的结点为为<strong>求此二叉搜索树中序遍历倒序的第K大的结点。</strong>（即中序遍历是会产生一个从小到大的排列[1, 2, 3, 4, 5]，中序遍历的倒序则是产生一个从大到小的排列[5, 4, 3, 2, 1]）</p>
<p>中序遍历递归顺序为：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 打印中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    print(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br></pre></td></tr></tbody></table></figure>
<p>倒序为</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 打印中序遍历倒序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br><span class="line">    print(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 20:43</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_62.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.k = <span class="literal">None</span></span><br><span class="line">        self.result_node = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">      	<span class="comment"># 对二叉搜索树进行反中序遍历，将产生一个从大到小的序列</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="comment"># 递归结束条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> self.k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 先遍历右结点</span></span><br><span class="line">            dfs(root.right)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对当前结点进行判断，如果当前k已经减到0了，则找到第k大的结点了，返回</span></span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                self.result_node = root.val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 再遍历左结点</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line"></span><br><span class="line">        self.k = k</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.result_node</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><p><img data-src="/images/algorithm/binary-tree.png" alt="binary-tree"></p>
<h2 id="binary-tree-inorder-traversal"><a href="#binary-tree-inorder-traversal" class="headerlink" title="binary-tree-inorder-traversal"></a>binary-tree-inorder-traversal</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/12 22:43</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 94_binary-tree-inorder-traversal.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            backtrack(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            backtrack(root.right)</span><br><span class="line">        backtrack(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = TreeNode(<span class="number">1</span>)</span><br><span class="line">root.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">root.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">so = Solution()</span><br><span class="line">print(so.inorderTraversal(root))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="unique-binary-search-trees-ii"><a href="#unique-binary-search-trees-ii" class="headerlink" title="unique-binary-search-trees-ii"></a>unique-binary-search-trees-ii</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/14 12:28 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 95_unique-binary-search-trees-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/unique-binary-search-trees-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generate_tree</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>, ]</span><br><span class="line">            all_trees = []</span><br><span class="line"></span><br><span class="line">            <span class="comment"># pick a root</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end+<span class="number">1</span>):</span><br><span class="line">                left_tree = generate_tree(start, i)</span><br><span class="line">                right_tree = generate_tree(i+<span class="number">1</span>, end)</span><br><span class="line">                <span class="keyword">for</span> left <span class="keyword">in</span> left_tree:</span><br><span class="line">                    <span class="keyword">for</span> right <span class="keyword">in</span> right_tree:</span><br><span class="line">                        current_tree = TreeNode(i)</span><br><span class="line">                        current_tree.left = TreeNode(left)</span><br><span class="line">                        current_tree.right = TreeNode(right)</span><br><span class="line">                        all_trees.append(current_tree)</span><br><span class="line">            <span class="keyword">return</span> all_trees</span><br><span class="line">        <span class="keyword">return</span> generate_tree(<span class="number">1</span>, n) <span class="keyword">if</span> n <span class="keyword">else</span> []</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="unique-binary-search-trees"><a href="#unique-binary-search-trees" class="headerlink" title="unique-binary-search-trees"></a>unique-binary-search-trees</h2><p>假设n个节点存在</p>
<p>令G(n)的从1到n可以形成二叉排序树个数</p>
<p>令f(i)为以i为根的二叉搜索树的个数</p>
<p>即有: <code>G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)</code></p>
<p>n为根节点，当i为根节点时，其左子树节点个数为<code>[1,2,3,...,i-1]</code>，右子树节点个数为<code>[i+1,i+2,...n]</code>，所以当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，即<code>f(i) = G(i-1)*G(n-i)</code></p>
<p>上面两式可得:G(n) = <code>G(0)*G(n-1) + G(1)*(n-2) +...+ G(n-1)*G(0)</code></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/13 18:49 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 96_unique-binary-search-trees.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/unique-binary-search-trees/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                dp[i] += dp[j] * dp[i - j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.numTrees(<span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="validate-binary-search-tree"><a href="#validate-binary-search-tree" class="headerlink" title="validate-binary-search-tree"></a>validate-binary-search-tree</h2><p>需要在遍历树的同时保留结点的上界与下界，在比较时不仅比较子结点的值，也要与上下界比较。这样才能保证节点的所有左子树都小于结点值，右子树都大于结点值。</p>
<p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode/">参考链接</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/14 22:59 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 98_validate-binary-search-tree.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/validate-binary-search-tree/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        stack = [(root, <span class="built_in">float</span>(<span class="string">'-inf'</span>), <span class="built_in">float</span>(<span class="string">'inf'</span>)), ]</span><br><span class="line">        <span class="comment"># 深度优先遍历</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root, lower, upper = stack.pop()</span><br><span class="line">            <span class="comment"># 防止append一个空子树</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            val = root.val</span><br><span class="line">            <span class="keyword">if</span> val &lt;= lower <span class="keyword">or</span> val &gt;= upper:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.append((root.right, val, upper)) <span class="comment"># 右子树的所有值都要大于根节点</span></span><br><span class="line">            stack.append((root.left, lower, val))  <span class="comment"># 左子树的所有值都要小于根节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="recover-binary-search-tree"><a href="#recover-binary-search-tree" class="headerlink" title="recover-binary-search-tree"></a>recover-binary-search-tree</h2><p><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/solution/zhong-xu-bian-li-by-powcai/">参考链接</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/16 22:36</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 99_recover-binary-search-tree.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/recover-binary-search-tree/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pre_node = TreeNode(<span class="built_in">float</span>(<span class="string">"-inf"</span>))</span><br><span class="line">        self.second_node = <span class="literal">None</span></span><br><span class="line">        self.first_node = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 中序遍历：找到第一个大于左子树的节点赋值为first_node，第一个小于右子树的节点赋值为second_node</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">in_order</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            in_order(root.left)</span><br><span class="line">            <span class="keyword">if</span> self.first_node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> self.pre_node.val &gt;= root.val:</span><br><span class="line">                self.first_node = self.pre_node</span><br><span class="line">            <span class="keyword">if</span> self.first_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.pre_node.val &gt;= root.val:</span><br><span class="line">                self.second_node = root</span><br><span class="line">            self.pre_node = root</span><br><span class="line">            in_order(root.right)</span><br><span class="line">        in_order(root)</span><br><span class="line">        self.first_node.val, self.second_node.val = self.second_node.val, self.first_node.val</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="same-tree"><a href="#same-tree" class="headerlink" title="same-tree"></a>same-tree</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/16 12:29</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 100_same-tree.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/same-tree/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p: TreeNode, q: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="merge-k-sorted-lists"><a href="#merge-k-sorted-lists" class="headerlink" title="merge-k-sorted-lists"></a>merge-k-sorted-lists</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/7 9:25 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 23_merge-k-sorted-lists.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/merge-k-sorted-lists/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 使用优先队列(堆排序)存储每个list中的第一个节点，由优先队列返回优先级最高（值最低的元素）</span></span><br><span class="line">        head_pre = p = ListNode(<span class="number">0</span>)</span><br><span class="line">        prior_queue = PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> list_node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> list_node:</span><br><span class="line">                prior_queue.put((list_node.val, list_node))</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> prior_queue.empty():</span><br><span class="line">            node_val, node = prior_queue.get()</span><br><span class="line">            p.<span class="built_in">next</span> = ListNode(node_val)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 将当前list的头指向list中的下一个节点</span></span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                prior_queue.put((node.val, node))</span><br><span class="line">        <span class="keyword">return</span> head_pre.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Bit-Operation"><a href="#Bit-Operation" class="headerlink" title="Bit Operation"></a>Bit Operation</h1><h2 id="divide-two-integers"><a href="#divide-two-integers" class="headerlink" title="divide-two-integers"></a>divide-two-integers</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/9 9:11 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 29_divide-two-integers.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/divide-two-integers/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span>(<span class="params">self, dividend: <span class="built_in">int</span>, divisor: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        flag = dividend &lt; <span class="number">0</span> ^ divisor &lt; <span class="number">0</span></span><br><span class="line">        dividend, divisor = <span class="built_in">abs</span>(dividend), <span class="built_in">abs</span>(divisor)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        move_step = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 移动除数直到比被除数大</span></span><br><span class="line">        <span class="keyword">while</span> divisor &lt;= dividend:</span><br><span class="line">            move_step += <span class="number">1</span></span><br><span class="line">            divisor &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 移动move_step 次使得 len(divisor) &gt; len(dividend),则 move_step-1 次使得 len(divisor) &gt;  len(dividend)</span></span><br><span class="line">        <span class="keyword">while</span> move_step &gt; <span class="number">0</span>:</span><br><span class="line">            move_step -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 此时divisor比division大，应该向右移动一位</span></span><br><span class="line">            divisor &gt;&gt;= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 判断是否除尽</span></span><br><span class="line">            <span class="keyword">if</span> dividend &gt;= divisor:</span><br><span class="line">                result += <span class="number">1</span> &lt;&lt; move_step</span><br><span class="line">                dividend -= divisor</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            result = -result</span><br><span class="line">        <span class="keyword">return</span> result <span class="keyword">if</span> -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>) &lt;= result &lt;= (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span> <span class="keyword">else</span> (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.divide(-<span class="number">45</span>, <span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="gray-code"><a href="#gray-code" class="headerlink" title="gray-code"></a>gray-code</h2><p>解题思路：</p>
<ul>
<li>结果是当前head的移位结果 + 已有结果的倒序（注：<a href="https://leetcode-cn.com/problems/gray-code/solution/gray-code-jing-xiang-fan-she-fa-by-jyd/">参考链接</a>）</li>
</ul>
<p><img data-src="/images/algorithm/leetcode-89.png" alt="leetcode-89"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/2 23:45</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 89_gray-code.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/gray-code/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        res, head = [<span class="number">0</span>], <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(head + res[j])</span><br><span class="line">            head &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.grayCode(<span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="convert-a-number-to-hexadecimal"><a href="#convert-a-number-to-hexadecimal" class="headerlink" title="convert-a-number-to-hexadecimal"></a>convert-a-number-to-hexadecimal</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/19 10:54</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 405_convert-a-number-to-hexadecimal.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toHex</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        num &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">        mask = <span class="number">0b1111</span></span><br><span class="line">        s = <span class="string">"0123456789abcdef"</span></span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 从num低4位开始，每隔4位依次取结果，并对应到s的相应数字</span></span><br><span class="line">            result += s[num &amp; mask]</span><br><span class="line">            num &gt;&gt;= <span class="number">4</span>  <span class="comment"># num向右移动4位</span></span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>] <span class="keyword">if</span> result <span class="keyword">else</span> <span class="string">"0"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.toHex(<span class="number">26</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="binary-watch"><a href="#binary-watch" class="headerlink" title="binary-watch"></a>binary-watch</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/20 12:38</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 401_binary-watch.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/binary-watch/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readBinaryWatch</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">count_binary_1</span>(<span class="params">i</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">bin</span>(i).count(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1~59分钟转换成二进制里面分别有多少1</span></span><br><span class="line">        dict_binary = {i: count_binary_1(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>)}</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>):</span><br><span class="line">                <span class="comment"># hour 与 minutes 亮灯的两者之和与num相等</span></span><br><span class="line">                <span class="keyword">if</span> dict_binary[h] + dict_binary[m] == num:</span><br><span class="line">                    hour = <span class="built_in">str</span>(h)</span><br><span class="line">                    m = <span class="built_in">str</span>(m) <span class="keyword">if</span> m &gt; <span class="number">9</span> <span class="keyword">else</span> <span class="string">"0"</span> + <span class="built_in">str</span>(m)</span><br><span class="line">                    res.append(hour + <span class="string">":"</span> + m)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.readBinaryWatch(<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-11"><a href="#interview-11" class="headerlink" title="interview_11"></a>interview_11</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 15:41</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_11.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span>  <span class="comment"># 牛客网要求只输出该数32位二进制表示中1的个数，故利用count来计数</span></span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">and</span> count &lt;= <span class="number">32</span>:</span><br><span class="line">            res += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.hammingWeight(-<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-48"><a href="#interview-48" class="headerlink" title="interview_48"></a>interview_48</h2><p><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mei-ri-suan-fa-day-66-jing-dian-mian-shi-ti-bu-yon/">题解来源</a></p>
<p>因为不允许采用四则运算，所以只能考虑位运算了。</p>
<p>其实就是用二进制来模拟加法操作。首先将两个数最低位相加，如果都是 1 ，那么就得到 0 ，并且进位 1 ，然后接着算下一位。</p>
<p>但是这样一位一位模拟不方便实现，更简单的实现方法是直接把两个数对应位相加，不管进位。然后进位单独计算，如果某一位两个数都是 1 ，那么进位就会对下一位产生影响。然后接着算不进位求和加上进位的值，再计算新的进位，依次重复下去，直到进位为 0 为止。</p>
<p>用一个实际的例子来演示一下，计算 3+7 的值，其中 s 表示每一步不考虑进位的求和，c 表示每一步的进位，最后得到结果 1010 ，也就是十进制的 10 </p>
<p><img data-src="/images/algorithm/interview_48.png" alt="interview_48"></p>
<p><strong>Python 负数的存储：</strong><br>Python，Java 等语言中的数字都是以 补码 形式存储的。但 Python 没有 int , long 等不同长度变量，即在编程时无变量位数的概念。<br>获取负数的补码： 需要将数字与十六进制数 0xffffffff 相与。可理解为舍去此数字 32 位以上的数字（将 32 位以上都变为 00 ），从无限长度变为一个 32 位整数。<br>返回前数字还原： 若补码 a 为负数（ 0x7fffffff 是最大的正数的补码 ），需执行 ~(a ^ x) 操作，将补码还原至 Python 的存储格式。 a ^ x 运算将 1 至 32 位按位取反； ~ 运算是将整个数字取反；因此， ~(a ^ x) 是将 32 位以上的位取反，1 至 32 位不变。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/25 14:37 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_48.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        a &amp;= <span class="number">0xffffffff</span></span><br><span class="line">        b &amp;= <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">            c = ((a &amp; b) &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffffff</span>  <span class="comment"># 进位用与操作</span></span><br><span class="line">            a ^= b  <span class="comment"># 不考虑进位的结果用异或操作</span></span><br><span class="line">            b = c</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(a ^ <span class="number">0xffffffff</span>)  <span class="comment"># 负数需要恢复成原码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.add(-<span class="number">3</span>, -<span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-49"><a href="#interview-49" class="headerlink" title="interview_49"></a>interview_49</h2><p><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/mian-shi-ti-67-ba-zi-fu-chuan-zhuan-huan-cheng-z-4/">参考链接</a></p>
<p><strong>数字越界处理：</strong></p>
<blockquote>
<p>题目要求返回的数值范围应在[ -2^31, 2 ^ 31 − 1] ，因此需要考虑数字越界问题。而由于题目指出环境只能存储 32 位大小的有符号整数 ，因此判断数字越界时，要始终保持 res 在 int 类型的取值范围内。</p>
</blockquote>
<p><img data-src="/images/algorithm/interview_49.png" alt="interview_49"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/25 14:37 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_49.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span>(<span class="params">self, <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">str</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># string = str.split()[0]  # 不使用split，strip等方法可以将空间复杂度降到O(1)</span></span><br><span class="line">        result, i, sign, len_str = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="built_in">len</span>(<span class="built_in">str</span>)  <span class="comment"># 结果，开始的索引，正负号，str的长度</span></span><br><span class="line">        int_max, int_min, boundary = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>, -<span class="number">2</span> ** <span class="number">31</span>, <span class="number">2</span> ** <span class="number">31</span> // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 去除空格</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">str</span>[i] == <span class="string">" "</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == len_str:  <span class="comment"># 空字符串</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断符号</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>[i] == <span class="string">"-"</span>:</span><br><span class="line">            sign = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>[i] <span class="keyword">in</span> (<span class="string">"+"</span>, <span class="string">"-"</span>):</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 整数拼接</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>[i:]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">"0"</span> &lt;= c &lt;= <span class="string">"9"</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> result &gt; boundary <span class="keyword">or</span> (result == boundary <span class="keyword">and</span> c &gt; <span class="string">"7"</span>):</span><br><span class="line">                <span class="keyword">return</span> int_max <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">else</span> int_min</span><br><span class="line">            result = result * <span class="number">10</span> + <span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">"0"</span>)  <span class="comment"># 结果通过字符与"0"的ASCII码求得</span></span><br><span class="line">        <span class="keyword">return</span> sign * result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.strToInt(<span class="string">"+123i adf"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>支持小数</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/25 14:37</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_49.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span>(<span class="params">self, <span class="built_in">str</span>: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">str</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># string = str.split()[0]  # 不使用split，strip等方法可以将空间复杂度降到O(1)</span></span><br><span class="line">        result, i, sign, len_str = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="built_in">len</span>(<span class="built_in">str</span>)  <span class="comment"># 结果，开始的索引，正负号，str的长度</span></span><br><span class="line">        int_max, int_min, boundary = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>, -(<span class="number">2</span> ** <span class="number">31</span>), <span class="number">2</span> ** <span class="number">31</span> // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 去除空格</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">str</span>[i] == <span class="string">" "</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == len_str:  <span class="comment"># 空字符串</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断符号</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>[i] == <span class="string">"-"</span>:</span><br><span class="line">            sign = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>[i] <span class="keyword">in</span> (<span class="string">"+"</span>, <span class="string">"-"</span>):</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 整数拼接</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>[i:]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">"0"</span> &lt;= c &lt;= <span class="string">"9"</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> result &gt; boundary <span class="keyword">or</span> (result == boundary <span class="keyword">and</span> c &gt; <span class="string">"7"</span>):</span><br><span class="line">                <span class="keyword">return</span> int_max <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">else</span> int_min</span><br><span class="line">            result = result * <span class="number">10</span> + <span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">"0"</span>)  <span class="comment"># 结果通过字符与"0"的ASCII码求得</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 求小数部分</span></span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">str</span>[i-<span class="number">1</span>] == <span class="string">"."</span>:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">str</span>[i:]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">"0"</span> &lt;= c &lt;= <span class="string">"9"</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> result &gt; boundary <span class="keyword">or</span> (result == boundary <span class="keyword">and</span> c &gt; <span class="string">"7"</span>):</span><br><span class="line">                    <span class="keyword">return</span> int_max <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">else</span> int_min</span><br><span class="line">                result = result + (<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">"0"</span>)) * <span class="number">0.1</span> ** x</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sign * result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.strToInt(<span class="string">"+12.3"</span>))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><h2 id="find-first-and-last-position-of-element-in-sorted-array"><a href="#find-first-and-last-position-of-element-in-sorted-array" class="headerlink" title="find-first-and-last-position-of-element-in-sorted-array"></a>find-first-and-last-position-of-element-in-sorted-array</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/2 11:18 上午 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 34_find-first-and-last-position-of-element-in-sorted-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_left_right_index</span>(<span class="params">self, nums, target, left_right_flag</span>):</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target <span class="keyword">or</span> (left_right_flag <span class="keyword">and</span> nums[mid] == target):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums, target: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="comment"># 找到左边界</span></span><br><span class="line">        left_index = self.find_left_right_index(nums, target, <span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> left_index == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[left_index] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 找到右边界</span></span><br><span class="line">        <span class="keyword">return</span> [left_index, self.find_left_right_index(nums, target, <span class="literal">False</span>) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.searchRange([<span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>], <span class="number">8</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="sqrtx"><a href="#sqrtx" class="headerlink" title="sqrtx"></a>sqrtx</h2><p>当<code>x ≥ 2</code> 时，它的整数平方根一定小于 <code>x / 2</code>。由于结果一定是整数，此问题可以转换成在有序整数集中寻找一个特定值，因此可以使用二分查找。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/11 11:57</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 69_sqrtx.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/sqrtx/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        left = <span class="number">2</span></span><br><span class="line">        right = x // <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> middle * middle &gt; x:</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> middle * middle &lt; x:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.mySqrt(<span class="number">8</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="search-a-2d-matrix"><a href="#search-a-2d-matrix" class="headerlink" title="search-a-2d-matrix"></a>search-a-2d-matrix</h2><p>将整个matric当做一个列表，进行二分查找。其中对应的元素与其行列的索引为：</p>
<blockquote>
<p>middle = (left + right) // 2</p>
<p>row_index = middle // cols</p>
<p>col_index = middle % cols</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/17 19:59 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 74_search-a-2d-matrix.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/search-a-2d-matrix/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = rows * cols - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = (left + right) // <span class="number">2</span></span><br><span class="line">            row = middle // cols</span><br><span class="line">            col = middle % cols</span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] &gt; target:</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.searchMatrix([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>],</span><br><span class="line">    [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">    [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">], <span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="search-in-rotated-sorted-array"><a href="#search-in-rotated-sorted-array" class="headerlink" title="search-in-rotated-sorted-array"></a>search-in-rotated-sorted-array</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/1 4:43 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 33_search-in-rotated-sorted-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="comment"># 右半部分是有序的</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="comment"># target在右半部分里</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt; nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 左半部分是有序的</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># target在左半部分里</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt; target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.search([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">0</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="find-minimum-in-rotated-sorted-array"><a href="#find-minimum-in-rotated-sorted-array" class="headerlink" title="find-minimum-in-rotated-sorted-array"></a>find-minimum-in-rotated-sorted-array</h2><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/xun-zhao-xuan-zhuan-pai-lie-shu-zu-zhong-de-zui-xi/">参考链接</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/26 12:39</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 153_find-minimum-in-rotated-sorted-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> len_nums &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len_nums - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 退出条件</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle - <span class="number">1</span>] &gt; nums[middle]:</span><br><span class="line">                <span class="keyword">return</span> nums[middle]</span><br><span class="line">            <span class="keyword">if</span> nums[middle] &gt; nums[middle + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[middle + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 左边为有序，寻找在右边的变化点</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &gt; nums[left]:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 右边为有序，寻找在左边的变化点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findMin([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="search-in-rotated-sorted-array-ii"><a href="#search-in-rotated-sorted-array-ii" class="headerlink" title="search-in-rotated-sorted-array-ii"></a>search-in-rotated-sorted-array-ii</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/26 19:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 81_search-in-rotated-sorted-array-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 右半部分是有序的</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="comment"># target在右半部分里</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt; nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 左半部分是有序的</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># target在左半部分里</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt; target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.search([<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="min-value-in-rotated-array"><a href="#min-value-in-rotated-array" class="headerlink" title="min-value-in-rotated-array"></a>min-value-in-rotated-array</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/25 12:37 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: min-value-in-rotated-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span>(<span class="params">self, rotateArray</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        len_rotatearray = <span class="built_in">len</span>(rotateArray)</span><br><span class="line">        <span class="keyword">if</span> len_rotatearray &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> rotateArray</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len_rotatearray - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            middle = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[middle] &gt; rotateArray[right]:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = middle</span><br><span class="line">        <span class="keyword">return</span> rotateArray[left]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.minNumberInRotateArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]))</span><br><span class="line">print(so.minNumberInRotateArray([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">print(so.minNumberInRotateArray([<span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="find-peak-element"><a href="#find-peak-element" class="headerlink" title="find-peak-element"></a>find-peak-element</h2><ul>
<li>时间复杂度 : O(log_2(n))。 每一步都将搜索空间减半。因此，总的搜索空间只需要 log_2(n)步。其中 n 为 num 数组的长度。</li>
<li>空间复杂度 : O(1)。 只使用了常数空间。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/27 12:46</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 162_find-peak-element.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/find-peak-element/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            middle = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 从middle左侧开始找峰值</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &gt; nums[middle + <span class="number">1</span>]:</span><br><span class="line">                right = middle</span><br><span class="line">            <span class="comment"># 从middle右侧开始找峰值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findPeakElement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-50"><a href="#interview-50" class="headerlink" title="interview_50"></a>interview_50</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/">参考链接</a></p>
<ul>
<li>方法一：暴力</li>
</ul>
<p>时间复杂度<code>O(N)</code></p>
<p>空间复杂度<code>O(N)</code></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        dic = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic: <span class="keyword">return</span> num</span><br><span class="line">            dic.add(num)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>方法二：原地根据索引交换</li>
</ul>
<p>时间复杂度<code>O(N)</code></p>
<p>空间复杂度<code>O(1)</code></p>
<p>索引处存放的值为对应的索引。</p>
<p>注：此方法不能保证重复数字出现的先后顺序（若有两个重复数字，如果需要返回第一个重复的数字，那么此方法不能保证返回的顺序正确）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == i:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[nums[i]]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-6"><a href="#interview-6" class="headerlink" title="interview_6"></a>interview_6</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/25 12:37</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_6.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span>(<span class="params">self, rotateArray</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        len_rotatearray = <span class="built_in">len</span>(rotateArray)</span><br><span class="line">        <span class="keyword">if</span> len_rotatearray &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> rotateArray</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len_rotatearray - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            middle = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[middle] &gt; rotateArray[right]:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = middle</span><br><span class="line">        <span class="keyword">return</span> rotateArray[left]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.minNumberInRotateArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]))</span><br><span class="line">print(so.minNumberInRotateArray([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">print(so.minNumberInRotateArray([<span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-37"><a href="#interview-37" class="headerlink" title="interview_37"></a>interview_37</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/25 12:37</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_6.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span>(<span class="params">self, data, k</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        len_data = <span class="built_in">len</span>(data)</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先找最左边等于k的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, len_data - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> data[i] == k:</span><br><span class="line">                left = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 再找最右边等于k的位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(len_data - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> data[j] == k:</span><br><span class="line">                right = j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 判断临界条件</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> data[left] == k:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Double-Pointer"><a href="#Double-Pointer" class="headerlink" title="Double Pointer"></a>Double Pointer</h1><h2 id="trapping-rain-water"><a href="#trapping-rain-water" class="headerlink" title="trapping-rain-water"></a>trapping-rain-water</h2><p> 直接思路：</p>
<ul>
<li>对于每个元素而言，它对应的水的数量由其左右两边最大的高度决定，即：<ul>
<li>当前元素向左扫描得到最大的高度max_left_height</li>
<li>当前元素向右扫描得到最大的高度max_right_height</li>
<li>取min(max_left_height, max_right_height)，得到min_height</li>
<li>再将min_height 与当前元素的height相减，即为当前元素所能注得的水量</li>
</ul>
</li>
<li>时间复杂度： $O(n^2)$ ，因数组中的每个元素都需要向左向右扫描。</li>
</ul>
<p>本题采用双指针法：时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ </p>
<p>思路如下：</p>
<ul>
<li><p>如果一端有更高的条形块（例如右端），积水的高度依赖于当前方向的高度（从左到右）。</p>
</li>
<li><p>当另一侧（左侧）的条形块高度较高时，积水的高度依赖于（从右到左）方向的高度。</p>
</li>
</ul>
<p>伪代码如下：</p>
<ul>
<li><p>初始化left指针为 0 并且right 指针为 size-1</p>
</li>
<li><p>While left &lt; right, do:</p>
<ul>
<li><p>If height[left] &lt; height[right]</p>
<ul>
<li><p>if height_left_max &lt;= height[left]: 更新height_left_max </p>
</li>
<li><p>else:</p>
</li>
</ul>
</li>
<li><p>result += height_left_max - height[left]</p>
</li>
<li><p>else:</p>
<ul>
<li><p>if height_right_max &lt;= height[right]: 更新height_right_max </p>
</li>
<li><p>else:</p>
<p>result += height_right_max - height[right]</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/14 09:11</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 42_trapping-rain-water.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/trapping-rain-water</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        left_max, right_max = height[left], height[right]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 因为是从0，size-1开始比较的，每次比较相当于间接确定了height[left] &lt; height[left_max] &lt; height[right]</span></span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                <span class="keyword">if</span> height[left] &gt;= left_max:</span><br><span class="line">                    left_max = height[left]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result += (left_max - height[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># height[right] &lt; height[right_max] &lt; height[left]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> height[right] &gt;= right_max:</span><br><span class="line">                    right_max = height[right]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result += (right_max - height[right])</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.trap([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="sort-colors"><a href="#sort-colors" class="headerlink" title="sort-colors"></a>sort-colors</h2><p>解题思路：</p>
<ul>
<li>left指向0、right指向2</li>
<li>当nums[current] = 0或2时，跟left、right指向的元素进行交换</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/18 23:41</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 75_sort-colors.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/sort-colors</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        current = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> nums[current] == <span class="number">0</span>:</span><br><span class="line">                nums[left], nums[current] = nums[current], nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[current] == <span class="number">1</span>:</span><br><span class="line">                nums[right], nums[current] = nums[current], nums[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.sortColors([<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="minimum-window-substring"><a href="#minimum-window-substring" class="headerlink" title="minimum-window-substring"></a>minimum-window-substring</h2><p>解题思路：</p>
<p>滑动窗口的思想</p>
<blockquote>
<p>left指针仅在当前窗口满足条件之后才会移动：即当前窗口中满足要求，left会试着移动以此减少结果的长度</p>
<p>right 指针不停向右移动，找寻满足条件的窗口</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/21 22:48</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 76_minimum-window-substring.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/minimum-window-substring</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow1</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        length_s = <span class="built_in">len</span>(s)</span><br><span class="line">        result = s + s  <span class="comment"># 随便设定一个比s长的字符串，便于后续处理</span></span><br><span class="line">        t_dict = Counter(t)  <span class="comment"># t各个数字的出现的次数</span></span><br><span class="line">        count_dict = defaultdict(<span class="keyword">lambda</span>: <span class="number">0</span>)  <span class="comment"># 创建一个默认值为0的字典</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前字典与目标字典长度、存储的值是否相同</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">contains</span>(<span class="params">t_dict, count_dict</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(count_dict) &lt; <span class="built_in">len</span>(t_dict):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> count_dict:</span><br><span class="line">                <span class="keyword">if</span> count_dict[key] &lt; t_dict[key] <span class="keyword">or</span> key <span class="keyword">not</span> <span class="keyword">in</span> t_dict:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 触发right移动</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(length_s):</span><br><span class="line">            <span class="keyword">if</span> s[right] <span class="keyword">in</span> t_dict:</span><br><span class="line">                count_dict[s[right]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#  触发left移动: 当前存储的字典中与目标字典中长度、包含的值相同</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; length_s <span class="keyword">and</span> contains(t_dict, count_dict):</span><br><span class="line">                <span class="comment"># 更新结果</span></span><br><span class="line">                <span class="keyword">if</span> right - left + <span class="number">1</span> &lt; <span class="built_in">len</span>(result):</span><br><span class="line">                    result = s[left:right + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> s[left] <span class="keyword">in</span> t_dict:</span><br><span class="line">                    count_dict[s[left]] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> result == s + s <span class="keyword">else</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution1()</span><br><span class="line">print(so.minWindow1(<span class="string">"ADOBECODEBANC"</span>, <span class="string">"ABC"</span>))</span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/22 22:32</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 77_combinations.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/combinations/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> n &lt; k:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        self.__dfs(<span class="number">1</span>, k, n, [], result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dfs</span>(<span class="params">self, index, k, n, pre, result</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pre) == k:</span><br><span class="line">            result.append(pre[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, n + <span class="number">1</span>):</span><br><span class="line">            pre.append(i)</span><br><span class="line">            self.__dfs(i + <span class="number">1</span>, k, n, pre, result)</span><br><span class="line">            pre.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.combine(<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="remove-duplicates-from-sorted-array-ii"><a href="#remove-duplicates-from-sorted-array-ii" class="headerlink" title="remove-duplicates-from-sorted-array-ii"></a>remove-duplicates-from-sorted-array-ii</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/26 14:00 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 80_remove-duplicates-from-sorted-array-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># j指向需要覆盖的位置</span></span><br><span class="line">        j, count = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count &lt;= <span class="number">2</span>:</span><br><span class="line">                nums[j] = nums[i]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.removeDuplicates([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-41"><a href="#interview-41" class="headerlink" title="interview_41"></a>interview_41</h2><p>窗口何时扩大，何时缩小？</p>
<ul>
<li>当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动</li>
<li>当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动</li>
<li>当窗口的和恰好等于 target 的时候，我们需要记录此时的结果。设此时的窗口为 [i, j)，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/23 18:33 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_41.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span>(<span class="params">self, target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        i = <span class="number">1</span>  <span class="comment"># 左边界，做减法</span></span><br><span class="line">        j = <span class="number">1</span>  <span class="comment"># 右边界，做加法</span></span><br><span class="line">        sum_current = <span class="number">0</span>  <span class="comment"># 当前滑动窗口中的总和</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 左边界不得超过target的中值</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= target // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> sum_current &lt; target:</span><br><span class="line">                sum_current += j</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum_current &gt; target:</span><br><span class="line">                sum_current -= i</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(<span class="built_in">list</span>(<span class="built_in">range</span>(i, j)))</span><br><span class="line">                sum_current -= i</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findContinuousSequence(<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-42"><a href="#interview-42" class="headerlink" title="interview_42"></a>interview_42</h2><p>算法流程：</p>
<ul>
<li>初始化： 双指针 i , j分别指向数组 nums 的左右两端 （俗称对撞双指针）。</li>
<li>循环搜索： 当双指针相遇时跳出；<ul>
<li>计算和 s = nums[i] + nums[j]；<br>若 s &gt; targets ，则指针 j 向左移动，即执行 j = j - 1；<br>若 s &lt; targets ，则指针 i 向右移动，即执行 i = i + 1；<br>若 s = targets ，立即返回数组 [nums[i], nums[j]] ；<br>返回空数组，代表无和为 target的数字组合。</li>
</ul>
</li>
</ul>
<p><img data-src="/images/algorithm/interview_42.png" alt="interview_42"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/23 18:33 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_42.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        <span class="keyword">while</span> i != j:</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] &gt; target:</span><br><span class="line">                <span class="comment"># j 向右移动</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] + nums[j] &lt; target:</span><br><span class="line">                <span class="comment"># i 向左移动</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [nums[i], nums[j]]</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.twoSum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">7</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-64"><a href="#interview-64" class="headerlink" title="interview_64"></a>interview_64</h2><p>如果使用暴力解法，可能会被面试官直接微笑回去等消息。即以下这种酸爽解法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> <span class="keyword">or</span> k == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(nums)-k+<span class="number">1</span>):</span><br><span class="line">            ans.append(<span class="built_in">max</span>(nums[i:i+k]))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure>
<p>为降低时间复杂度，此题难点是：</p>
<blockquote>
<p>如何在每次窗口滑动后，将 “获取窗口内最大值” 的时间复杂度从 O(k) 降低至 O(1) 。</p>
</blockquote>
<p>此题与interview_20（<a href="https://unknown.yuzhouwan.com/posts/55663/#interview_20">包含min函数的栈</a>）一起食用最佳。即：</p>
<blockquote>
<p>维护一个队列。保持队列是单调递减，即加入时把前面比其小的数pop掉。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:58</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_64.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        de = collections.deque()  <span class="comment"># 构建一个双向单调递减队列，队列头记录当前窗口的最大值</span></span><br><span class="line">        result, len_nums = [], <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> left, right <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">1</span> - k, len_nums + <span class="number">1</span> - k), <span class="built_in">range</span>(len_nums)):</span><br><span class="line">            <span class="comment"># 为队列元素同步滑动窗口：队列内仅包含窗口内的元素,每轮窗口滑动移除了元素 nums[left - 1] ，需将队列内的对应元素一起删除。</span></span><br><span class="line">            <span class="comment"># 如果不相等，则证明当前最大不等于滑动窗口刚滑过的元素</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> de[<span class="number">0</span>] == nums[left-<span class="number">1</span>]:</span><br><span class="line">                de.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 为保持队列的单调性：若队列中最小的元素小于待比较的元素，则将队尾元素弹出，新元素加入队尾</span></span><br><span class="line">            <span class="keyword">while</span> de <span class="keyword">and</span> de[-<span class="number">1</span>] &lt; nums[right]:</span><br><span class="line">                de.pop()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果本身就小于队尾元素，则直接加入队尾</span></span><br><span class="line">            de.append(nums[right])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将每次比较的结果添加到返回列表中</span></span><br><span class="line">            <span class="keyword">if</span> left &gt;= <span class="number">0</span>:</span><br><span class="line">                result.append(de[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><h2 id="wildcard-matching"><a href="#wildcard-matching" class="headerlink" title="wildcard-matching"></a>wildcard-matching</h2><p>解题思路：</p>
<ul>
<li><p>状态  dp[i][j]  : 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配 (true 的话表示匹配)</p>
</li>
<li><p>状态转移方程：</p>
<ul>
<li><p>当 s[i] == p[j]，或者 p[j] == ? 那么  dp[i][j] = dp[i - 1][j - 1] </p>
</li>
<li><p>当  p[j] == *  且  dp[i][j] = dp[i][j - 1]  ||  dp[i - 1][j]     </p>
</li>
</ul>
</li>
<li><p>初始化：</p>
<ul>
<li><p>dp[0][0]  表示什么都没有，其值为 true</p>
</li>
<li><p>第一行  dp[0][j] ，换句话说，s 为空，与 p 匹配，所以只要 p 开始为 * 才为 true</p>
</li>
<li><p>第一列 dp[i][0] ，当然全部为 false</p>
</li>
</ul>
</li>
<li><p>例如 </p>
<p><code>s = "abcd"</code> <code>p ="ab*"</code> ，其状态矩阵如下：</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>true</th>
<th>false</th>
<th>false</th>
<th>false</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/16 09:45</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 44_wildcard-matching.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/wildcard-matching/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        s_len = <span class="built_in">len</span>(s)</span><br><span class="line">        p_len = <span class="built_in">len</span>(p)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * (p_len + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s_len + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 初始化，如果s为空，且p的第一个字符为"*"，则置为True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, p_len + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[i-<span class="number">1</span>] == <span class="string">"*"</span>:</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, s_len + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, p_len + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i-<span class="number">1</span>] == p[j-<span class="number">1</span>] <span class="keyword">or</span> p[j-<span class="number">1</span>] == <span class="string">"?"</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j - <span class="number">1</span>] == <span class="string">"*"</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isMatch(<span class="string">"adceb"</span>, <span class="string">"*a*b"</span>))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="maximum-subarray"><a href="#maximum-subarray" class="headerlink" title="maximum-subarray"></a>maximum-subarray</h2><ul>
<li>解法1:贪心算法</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/25 09:52</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 53_maximum-subarray.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/maximum-subarray/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray_GA</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">        current_sum = max_sum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len_nums):</span><br><span class="line">          	<span class="comment"># 寻找局部最优解</span></span><br><span class="line">            current_sum = <span class="built_in">max</span>(nums[i], current_sum + nums[i])</span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, current_sum)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.maxSubArray([-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>解法2:动态规划</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray_DP</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">    len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">    max_sum = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len_nums):</span><br><span class="line">        <span class="keyword">if</span> nums[i-<span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">            nums[i] += nums[i-<span class="number">1</span>]</span><br><span class="line">        max_sum = <span class="built_in">max</span>(max_sum, nums[i])</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></tbody></table></figure>
<h2 id="jump-game"><a href="#jump-game" class="headerlink" title="jump-game"></a>jump-game</h2><p>解题思路：</p>
<p>从右向左迭代，对于每个节点我们检查是否存在一步跳跃可以到达 GOOD 的位置（currPosition + nums[currPosition] &gt;= leftmostGoodIndex）。如果可以到达，当前位置也标记为 GOOD ，同时，这个位置将成为新的最左边的 GOOD 位置，一直重复到数组的开头，如果第一个坐标标记为 GOOD 意味着可以从第一个位置跳到最后的位置。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nums</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>Good/Bad</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>*Good</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>*Good</td>
<td>Good</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>*Good</td>
<td>Good</td>
<td>Good</td>
</tr>
<tr>
<td></td>
<td></td>
<td>False(1+0 &lt; 2)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>*Good(0+2 &gt;= 2)</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/27 12:08 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 55_jump-game.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/jump-game/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        last_true_index = nums[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i + nums[i] &gt;= last_true_index:</span><br><span class="line">                last_true_index = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.canJump([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="unique-paths"><a href="#unique-paths" class="headerlink" title="unique-paths"></a>unique-paths</h2><p>解题思路：</p>
<ul>
<li><p>假设<code>dp[row][col]</code>代表到格子<code>[i][j]</code>的路径个数，其中第一行<code>dp[0][j]</code>与第一列<code>dp[i][0]</code>都为1。</p>
</li>
<li><p>那么每个格子的路径个数取决于它左边格子的路径个数+它上边格子的路径个数。</p>
<p>即<code>dp[i][j]=dp[i][j-1]+dp[i-1][j]</code></p>
</li>
<li><p>为了节省空间，利用两个数组pre与cur来代表上一行与当前行。初始化都为1。</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/5 20:13</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 62_unique-paths.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/unique-paths/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        pre = [<span class="number">1</span>] * n</span><br><span class="line">        cur = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                cur[col] = cur[col-<span class="number">1</span>] + pre[col]</span><br><span class="line">            pre = cur</span><br><span class="line">        <span class="keyword">return</span> pre[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.uniquePaths(<span class="number">7</span>, <span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="unique-paths-ii"><a href="#unique-paths-ii" class="headerlink" title="unique-paths-ii"></a>unique-paths-ii</h2><p>解题思路：</p>
<ul>
<li>与上一题思路类似，让obstacleGrid存储到达各个单元的路径。</li>
<li>首先进行边界初始化，边界上的元素，只有自身为0（代表本身无障碍）且上一个单元值为1（已初始化，此时的1代表无障碍，有1条路可以通行）时，自身的值才被置为1（代表有路径可走）。</li>
<li>根据相邻单元的路径情况，进行自身路径的计算即可。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/5 21:51</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 63_unique-paths-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/unique-paths-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        row = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        col = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 1.边界初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, col):</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][i] = <span class="built_in">int</span>(obstacleGrid[<span class="number">0</span>][i-<span class="number">1</span>] == <span class="number">1</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, row):</span><br><span class="line">            obstacleGrid[j][<span class="number">0</span>] = <span class="built_in">int</span>(obstacleGrid[j-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">and</span> obstacleGrid[j][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">        print(obstacleGrid)</span><br><span class="line">				<span class="comment"># 2.计算路径</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, col):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i-<span class="number">1</span>][j] + obstacleGrid[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.uniquePathsWithObstacles([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="minimum-path-sum"><a href="#minimum-path-sum" class="headerlink" title="minimum-path-sum"></a>minimum-path-sum</h2><p>解题思路：</p>
<ol>
<li>将Grid二维数组自身进行修改，使其存储当前元素到最右下角元素的路径值</li>
<li>从数组右下角元素开始遍历</li>
<li>最后一行的元素，路径等于自身加右侧的权值</li>
<li>除最后一行，其他行的最后一列，路径等于同列的下一行的权值加自身值</li>
<li>其他元素的路径，等于自身加上右侧权值与下侧路径的较小值</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/8 00:12</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 64_minimum-path-sum.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/minimum-path-sum/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        row_len = <span class="built_in">len</span>(grid)</span><br><span class="line">        col_len = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(row_len-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(col_len-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 1.最后一行的元素，路径等于自身加右侧的权值</span></span><br><span class="line">                <span class="keyword">if</span> row == row_len-<span class="number">1</span> <span class="keyword">and</span> col != col_len-<span class="number">1</span>:</span><br><span class="line">                    grid[row][col] += grid[row][col+<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 2. 除最后一行，其他行的最后一列，路径等于同列的下一行的权值加自身值</span></span><br><span class="line">                <span class="keyword">elif</span> row != row_len-<span class="number">1</span> <span class="keyword">and</span> col == col_len-<span class="number">1</span>:</span><br><span class="line">                    grid[row][col] += grid[row+<span class="number">1</span>][col]</span><br><span class="line">                <span class="comment"># 3. 其他元素的路径，等于自身加上右侧权值与下侧路径的较小值</span></span><br><span class="line">                <span class="keyword">elif</span> row != row_len-<span class="number">1</span> <span class="keyword">and</span> col != col_len-<span class="number">1</span>:</span><br><span class="line">                    grid[row][col] += <span class="built_in">min</span>(grid[row+<span class="number">1</span>][col], grid[row][col+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.minPathSum([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="climbing-stairs"><a href="#climbing-stairs" class="headerlink" title="climbing-stairs"></a>climbing-stairs</h2><p><code>dp</code>用于存储到达每个台阶的方法总数。</p>
<p>则到达第n阶，有<code>dp[i-1]+dp[i-2]</code>种方法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/11 12:09</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 70_climbing-stairs.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/climbing-stairs/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.climbStairs(<span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="climbing-stairsII"><a href="#climbing-stairsII" class="headerlink" title="climbing-stairsII"></a>climbing-stairsII</h2><p>f(n)=f(n-1)+f(n-2)+……f(1)<br>f(n-1)=f(n-2)+……f(1)<br>得f(n)=2f(n-1)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/26 12:35 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: jumpFloorII.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, number+<span class="number">1</span>):</span><br><span class="line">            n = <span class="number">2</span> * n</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></tbody></table></figure>
<h2 id="edit-distance"><a href="#edit-distance" class="headerlink" title="edit-distance"></a>edit-distance</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/16 12:03 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 72_edit-distance.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/edit-distance/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n1 = <span class="built_in">len</span>(word1)</span><br><span class="line">        n2 = <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 第一行，进行初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 第一列，进行初始化</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            dp[j][<span class="number">0</span>] = dp[j - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.minDistance(word1=<span class="string">"horse"</span>, word2=<span class="string">"ros"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="decode-ways"><a href="#decode-ways" class="headerlink" title="decode-ways"></a>decode-ways</h2><p><a href="https://leetcode-cn.com/problems/decode-ways/solution/dong-tai-gui-hua-cong-jian-dan-de-pa-lou-ti-wen-ti/">解题思路</a></p>
<p>dp[i+1]：代表s[0:i]的译码方式总数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/5 22:40</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 91_decode-ways.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/decode-ways/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">"0"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span> <span class="keyword">if</span> s[<span class="number">0</span>] != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>  <span class="comment"># dp[i] -&gt; s[i-1]</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">"0"</span>:</span><br><span class="line">                dp[i+<span class="number">1</span>] += dp[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"10"</span> &lt;= s[i-<span class="number">1</span>:i+<span class="number">1</span>] &lt;= <span class="string">"26"</span>:</span><br><span class="line">                dp[i+<span class="number">1</span>] += dp[i-<span class="number">2</span>]</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.numDecodings(<span class="string">"226"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interleaving-string"><a href="#interleaving-string" class="headerlink" title="interleaving-string"></a>interleaving-string</h2><p><code>dp[i][j]</code>代表s1[:i]与s2[:j]能否构成s3[:i+j]</p>
<p><a href="https://leetcode-cn.com/problems/interleaving-string/solution/dong-tai-gui-hua-zhu-xing-jie-shi-python3-by-zhu-3/">参考链接</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/12 21:47 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 97_interleaving-string.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/interleaving-string/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span>, s3: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        len_s1 = <span class="built_in">len</span>(s1)</span><br><span class="line">        len_s2 = <span class="built_in">len</span>(s2)</span><br><span class="line">        len_s3 = <span class="built_in">len</span>(s3)</span><br><span class="line">        <span class="keyword">if</span> len_s1 + len_s2 != len_s3:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(len_s2+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(len_s1+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len_s2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="literal">True</span> <span class="keyword">if</span> s3[j-<span class="number">1</span>] == s2[j-<span class="number">1</span>] <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len_s1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">True</span> <span class="keyword">if</span> s3[i-<span class="number">1</span>] == s1[i-<span class="number">1</span>] <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len_s1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len_s2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[i-<span class="number">1</span>][j] <span class="keyword">and</span> s1[i-<span class="number">1</span>] == s3[i+j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j-<span class="number">1</span>] <span class="keyword">and</span> s2[j-<span class="number">1</span>] == s3[i+j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isInterleave(s1=<span class="string">"aabcc"</span>, s2=<span class="string">"dbbca"</span>, s3=<span class="string">"aadbbcbcac"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="split-array-with-equal-sum"><a href="#split-array-with-equal-sum" class="headerlink" title="split-array-with-equal-sum"></a>split-array-with-equal-sum</h2><p><a href="https://leetcode-cn.com/problems/split-array-with-equal-sum/solution/jiang-shu-zu-fen-ge-cheng-he-xiang-deng-de-zi-shu-/">参考链接</a></p>
<p>这道题确定i,j,k的取值范围是关键。</p>
<p>通过j去约定i和k的范围，可以减少复杂度。</p>
<p><img data-src="/images/algorithm/split-array-with-equal-sum.png" alt="split-array-with-equal-sum"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/13 12:33 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 548_split-array-with-equal-sum.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/split-array-with-equal-sum/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> len_nums &lt; <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        sum_list = <span class="built_in">list</span>()</span><br><span class="line">        sum_list.append(nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len_nums):</span><br><span class="line">            sum_list.append(sum_list[i - <span class="number">1</span>] + nums[i])</span><br><span class="line">        <span class="comment"># 用中间的j去约定i与k的范围</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, len_nums - <span class="number">3</span>):</span><br><span class="line">            sum_set = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, j - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> sum_list[i - <span class="number">1</span>] == sum_list[j - <span class="number">1</span>] - sum_list[i]:</span><br><span class="line">                    sum_set.add(sum_list[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j + <span class="number">2</span>, len_nums - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> sum_list[-<span class="number">1</span>] - sum_list[k] == sum_list[k - <span class="number">1</span>] - sum_list[j] \</span><br><span class="line">                        <span class="keyword">and</span> (sum_list[k - <span class="number">1</span>] - sum_list[j]) <span class="keyword">in</span> sum_set:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.splitArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-33"><a href="#interview-33" class="headerlink" title="interview_33"></a>interview_33</h2><p><a href="https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/">解题思路</a></p>
<blockquote>
<p>丑数的递推性质： 丑数只包含因子 2, 3, 5。因此有 “丑数 == 某较小丑数 × 某因子” （例如：10 = 5 ×2）</p>
</blockquote>
<p><img data-src="/images/algorithm/interview_33.png" alt="interview_33"></p>
<p>指针a,b,c分别代表<code>*2、*3、*5</code>的三个指针，它们指向的丑数一旦完成计算，则继续指向下一个丑数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/3 10:21</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_33.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/chou-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp, a, b, c = [<span class="number">1</span>] * n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 从三个倍数中选一个最小的</span></span><br><span class="line">            min_ugly = <span class="built_in">min</span>(dp[a] * <span class="number">2</span>, dp[b] * <span class="number">3</span>, dp[c] * <span class="number">5</span>)</span><br><span class="line">            dp[i] = min_ugly</span><br><span class="line">            <span class="keyword">if</span> min_ugly == dp[a] * <span class="number">2</span>:</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_ugly == dp[b] * <span class="number">3</span>:</span><br><span class="line">                b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_ugly == dp[c] * <span class="number">5</span>:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.nthUglyNumber(<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-7"><a href="#interview-7" class="headerlink" title="interview_7"></a>interview_7</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 11:36 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_7.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, N: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        f_dict = {<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>}</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, N):</span><br><span class="line">            f_dict[i] = f_dict[i - <span class="number">1</span>] + f_dict[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> f_dict[N - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.fib(<span class="number">4</span>))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-8"><a href="#interview-8" class="headerlink" title="interview_8"></a>interview_8</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 11:38</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_8.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        dp = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.climbStairs(<span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-9"><a href="#interview-9" class="headerlink" title="interview_9"></a>interview_9</h2><p>用<code>f(n)</code>表示青蛙跳上n阶台阶的跳法数，设定<code>f(0) = 1</code>;</p>
<p>当<code>n = 1</code> 时，只有一种跳的方式，一阶跳，<code>f(1) = 1</code></p>
<p>当<code>n = 2</code> 时，有两种跳的方式，一阶跳和两阶跳，<code>f(2) = f(1) + f(0) = 2</code></p>
<p>当<code>n = 3</code> 时，有三种跳的方式，第一次跳出一阶后，后面还有<code>f(3-1)</code>中跳法； 第一次跳出二阶后，后面还有<code>f(3-2)</code>中跳法；第一次跳出三阶后，后面还有<code>f(3-3)</code>种跳法，<code>f(3) = f(2) + f(1) + f(0) = 4</code></p>
<p>当n = n 时，第一次跳出一阶后，后面还有<code>f(n-1)</code>中跳法； 第一次跳出二阶后，后面还有<code>f(n-2)</code>中跳法……第一次跳出n阶后，后面还有<code>f(n-n)</code>中跳法，即</p>
<p><code>f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-n) = f(0) + f(1) + f(2) + ... + f(n-1)</code></p>
<p>又因为<code>f(n-1) = f(0) + f(2) + f(3) + ... + f(n-2)</code></p>
<p>两式相减得：<code>f(n) = 2 * f(n-1)  ( n &gt;= 2)</code></p>
<p>​              | 0，n = 0</p>
<p>f(n)  =    | 1, n = 1</p>
<p>​              | 2 * f(n-1) , n &gt;= 2</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/26 12:35</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_9.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">            n = <span class="number">2</span> * n</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-67"><a href="#interview-67" class="headerlink" title="interview_67"></a>interview_67</h2><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/xiang-jie-bao-li-di-gui-ji-yi-hua-ji-zhu-dong-tai-/">参考链接</a></p>
<p>方法一：暴力递归</p>
<ul>
<li>时间复杂度：$O(2^N)$。</li>
<li>空间复杂度：$O(2^N)$。</li>
</ul>
<p>设 <strong>F(n)</strong>为长度为 n 的绳子可以得到的最大乘积，对于每一个 F(n)，<strong>注意到我们每次将一段绳子剪成两段时，剩下的部分可以继续剪，也可以不剪</strong>。这就得到了递归函数：</p>
<blockquote>
<p>F(n) = max( i * ( n-i ) , i * F( n-1) ), i=1,2,…,n−2</p>
</blockquote>
<p><img data-src="/images/algorithm/interview_67.png" alt="递归树"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:59</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_67.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/jian-sheng-zi-lcof/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        result = -<span class="number">1</span> </span><br><span class="line">        <span class="comment"># 1 * F(n-1)、2 * F(n-2).....、i * F(n - i)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 剪或不剪</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, <span class="built_in">max</span>(i * (n-i), i * memorize(n - i)))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure>
<p>方法二：记忆化技术（自顶向下）</p>
<p><strong>暴力法超时的原因是因为重复计算了F(N）</strong>，为了避免重复计算可以使用 记忆化（memoization） 技术。</p>
<p>记忆化技术的代码中经常需要建立函数 <code>memoize</code> 辅助实现。我们使用数组 <code>f</code> 来保存长度为 <code>i</code>时的最大长度 <code>f[i]</code>，最后返回 <code>f[n]</code>即可。</p>
<p>由于利用数组保存了中间结果，所以可以将空间复杂度降低至$O(N)$</p>
<ul>
<li>时间复杂度：$O(2^N)$。</li>
<li>空间复杂度：$O(N)$。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:59</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_67.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/jian-sheng-zi-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">memorize</span>(<span class="params">n</span>):</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> fn[n] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> fn[n]</span><br><span class="line"></span><br><span class="line">            result = -<span class="number">1</span></span><br><span class="line">            <span class="comment"># 1 * F(n-1)、2 * F(n-2).....、i * F(n - i)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 剪或不剪</span></span><br><span class="line">                result = <span class="built_in">max</span>(result, <span class="built_in">max</span>(i * (n-i), i * memorize(n - i)))</span><br><span class="line">            fn[n] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        fn = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]  <span class="comment"># 用于计算已计算过的函数变量</span></span><br><span class="line">        <span class="keyword">return</span> memorize(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.cuttingRope(<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>方法三：记忆化技术（自底向上）<strong>(推荐贪心法：简洁易懂)</strong></p>
<p><img data-src="/images/algorithm/interview_67_1.png" alt="自底向上"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:59</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_67.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/jian-sheng-zi-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]  <span class="comment"># 用于计算已计算过的函数变量</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 遍历dp: 即F(n)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">           	<span class="comment"># 求解loop，求每个F(n)的解</span></span><br><span class="line">            <span class="comment"># j代表在i长的绳子上要怎么剪，j==0or==i都代表不需要剪</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>((i - j) * j, dp[i - j] * j))</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.cuttingRope(<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h1><h2 id="jump-game-ii"><a href="#jump-game-ii" class="headerlink" title="jump-game-ii"></a>jump-game-ii</h2><p>本题使用贪心算法求解，寻找<strong>局部最优解</strong>。</p>
<ul>
<li>即在可跳范围内选择能跳的最远的位置</li>
<li>当前位置在“2”，可跳位置为“3”，“1”，其中可跳的最远的位置为“3”，则选择“3”</li>
<li>当前位置在“3”，可跳位置为“1”、“1”、“4”，其中可跳的最远的位置为“4”，则选择“4”</li>
<li>跳跃结束，step为2</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>步数</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Step1</td>
<td>2（当前位置）</td>
<td>*3</td>
<td>*1</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>Step1</td>
<td>2</td>
<td>3（当前位置）</td>
<td>*1</td>
<td>*1</td>
<td>*4</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/17 09:45</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 45_jump-game-ii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/jump-game-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        max_position = <span class="number">0</span>  <span class="comment"># 记录局部可跳跃的最大值</span></span><br><span class="line">        end = <span class="number">0</span>  <span class="comment"># 记录每次跳跃的最大值的下标</span></span><br><span class="line">        step = <span class="number">0</span>  <span class="comment"># 记录跳跃的步数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 寻找局部最优解</span></span><br><span class="line">            max_position = <span class="built_in">max</span>(max_position, nums[i] + i)</span><br><span class="line">            <span class="keyword">if</span> i == end:</span><br><span class="line">                end = max_position</span><br><span class="line">                step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.jump([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="maximum-subarray-1"><a href="#maximum-subarray-1" class="headerlink" title="maximum-subarray"></a>maximum-subarray</h2><ul>
<li>解法1:贪心算法</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/25 09:52</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 53_maximum-subarray.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/maximum-subarray/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray_GA</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">        current_sum = max_sum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len_nums):</span><br><span class="line">          	<span class="comment"># 寻找局部最优解</span></span><br><span class="line">            current_sum = <span class="built_in">max</span>(nums[i], current_sum + nums[i])</span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, current_sum)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.maxSubArray([-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>解法2:动态规划</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray_DP</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">    len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">    max_sum = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len_nums):</span><br><span class="line">        <span class="keyword">if</span> nums[i-<span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">            nums[i] += nums[i-<span class="number">1</span>]</span><br><span class="line">        max_sum = <span class="built_in">max</span>(max_sum, nums[i])</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-30"><a href="#interview-30" class="headerlink" title="interview_30"></a>interview_30</h2><p>此题同<a href="https://unknown.yuzhouwan.com/posts/55663/#maximum_subarray">maximum_subarray</a></p>
<p><img data-src="/images/algorithm/interview_30.png" alt="interview_30"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/30 14:52 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_30.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;</span></span><br><span class="line"><span class="comment"># qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_number = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] += <span class="built_in">max</span>(nums[i-<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">            max_number = <span class="built_in">max</span>(max_number, nums[i])</span><br><span class="line">        <span class="keyword">return</span> max_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.maxSubArray([-<span class="number">2</span>, <span class="number">1</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">5</span>, <span class="number">4</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="merge-intervals"><a href="#merge-intervals" class="headerlink" title="merge-intervals"></a>merge-intervals</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/28 11:49</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 56_merge-intervals.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/merge-intervals/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        seq = <span class="built_in">sorted</span>(intervals)  <span class="comment"># 先按照seq[0]排序，若seq[0]一样，则按照seq[1]排序</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(seq):</span><br><span class="line">            <span class="keyword">if</span> seq[i-<span class="number">1</span>][<span class="number">0</span>] &lt;= seq[i][<span class="number">0</span>] &lt;= seq[i-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> seq[i][<span class="number">1</span>] &gt; seq[i-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                    seq[i-<span class="number">1</span>][<span class="number">1</span>] = seq[i][<span class="number">1</span>]</span><br><span class="line">                seq.remove(seq[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.merge([[<span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">6</span>], [<span class="number">1</span>, <span class="number">80</span>], [<span class="number">15</span>, <span class="number">7</span>]]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="insert-interval"><a href="#insert-interval" class="headerlink" title="insert-interval"></a>insert-interval</h2><p><a href="https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode/">参考链接</a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/29 11:45</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 57_insert-interval.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/insert-interval/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, intervals: <span class="string">'List[Interval]'</span>, newInterval: <span class="string">'Interval'</span></span>) -&gt; 'List[Interval]':</span></span><br><span class="line">        start, end = newInterval</span><br><span class="line">        current, n = <span class="number">0</span>, <span class="built_in">len</span>(intervals)</span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将newInterval之前的序列直接添加到output中</span></span><br><span class="line">        <span class="keyword">while</span> current &lt; n <span class="keyword">and</span> intervals[current][<span class="number">0</span>] &lt; start:</span><br><span class="line">            output.append(intervals[current])</span><br><span class="line">            current += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加newInterval到output中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> output <span class="keyword">and</span> output[-<span class="number">1</span>][<span class="number">1</span>] &lt; start:</span><br><span class="line">            output.append(newInterval)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(end, output[-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加剩余的interval</span></span><br><span class="line">        <span class="keyword">while</span> current &lt; n:</span><br><span class="line">            <span class="keyword">if</span> output[-<span class="number">1</span>][<span class="number">1</span>] &lt; intervals[current][<span class="number">0</span>]:</span><br><span class="line">                output.append(intervals[current])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(intervals[current][<span class="number">1</span>], output[-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            current += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.insert([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">10</span>], [<span class="number">12</span>, <span class="number">16</span>]], [<span class="number">4</span>, <span class="number">8</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="queue-reconstruction-by-height"><a href="#queue-reconstruction-by-height" class="headerlink" title="queue-reconstruction-by-height"></a>queue-reconstruction-by-height</h2><p>这道题的关键思想是官网所说的：<strong>“因为个子矮的人相对于个子高的人是 “看不见” 的，所以可以先安排个子高的人。”</strong></p>
<p>即，先按照身高对每个人进行排序，然后再根据个子矮的人所对应的索引，插入到个子高的人中，因为个子矮的人相对于个子高的人是 <strong>“看不见”</strong> 的，所以插入过程中并不会影响前面已经排好序的个子高的人。</p>
<p>过程如下：具体<a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/">解题思路</a>见官网。</p>
<ul>
<li>排序：<ul>
<li>按高度降序排列。</li>
<li>在同一高度的人中，按 <code>k</code> 值的升序排列。</li>
</ul>
</li>
<li>逐个地把它们放在输出队列中，索引等于它们的 <code>k</code> 值。</li>
<li>返回输出队列</li>
</ul>
<p><img data-src="/images/algorithm/queue-reconstruction-by-height.png" alt="queue-reconstruction-by-height"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/14 19:37 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 406_queue-reconstruction-by-height.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/queue-reconstruction-by-height/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span>(<span class="params">self, people: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># 按照x[0]的逆序（所以为-x[0]），x[1]的正序进行排序</span></span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]), reverse=<span class="literal">False</span>)</span><br><span class="line">        out_put_people = []</span><br><span class="line">        <span class="comment"># 根据索引，依次做插入操作</span></span><br><span class="line">        <span class="keyword">for</span> person <span class="keyword">in</span> people:</span><br><span class="line">            out_put_people.insert(person[<span class="number">1</span>], person)</span><br><span class="line">        <span class="keyword">return</span> out_put_people</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reconstructQueue([[<span class="number">7</span>, <span class="number">0</span>], [<span class="number">4</span>, <span class="number">4</span>], [<span class="number">7</span>, <span class="number">1</span>], [<span class="number">5</span>, <span class="number">2</span>], [<span class="number">6</span>, <span class="number">1</span>], [<span class="number">5</span>, <span class="number">0</span>]]))</span><br><span class="line"><span class="comment"># out_put : [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="remove-duplicate-letters"><a href="#remove-duplicate-letters" class="headerlink" title="remove-duplicate-letters"></a>remove-duplicate-letters</h2><p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/solution/zhan-by-liweiwei1419/">参考链接</a></p>
<p><img data-src="/images/algorithm/remove-duplicate-letters.png" alt="remove-duplicate-letters"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/17 23:06 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 316_remove-duplicate-letters.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/remove-duplicate-letters/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        stack = []</span><br><span class="line">        value_in_stack = <span class="built_in">set</span>()</span><br><span class="line">        last_occurance = {k:i <span class="keyword">for</span> i, k <span class="keyword">in</span> <span class="built_in">enumerate</span>(s)}</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> value_in_stack:</span><br><span class="line">                <span class="comment"># stack[-1] &gt; c:如果栈顶元素的字典序大于当前的c</span></span><br><span class="line">                <span class="comment"># last_occurance[stack[-1]] &gt; i：且栈顶元素还会在后续s中出现</span></span><br><span class="line">                <span class="comment"># 则将栈顶元素弹出，并压入当前元素</span></span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] &gt; c <span class="keyword">and</span> last_occurance[stack[-<span class="number">1</span>]] &gt; i:</span><br><span class="line">                    value_in_stack.discard(stack.pop())</span><br><span class="line">                stack.append(c)</span><br><span class="line">                value_in_stack.add(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.removeDuplicateLetters(<span class="string">"cbacdcbc"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>在合并两个数组或者字符串时，如果从前往后复制每个数字（或者字符）需要重复移动数字（或字符）多次，则可以考虑从后往前复制，就能减少移动的次数。</p>
<h2 id="3-length-of-longest-substring"><a href="#3-length-of-longest-substring" class="headerlink" title="3_length_of_longest_substring"></a>3_length_of_longest_substring</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2019/10/8 8:17 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File:  3_length_of_longest_substring.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthoflongestsubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        tem_length = <span class="number">0</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        s_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> s_set:</span><br><span class="line">                s_set.remove(s[i])</span><br><span class="line">                tem_length = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s_set.add(s[i])</span><br><span class="line">                tem_length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> tem_length &gt; max_length:</span><br><span class="line">                max_length = tem_length</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    so = Solution()</span><br><span class="line">    test_list = <span class="string">"pwdflkkkpwdsadf"</span></span><br><span class="line">    start = timeit.default_timer()</span><br><span class="line">    print(so.lengthoflongestsubstring(test_list))</span><br><span class="line">    end = timeit.default_timer()</span><br><span class="line">    print(<span class="built_in">str</span>((end - start) * <span class="number">1000</span>), <span class="string">"s"</span>)  <span class="comment"># s0.034690000006776245 s</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="valid-number-1"><a href="#valid-number-1" class="headerlink" title="valid-number"></a>valid-number</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/8 00:41</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 65_valid-number.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/valid-number/</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># return bool(re.match(r' *[+-]?([0-9]+(\.[0-9]*)?|\.[0-9]+)(e[+-]?[0-9]+)? *$', s))</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="comment"># 去除s两边的空白符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 去除"+"、"-"</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">"+"</span>, <span class="string">"-"</span>]:</span><br><span class="line">            s = s[<span class="number">1</span>:]</span><br><span class="line">        <span class="comment"># 判断是否含有e</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"e"</span> <span class="keyword">in</span> s:</span><br><span class="line">            s_list = s.split(<span class="string">"e"</span>)</span><br><span class="line">            <span class="comment"># 说明有两个e</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s_list) &gt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 去掉e前面的"."</span></span><br><span class="line">            s_list[<span class="number">0</span>] = s_list[<span class="number">0</span>].replace(<span class="string">"."</span>, <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 去掉e后面的"+、"-"</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s_list[<span class="number">1</span>]) &gt; <span class="number">0</span> <span class="keyword">and</span> s_list[<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">"+"</span>, <span class="string">"-"</span>]:</span><br><span class="line">                s_list[<span class="number">1</span>] = s_list[<span class="number">1</span>].replace(s_list[<span class="number">1</span>][<span class="number">0</span>], <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 判断是否为数字</span></span><br><span class="line">            <span class="keyword">if</span> s_list[<span class="number">0</span>].isnumeric() <span class="keyword">and</span> s_list[<span class="number">1</span>].isnumeric():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = s.replace(<span class="string">"."</span>, <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> s.isnumeric():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isNumber(<span class="string">"53.5e93"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="text-justification"><a href="#text-justification" class="headerlink" title="text-justification"></a>text-justification</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/9 19:20</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 68_text-justification.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/text-justification/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span>(<span class="params">self, words: List[<span class="built_in">str</span>], maxWidth: <span class="built_in">int</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        current_chars_number = <span class="number">0</span>  <span class="comment"># 当前行存储的字符个数(不包括空格)</span></span><br><span class="line">        current_words_number = <span class="number">0</span>  <span class="comment"># 当前行存储的单词个数，用于统计</span></span><br><span class="line">        word_list = []  <span class="comment"># 当前行的单词列表</span></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(words):</span><br><span class="line">            current_word_length = <span class="built_in">len</span>(value)</span><br><span class="line">            <span class="comment"># 当前字符数量大于最大限制</span></span><br><span class="line">            <span class="keyword">if</span> current_chars_number + current_word_length + current_words_number &gt; maxWidth:</span><br><span class="line">                <span class="keyword">if</span> current_words_number == <span class="number">1</span>:</span><br><span class="line">                    result.append(word_list[<span class="number">0</span>] + <span class="string">" "</span> * (maxWidth - current_chars_number))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    blank_space_number = maxWidth - current_chars_number  <span class="comment"># 当前的空格数量</span></span><br><span class="line">                    <span class="keyword">if</span> blank_space_number % (current_words_number - <span class="number">1</span>) == <span class="number">0</span>:  <span class="comment"># 空格可以平均分配</span></span><br><span class="line">                        result.append((<span class="string">" "</span>* (blank_space_number // (current_words_number - <span class="number">1</span>))).join(word_list))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 空格不能平均分配</span></span><br><span class="line">                        more_blankspace = blank_space_number % (current_words_number - <span class="number">1</span>)  <span class="comment"># 多余的空格</span></span><br><span class="line">                        stand_blankspace = blank_space_number // (current_words_number - <span class="number">1</span>)  <span class="comment"># 标准的最少空格</span></span><br><span class="line">                        res = word_list[<span class="number">0</span>]</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(more_blankspace):</span><br><span class="line">                            res += <span class="string">" "</span> * (stand_blankspace+<span class="number">1</span>) + word_list[i+<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(more_blankspace+<span class="number">1</span>, <span class="built_in">len</span>(word_list)):</span><br><span class="line">                            res += <span class="string">" "</span> * stand_blankspace + word_list[i]</span><br><span class="line">                        result.append(res)</span><br><span class="line">                current_chars_number = current_word_length</span><br><span class="line">                current_words_number = <span class="number">1</span></span><br><span class="line">                word_list = [value]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current_chars_number += current_word_length</span><br><span class="line">                current_words_number += <span class="number">1</span></span><br><span class="line">                word_list.append(value)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.fullJustify([<span class="string">"This"</span>, <span class="string">"is"</span>, <span class="string">"an"</span>, <span class="string">"example"</span>, <span class="string">"of"</span>, <span class="string">"text"</span>, <span class="string">"justification."</span>], <span class="number">16</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="simplify-path"><a href="#simplify-path" class="headerlink" title="simplify-path"></a>simplify-path</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/12 12:01</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 71_simplify-path.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/simplify-path/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span>(<span class="params">self, path: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        result_list = []</span><br><span class="line">        path = path.split(<span class="string">"/"</span>)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> path:</span><br><span class="line">            <span class="keyword">if</span> value == <span class="string">".."</span>:</span><br><span class="line">                <span class="keyword">if</span> result_list:</span><br><span class="line">                    result_list.pop()</span><br><span class="line">            <span class="keyword">elif</span> value <span class="keyword">and</span> value != <span class="string">"."</span>:</span><br><span class="line">                result_list.append(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/"</span> + <span class="string">"/"</span>.join(result_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.simplifyPath(<span class="string">"/a/./b/../../c/"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Interview-2"><a href="#Interview-2" class="headerlink" title="Interview_2"></a>Interview_2</h2><ul>
<li>方法一：时间复杂度<code>O(n)</code>,空间复杂度<code>O(1)</code></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/8 22:38 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_2.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">" "</span>, <span class="string">"%20"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.replaceSpace(<span class="string">"We are happy."</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>方法二:时间复杂度<code>O(n)</code>,空间复杂度<code>O(n)</code></li>
</ul>
<p>这里用list而不是str直接处理的原因是。str是不可变数据类型，也就是说每在一个str后面加了一个字符，都是新的str。这样导致空间开销太大。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/8 22:38 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_2.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        s_list = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> s_value <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> s_value == <span class="string">" "</span>:</span><br><span class="line">                s_list.append(<span class="string">"%20"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s_list.append(s_value)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(s_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.replaceSpace(<span class="string">"We are happy."</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-43"><a href="#interview-43" class="headerlink" title="interview_43"></a>interview_43</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/23 18:33 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_43.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span>(<span class="params">self, s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        len_s = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n &gt;= len_s <span class="keyword">or</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">return</span> s[n:] + s[:n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reverseLeftWords(<span class="string">"abcdefg"</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-44"><a href="#interview-44" class="headerlink" title="interview_44"></a>interview_44</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/24 15:15 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_44.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        s_rotate = s.split()</span><br><span class="line">        <span class="comment"># " "的情况，直接返回s</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s_rotate) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(s_rotate[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reverseWords(<span class="string">"abc bvc nbm"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-45"><a href="#interview-45" class="headerlink" title="interview_45"></a>interview_45</h2><p>先对数组执行排序</p>
<ul>
<li>判别重复： 排序数组中的相同元素位置相邻，因此可通过遍历数组，判断 nums[i] = nums[i + 1]是否成立来判重。</li>
<li>获取最大 / 最小的牌： 排序后，数组末位元素 nums[4] 为最大牌；元素 nums[joker]为最小牌，其中 joker为大小王的数量。</li>
</ul>
<p><img data-src="/images/algorithm/interview_45.png" alt="interview_45"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/24 15:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_45.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isStraight</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        joker = <span class="number">0</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                joker += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[joker] &lt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isStraight([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h1><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><div class="table-container">
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最差时间复杂度</th>
<th>额外空间复杂度</th>
<th>稳定性</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>$o(n^2)$</td>
<td>$o(n^2)$</td>
<td>$o(1)$</td>
<td>稳定</td>
<td>n小时效果好</td>
</tr>
<tr>
<td>选择排序</td>
<td>$o(n^2)$</td>
<td>$o(n^2)$</td>
<td>$o(1)$</td>
<td>不稳定</td>
<td>n小时效果好</td>
</tr>
<tr>
<td>交换排序</td>
<td>$o(n^2)$</td>
<td>$o(n^2)$</td>
<td>$o(1)$</td>
<td>不稳定</td>
<td>n小时效果好</td>
</tr>
<tr>
<td>插入排序</td>
<td>$o(n^2)$</td>
<td>$o(n^2)$</td>
<td>$o(1)$</td>
<td>稳定</td>
<td>n小时效果好</td>
</tr>
<tr>
<td>快速排序</td>
<td>$o(nlogn)$</td>
<td>$o(n^2)$</td>
<td>$o(nlogn)-o(n)$</td>
<td>不稳定</td>
<td>n大时效果好</td>
</tr>
<tr>
<td>归并排序</td>
<td>$o(nlogn)$</td>
<td>$o(nlogn)$</td>
<td>$o(n)$</td>
<td>稳定</td>
<td>n大时效果好</td>
</tr>
<tr>
<td>堆排序</td>
<td>$o(nlogn)$</td>
<td>$o(nlogn)$</td>
<td>$o(1)$</td>
<td>不稳定</td>
<td>n大时效果好</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$o(nlogn)$</td>
<td>$o(n^s)$ 1&lt;s&lt;2</td>
<td>$o(1)$</td>
<td>不稳定</td>
<td>s是所选分组</td>
</tr>
<tr>
<td>基数排序</td>
<td>$o(log_RB)($线性复杂度)</td>
<td>$o(log_RB)$</td>
<td>$o(n)$</td>
<td>稳定</td>
<td>B是真数(0-9)，R是基数(个十百)</td>
</tr>
<tr>
<td>计数排序</td>
<td>$o(n)$</td>
<td>$o(nlogn)$</td>
<td></td>
<td>稳定</td>
<td>0</td>
</tr>
<tr>
<td>划分排序</td>
<td>$o(n)$</td>
<td>0</td>
<td>0</td>
<td>稳定</td>
<td>0</td>
</tr>
<tr>
<td>桶排序</td>
<td>$o(n)$</td>
<td>0</td>
<td>0</td>
<td>稳定</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p><a href="https://leetcode-cn.com/problems/sort-an-array/solution/python-shi-xian-de-shi-da-jing-dian-pai-xu-suan-fa/">https://leetcode-cn.com/problems/sort-an-array/solution/python-shi-xian-de-shi-da-jing-dian-pai-xu-suan-fa/</a></p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p>
<p><strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p>
<p><strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p>
<p><strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergesort</span>(<span class="params">seq</span>):</span></span><br><span class="line">    <span class="string">"""归并排序"""</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(seq) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> seq</span><br><span class="line">    mid = <span class="built_in">len</span>(seq) / <span class="number">2</span>  <span class="comment"># 将列表分成更小的两个列表</span></span><br><span class="line">    <span class="comment"># 分别对左右两个列表进行处理，分别返回两个排序好的列表</span></span><br><span class="line">    left = mergesort(seq[:mid])</span><br><span class="line">    right = mergesort(seq[mid:])</span><br><span class="line">    <span class="comment"># 对排序好的两个列表合并，产生一个新的排序好的列表</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    <span class="string">"""合并两个已排序好的列表，产生一个新的已排序好的列表"""</span></span><br><span class="line">    result = []  <span class="comment"># 新的已排序好的列表</span></span><br><span class="line">    i = <span class="number">0</span>  <span class="comment"># 下标</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 对两个列表中的元素 两两对比。</span></span><br><span class="line">    <span class="comment"># 将最小的元素，放到result中，并对当前列表下标加1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    result += left[i:]</span><br><span class="line">    result += right[j:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">seq = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">'排序前：'</span>,seq</span><br><span class="line">result = mergesort(seq)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="largest-number"><a href="#largest-number" class="headerlink" title="largest-number"></a>largest-number</h2><p>自定义排序</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/23 21:18</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 179_largest-number.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/largest-number/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargerNumKey</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x + y &lt; y + x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        return_value = <span class="string">""</span>.join(<span class="built_in">sorted</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, nums), key=LargerNumKey, reverse=<span class="literal">True</span>)).lstrip(<span class="string">"0"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span> <span class="keyword">if</span> return_value[<span class="number">0</span>] == <span class="string">"0"</span> <span class="keyword">else</span> return_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.largestNumber([<span class="number">3</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">9</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-32"><a href="#interview-32" class="headerlink" title="interview_32"></a>interview_32</h2><p>同上一题：largest-number，这题不加任何技巧。<strong>类似于冒泡排序。</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/2 11:54 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_32.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] = <span class="built_in">str</span>(nums[i])</span><br><span class="line">        <span class="comment"># 冒泡排序：每次把最小的元素放在第一位</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j]) &gt; (nums[j] + nums[i]):</span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.minNumber([<span class="number">3</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">9</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Top-K-Sort"><a href="#Top-K-Sort" class="headerlink" title="Top-K Sort"></a>Top-K Sort</h2><h3 id="kth-largest-element-in-an-array"><a href="#kth-largest-element-in-an-array" class="headerlink" title="kth-largest-element-in-an-array"></a>kth-largest-element-in-an-array</h3><p>堆排序</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/25 12:43</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 215_kth-largest-element-in-an-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, nums)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findKthLargest([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>], <span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="interview-29"><a href="#interview-29" class="headerlink" title="interview_29"></a>interview_29</h3><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/tu-jie-top-k-wen-ti-de-liang-chong-jie-fa-you-lie-/">解题思路</a></p>
<ol>
<li>方法一：堆排序</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/29 16:40 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_29.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?</span></span><br><span class="line"><span class="comment"># tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, arr: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        len_tinput = <span class="built_in">len</span>(tinput)</span><br><span class="line">        <span class="keyword">if</span> k &gt; len_tinput:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> heapq.nsmallest(k, arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findKthLargest([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>], <span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>方法2：利用快速排序思想</li>
</ol>
<p><img data-src="/images/algorithm/interview_29.png" alt="interview_29"></p>
<p>这个 partition 操作是原地进行的，需要 O(n)的时间，接下来，快速排序会递归地排序左右两侧的数组。而快速选择（quick select）算法的不同之处在于，接下来只需要递归地选择一侧的数组。快速选择算法想当于一个“不完全”的快速排序，因为我们只需要知道最小的 k 个数是哪些，并不需要知道它们的顺序。</p>
<p>我们的目的是寻找最小的 k 个数。假设经过一次 partition 操作，枢纽元素位于下标 m，也就是说，左侧的数组有 m 个元素，是原数组中最小的 m 个数。那么：</p>
<ul>
<li>若 k = m，我们就找到了最小的 k 个数，就是左侧的数组；</li>
<li>若 k &lt; m ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li>
<li>若 k &gt; m，则左侧数组中的 m 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k-m 个数，对右侧数组递归地 partition 即可。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/29 16:40</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_29.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?</span></span><br><span class="line"><span class="comment"># tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span>(<span class="params">self, arr: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> k &gt; <span class="built_in">len</span>(arr):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">        pivot = self.quicksort(arr, start, end)</span><br><span class="line">        <span class="keyword">while</span> pivot != k - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> pivot &gt; k - <span class="number">1</span>:</span><br><span class="line">                end = pivot - <span class="number">1</span></span><br><span class="line">                pivot = self.quicksort(arr, start, end)</span><br><span class="line">            <span class="keyword">if</span> pivot &lt; k - <span class="number">1</span>:</span><br><span class="line">                start = pivot + <span class="number">1</span></span><br><span class="line">                pivot = self.quicksort(arr, start, end)</span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params">self, arr, left, right</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        简单版快速排序</span></span><br><span class="line"><span class="string">        返回一个坐标，坐标左侧都小于返回值，右侧都大于返回值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = left</span><br><span class="line">        j = right</span><br><span class="line">        temp = arr[left]</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="comment"># 从右侧搜索小元素，并进行交换</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt;= temp:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            arr[i] = arr[j]</span><br><span class="line">            <span class="comment"># 从左侧搜索大元素，并进行交换</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt; temp:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            arr[j] = arr[i]</span><br><span class="line">        <span class="comment"># 最初left上的数字已经被覆盖了，所以需要重新赋值</span></span><br><span class="line">        arr[i] = temp</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.getLeastNumbers([<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>], <span class="number">4</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="sort-an-array"><a href="#sort-an-array" class="headerlink" title="sort-an-array"></a>sort-an-array</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/28 22:52 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 912_sort-an-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/sort-an-array/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#  快速排序</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quick</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">                <span class="keyword">return</span> nums</span><br><span class="line">            <span class="comment"># 哨兵</span></span><br><span class="line">            pivot = left</span><br><span class="line">            i = left</span><br><span class="line">            j = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                <span class="comment"># 寻找右半部分</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &gt; nums[pivot]:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 寻找左半部分</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= nums[pivot]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            nums[pivot], nums[j] = nums[j], nums[pivot]</span><br><span class="line">            quick(left, j-<span class="number">1</span>)</span><br><span class="line">            quick(j+<span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quick(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="comment"># def insertion_sort(nums):</span></span><br><span class="line"><span class="comment">#     n = len(nums)</span></span><br><span class="line"><span class="comment">#     for i in range(1, n):</span></span><br><span class="line"><span class="comment">#         while i &gt; 0 and nums[i - 1] &gt; nums[i]:</span></span><br><span class="line"><span class="comment">#             nums[i - 1], nums[i] = nums[i], nums[i - 1]</span></span><br><span class="line"><span class="comment">#             i -= 1</span></span><br><span class="line"><span class="comment">#     return nums</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.sortArray([<span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="maximum-gap"><a href="#maximum-gap" class="headerlink" title="maximum-gap"></a>maximum-gap</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/29 12:39</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 164_maximum-gap.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/maximum-gap/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        len_nums = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> len_nums &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums.sort(reverse=<span class="literal">False</span>)</span><br><span class="line">        max_gap = <span class="built_in">abs</span>(nums[<span class="number">1</span>] - nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, len_nums):</span><br><span class="line">            max_gap = <span class="built_in">max</span>(max_gap, <span class="built_in">abs</span>(nums[i] - nums[i - <span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> max_gap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.maximumGap([<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="contains-duplicate"><a href="#contains-duplicate" class="headerlink" title="contains-duplicate"></a>contains-duplicate</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/30 17:45</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 217_contains-duplicate.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/contains-duplicate/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 先排序</span></span><br><span class="line">        nums.sort(reverse=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 再比较</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.containsDuplicate([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="contains-duplicate-ii"><a href="#contains-duplicate-ii" class="headerlink" title="contains-duplicate-ii"></a>contains-duplicate-ii</h2><p>用散列表来维护这个k大小的滑动窗口。</p>
<p>遍历数组，对于每个元素做以下操作：</p>
<ul>
<li><p>在散列表中搜索当前元素，如果找到了就返回 true。</p>
</li>
<li><p>在散列表中插入当前元素。</p>
</li>
<li><p>如果当前散列表的大小超过了 k， 删除散列表中最旧的元素。</p>
</li>
</ul>
<p>返回 false。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/30 17:46</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 219_contains-duplicate-ii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/contains-duplicate-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        nums_sort = <span class="built_in">list</span>()</span><br><span class="line">        nums_sort.append(nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> nums_sort:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(nums_sort) &gt;= k:</span><br><span class="line">                nums_sort.pop(<span class="number">0</span>)</span><br><span class="line">            nums_sort.append(nums[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.containsNearbyDuplicate([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="contains-duplicate-iii"><a href="#contains-duplicate-iii" class="headerlink" title="contains-duplicate-iii"></a>contains-duplicate-iii</h2><p>方法一：线性搜索，超时</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/5 21:24 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 220_contains-duplicate-iii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/contains-duplicate-iii</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        nums_sort = <span class="built_in">list</span>()</span><br><span class="line">        nums_sort.append(nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums_sort) &gt; k:</span><br><span class="line">                nums_sort.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 查询当前子列表中的每个元素是否满足t的要求</span></span><br><span class="line">            tmp_nums_sored = <span class="built_in">sorted</span>(nums_sort, reverse=<span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> tmp_nums_sored:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(nums[i] - v) &lt;= t:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            nums_sort.append(nums[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.containsNearbyAlmostDuplicate(nums=[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], k=<span class="number">2</span>, t=<span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>方法二：桶排序</p>
<p>由于本题对索引有要求，考虑使用桶排序。</p>
<ul>
<li>每个数字nums[i] 都被分配到一个桶中</li>
<li>每个桶序号代表存放t的倍数的数 nums[i] // (t + 1)<ul>
<li>不相邻的桶一定不满足相差小于等于t，且同一个桶内的数字最多相差t</li>
<li>因此如果命中同一个桶内，那么直接返回True</li>
<li>如果命中相邻桶，我们再判断一下是否满足相差 &lt;= t</li>
</ul>
</li>
<li>题目有索引相差k的要求，因此要维护一个大小为k的窗口，定期清除桶中过期的数字。bucket.pop(nums[i - k] // (t + 1)) 即清除当前i前的第k个元素所对应的桶序号。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/5 21:24 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 220_contains-duplicate-iii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/contains-duplicate-iii</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        bucket = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">if</span> t &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 每个桶序号代表存放t的倍数的数</span></span><br><span class="line">            bucket_nth = nums[i] // (t + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> bucket_nth <span class="keyword">in</span> bucket:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> bucket_nth - <span class="number">1</span> <span class="keyword">in</span> bucket <span class="keyword">and</span> <span class="built_in">abs</span>(bucket[bucket_nth - <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> bucket_nth + <span class="number">1</span> <span class="keyword">in</span> bucket <span class="keyword">and</span> <span class="built_in">abs</span>(bucket[bucket_nth + <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            bucket[bucket_nth] = nums[i]</span><br><span class="line">            <span class="comment"># 当桶大于k时，代表窗口已经越界，越界元素可以进行清除</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                bucket.pop(nums[i - k] // (t + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.containsNearbyAlmostDuplicate(nums=[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], k=<span class="number">2</span>, t=<span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-63"><a href="#interview-63" class="headerlink" title="interview_63"></a>interview_63</h2><p><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/mian-shi-ti-41-shu-ju-liu-zhong-de-zhong-wei-shu-y/">参考链接</a></p>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：<br>查找中位数 O(1) ： 获取堆顶元素使用 O(1)时间；（二分查找等则需要O(log N)）<br>添加数字 O(log N) ： 堆的插入和弹出操作使用 O(log N) 时间。（线性插入O(N)）</li>
<li>空间复杂度 O(N)： 其中 N 为数据流中的元素数量，小顶堆 B 和大顶堆 A最多同时保存 N 个元素。</li>
</ul>
<p>算法利用大顶堆A和小顶堆B，A存放较小的元素，B存放较大的元素。使得B的最小的元素也比A中最大的元素大，保证数据流保持有序。</p>
<p><strong>B保持比A多一个的状态</strong>，当数据流长度时为奇数时，则向A中插入元素；偶数时，则向B中插入元素。</p>
<blockquote>
<p>Python 中 heapq 模块是小顶堆。实现 <strong>大顶堆</strong> 方法： 小顶堆的插入和弹出操作均将元素 <strong>取反</strong> 即可。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:58</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @Fil</span></span><br><span class="line">e: interview_63.py</span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.A = []  <span class="comment"># 大顶堆，存放较小的元素</span></span><br><span class="line">        self.B = []  <span class="comment"># 小顶堆，存放较大的元素，使得B的最小的元素也比A中最大的元素大，保证数据流保持有序</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># 数据流长度为奇数时，需向A中插入元素：先向B中插入num，再将B的堆顶元素插入至A，保证B比A大</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.A) != <span class="built_in">len</span>(self.B):</span><br><span class="line">            heappush(self.B, num)</span><br><span class="line">            heappush(self.A, -heappop(self.B))</span><br><span class="line">        <span class="comment"># 数据流长度为偶数时，需向B中插入元素：先向A中插入num，再将A的堆顶元素插入至B，保证B比A大</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heappush(self.A, -num)</span><br><span class="line">            heappush(self.B, -heappop(self.A))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span>(<span class="params">self</span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.A) != <span class="built_in">len</span>(self.B):</span><br><span class="line">            <span class="keyword">return</span> self.B[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># A由于是存放的都是相反数，所以计算时，A中最大的数其实在A[0],也就是-A[0]是A中最大的数</span></span><br><span class="line">            <span class="keyword">return</span> (-self.A[<span class="number">0</span>] + self.B[<span class="number">0</span>]) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MedianFinder()</span></span><br><span class="line"><span class="comment"># obj.addNum(num)</span></span><br><span class="line"><span class="comment"># param_2 = obj.findMedian()</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><h2 id="interview-12"><a href="#interview-12" class="headerlink" title="interview_12"></a>interview_12</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2^3</span><br><span class="line">2^3 = 2^1 * 2^1 * 2 </span><br><span class="line">2^1 = 2^0 * 2</span><br><span class="line">2^0 = 1</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2^4</span><br><span class="line">2^4 = 2^2 * 2^2</span><br><span class="line">2^2 = 2^1 * 2^1</span><br><span class="line">2^1 = 2^0 * 2</span><br><span class="line">2^0 = 1</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 16:24</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_12.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;q</span></span><br><span class="line"><span class="comment"># ru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x: <span class="built_in">float</span>, n: <span class="built_in">int</span></span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / x</span><br><span class="line">        half = self.myPow(x, n // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> half * half</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> half * half * x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.myPow(<span class="number">2.00000</span>, -<span class="number">10</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="remove-duplicates-from-sorted-array"><a href="#remove-duplicates-from-sorted-array" class="headerlink" title="remove-duplicates-from-sorted-array"></a>remove-duplicates-from-sorted-array</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/2 11:53 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 26_remove-duplicates-from-sorted-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.removeDuplicates([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="remove-element"><a href="#remove-element" class="headerlink" title="remove-element"></a>remove-element</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/3 11:41 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 27_remove-element.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/remove-element/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">self, nums, val: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != val:</span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.removeElement([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>], <span class="number">2</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="implement-strstr"><a href="#implement-strstr" class="headerlink" title="implement-strstr"></a>implement-strstr</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/4 8:45 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 28_implement-strstr.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/implement-strstr/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># haystack.find(needle)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(haystack) &lt; <span class="built_in">len</span>(needle):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(haystack) - <span class="built_in">len</span>(needle) + <span class="number">1</span>):</span><br><span class="line">            index = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(needle)):</span><br><span class="line">                <span class="keyword">if</span> haystack[i] != needle[j]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.strStr(<span class="string">"hello"</span>, <span class="string">"ll"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="substring-with-concatenation-of-all-words"><a href="#substring-with-concatenation-of-all-words" class="headerlink" title="substring-with-concatenation-of-all-words"></a>substring-with-concatenation-of-all-words</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/14 10:25 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 30_substring-with-concatenation-of-all-words.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span>(<span class="params">self, s, words</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        words_number = <span class="built_in">len</span>(words)</span><br><span class="line">        words_len = <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">        s_len = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将words中的单词与个数存储到字典中</span></span><br><span class="line">        word_dic = {}</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> word_dic.keys():</span><br><span class="line">                word_dic[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                word_dic[word] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        output_list = []</span><br><span class="line">        <span class="comment"># 按照word的长度设三段切词的起点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(words_len):</span><br><span class="line">            <span class="comment"># 将s按照word的长度截取words_number段</span></span><br><span class="line">            start_index = i</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 先对s进行切割</span></span><br><span class="line">            s_cut_list = []</span><br><span class="line">            cut_number = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 切词</span></span><br><span class="line">            <span class="keyword">while</span> s_len - start_index &gt;= words_len:</span><br><span class="line">                s_cut_list.append(s[start_index : start_index + words_len])</span><br><span class="line">                cut_number += <span class="number">1</span></span><br><span class="line">                start_index += words_len</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 再对切割后的s进行判断，检验长度要求，个数要求</span></span><br><span class="line">            start_cut_i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> cut_number - start_cut_i &gt; words_number:</span><br><span class="line">                <span class="comment"># count记录当前已经匹配完成的个数</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                w_dic = {}</span><br><span class="line">                <span class="comment"># 在s_cut_list中截取n个单词</span></span><br><span class="line">                <span class="keyword">for</span> s_word <span class="keyword">in</span> s_cut_list[start_cut_i : start_cut_i + words_number]:</span><br><span class="line">                    <span class="keyword">if</span> s_word <span class="keyword">in</span> word_dic.keys():</span><br><span class="line">                        <span class="keyword">if</span> s_word <span class="keyword">in</span> w_dic.keys():</span><br><span class="line">                            w_dic[s_word] += <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> w_dic[s_word] &gt; word_dic[s_word]:</span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                            count += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            w_dic[s_word] = <span class="number">1</span></span><br><span class="line">                            count += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> count == words_number:</span><br><span class="line">                    output_list.append(i + start_cut_i * words_len)</span><br><span class="line">                start_cut_i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findSubstring(<span class="string">"barfoothefoobarman"</span>, [<span class="string">"foo"</span>, <span class="string">"bar"</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next-permutation"></a>next-permutation</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/19 12:18 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 31_next-permutation.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/next-permutation/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        left = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 从右开始，找到第一个升序的数</span></span><br><span class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                left = i - <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 如果不存在left，则为降序数列，翻转整个数组</span></span><br><span class="line">        <span class="keyword">if</span> left == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则找到第一个比nums[left]大的数，至少有一个（为nums[left+1]）</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, left, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[right] &gt; nums[left]:</span><br><span class="line">                nums[right], nums[left] = nums[left], nums[right]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 此时nums[left+1]依旧为降序数列，翻转nums[left+1]</span></span><br><span class="line">        nums_left = nums[left + <span class="number">1</span> : <span class="built_in">len</span>(nums)]</span><br><span class="line">        nums_left = nums_left[::-<span class="number">1</span>]</span><br><span class="line">        nums[left + <span class="number">1</span> : <span class="built_in">len</span>(nums)] = nums_left</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.nextPermutation([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="longest-valid-parentheses"><a href="#longest-valid-parentheses" class="headerlink" title="longest-valid-parentheses"></a>longest-valid-parentheses</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/21 12:58 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 32_longest-valid-parentheses.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/longest-valid-parentheses/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="built_in">len</span>(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        maxlen = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 当前字符为"("，left+=1,")"right+=1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 正向搜索: 即")"必须与"("相同</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">"("</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                maxlen = right * <span class="number">2</span> <span class="keyword">if</span> maxlen &lt; right * <span class="number">2</span> <span class="keyword">else</span> maxlen</span><br><span class="line">            <span class="keyword">elif</span> right &gt; left:</span><br><span class="line">                left = right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反向搜索：即"("必须与")"相同</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">"("</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                maxlen = left * <span class="number">2</span> <span class="keyword">if</span> maxlen &lt; left * <span class="number">2</span> <span class="keyword">else</span> maxlen</span><br><span class="line">            <span class="keyword">elif</span> left &gt; right:</span><br><span class="line">                left = right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.longestValidParentheses(<span class="string">"())((())"</span>))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="search-insert-position"><a href="#search-insert-position" class="headerlink" title="search-insert-position"></a>search-insert-position</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/5 6:22 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 35_search-insert-position.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/search-insert-position/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums, target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == target:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">elif</span> nums[i] &lt; target &lt;= nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] &gt; target:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.searchInsert([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="combination-sum-ii"><a href="#combination-sum-ii" class="headerlink" title="combination-sum-ii"></a>combination-sum-ii</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/10 2:57 下午 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 40_combination-sum-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/combination-sum-ii/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates <span class="keyword">or</span> <span class="keyword">not</span> target:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        output_list = []</span><br><span class="line">        path = []</span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line">        size = <span class="built_in">len</span>(candidates)</span><br><span class="line">        self._dfs(candidates, begin, size, path, output_list, target)</span><br><span class="line">        <span class="keyword">return</span> output_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span>(<span class="params">self, candidates, begin, size, path, output_list, target</span>):</span></span><br><span class="line">        <span class="comment"># 递归终止的条件</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            output_list.append(path[:])</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(begin, size):</span><br><span class="line">            residue = target - candidates[index]</span><br><span class="line">            <span class="keyword">if</span> residue &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> index &gt; begin <span class="keyword">and</span> candidates[index - <span class="number">1</span>] == candidates[index]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(candidates[index])</span><br><span class="line">            self._dfs(candidates, index+<span class="number">1</span>, size, path, output_list, residue)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    candidates = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    target = <span class="number">5</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    result = solution.combinationSum(candidates, target)</span><br><span class="line">    print(result)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="multiply-strings"><a href="#multiply-strings" class="headerlink" title="multiply-strings"></a>multiply-strings</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/15 11:17</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 43_multiply-strings.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/multiply-strings/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> num1 == <span class="string">'0'</span> <span class="keyword">or</span> num2 == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        return_sum = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> val1 <span class="keyword">in</span> num2[::-<span class="number">1</span>]:</span><br><span class="line">            add = <span class="number">0</span>  <span class="comment"># 进位符</span></span><br><span class="line">            multiply_sum = <span class="number">0</span></span><br><span class="line">            count1 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> val2 <span class="keyword">in</span> num1[::-<span class="number">1</span>]:</span><br><span class="line">                multi_sum = (<span class="built_in">int</span>(val1) * <span class="built_in">int</span>(val2) + add) % <span class="number">10</span></span><br><span class="line">                multiply_sum += multi_sum * (<span class="number">10</span> ** count1)</span><br><span class="line">                add = (<span class="built_in">int</span>(val1) * <span class="built_in">int</span>(val2) + add) // <span class="number">10</span></span><br><span class="line">                count1 += <span class="number">1</span></span><br><span class="line">            return_sum += multiply_sum * (<span class="number">10</span> ** count)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(return_sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.multiply(<span class="string">"123"</span>, <span class="string">"456"</span>))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="group-anagrams"><a href="#group-anagrams" class="headerlink" title="group-anagrams"></a>group-anagrams</h2><p>解题方法：</p>
<ul>
<li><p>collections类中的defaultdict()方法来为字典提供默认值。</p>
</li>
<li><p>按排序数组分类</p>
<ul>
<li><p>ans = {(“a”,e”,”r”):[“are”,”ear”,”era”],</p>
<p>​            (“a”,”b”,”t”):[“bat”,”tab”]</p>
<p>​            (“e”,”c”,”d”,”o”):[“code”]}</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/20 00:01</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 49_group-anagrams.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/group-anagrams/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">self, strs</span>):</span></span><br><span class="line">        ans = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            ans[<span class="built_in">tuple</span>(<span class="built_in">sorted</span>(s))].append(s)</span><br><span class="line">        <span class="keyword">return</span> ans.values()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.groupAnagrams([<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>]))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="plus-one"><a href="#plus-one" class="headerlink" title="plus-one"></a>plus-one</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/22 19:31</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 66_plus-one.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/plus-one/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        len_digits = <span class="built_in">len</span>(digits)</span><br><span class="line">        add = (digits[len_digits-<span class="number">1</span>] + <span class="number">1</span>) // <span class="number">10</span></span><br><span class="line">        digits[len_digits-<span class="number">1</span>] = (digits[len_digits-<span class="number">1</span>] + <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_digits - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            add = (digits[i] + add) // <span class="number">10</span></span><br><span class="line">            digits[i] = (digits[i] + add) % <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> add == <span class="number">1</span>:</span><br><span class="line">            digits.insert(<span class="number">0</span>, add)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.plusOne([<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="length-of-last-word"><a href="#length-of-last-word" class="headerlink" title="length-of-last-word"></a>length-of-last-word</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/1 18:01</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 58_length-of-last-word.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/length-of-last-word/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s.split()[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.lengthOfLastWord(<span class="string">"Hello World"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="permutation-sequence"><a href="#permutation-sequence" class="headerlink" title="permutation-sequence"></a>permutation-sequence</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/2 12:07</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 60_permutation-sequence.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/permutation-sequence/</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        nums = [<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>)]</span><br><span class="line">        output_str = <span class="string">""</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; -<span class="number">1</span>:</span><br><span class="line">            number_combination = math.factorial(n)  <span class="comment"># 每组组合数总和</span></span><br><span class="line">            output_number_index = math.ceil(k / number_combination) - <span class="number">1</span>  <span class="comment"># 不用\\的原因是因为 1 1希望输出的是0，"\\"会输出1</span></span><br><span class="line">            output_str += nums[output_number_index]</span><br><span class="line">            nums.pop(output_number_index)</span><br><span class="line">            k %= number_combination</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.getPermutation(<span class="number">4</span>, <span class="number">9</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="6-convert"><a href="#6-convert" class="headerlink" title="6_convert"></a>6_convert</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/18 11:52 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 6_convert.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/zigzag-conversion/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">self, s: <span class="built_in">str</span>, numRows: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        outstr = [<span class="string">""</span>] * numRows</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, numRows):</span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                    outstr[j] += s[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(numRows - <span class="number">2</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s):</span><br><span class="line">                    outstr[j] += s[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        outstr = <span class="string">""</span>.join(outstr)</span><br><span class="line">        <span class="keyword">return</span> outstr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">"ABCDE"</span></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.convert(s, <span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="7-reverse-integer"><a href="#7-reverse-integer" class="headerlink" title="7_reverse-integer"></a>7_reverse-integer</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/19 1:05 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 7_reverse-integer.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/reverse-integer/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        len_x = <span class="built_in">len</span>(<span class="built_in">str</span>(x))</span><br><span class="line">        reverse_x = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, len_x):</span><br><span class="line">            middle_x = (x % <span class="built_in">pow</span>(<span class="number">10</span>, i + <span class="number">1</span>)) // <span class="built_in">pow</span>(<span class="number">10</span>, i)</span><br><span class="line">            reverse_x = reverse_x + <span class="built_in">str</span>(middle_x)</span><br><span class="line">        <span class="keyword">return</span> reverse_x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="number">123456789</span></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reverse(s))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="palindrome-number"><a href="#palindrome-number" class="headerlink" title="palindrome_number"></a>palindrome_number</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/20 11:38 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 9_palindrome_number.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/palindrome-number/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        return_num = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 只对比一半</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; return_num:</span><br><span class="line">            return_num = return_num * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x = x // <span class="number">10</span></span><br><span class="line">        <span class="comment"># x是偶数则相等 奇数要去掉最后一位</span></span><br><span class="line">        <span class="keyword">return</span> x == return_num <span class="keyword">or</span> x == return_num // <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isPalindrome(<span class="number">1221</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="container-with-most-water"><a href="#container-with-most-water" class="headerlink" title="container-with-most-water"></a>container-with-most-water</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/23 11:33 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 11_container-with-most-water.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/container-with-most-water/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        max_size = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt; height[j]:</span><br><span class="line">                tmp_size = (j - i) * height[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp_size = (j - i) * height[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            max_size = tmp_size <span class="keyword">if</span> tmp_size &gt; max_size <span class="keyword">else</span> max_size</span><br><span class="line">        <span class="keyword">return</span> max_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line"><span class="keyword">assert</span> so.maxArea([<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>])</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="integer-to-roman"><a href="#integer-to-roman" class="headerlink" title="integer-to-roman"></a>integer-to-roman</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/25 7:29 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 12_integer-to-roman.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/integer-to-roman/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        output = <span class="string">""</span></span><br><span class="line">        roman_dict = {</span><br><span class="line">            <span class="number">1000</span>: <span class="string">"M"</span>,</span><br><span class="line">            <span class="number">900</span>: <span class="string">"CM"</span>,</span><br><span class="line">            <span class="number">500</span>: <span class="string">"D"</span>,</span><br><span class="line">            <span class="number">400</span>: <span class="string">"CD"</span>,</span><br><span class="line">            <span class="number">100</span>: <span class="string">"C"</span>,</span><br><span class="line">            <span class="number">90</span>: <span class="string">"XC"</span>,</span><br><span class="line">            <span class="number">50</span>: <span class="string">"L"</span>,</span><br><span class="line">            <span class="number">40</span>: <span class="string">"XL"</span>,</span><br><span class="line">            <span class="number">10</span>: <span class="string">"X"</span>,</span><br><span class="line">            <span class="number">9</span>: <span class="string">"IX"</span>,</span><br><span class="line">            <span class="number">5</span>: <span class="string">"V"</span>,</span><br><span class="line">            <span class="number">4</span>: <span class="string">"IV"</span>,</span><br><span class="line">            <span class="number">1</span>: <span class="string">"I"</span>,</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> key, value <span class="keyword">in</span> roman_dict.items():</span><br><span class="line">                <span class="keyword">if</span> num &gt;= key:</span><br><span class="line">                    output += value</span><br><span class="line">                    num -= key</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.intToRoman(<span class="number">999</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="roman-to-integer"><a href="#roman-to-integer" class="headerlink" title="roman-to-integer"></a>roman-to-integer</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/25 7:43 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 13_roman-to-integer.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/roman-to-integer/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        output = <span class="number">0</span></span><br><span class="line">        roman_dict = {<span class="string">"I"</span>: <span class="number">1</span>, <span class="string">"V"</span>: <span class="number">5</span>, <span class="string">"X"</span>: <span class="number">10</span>, <span class="string">"L"</span>: <span class="number">50</span>, <span class="string">"C"</span>: <span class="number">100</span>, <span class="string">"D"</span>: <span class="number">500</span>, <span class="string">"M"</span>: <span class="number">1000</span>}</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s) - <span class="number">1</span> <span class="keyword">and</span> roman_dict[s[i]] &lt; roman_dict[s[i + <span class="number">1</span>]]:</span><br><span class="line">                output -= roman_dict[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output += roman_dict[s[i]]</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.romanToInt(<span class="string">"MCMXCIV"</span>))  <span class="comment"># 1994</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="longest-common-prefix"><a href="#longest-common-prefix" class="headerlink" title="longest-common-prefix"></a>longest-common-prefix</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/25 9:12 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 14_longest-common-prefix.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/longest-common-prefix/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, li</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> li:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="comment"># 按照ASCII码进行排序</span></span><br><span class="line">        min_str = <span class="built_in">min</span>(li)</span><br><span class="line">        max_str = <span class="built_in">max</span>(li)</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(min_str):</span><br><span class="line">            <span class="keyword">if</span> value != max_str[index]:</span><br><span class="line">                <span class="keyword">return</span> max_str[:index]</span><br><span class="line">        <span class="keyword">return</span> min_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.longestCommonPrefix([<span class="string">"flower"</span>, <span class="string">"flow"</span>, <span class="string">"flight"</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="3sum"><a href="#3sum" class="headerlink" title="3sum"></a>3sum</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/27 12:18 上午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 15_3sum.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/3sum/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        output = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> output</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[left] + nums[right] == <span class="number">0</span>:</span><br><span class="line">                    output.append((nums[i], nums[left], nums[right]))</span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.threeSum([-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="3sum-closest"><a href="#3sum-closest" class="headerlink" title="3sum-closest"></a>3sum-closest</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/28 4:32 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 16_3sum-closest.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/3sum-closest/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums, target</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        result = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - <span class="number">2</span>):</span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                min_value = nums[i] + nums[left] + nums[left + <span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 最小的都比target大，后面的元素则无需进行比较</span></span><br><span class="line">                <span class="keyword">if</span> target &lt; min_value:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">abs</span>(min_value - target) &lt; <span class="built_in">abs</span>(result - target):</span><br><span class="line">                        result = min_value</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 最大的都比target小，前面的元素则无需进行比较</span></span><br><span class="line">                max_value = nums[i] + nums[right] + nums[right - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> target &gt; max_value:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">abs</span>(max_value - target) &lt; <span class="built_in">abs</span>(result - target):</span><br><span class="line">                        result = max_value</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                sum_value = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(sum_value - target) &lt; <span class="built_in">abs</span>(result - target):</span><br><span class="line">                    result = sum_value</span><br><span class="line">                <span class="keyword">if</span> sum_value == target:</span><br><span class="line">                    <span class="keyword">return</span> sum_value</span><br><span class="line">                <span class="keyword">if</span> sum_value &gt; target:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">not</span> left == right) <span class="keyword">and</span> nums[right] == nums[right + <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">not</span> left == right) <span class="keyword">and</span> nums[left] == nums[left - <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 去重</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n - <span class="number">2</span> <span class="keyword">and</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.threeSumClosest([-<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">4</span>], <span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="letter-combinations-of-a-phone-number"><a href="#letter-combinations-of-a-phone-number" class="headerlink" title="letter-combinations-of-a-phone-number"></a>letter-combinations-of-a-phone-number</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/29 5:55 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 17_letter-combinations-of-a-phone-number.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>):</span></span><br><span class="line">        digit_number_dict = {</span><br><span class="line">            <span class="string">"2"</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>],</span><br><span class="line">            <span class="string">"3"</span>: [<span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>],</span><br><span class="line">            <span class="string">"4"</span>: [<span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>],</span><br><span class="line">            <span class="string">"5"</span>: [<span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>],</span><br><span class="line">            <span class="string">"6"</span>: [<span class="string">"m"</span>, <span class="string">"n"</span>, <span class="string">"o"</span>],</span><br><span class="line">            <span class="string">"7"</span>: [<span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>],</span><br><span class="line">            <span class="string">"8"</span>: [<span class="string">"t"</span>, <span class="string">"u"</span>, <span class="string">"v"</span>],</span><br><span class="line">            <span class="string">"9"</span>: [<span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>],</span><br><span class="line">        }</span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">combination, next_digits</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> next_digits:</span><br><span class="line">                output.append(combination)  <span class="comment"># "ap"、"aq"、"ar"......</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> letter <span class="keyword">in</span> digit_number_dict[next_digits[<span class="number">0</span>]]:</span><br><span class="line">                    backtrack(combination + letter, next_digits[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> digits:</span><br><span class="line">            backtrack(<span class="string">""</span>, digits)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.letterCombinations(<span class="string">"27"</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a>4Sum</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/30 1:15 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 18_4Sum.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/4sum/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">sum</span>(nums[:<span class="number">4</span>]) &gt; target:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        result_li = []</span><br><span class="line">        <span class="comment"># 固定i与left，对middle与right进行查找与去重</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">                middle = left + <span class="number">1</span></span><br><span class="line">                right = n - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> middle != right:</span><br><span class="line">                    sum_value = nums[i] + nums[left] + nums[middle] + nums[right]</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        sum_value == target</span><br><span class="line">                        <span class="keyword">and</span> [nums[i], nums[left], nums[middle], nums[right]]</span><br><span class="line">                        <span class="keyword">not</span> <span class="keyword">in</span> result_li</span><br><span class="line">                    ):</span><br><span class="line">                        result_li.append(</span><br><span class="line">                            [nums[i], nums[left], nums[middle], nums[right]]</span><br><span class="line">                        )</span><br><span class="line">                    <span class="keyword">if</span> sum_value &lt;= target:</span><br><span class="line">                        middle += <span class="number">1</span></span><br><span class="line">                        <span class="comment"># 去重</span></span><br><span class="line">                        <span class="keyword">while</span> middle != right <span class="keyword">and</span> nums[middle] == nums[middle - <span class="number">1</span>]:</span><br><span class="line">                            middle += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                        <span class="comment"># 去重</span></span><br><span class="line">                        <span class="keyword">while</span> middle != right <span class="keyword">and</span> nums[right] == nums[right + <span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result_li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.fourSum([<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">2</span>], <span class="number">0</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="remove-nth-node-from-end-of-list"><a href="#remove-nth-node-from-end-of-list" class="headerlink" title="remove-nth-node-from-end-of-list"></a>remove-nth-node-from-end-of-list</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/31 12:11 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 19_remove-nth-node-from-end-of-list.py</span></span><br><span class="line"><span class="comment"># @Desc: 通过同时向前移动两个间隔为n的指针，直到第一个指针到达最后一个节点。此时第二个指针将指向从最后一个节点数起的第n个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 哑节点用来简化某些极端情况，例如列表中只有含有一个节点，或需要删除列表的头部</span></span><br><span class="line">        head_pre = ListNode(-<span class="number">1</span>)</span><br><span class="line">        head_pre.<span class="built_in">next</span>, start, end = head, head_pre, head_pre</span><br><span class="line">        <span class="comment"># 让end节点向前走n步</span></span><br><span class="line">        <span class="keyword">while</span> end <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            end = end.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 如果end已经走到末尾，则证明比n长，直接退出</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> end:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">while</span> end.<span class="built_in">next</span>:</span><br><span class="line">            start, end = start.<span class="built_in">next</span>, end.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 删除倒数第n个节点</span></span><br><span class="line">        start.<span class="built_in">next</span> = start.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-length-of-longest-substring-1"><a href="#3-length-of-longest-substring-1" class="headerlink" title="3_length_of_longest_substring"></a>3_length_of_longest_substring</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2019/10/8 8:17 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File:  3_length_of_longest_substring.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthoflongestsubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        tem_length = <span class="number">0</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        s_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> s_set:</span><br><span class="line">                s_set.remove(s[i])</span><br><span class="line">                tem_length = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s_set.add(s[i])</span><br><span class="line">                tem_length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> tem_length &gt; max_length:</span><br><span class="line">                max_length = tem_length</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    so = Solution()</span><br><span class="line">    test_list = <span class="string">"pwdflkkkpwdsadf"</span></span><br><span class="line">    start = timeit.default_timer()</span><br><span class="line">    print(so.lengthoflongestsubstring(test_list))</span><br><span class="line">    end = timeit.default_timer()</span><br><span class="line">    print(<span class="built_in">str</span>((end - start) * <span class="number">1000</span>), <span class="string">"s"</span>)  <span class="comment"># s0.034690000006776245 s</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="merge-sorted-array"><a href="#merge-sorted-array" class="headerlink" title="merge-sorted-array"></a>merge-sorted-array</h2><p>解题思路：</p>
<p>初阶版 — 合并后排序</p>
<p>时间复杂度 : <code>O((n + m)log(n + m))</code>、空间复杂度<code>O(1)</code></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: List[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; List:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums1[:] = <span class="built_in">sorted</span>(nums1[:m], nums2)</span><br><span class="line">        <span class="keyword">return</span> nums1</span><br></pre></td></tr></tbody></table></figure>
<p>进阶版：双指针/从前往后</p>
<p>最直接的算法实现是将指针p1 置为 nums1的开头， p2为 nums2的开头，在每一步将最小值放入输出数组中。</p>
<p>由于 nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方，也就需要 O(m)O(m) 的空间复杂度。</p>
<p>时间复杂度 : <code>O(n + m)</code>、空间复杂度<code>O(m)</code></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># Make a copy of nums1.</span></span><br><span class="line">        nums1_copy = nums1[:m] </span><br><span class="line">        nums1[:] = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Two get pointers for nums1_copy and nums2.</span></span><br><span class="line">        p1 = <span class="number">0</span> </span><br><span class="line">        p2 = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Compare elements from nums1_copy and nums2</span></span><br><span class="line">        <span class="comment"># and add the smallest one into nums1.</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; m <span class="keyword">and</span> p2 &lt; n: </span><br><span class="line">            <span class="keyword">if</span> nums1_copy[p1] &lt; nums2[p2]: </span><br><span class="line">                nums1.append(nums1_copy[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1.append(nums2[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if there are still elements to add</span></span><br><span class="line">        <span class="keyword">if</span> p1 &lt; m: </span><br><span class="line">            nums1[p1 + p2:] = nums1_copy[p1:]</span><br><span class="line">        <span class="keyword">if</span> p2 &lt; n:</span><br><span class="line">            nums1[p1 + p2:] = nums2[p2:]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>高阶版：三指针/从后往前</p>
<p>p1、p2分别指向nums1、nums2当前准备移动的元素。p指向当前待放置的位置。</p>
<p>哪个指向的数字大，则将其放置于p所指的位置上。</p>
<p>时间复杂度 :  <code>O(n + m)</code>、空间复杂度<code>O(1)</code></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/1 11:24 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 88_merge-sorted-array.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/merge-sorted-array/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: List[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; List:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums1:</span><br><span class="line">            <span class="keyword">return</span> nums2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums2:</span><br><span class="line">            <span class="keyword">return</span> nums1</span><br><span class="line">        p1 = m - <span class="number">1</span></span><br><span class="line">        p2 = n - <span class="number">1</span></span><br><span class="line">        p = m + n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &gt;= <span class="number">0</span> <span class="keyword">and</span> p2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                nums1[p] = nums2[p2]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p] = nums1[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果nums2中有没有进行添加的元素，则进行添加</span></span><br><span class="line">        nums1[:p2 + <span class="number">1</span>] = nums2[:p2 + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> nums1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.merge(nums1=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], m=<span class="number">3</span>, nums2=[<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>], n=<span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="reOrderArray"><a href="#reOrderArray" class="headerlink" title="reOrderArray"></a>reOrderArray</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/30 11:35 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: reOrderArray.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;tqId=11166&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        len_array = <span class="built_in">len</span>(array)</span><br><span class="line">        <span class="keyword">if</span> len_array &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len_array - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 如果是偶数，就添加到末尾</span></span><br><span class="line">            <span class="keyword">if</span> array[left] &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                array.append(array.pop(left))</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reOrderArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-31"><a href="#interview-31" class="headerlink" title="interview_31"></a>interview_31</h2><p>写不动写不动，太难了。直接暴力吧。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/2 11:50 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_31.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        s = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            s += <span class="built_in">str</span>(n)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s.count(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">so = Solution()</span><br><span class="line">print(so.countDigitOne(<span class="number">12</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-13"><a href="#interview-13" class="headerlink" title="interview_13"></a>interview_13</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/30 11:35</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_13.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;tqId=11166&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        len_array = <span class="built_in">len</span>(array)</span><br><span class="line">        <span class="keyword">if</span> len_array &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len_array - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 如果是偶数，就添加到末尾</span></span><br><span class="line">            <span class="keyword">if</span> array[left] &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                array.append(array.pop(left))</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reOrderArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-40"><a href="#interview-40" class="headerlink" title="interview_40"></a>interview_40</h2><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/16 20:41</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_40.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span>(<span class="params">self, array</span>):</span></span><br><span class="line">        <span class="comment"># write code here1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        len_array = <span class="built_in">len</span>(array)</span><br><span class="line">        <span class="keyword">if</span> len_array &lt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        array.sort()</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># i指向重复的首字符，j负责寻找</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, len_array):</span><br><span class="line">            <span class="keyword">if</span> array[i] != array[j]:</span><br><span class="line">                <span class="comment"># 如果间隔小于1，证明重复次数小于1</span></span><br><span class="line">                <span class="keyword">if</span> j - i == <span class="number">1</span>:</span><br><span class="line">                    result.append(array[i])</span><br><span class="line">                <span class="comment"># 如果间隔大于1，证明j又找到一个新的不相等的数</span></span><br><span class="line">                i = j</span><br><span class="line">        <span class="comment"># 最后需要判断下最后一个字符</span></span><br><span class="line">        <span class="keyword">if</span> array[-<span class="number">1</span>] != array[-<span class="number">2</span>]:</span><br><span class="line">            result.append(array[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">","</span>.join(<span class="built_in">str</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.FindNumsAppearOnce([<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>]))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-46"><a href="#interview-46" class="headerlink" title="interview_46"></a>interview_46</h2><p>暴力法</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/24 15:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_46.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span>(<span class="params">self, n: <span class="built_in">int</span>, m: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        i, array = <span class="number">0</span>, <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(array) &gt; <span class="number">1</span>:</span><br><span class="line">            i = (i + m - <span class="number">1</span>) % <span class="built_in">len</span>(array)</span><br><span class="line">            array.pop(i)</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.lastRemaining(<span class="number">5</span>, <span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-47"><a href="#interview-47" class="headerlink" title="interview_47"></a>interview_47</h2><p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/mian-shi-ti-64-qiu-1-2-nluo-ji-fu-duan-lu-qing-xi-/">短路思想</a></p>
<p>以逻辑运算符 &amp; 为例，对于 A &amp; B 这个表达式，如果 A 表达式返回 False ，那么 A &amp; B 已经确定为 False ，此时不会去执行表达式 B。同理，对于逻辑运算符 ||， 对于 A || B 这个表达式，如果 A 表达式返回 True ，那么 A || B 已经确定为 True ，此时不会去执行表达式 B。</p>
<p>利用这一特性，我们可以将判断是否为递归的出口看作 A &amp; B 表达式中的 A 部分，递归的主体函数看作 B 部分。如果不是递归出口，则返回True，并继续执行表达式 B 的部分，否则递归结束。</p>
<p><img data-src="/images/algorithm/interview_47_1.png" alt="shortcut"></p>
<p>递归思路</p>
<p><img data-src="/images/algorithm/interview_47_2.png" alt="递归思路"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/24 15:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_47.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/qiu-12n-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNums</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 如果n大于1，则and后面的语句继续执行，即，继续递归</span></span><br><span class="line">        n &gt; <span class="number">1</span> <span class="keyword">and</span> self.sumNums(n - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果已经不大于1，则程序继续执行下面的语句，进行累加</span></span><br><span class="line">        self.res += n</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 最后返回当前累加的结果</span></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.sumNums(<span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="interview-54"><a href="#interview-54" class="headerlink" title="interview_54"></a>interview_54</h2><p>Insert函数用来接收字符，构成字符流。</p>
<p>FirstAppearingOnce函数用来判断是否为第一个只出现一次的字符。用了字典来记录字符以及出现的次数。</p>
<blockquote>
<p>由于python的dict不是按照时间顺序来存储的，所以需要借助一个数组来记录。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 16:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_54.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.char_appearing_dict = {}</span><br><span class="line">        self.char_insert = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.char_appearing_dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#"</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.char_insert:</span><br><span class="line">            <span class="keyword">if</span> self.char_appearing_dict[c] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> c</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span>(<span class="params">self, char</span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.char_insert.append(char)</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> self.char_appearing_dict:</span><br><span class="line">            self.char_appearing_dict[char] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.char_appearing_dict[char] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
