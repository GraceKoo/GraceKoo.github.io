<!DOCTYPE html>
<html lang="Zh">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/me.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/me.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/me.jpg">
  <link rel="mask-icon" href="/images/me.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"unknown.yuzhouwan.com","root":"/","scheme":"Muse","version":"0.0.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":false,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="正在深入学习各种CV知识">
<meta property="og:type" content="website">
<meta property="og:title" content="Grace Koo&#39;s Blog">
<meta property="og:url" content="https://unknown.yuzhouwan.com/page/2/index.html">
<meta property="og:site_name" content="Grace Koo&#39;s Blog">
<meta property="og:description" content="正在深入学习各种CV知识">
<meta property="og:locale" content="Zh">
<meta property="article:author" content="Grace Koo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://unknown.yuzhouwan.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>Grace Koo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Grace Koo's Blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Grace Koo's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">LaLaLa~~~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>Books</a>

  </li>
        <li class="menu-item menu-item-mr.sweet">

    <a href="/sweet/" rel="section"><i class="fa fa-fw fa-paw"></i>Mr.Sweet</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Zh">
    <link itemprop="mainEntityOfPage" href="https://unknown.yuzhouwan.com/posts/2246/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Grace Koo">
      <meta itemprop="description" content="正在深入学习各种CV知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Grace Koo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/2246/" class="post-title-link" itemprop="url">操作系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-31 23:55:00" itemprop="dateCreated datePublished" datetime="2020-01-31T23:55:00Z">2020-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 08:34:20" itemprop="dateModified" datetime="2020-11-19T08:34:20Z">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Basic/" itemprop="url" rel="index"><span itemprop="name">Computer Basic</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Basic/Interview/" itemprop="url" rel="index"><span itemprop="name">Interview</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>11 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="同步，异步，阻塞，非阻塞？"><a href="#同步，异步，阻塞，非阻塞？" class="headerlink" title="同步，异步，阻塞，非阻塞？"></a>同步，异步，阻塞，非阻塞？</h2><p>同步： 多个任务之间有先后顺序执行，一个执行完下个才能执行。</p>
<p>异步： 多个任务之间没有先后顺序，可以同时执行，有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！</p>
<p>阻塞： 如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。</p>
<p>非阻塞： 如果不会卡住，可以继续执行，就是说非阻塞的。</p>
<p>同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。</p>
<h3 id="同步阻塞、同步非阻塞、多路I-O复用、异步I-O"><a href="#同步阻塞、同步非阻塞、多路I-O复用、异步I-O" class="headerlink" title="同步阻塞、同步非阻塞、多路I/O复用、异步I/O"></a>同步阻塞、同步非阻塞、多路I/O复用、异步I/O</h3><ul>
<li><p><strong>同步阻塞I/O:</strong> </p>
<p>当进程调用某些涉及I/O操作的系统调用或库函数是，比如send()、accept()等，进程便暂停下来，等I/O操作完成后再继续运行。</p>
</li>
<li><p><strong>同步非阻塞I/O: (轮询)</strong></p>
<ol>
<li><p>不会等待数据就绪，而是结合反复轮询来尝试数据是否就绪</p>
</li>
<li><p>与同步阻塞相比，同步非阻塞好处是在一个进程中可以同时处理多个I/O操作，而不是阻塞在一个I/O操作上</p>
</li>
</ol>
</li>
<li><p><strong>多路I/O复用</strong></p>
<ol>
<li>允许进程通过一种方法来同时监听所有文件描述符，并可以快速获得所有就绪的文件描述符，然后只针对这些文件描述符进行数据访问。select、poll、epoll等函数使用了I/O 复用模型</li>
</ol>
</li>
<li><p><strong>异步I/O</strong></p>
<ol>
<li>启动某个操作，并让内核在整个操作（包括等待数据和将数据从内核复制到用户空间）完成后通知应用进程。<strong>应用进程在整个操作期间都不会被阻塞。</strong></li>
</ol>
</li>
</ul>
<h3 id="Python异步使用场景有哪些"><a href="#Python异步使用场景有哪些" class="headerlink" title="Python异步使用场景有哪些"></a>Python异步使用场景有哪些</h3><p>异步的使用场景:</p>
<p>1、 不涉及共享资源，获对共享资源只读，即<strong>非互斥</strong>操作</p>
<p>2、 <strong>没有时序上的严格关系</strong></p>
<p>3、 不需要原子操作，或可以通过其他方式控制原子性</p>
<p>4、 <strong>常用于IO操作等耗时操作</strong>，因为比较影响客户体验和使用性能</p>
<p>5、 <strong>不影响主线程逻辑</strong></p>
<h3 id="select-poll和epoll"><a href="#select-poll和epoll" class="headerlink" title="select,poll和epoll"></a>select,poll和epoll</h3><p><strong>进程监视多个描述符</strong></p>
<p><strong>进程监视多个描述符</strong></p>
<p><strong>进程监视多个描述符</strong></p>
<p>Select、poll、epoll都是I/O多路复用的机制。<strong>I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（通常是读写操作），能够通知程序进行相应的读写操作。</strong></p>
<p><strong>都是I/O轮询的方法（同步I/O）</strong>，它们都需要在读写事件就绪后自己负责读写。</p>
<p><a href="https://www.wemeng.top/2019/08/22/%E8%81%8A%E8%81%8AIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">聊聊I/O多路复用之select、poll、epoll</a></p>
<p>关于epoll的: <a href="http://www.cnblogs.com/my_life/articles/3968782.html" target="_blank" rel="noopener">http://www.cnblogs.com/my_life/articles/3968782.html</a></p>
<p>基本上select有3个缺点:</p>
<ol>
<li><strong>连接数受限</strong>：单个进程所打开的fd是有一定限制的</li>
<li><strong>查找配对速度慢</strong>：对socket进行轮询扫描时是<strong>线性扫描</strong>，效率较低。</li>
<li><strong>数据由内核拷贝到用户态</strong>：维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li>
</ol>
<p>poll改善了第一个缺点：原因是它是基于<strong>链表来存储的</strong></p>
<p>epoll改了三个缺点：<strong>epoll通过内核和用户空间共享一块内存来实现</strong>。通知机制需要很多函数回调。</p>
<h3 id="边沿触发和水平触发"><a href="#边沿触发和水平触发" class="headerlink" title="边沿触发和水平触发"></a>边沿触发和水平触发</h3><p>水平触发是<strong>只要满足条件</strong>就发生一个 io 事件，边缘触发是指每当<strong>状态变化</strong>时发生一个 io 事件。</p>
<p>如：epoll也是实现I/O多路复用的一种方法。</p>
<p>epoll有<strong>水平触发</strong>（level trigger，LT，LT为epoll的默认工作模式）与<strong>边缘触发</strong>（edge trigger，ET）两种工作模式。</p>
<ul>
<li>水平触发</li>
</ul>
<ol>
<li>对于读操作</li>
</ol>
<p>只要<strong>缓冲内容</strong>不为空，LT模式返回读就绪。</p>
<ol>
<li>对于写操作</li>
</ol>
<p>只要缓冲区还不满，LT模式会返回写就绪。</p>
<ul>
<li>边缘触发</li>
</ul>
<ol>
<li>对于读操作</li>
</ol>
<p>（1）当缓冲区<strong>由不可读变为可读</strong>的时候，即缓冲区<strong>由空变为不空</strong>的时候。</p>
<p>（2）当有<strong>新数据到达</strong>时，即缓冲区中的待读数据变多的时候。</p>
<p>（3）当缓冲区有数据可读，且应用进程对相应的描述符进行<code>EPOLL_CTL_MOD</code> 修改<code>EPOLLIN</code>事件时。</p>
<ol>
<li>对于写操作</li>
</ol>
<p>（1）当缓冲区由不可写变为可写时。</p>
<p>（2）当有旧数据被发送走，即缓冲区中的内容变少的时候。</p>
<p>（3）当缓冲区有空间可写，且应用进程对相应的描述符进行<code>EPOLL_CTL_MOD</code> 修改<code>EPOLLOUT</code>事件时。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程总结"><a href="#进程总结" class="headerlink" title="进程总结"></a>进程总结</h3><p><strong>进程：程序运行在操作系统上的一个实例，就称之为进程。进程需要相应的系统资源：内存、时间片、pid。</strong><br>创建进程：<br>首先要导入multiprocessing中的Process：<br>创建一个Process对象;<br>创建Process对象时，可以传递参数;</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = Process(target=XXX,args=(tuple,),kwargs={key:value})</span><br><span class="line">target = XXX 指定的任务函数，不用加(),</span><br><span class="line">args=(tuple,)kwargs={key:value}给任务函数传递的参数</span><br></pre></td></tr></tbody></table></figure>
<p>使用start()启动进程<br>结束进程<br>给子进程指定函数传递参数Demo</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> mulitprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pro_func</span><span class="params">(name,age,**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"子进程正在运行中，name=%s,age=%d,pid=%d"</span>%(name,age,os.getpid()))</span><br><span class="line">        print(kwargs)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#创建Process对象</span></span><br><span class="line">    p = Process(target=pro_func,args=(<span class="string">'小明'</span>,<span class="number">18</span>),kwargs={<span class="string">'m'</span>:<span class="number">20</span>})</span><br><span class="line">    <span class="comment">#启动进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#1秒钟之后，立刻结束子进程</span></span><br><span class="line">    p.terminate()</span><br><span class="line">    p.join()</span><br></pre></td></tr></tbody></table></figure>
<p>注意：进程间不共享全局变量</p>
<p>进程之间的通信-Queue</p>
<p>在初始化Queue()对象时（例如q=Queue(),若在括号中没有指定最大可接受的消息数量，获数量为负值时，那么就代表可接受的消息数量没有上限一直到内存尽头）</p>
<p>Queue.qsize():返回当前队列包含的消息数量</p>
<p>Queue.empty():如果队列为空，返回True，反之False</p>
<p>Queue.full():如果队列满了，返回True,反之False</p>
<p>Queue.get([block[,timeout]]):获取队列中的一条消息，然后将其从队列中移除，</p>
<p>block默认值为True。</p>
<p>如果block使用默认值，且没有设置timeout（单位秒),消息队列如果为空，此时程序将被阻塞（停在读中状态），直到消息队列读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出“Queue.Empty”异常：</p>
<p>Queue.get_nowait()相当于Queue.get(False)</p>
<p>Queue.put(item,[block[,timeout]]):将item消息写入队列，block默认值为True;<br>如果block使用默认值，且没有设置timeout（单位秒），消息队列如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息队列腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常<br>如果block值为False，消息队列如果没有空间可写入，则会立刻抛出”Queue.Full”异常;<br>Queue.put_nowait(item):相当Queue.put(item,False)</p>
<p>进程间通信Demo:</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process.Queue</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"><span class="comment">#写数据进程执行的代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>]:</span><br><span class="line">        print(<span class="string">"Put %s to queue..."</span>,%value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"><span class="comment">#读数据进程执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            value = q.get(<span class="literal">True</span>)</span><br><span class="line">            print(<span class="string">"Get %s from queue."</span>,%value)</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#父进程创建Queue，并传给各个子进程</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write,args=(q,))</span><br><span class="line">    pr = Process(target=read,args=(q,))</span><br><span class="line">    <span class="comment">#启动子进程pw ，写入：</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment">#等待pw结束</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment">#启动子进程pr，读取：</span></span><br><span class="line">    pr.start()</span><br><span class="line">    pr.join()</span><br><span class="line">    <span class="comment">#pr 进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    print(<span class="string">''</span>)</span><br><span class="line">    print(<span class="string">'所有数据都写入并且读完'</span>)</span><br></pre></td></tr></tbody></table></figure>
<pre><code>进程池Pool
</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(msg)</span>:</span></span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(<span class="string">"%s 开始执行，进程号为%d"</span>%(msg,os.getpid()))</span><br><span class="line">    <span class="comment"># random.random()随机生成0-1之间的浮点数</span></span><br><span class="line">    time.sleep(random.random()*<span class="number">2</span>)</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(msg,<span class="string">"执行完毕，耗时%0.2f”%（t_stop-t_start))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">po = Pool(3)#定义一个进程池，最大进程数3</span></span><br><span class="line"><span class="string">for i in range(0,10):</span></span><br><span class="line"><span class="string">    po.apply_async(worker,(i,))</span></span><br><span class="line"><span class="string">print("</span>---start----<span class="string">")</span></span><br><span class="line"><span class="string">po.close()</span></span><br><span class="line"><span class="string">po.join()</span></span><br><span class="line"><span class="string">print("</span>----end----<span class="string">")</span></span><br></pre></td></tr></tbody></table></figure>
<p>进程池中使用Queue</p>
<p>如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue(),而不是multiprocessing.Queue(),否则会得到如下的错误信息：</p>
<p>RuntimeError： Queue objects should only be shared between processs through inheritance</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager,Pool</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">"reader 启动(%s),父进程为（%s)"</span>%(os.getpid(),os.getpid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(q.qsize()):</span><br><span class="line">        print(<span class="string">"reader 从Queue获取到消息:%s"</span>%q.get(<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">"writer 启动（%s),父进程为(%s)"</span>%(os.getpid(),os.getpid()))</span><br><span class="line">    <span class="keyword">for</span> i ini <span class="string">"itcast"</span>:</span><br><span class="line">        q.put(i)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"(%s)start"</span>%os.getpid())</span><br><span class="line">    q = Manager().Queue()<span class="comment">#使用Manager中的Queue</span></span><br><span class="line">    po = Pool()</span><br><span class="line">    po.apply_async(wrtier,(q,))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    po.apply_async(reader,(q,))</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    print(<span class="string">"(%s)End"</span>%os.getpid())</span><br></pre></td></tr></tbody></table></figure>
<h3 id="多进程，多线程，以及协程的理解"><a href="#多进程，多线程，以及协程的理解" class="headerlink" title="多进程，多线程，以及协程的理解"></a>多进程，多线程，以及协程的理解</h3><p>这个问题被问的概念相当之大。<br>进程：<strong>一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间</strong>，所有进程间数据不共享，开销大。</p>
<p>线程: <strong>cpu调度执行的最小单位，依赖进程存在</strong>，一个进程至少有一个线程，叫主线程，而<strong>多个线程共享内存</strong>（数据共享，共享全局变量), 从而极大地提高了程序的运行效率。</p>
<p>协程: 是一种用户态的轻量级线程，<strong>协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。</strong>协程调度时，将<strong>寄存器上下文和栈</strong>保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<p>协程是进程和线程的升级版, <strong>进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.</strong>（实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU））</p>
<p><strong>Python里最常见的yield就是协程的思想</strong>!</p>
<p>协程：<a href="https://www.cnblogs.com/zingp/p/8678109.html" target="_blank" rel="noopener">https://www.cnblogs.com/zingp/p/8678109.html</a></p>
<h3 id="协程库：python-asyncio的原理"><a href="#协程库：python-asyncio的原理" class="headerlink" title="协程库：python asyncio的原理"></a>协程库：python asyncio的原理</h3><p>asyncio这个库就是实现协程，<strong>底层都是基于生成器（yield）来实现的。</strong></p>
<p>在生成器的基础上实现了：</p>
<ol>
<li><p>现在的生成器虽然可以在暂停执行时吐出一个值，<strong>但是恢复生成器时，我们不能传入参数。</strong> （言下之意是恢复协程时，应该需要支持传入参数）</p>
</li>
<li><p>现在的生成器不支持在 try block 中暂停（言下之意是<strong>协程应该要支持在 try block 中暂停</strong>）</p>
</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'hello world'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'job1 started...'</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'job1 paused'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> hello_world()</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'job1 resumed'</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'job1 finished'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loop = asyncio.get_event_loop()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loop.run_until_complete(job1())</span><br></pre></td></tr></tbody></table></figure>
<p><a href="http://cosven.me/blogs/88" target="_blank" rel="noopener">http://cosven.me/blogs/88</a></p>
<h3 id="僵尸进程和孤儿进程？怎么避免僵尸进程"><a href="#僵尸进程和孤儿进程？怎么避免僵尸进程" class="headerlink" title="僵尸进程和孤儿进程？怎么避免僵尸进程"></a>僵尸进程和孤儿进程？怎么避免僵尸进程</h3><ul>
<li><p>孤儿进程： <strong>父进程退出，子进程还在运行的这些子进程都是孤儿进程</strong>，孤儿进程将被init 进程（进程号为1）所收养，并<strong>由init 进程对他们完成状态收集工作</strong>。</p>
</li>
<li><p>僵尸进程： <strong>进程使用fork 创建子进程，如果子进程退出</strong>，而父进程并没有<strong>调用wait （join方法）获waitpid 获取子进程的退出状态信息</strong>，那么<strong>子进程的进程描述符仍然保存在系统中</strong>的这些进程是僵尸进程。</p>
</li>
</ul>
<p>避免僵尸进程的方法：</p>
<ol>
<li><p><strong>暴力法</strong>：结束父进程（主进程），父进程退出时子进程也会退出。</p>
</li>
<li><p><strong>用wait使父进程阻塞</strong>：如join()方法来wait</p>
</li>
<li><p><strong>使用信号量</strong>：在<strong>父进程中处理</strong>signal handler信号，在<strong>处理程序中调用waitpid</strong>, 这样父进程不用阻塞</p>
</li>
</ol>
<h3 id="进程与线程的使用场景"><a href="#进程与线程的使用场景" class="headerlink" title="进程与线程的使用场景"></a>进程与线程的使用场景</h3><p>多线程适合在IO密性型操作（读写数据操作比多的的，比如爬虫）</p>
<p>多进程适合在CPU密集操作（cpu操作指令比较多，如位多的的浮点运算）。</p>
<h3 id="IO密集型和CPU密集型区别"><a href="#IO密集型和CPU密集型区别" class="headerlink" title="IO密集型和CPU密集型区别"></a>IO密集型和CPU密集型区别</h3><p>IO密集型： 系统运行，大部分的状况是CPU在等 I/O（硬盘/内存）的读/写</p>
<p>CPU密集型： 大部分时间用来做计算，逻辑判断等CPU动作的程序称之CPU密集型。</p>
<h3 id="线程，进程是并发还是并行"><a href="#线程，进程是并发还是并行" class="headerlink" title="线程，进程是并发还是并行"></a>线程，进程是并发还是并行</h3><ul>
<li><p>线程是并发，</p>
</li>
<li><p>进程是并行;</p>
</li>
</ul>
<p>进程之间互相独立，是系统分配资源的最小单位，同一个线程中的所有线程共享资源。</p>
<h3 id="什么是多线程竞争"><a href="#什么是多线程竞争" class="headerlink" title="什么是多线程竞争"></a>什么是多线程竞争</h3><ul>
<li><p>线程是非独立的，<strong>同一个进程里线程是数据共享的，当各个线程访问数据资源时会出现竞争状态即：数据几乎同步会被多个线程占用，造成数据混乱</strong>，即所谓的线程不安全</p>
</li>
<li><p>怎么解决多线程竞争问题？—- <strong>锁</strong></p>
</li>
</ul>
<p>锁的好处： 确保了某段关键代码（共享数据资源）只能由一个线程从头到尾完整地执行能解决多线程资源竞争下的原子操作问题。</p>
<p>锁的坏处： <strong>阻止了多线程并发执行</strong>，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</p>
<p><strong>锁的致命问题: 死锁</strong></p>
<h3 id="Python的线程同步"><a href="#Python的线程同步" class="headerlink" title="Python的线程同步"></a>Python的线程同步</h3><p> 一、 setDaemon(False)<br>当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行的最小单位，当设置多线程时，<strong>主线程会创建多个子线程</strong>，在Python中，默认情况下就是setDaemon(False), <strong>主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。</strong></p>
<p>例子</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'---子线程结束---'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    t1 = threading.Thread(target=thread)</span><br><span class="line">    t1.start()</span><br><span class="line">    print(<span class="string">'---主线程--结束'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line">---主线程--结束</span><br><span class="line">---子线程结束---</span><br></pre></td></tr></tbody></table></figure>
<p>二、 setDaemon（True)<br>当我们使用setDaemon(True)时，<strong>这是子线程为守护线程，主线程一旦执行结束，则全部子线程被强制终止</strong></p>
<p>例子</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(’---子线程结束---<span class="string">')</span></span><br><span class="line"><span class="string">def main():</span></span><br><span class="line"><span class="string">    t1 = threading.Thread(target=thread)</span></span><br><span class="line"><span class="string">    t1.setDaemon(True)#设置子线程守护主线程</span></span><br><span class="line"><span class="string">    t1.start()</span></span><br><span class="line"><span class="string">    print('</span>---主线程结束---<span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ =='</span>__main__<span class="string">':</span></span><br><span class="line"><span class="string">    main()</span></span><br><span class="line"><span class="string">#执行结果</span></span><br><span class="line"><span class="string">---主线程结束--- #只有主线程结束，子线程来不及执行就被强制结束</span></span><br></pre></td></tr></tbody></table></figure>
<p>三、 join（线程同步)<br><strong>join 所完成的工作就是线程同步</strong>，即主线程任务结束以后，进入堵塞状态，一直<strong>等待所有的子线程结束以后，主线程再终止</strong>。</p>
<p>当设置守护线程时，含义是<strong>主线程对于子线程等待timeout的时间将会杀死该子线程</strong>，最后退出程序，所以说，如果有10个子线程，全部的等待时间就是每个timeout的累加和，简单的来说，就是给每个子线程一个timeou的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。</p>
<p>没有设置守护线程时，主线程将会等待timeout的累加和这样的一段时间，时间一到，主线程结束，但是并没有杀死子线程，子线程依然可以继续执行，直到子线程全部结束，程序退出。</p>
<p>例子</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'---子线程结束---'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    t1 = threading.Thread(target=thread)</span><br><span class="line">    t1.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t1.join(timeout=<span class="number">1</span>)<span class="comment">#1 线程同步，主线程堵塞1s 然后主线程结束，子线程继续执行</span></span><br><span class="line">                        <span class="comment">#2 如果不设置timeout参数就等子线程结束主线程再结束</span></span><br><span class="line">                        <span class="comment">#3 如果设置了setDaemon=True和timeout=1主线程等待1s后会强制杀死子线程，然后主线程结束</span></span><br><span class="line">    print(<span class="string">'---主线程结束---'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main___'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="多线程交互访问数据，如果访问到了就不访问了"><a href="#多线程交互访问数据，如果访问到了就不访问了" class="headerlink" title="多线程交互访问数据，如果访问到了就不访问了"></a>多线程交互访问数据，如果访问到了就不访问了</h3><p>怎么避免重读？</p>
<p><strong>创建一个已访问数据列表，用于存储已经访问过的数据，并加上互斥锁</strong>，在多线程访问数据的时候先查看数据是否在已访问的列表中，若已存在就直接跳过。</p>
<h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul>
<li><p>并发（concurrency)：不会在同一时刻同时运行，存在交替执行的情况。（threading）</p>
</li>
<li><p>并行（parallel）： 同一时刻多个任务同时在运行（multiprocessing）</p>
</li>
</ul>
<p>程序需要执行较多的读写、请求和回复任务的需要大量的IO操作，IO密集型操作使用并发更好<strong>（I/O密集型 - 线程 - 并发）</strong></p>
<p>CPU运算量大的程序，使用并行会更好<strong>（CPU密集型 - 进程 - 并行）</strong></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h3><p>锁(Lock)是python提供的对线程控制的对象。<strong>有互斥锁，可重入锁，死锁</strong>。</p>
<ul>
<li>死锁：死锁是一个资源被多次调用，而多次调用方都未能释放该资源就会造成死锁</li>
<li>互斥锁：threading.Lock</li>
<li>可重入锁：threading.RLock，为了支持在<strong>同一线程中多次请求同一资源</strong>，python提供了“可重入锁”：threading.RLock。<strong>RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次acquire。</strong>直到一个线程所有的acquire都被release，其他的线程才能获得资源。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>若干子线程在<strong>系统资源竞争</strong>时，都在<strong>等待对方对某部分资源解除占用状态</strong>，结果是<strong>谁也不愿先解锁</strong>，互相干等着，程序无法执行下去，这就是死锁。</p>
<p>必要条件:</p>
<ol>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ol>
<p>处理死锁基本方法:</p>
<ol>
<li>预防死锁(摒弃除1以外的条件)</li>
<li><strong>避免死锁(银行家算法)</strong>：当一个进程申请使用资源的时候，银行家算法通过先 <strong>试探</strong> 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。</li>
<li>检测死锁(<strong>资源分配图</strong>)</li>
<li>解除死锁<ol>
<li><strong>剥夺资源</strong></li>
<li><strong>撤销进程</strong></li>
</ol>
</li>
</ol>
<p>死锁概念处理策略详细介绍:<a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html</a></p>
<p>一个死锁的例子：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_numbers</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"1"</span>)</span><br><span class="line">    s2.acquire()</span><br><span class="line">    print(<span class="string">"2"</span>)</span><br><span class="line">    s1.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_char</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"3"</span>)</span><br><span class="line">    s1.acquire()</span><br><span class="line">    print(<span class="string">"4"</span>)</span><br><span class="line">    s2.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 创建锁</span></span><br><span class="line">    s1 = Lock()</span><br><span class="line">    s2 = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建两个线程</span></span><br><span class="line">    t1 = Thread(name=<span class="string">"打印字符"</span>, target=print_numbers)</span><br><span class="line">    t2 = Thread(name=<span class="string">"打印字母"</span>, target=print_char)</span><br><span class="line">    s1.acquire()</span><br><span class="line">    s2.acquire()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="互斥锁、线程安全"><a href="#互斥锁、线程安全" class="headerlink" title="互斥锁、线程安全"></a>互斥锁、线程安全</h3><p><strong>每个对象</strong>都对应于一个可称为’互斥锁‘的标记，这个<strong>标记用来保证在任一时刻，只能有一个线程访问该对象。</strong></p>
<p>同一进程中的多线程之间是共享系统资源的，多个线程同时对一个对象进行操作，一个线程操作尚未结束，另一线程已经对其进行操作，导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。</p>
<h3 id="GIL锁-全局解释器锁"><a href="#GIL锁-全局解释器锁" class="headerlink" title="GIL锁 全局解释器锁"></a>GIL锁 全局解释器锁</h3><p>作用： 限制多线程同时执行，保证同一时间只有一个线程执行，所以cython里的多线程其实是伪多线程！</p>
<p>所以python里常常使用协程技术来代替多线程，协程是一种更轻量级的线程。</p>
<p>进程和线程的切换时由系统决定，而协程由我们程序员自己决定，而模块gevent下切换是遇到了耗时操作时才会切换</p>
<p>三者的关系：进程里有线程，线程里有协程。</p>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul>
<li><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反<strong>数据完整性</strong>的操作</p>
<p><strong>互斥锁、可重入锁都属于悲观锁。</strong>当你读取或者写入数据时，你都悲观地认为有别人正在改动数据，所以你希望在你 操作数据的时候上锁，防止别人改动。当然，当已经有别人上锁，你必须等待别人操作完毕。</p>
</li>
</ul>
<p>  悲观锁的业务流程:</p>
<blockquote>
<p>事务开始<br>查询、修改数据表之前 加锁<br>对数据库 操作<br>事务提交（检测、返回冲突）</p>
</blockquote>
<ul>
<li><p>乐观锁：假设不会发生并发冲突，只在<strong>提交操作时检查</strong>是否违反数据完整性。</p>
<p><strong>Redis的并发竞争解决方案</strong>，使用乐观锁，成本低，非阻塞，性能高。</p>
<p>每次去取数据的时候总认为不会有其他线程对数据进行修改，因此<strong>不会上锁</strong>，但是在更新时会判断其他线程在这之前有没有对数据进行修改。</p>
</li>
</ul>
<p>乐观锁与悲观锁的具体区别:</p>
<p> <a href="http://www.cnblogs.com/Bob-FD/p/3352216.html" target="_blank" rel="noopener">http://www.cnblogs.com/Bob-FD/p/3352216.html</a></p>
<p><a href="http://blog.csdn.net/chosen0ne/article/details/18093187" target="_blank" rel="noopener">http://blog.csdn.net/chosen0ne/article/details/18093187</a>)</p>
<h3 id="多线程共同操作同一个数据互斥锁同步？"><a href="#多线程共同操作同一个数据互斥锁同步？" class="headerlink" title="多线程共同操作同一个数据互斥锁同步？"></a>多线程共同操作同一个数据互斥锁同步？</h3><p>两个线程循环打印数字和字母</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/11/9 11:00 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: test.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_numbers</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">27</span>):</span><br><span class="line">        <span class="keyword">if</span> s1.acquire(): <span class="comment"># 判断是否得到锁</span></span><br><span class="line">            print(str(i))</span><br><span class="line">            s1.release() <span class="comment"># 释放锁</span></span><br><span class="line">            time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_char</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">65</span>, <span class="number">91</span>):</span><br><span class="line">        <span class="keyword">if</span> s1.acquire():</span><br><span class="line">            print(chr(i))</span><br><span class="line">            s1.release()</span><br><span class="line">            time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 创建锁</span></span><br><span class="line">    s1 = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建两个线程</span></span><br><span class="line">    t1 = Thread(name=<span class="string">"打印字符"</span>, target=print_numbers)</span><br><span class="line">    t2 = Thread(name=<span class="string">"打印字母"</span>, target=print_char)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></tbody></table></figure>
<h2 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h2><ol>
<li><p>先来先服务(FCFS, First Come First Serve)</p>
</li>
<li><p><strong>短作业优先</strong>(SJF, Shortest Job First)</p>
</li>
<li><p><strong>最高优先权调度</strong>(Priority Scheduling)</p>
</li>
<li><p><strong>时间片轮转</strong>(RR, Round Robin)：把CPU的时间分给各个任务用</p>
</li>
<li><p><strong>多级反馈队列调度</strong>(multilevel feedback queue scheduling)：能使优先级高的作业得到响应又能使短作业（进程）迅速完成。</p>
<p>对于优先级高的作业，首先执行；</p>
<p>对于优先级低的队列，采用时间片轮询的方法。</p>
</li>
</ol>
<p>常见的调度算法总结:<a href="http://www.jianshu.com/p/6edf8174c1eb" target="_blank" rel="noopener">http://www.jianshu.com/p/6edf8174c1eb</a></p>
<p>实时调度算法:</p>
<ol>
<li>最早截至时间优先 EDF</li>
<li>最低松弛度优先 LLF</li>
</ol>
<h2 id="程序编译与链接"><a href="#程序编译与链接" class="headerlink" title="程序编译与链接"></a>程序编译与链接</h2><p>推荐: <a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/11/compiler.html</a></p>
<p>Bulid过程可以分解为4个步骤:<strong>预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking)</strong></p>
<p>以c语言为例:</p>
<h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1 预处理"></a>1 预处理</h3><p><strong>预编译过程主要处理那些源文件中的以“#”开始的预编译指令</strong>，主要处理规则有：</p>
<ol>
<li>将所有的“<strong>#define</strong>”删除，并展开所用的宏定义</li>
<li>处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif”</li>
<li>处理“<strong>#include</strong>”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是<strong>递归</strong>进行的</li>
<li><strong>删除所有注释</strong></li>
<li><strong>添加行号和文件名标识</strong>，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号</li>
<li>保留所有的#pragma编译器指令。</li>
</ol>
<h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2 编译"></a>2 编译</h3><p>编译过程就是把预处理完的文件进行一系列的<strong>词法分析、语法分析、语义分析及优化</strong>后<strong>生成相应的汇编代码文件</strong>。这个过程是整个程序构建的核心部分。</p>
<h3 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3 汇编"></a>3 汇编</h3><p>汇编器是将<strong>汇编代码转化成机器可以执行的指令</strong>，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件<strong>成为目标文件</strong>(Object File)</p>
<h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4 链接"></a>4 链接</h3><p>链接的主要内容就是把<strong>各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。</strong><br>链接的主要过程包块地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。</p>
<h2 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h2><ul>
<li><p>静态链接方法：<strong>静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来</strong><br>静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库</p>
</li>
<li><p>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是<strong>直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址</strong>，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式<strong>使程序初始化时间较短，但运行期间的性能比不上静态链接的程序</strong></p>
</li>
</ul>
<h2 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h2><p>虚拟存储器是指具有<strong>请求调入</strong>功能和<strong>置换功能</strong>,能<strong>从逻辑上对内存容量加以扩充的一种存储系统.</strong></p>
<h2 id="分页和分段"><a href="#分页和分段" class="headerlink" title="分页和分段"></a>分页和分段</h2><p>分页: <strong>用户程序的地址空间被划分成若干固定大小的区域，称为“页”</strong>，相应地，<strong>内存空间分成若干个物理块，页和块的大小相等</strong>。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p>
<p>分段: 将用户程序地址空间分成<strong>若干个大小不等的段</strong>，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，<strong>段与段在内存中可以不相邻接，也实现了离散分配。</strong></p>
<h2 id="分页与分段的主要区别"><a href="#分页与分段的主要区别" class="headerlink" title="分页与分段的主要区别"></a>分页与分段的主要区别</h2><ol>
<li><p><strong>页是信息的物理单位</strong>,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于<strong>系统管理的需要</strong>.</p>
<p><strong>段是信息的逻辑单位</strong>,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,<strong>满足用户的需要</strong>.</p>
</li>
<li><p>页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是<strong>由机器硬件实现的</strong>.</p>
<p>而段的长度却不固定,决定于用户所编写的程序,通常由<strong>编译程序</strong>在对源程序进行编译时根据信息的性质来划分.</p>
</li>
<li><p>分页的作业地址空间是一维的.</p>
<p>分段的地址空间是二维的.</p>
</li>
</ol>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ol>
<li><strong>最佳置换算法OPT</strong>:不可能实现，选择的被淘汰的页面将是以后永不使用的，或是在最长（未来）时间内不再被访问的页面。采用最佳置换算法通常可保证<strong>最低的缺页率</strong>。</li>
<li><strong>先进先出FIFO</strong></li>
<li><strong>最近最久未使用算法LRU</strong>: 最近一段时间里最久没有使用过的页面予以置换.</li>
<li><strong>clock算法</strong></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Zh">
    <link itemprop="mainEntityOfPage" href="https://unknown.yuzhouwan.com/posts/23063/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Grace Koo">
      <meta itemprop="description" content="正在深入学习各种CV知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Grace Koo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/23063/" class="post-title-link" itemprop="url">Python进阶</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-31 23:00:01" itemprop="dateCreated datePublished" datetime="2020-01-31T23:00:01Z">2020-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-19 12:39:03" itemprop="dateModified" datetime="2020-10-19T12:39:03Z">2020-10-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>18 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="args-和-Kwargs"><a href="#args-和-Kwargs" class="headerlink" title="*args 和 **Kwargs"></a><strong>*args</strong> 和 **Kwargs</h1><ul>
<li>*args 是用来发送一个非键值对的可变数量的参数列表给一个函数</li>
<li>kwargs 允许你将不定长度的键值对, 作为参数传递给一个函数。 如果你想要在一个函 数里处理带名字的参数, 你应该使用kwargs。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_args_kwargs</span><span class="params">(arg1, arg2, arg3)</span>:</span></span><br><span class="line">    print(<span class="string">"arg1:"</span>, arg1)</span><br><span class="line">    print(<span class="string">"arg2:"</span>, arg2)</span><br><span class="line">    print(<span class="string">"arg3:"</span>, arg3)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Test *args</span></span><br><span class="line">args = (<span class="string">"two"</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">test_args_kwargs(*args)</span><br><span class="line"></span><br><span class="line">arg1: two</span><br><span class="line">arg2: <span class="number">3</span></span><br><span class="line">arg3: <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Test **kwargs</span></span><br><span class="line">kwargs = {<span class="string">"arg3"</span>: <span class="number">3</span>, <span class="string">"arg2"</span>: <span class="string">"two"</span>, <span class="string">"arg1"</span>: <span class="number">5</span>}</span><br><span class="line">test_args_kwargs(**kwargs)</span><br><span class="line">arg1: <span class="number">5</span></span><br><span class="line">arg2: two</span><br><span class="line">arg3: <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/23063/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Zh">
    <link itemprop="mainEntityOfPage" href="https://unknown.yuzhouwan.com/posts/6678/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Grace Koo">
      <meta itemprop="description" content="正在深入学习各种CV知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Grace Koo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/6678/" class="post-title-link" itemprop="url">计算机网络</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 23:55:00" itemprop="dateCreated datePublished" datetime="2020-01-30T23:55:00Z">2020-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 08:34:30" itemprop="dateModified" datetime="2020-11-19T08:34:30Z">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Basic/" itemprop="url" rel="index"><span itemprop="name">Computer Basic</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Basic/Interview/" itemprop="url" rel="index"><span itemprop="name">Interview</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>11 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ol>
<li>客户端通过向服务器端<strong>发送一个请求报文SYN</strong>来创建一个主动打开。</li>
<li>Server端接受连接后<strong>回复ACK报文</strong>，并为这次连接分配资源。</li>
<li>Client端接收到<strong>ACK报文</strong>后也向Server段发送报文，并分配资源，这样TCP连接就建立了。</li>
</ol>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 00.57.08.png" alt="Screen Shot 2020-11-08 at 00.57.08"></p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><em>注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.</em></p>
<ol>
<li>客户端发送一个<strong>FIN报文</strong>. 客户端进入 <strong>FIN-WAIT 状态</strong>. 该状态下客户端只接收数据, 不再发送数据.</li>
<li>服务器接收到带有 FIN = 1 的数据分段, 发送带有 <strong>ACK = 1 的剩余数据分段</strong>, 确认收到客户端发来的 FIN 信息.</li>
<li>服务器<strong>等到所有数据传输结束,</strong> 向客户端发送一个带有 <strong>FIN = 1 的数据分段</strong>, 并进入 <strong>CLOSE-WAIT 状态</strong>, 等待客户端发来带有 ACK = 1 的确认报文.</li>
<li>客户端收到服务器发来带有 FIN = 1 的报文, 返回 <strong>ACK = 1 的报文</strong>确认, <strong>为了防止服务器端未收到需要重发</strong>, 进入 <strong>TIME-WAIT</strong> 状态. 服务器接收到报文后关闭连接. 客户端等待 <strong>2MSL 后未收到回复, 则认为服务器成功关闭</strong>, 客户端关闭连接。</li>
</ol>
<blockquote>
<p> 注：MSL是报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。RFC规定为两分钟，实际应用中常用的是30秒，1分钟和2分钟。</p>
</blockquote>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 00.57.38.png" alt="Screen Shot 2020-11-08 at 00.57.38"></p>
<p>图解: <a href="http://blog.csdn.net/whuslei/article/details/6667471" target="_blank" rel="noopener">http://blog.csdn.net/whuslei/article/details/6667471</a></p>
<h2 id="七层网络模型"><a href="#七层网络模型" class="headerlink" title="七层网络模型"></a>七层网络模型</h2><p>网络通信的分层模型讲起：七层模型，也称OSI (Open System Interconnection)模型。</p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 11.56.48.png" alt="Screen Shot 2020-11-08 at 11.56.48"></p>
<h2 id="TCP和UDP对比"><a href="#TCP和UDP对比" class="headerlink" title="TCP和UDP对比"></a>TCP和UDP对比</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>TCP</th>
<th style="text-align:left">UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">是否连接</td>
<td>面向连接</td>
<td style="text-align:left">无连接，想发就发</td>
</tr>
<tr>
<td style="text-align:left">是否可靠</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
<td style="text-align:left">不可靠传输，不使用流量控制和拥塞控制</td>
</tr>
<tr>
<td style="text-align:left">连接对象个数</td>
<td>只能是一对一通信</td>
<td style="text-align:left">支持一对一，一对多，多对一和多对多交互通信</td>
</tr>
<tr>
<td style="text-align:left">传输方式</td>
<td>面向字节流</td>
<td style="text-align:left">面向报文</td>
</tr>
<tr>
<td style="text-align:left">首部开销</td>
<td>首部最小20字节，最大60字节</td>
<td style="text-align:left">首部开销小，仅8字节</td>
</tr>
<tr>
<td style="text-align:left">适用场景</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
<td style="text-align:left">适用于实时应用（IP电话、视频会议、直播等）</td>
</tr>
</tbody>
</table>
</div>
<p>总结</p>
<ul>
<li>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。</li>
<li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li>
<li>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</li>
</ul>
<h2 id="Socket-Ip-address-TCP-UDP-port"><a href="#Socket-Ip-address-TCP-UDP-port" class="headerlink" title="Socket(Ip address+ TCP/UDP + port)"></a>Socket(Ip address+ TCP/UDP + port)</h2><p><strong>套接字用于描述IP地址和端口，是一个通信链的句柄。</strong>应用程序通过套接字向网络发出请求或应答网络请求。注意的是套接字既不是程序也不是协议，只是<strong>操作系统提供给通信层的一组抽象API接口。</strong></p>
<p>Socket=Ip address+ TCP/UDP + port</p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.31.08.png" alt="Screen Shot 2020-11-08 at 15.31.08"></p>
<p>推荐: <a href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></p>
<p>使用Socket套接字需要传入哪些参数？</p>
<ul>
<li><p><strong>地址族(Address Family)</strong></p>
<p>地址族通常作为 socket() 函数的第一个参数。</p>
<p>socket.AF_INET 　IPv4地址族，(host, port) 形式的二元组，host是一个表示网络主机的字符串，port为套接字的端口号。AF_INET对应的数值是：2。</p>
<p>socket.AF_INET6 　(host, port, flowinfo, scopeid) 形式的四元组。AF_INET6对应的数值是：23。</p>
</li>
<li><p><strong>套接字类型（Type）</strong></p>
<p>套接字类型用于 socket() 函数的第二个参数。</p>
<p>但是只有 SOCK_STREAM （TCP）和 SOCK_DGRAM （UDP）是比较常见的。</p>
</li>
</ul>
<h2 id="怎么强行关闭客户端和服务器的连接"><a href="#怎么强行关闭客户端和服务器的连接" class="headerlink" title="怎么强行关闭客户端和服务器的连接"></a>怎么强行关闭客户端和服务器的连接</h2><ul>
<li><p>关闭TCP连接是指TCP协议层的东西，就是两个TCP端之间交换了一些协议包（FIN，RST等），具体的交换过程可以看TCP协议。</p>
</li>
<li><p>而关闭socket是指<strong>关闭用户应用程序中的socket句柄，释放相关资源</strong>。但是当用户<strong>关闭socket句柄时会隐含的触发TCP连接的关闭过程</strong>。</p>
</li>
</ul>
<p>TCP连接的关闭过程有两种，一种是<strong>优雅关闭</strong>（graceful close），一种是<strong>强制关闭</strong>（hard close或abortive close）</p>
<ul>
<li>优雅关闭是指，如果<strong>发送缓存</strong>中还有数据未发出则其发出去，<strong>并且收到所有数据的ACK之后，发送FIN包，开始关闭过程</strong>。</li>
<li>强制关闭是指如果<strong>缓存中</strong>还有数据，则这些数据都将被丢弃，然后发送<strong>RST</strong>包，直接重置TCP连接。</li>
</ul>
<p>shutdown函数，用于关闭TCP连接，但并不关闭socket句柄。</p>
<ul>
<li>SD_RECEIVE表明<strong>关闭接收通道</strong>，在该socket上不能再接收数据，如果当前接收缓存中仍有未取出数据或者<strong>以后再有数据到达，则TCP会向发送端发送RST包</strong>，将连接重置。</li>
<li>SD_SEND表明<strong>关闭发送通道</strong>，TCP会将发送缓存中的数据都发送完毕并<strong>收到所有数据的ACK后向对端发送FIN包</strong>，表明本端没有更多数据发送。这个是一个优雅关闭过程。</li>
<li>SD_BOTH则表示<strong>同时关闭接收通道和发送通道</strong>。</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1xx 报告</td>
<td style="text-align:left">接收到请求，继续进程</td>
</tr>
<tr>
<td style="text-align:left">2xx 成功</td>
<td style="text-align:left">步骤成功接收，被理解，并被接受</td>
</tr>
<tr>
<td style="text-align:left">3xx 重定向</td>
<td style="text-align:left">为了完成请求,必须采取进一步措施</td>
</tr>
<tr>
<td style="text-align:left">4xx 客户端出错</td>
<td style="text-align:left">请求包括错的顺序或不能完成</td>
</tr>
<tr>
<td style="text-align:left">5xx 服务器出错</td>
<td style="text-align:left">服务器无法完成显然有效的请求</td>
</tr>
</tbody>
</table>
</div>
<p>403: Forbidden<br>404: Not Found</p>
<h3 id="HTTP1-0和HTTP1-1"><a href="#HTTP1-0和HTTP1-1" class="headerlink" title="HTTP1.0和HTTP1.1"></a>HTTP1.0和HTTP1.1</h3><p>推荐: <a href="http://blog.csdn.net/elifefly/article/details/3964766" target="_blank" rel="noopener">http://blog.csdn.net/elifefly/article/details/3964766</a></p>
<p><strong>HTTP 1.0*规定浏览器与服务器只保持短暂的连接</strong>，浏览器的每次请求都需要与服务器建立一个<em>TCP</em>连接，服务器完成请求处理后立即断开<em>TCP</em>连接，服务器不跟踪每个客户也不记录过去的请求。</p>
<p><strong>HTTP1.1改进点</strong></p>
<ol>
<li><strong>支持了长链接</strong>：在一个<em>TCP</em>连接上可以传送多个<em>HTTP</em>请求和响应，减少了建立和关闭连接的消耗和延迟。</li>
<li><strong>HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求</strong>。但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</li>
<li><strong>增加请求头Host字段</strong>：一个服务器多个虚拟Web站点。</li>
<li><strong>身份认证,状态管理,Cache缓存等机制</strong>相关的请求头和响应头。</li>
</ol>
<h3 id="HTTP常见请求头与响应头"><a href="#HTTP常见请求头与响应头" class="headerlink" title="HTTP常见请求头与响应头"></a>HTTP常见请求头与响应头</h3><p>常见请求头：Request</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Accept</th>
<th>可接受的响应内容类型（<code>Content-Types</code>）。</th>
<th><code>Accept: text/plain</code></th>
<th>固定</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Charset</td>
<td>浏览器可接受的字符集</td>
<td><code>Accept-Charset: utf-8</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>可接受的响应内容的数据压缩格式</td>
<td><code>Accept-Encoding: gzip, deflate</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>可接受的响应内容语言列表。</td>
<td><code>Accept-Language: en-US</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Datetime</td>
<td>可接受的按照时间来表示的响应内容版本</td>
<td>Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT</td>
<td>临时</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>用来指定当前的请求/回复中的，是否使用缓存机制。</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>常见响应头：Response</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">响应头</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Age</td>
<td style="text-align:left">响应对象在代理缓存中存在的时间，以秒为单位</td>
<td style="text-align:left"><code>Age: 12</code></td>
<td style="text-align:left">固定</td>
</tr>
<tr>
<td style="text-align:left">Cache-Control</td>
<td style="text-align:left">通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒</td>
<td style="text-align:left"><code>Cache-Control: max-age=3600</code></td>
<td style="text-align:left">固定</td>
</tr>
</tbody>
</table>
</div>
<p><a href="https://itbilu.com/other/relate/EJ3fKUwUx.html" target="_blank" rel="noopener">https://itbilu.com/other/relate/EJ3fKUwUx.html</a></p>
<p><a href="https://juejin.im/post/6844903745004765198" target="_blank" rel="noopener">https://juejin.im/post/6844903745004765198</a></p>
<h3 id="HTTP协议以及协议头部中表示数据类型的字段"><a href="#HTTP协议以及协议头部中表示数据类型的字段" class="headerlink" title="HTTP协议以及协议头部中表示数据类型的字段"></a>HTTP协议以及协议头部中表示数据类型的字段</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Accept</th>
<th>可接受的响应内容类型（<code>Content-Types</code>）。</th>
<th><code>Accept: text/plain</code></th>
<th>固定</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Charset</td>
<td>浏览器可接受的字符集</td>
<td><code>Accept-Charset: utf-8</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>可接受的响应内容的数据压缩格式</td>
<td><code>Accept-Encoding: gzip, deflate</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>可接受的响应内容语言列表。</td>
<td><code>Accept-Language: en-US</code></td>
<td>固定</td>
</tr>
</tbody>
</table>
</div>
<h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><p>HTTP请求8种方法介绍<br>HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。</p>
<ol>
<li>GET</li>
</ol>
<p><strong>GET请求会显示请求指定的资源</strong>。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的幂等的操作中。</p>
<p>GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。</p>
<ol>
<li>HEAD</li>
</ol>
<p><strong>HEAD方法与GET方法一样，都是向服务器发出指定资源的请求</strong>。但是，服务器在响应HEAD请求时<strong>不会回传资源的内容部分，即：响应主体</strong>。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。</p>
<ol>
<li>POST</li>
</ol>
<p><strong>POST请求会向指定资源提交数据，请求服务器进行处理</strong>，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。<strong>POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。</strong></p>
<ol>
<li>PUT</li>
</ol>
<p><strong>PUT请求会身向指定资源位置上传其最新内容</strong>，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</p>
<ol>
<li>DELETE</li>
</ol>
<p><strong>DELETE请求用于请求服务器删除所请求URI</strong>（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。</p>
<ol>
<li>CONNECT</li>
</ol>
<p><strong>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器</strong>。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p>
<ol>
<li>OPTIONS</li>
</ol>
<p><strong>OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能</strong>。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许</p>
<ol>
<li>TRACE</li>
</ol>
<p><strong>TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。</strong></p>
<p>HTTP/1.1之后增加的方法</p>
<p>在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：</p>
<ol>
<li>PATCH</li>
</ol>
<p>PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：</p>
<p><strong>但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。</strong><br>当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。</p>
<h3 id="Post和Get"><a href="#Post和Get" class="headerlink" title="Post和Get"></a>Post和Get</h3><p><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html" target="_blank" rel="noopener">GET和POST有什么区别？及为什么网上的多数答案都是错的</a><br><a href="https://www.zhihu.com/question/31640769?rf=37401322" target="_blank" rel="noopener">知乎回答</a></p>
<p>get: <a href="http://tools.ietf.org/html/rfc2616#section-9.3" target="_blank" rel="noopener">RFC 2616 - Hypertext Transfer Protocol — HTTP/1.1</a><br>post: <a href="http://tools.ietf.org/html/rfc2616#section-9.5" target="_blank" rel="noopener">RFC 2616 - Hypertext Transfer Protocol — HTTP/1.1</a></p>
<p>HTTP协议用法的约定，使用上的区别：</p>
<ol>
<li><strong>GET使用URL或Cookie传参，而POST将数据放在BODY中。</strong></li>
<li><strong>GET方式提交的数据长度有限，而POST的数据则可以非常大。</strong>（这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。也不是GET和POST本身的区别。）</li>
<li><strong>POST比GET安全，因为数据在地址栏上不可见。</strong></li>
</ol>
<p>终极区别：</p>
<ol>
<li><strong>GET请求是满足幂等性的，POST请求不是。</strong>所以不应该且不能用get请求做数据的<strong>增删改</strong>这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用。</li>
</ol>
<blockquote>
<p>什么是幂等性？简单来说意味着对同一URL的多个请求应该返回同样的结果。</p>
</blockquote>
<h3 id="幂等-Idempotence"><a href="#幂等-Idempotence" class="headerlink" title="幂等 Idempotence"></a>幂等 Idempotence</h3><p><strong>HTTP方法的幂等性是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用</strong>。(注意是副作用)</p>
<p>1.、HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>2、GET：<strong>向特定的资源发出请求数据。（要数据）</strong><br>3、POST：<strong>向指定资源提交数据进行处理请求（给数据）</strong>（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。<br>4、PUT：向指定资源位置上传其最新内容。<br>5、DELETE：请求服务器删除Request-URI所标识的资源。 </p>
<p>如：</p>
<p><code>GET http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，<strong>这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。</strong><code>GET http://www.news.com/latest-news</code>这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，<strong>因而是满足幂等性的。</strong></p>
<p>DELETE方法用于删除资源，有副作用，但它<strong>应该满足幂等性</strong>。比如：<code>DELETE http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p>
<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：<code>POST http://www.forum.com/articles</code>的语义是在<code>http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，<strong>POST方法不具备幂等性</strong>。</p>
<p>PUT所对应的URI是要创建或更新的资源本身。比如：<code>PUT http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，<strong>PUT方法具有幂等性</strong>。</p>
<h3 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h3><p>HTTPS协议是由<strong>SSL+HTTP协议构建的可进行加密传输</strong>、身份认证的网络协议，要比http协议安全。(SSL: Secure Sockets Layer)</p>
<p>HTTPS和HTTP的区别主要如下：</p>
<ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li><p>http的连接很简单，<strong>是无状态的</strong>；HTTPS协议是由SSL+HTTP协议构建的<strong>可进行加密传输、身份认证的网络协议</strong>，比http协议安全。</p>
</li>
<li><p>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
</li>
</ol>
<h2 id="URL的形式"><a href="#URL的形式" class="headerlink" title="URL的形式"></a>URL的形式</h2><ul>
<li>定义</li>
</ul>
<p>URL(Uniform Resource Locator,统一资源定位符)，定义资源在网上唯一的地址。</p>
<ul>
<li>组成部分</li>
</ul>
<p>URL由三部分组成：资源类型、存放资源的主机域名、资源文件名</p>
<blockquote>
<p>protocol :// hostname[:port] / path / [;parameters][?query]#fragment</p>
</blockquote>
<ul>
<li>protocol(协议):</li>
</ul>
<p>file 资源是本地计算机上的文件。格式file:///，注意后边应是三个斜杠。</p>
<p>ftp 通过 FTP访问资源。格式 FTP://</p>
<p>http 通过 HTTP 访问该资源。 格式 </p>
<p>HTTP:// https 通过安全的 HTTPS 访问该资源。 格式 HTTPS://</p>
<p>mailto 资源为电子邮件地址，通过 SMTP 访问。 格式 mailto:</p>
<ul>
<li>hostname(主机名)</li>
</ul>
<p>是指存放资源的服务器的域名系统(DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式: username:password@hostname）。</p>
<ul>
<li>Path(路径)</li>
</ul>
<p>由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。parameters（参数）</p>
<ul>
<li>query（查询）</li>
</ul>
<p>可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//变量url即具有了url模块所提供的方法</span><br><span class="line">var url = require(<span class="string">'url'</span>);</span><br><span class="line">var queryUrl = <span class="string">"http://localhost:8888/bb?name=bigbear&amp;memo-helloworld"</span>;</span><br><span class="line">console.log(typeof url.parse(queryUrl));</span><br><span class="line">console.log(url.parse(queryUrl));</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">object</span><br><span class="line">Url {</span><br><span class="line">  protocol: <span class="string">'http:'</span>,</span><br><span class="line">  slashes: true,</span><br><span class="line">  auth: null,</span><br><span class="line">  host: <span class="string">'localhost:8888'</span>,</span><br><span class="line">  port: <span class="string">'8888'</span>,</span><br><span class="line">  hostname: <span class="string">'localhost'</span>,</span><br><span class="line">  hash: null,</span><br><span class="line">  search: <span class="string">'?name=bigbear&amp;memo-helloworld'</span>,</span><br><span class="line">  query: <span class="string">'name=bigbear&amp;memo-helloworld'</span>,</span><br><span class="line">  pathname: <span class="string">'/bb'</span>,</span><br><span class="line">  path: <span class="string">'/bb?name=bigbear&amp;memo-helloworld'</span>,</span><br><span class="line">  href: <span class="string">'http://localhost:8888/bb?name=bigbear&amp;memo-helloworld'</span> }</span><br></pre></td></tr></tbody></table></figure>
<h2 id="urllib和urllib2的区别"><a href="#urllib和urllib2的区别" class="headerlink" title="urllib和urllib2的区别"></a>urllib和urllib2的区别</h2><p>这个面试官确实问过,当时答的<strong>urllib2可以Post而urllib不可以</strong>.</p>
<ol>
<li>urllib提供<strong>urlencode</strong>方法用来<strong>GET查询字符串的产生</strong>，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li>
<li>urllib2可以接受一个<strong>Request类的实例来设置URL请求的headers，urllib仅可以接受URL</strong>。<strong>这意味着，你不可以伪装你的用户代理字符串等</strong>。</li>
</ol>
<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p><strong>地址解析协议(Address Resolution Protocol)</strong>，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，<strong>以保证通信的顺利进行</strong>。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被<strong>邻居发现协议（NDP）所替代</strong>（Neighbor Discovery Protocol）。</p>
<h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Cookie</th>
<th style="text-align:left">Session</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">储存位置</td>
<td style="text-align:left">客户端</td>
<td style="text-align:left">服务器端</td>
</tr>
<tr>
<td style="text-align:left">目的</td>
<td style="text-align:left">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td>
<td style="text-align:left">跟踪会话</td>
</tr>
<tr>
<td style="text-align:left">安全性</td>
<td style="text-align:left">不安全</td>
<td style="text-align:left">安全</td>
</tr>
</tbody>
</table>
</div>
<p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p>
<h2 id="apache和nginx的区别（Web服务器）"><a href="#apache和nginx的区别（Web服务器）" class="headerlink" title="apache和nginx的区别（Web服务器）"></a>apache和nginx的区别（Web服务器）</h2><p>nginx 相对 apache 的优点：</p>
<ul>
<li><strong>轻量级</strong>，同样起web 服务，比apache 占用更少的内存及资源</li>
<li><strong>抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接</strong>，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能</li>
<li><strong>配置简洁</strong></li>
<li>高度模块化的设计，编写模块相对简单</li>
<li>社区活跃</li>
</ul>
<p>apache 相对nginx 的优点：</p>
<ul>
<li><p><strong>rewrite ，比nginx 的rewrite 强大</strong></p>
</li>
<li><p><strong>模块超多</strong>，基本想到的都可以找到</p>
</li>
<li><p><strong>少bug</strong> ，nginx 的bug 相对较多</p>
</li>
<li><p><strong>超稳定</strong></p>
</li>
</ul>
<h2 id="网站用户密码保存"><a href="#网站用户密码保存" class="headerlink" title="网站用户密码保存"></a>网站用户密码保存</h2><ol>
<li><strong>明文保存</strong>在数据库中</li>
<li><strong>明文hash后保存,如MD5</strong></li>
<li><strong>MD5+Salt方式,这个Salt可以随机</strong></li>
<li>知乎使用了Bcrypy(好像)加密</li>
</ol>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>推荐: <a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p>
<p>304 Not Modified</p>
<p>浏览器缓存机制，其实<strong>主要就是HTTP协议定义的缓存机制</strong>（如：Expires；Cache-control等）</p>
<p>但是也有非HTTP协议定义的缓存机制。</p>
<p><strong>一、非HTTP协议定义的缓存机制</strong></p>
 <figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">"Pragma"</span> <span class="attr">CONTENT</span>=<span class="string">"no-cache"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有<strong>缓存代理服务器都不支持，因为代理不解析HTML内容本身。</strong></p>
<p><strong>二、HTTP协议定义的缓存机制</strong></p>
<ol>
<li><p>Expires策略:  是Web服务器响应消息头字段，在响应http请求时告诉<strong>浏览器在过期时间前</strong>浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.41.48.png" alt="Screen Shot 2020-11-08 at 15.41.48"></p>
</li>
<li><p>Cache-control策略:Cache-Control与Expires的作用一致，都是指明当前资源的<strong>有效期</strong>，控制浏览器<strong>是否直接从浏览器缓存取数据还是重新发请求到服务器取数据</strong>。只不过Cache-Control的<strong>选择更多，设置更细致</strong>，如果同时设置的话，其<strong>优先级高于</strong>Expires。</p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.42.01.png" alt="Screen Shot 2020-11-08 at 15.42.01"></p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.42.14.png" alt="Screen Shot 2020-11-08 at 15.42.14"></p>
</li>
</ol>
<h2 id="CSRF和XSS"><a href="#CSRF和XSS" class="headerlink" title="CSRF和XSS"></a>CSRF和XSS</h2><ul>
<li><strong>CSRF(Cross-site request forgery)跨站请求伪造</strong>：<strong>网站过分信任用户</strong>，放任来自所谓通过访问控制机制的代表合法用户的请求执行网站的某个特定功能。</li>
<li><strong>XSS(Cross Site Scripting)跨站脚本攻击：用户过分信任网站</strong>，放任来自来自浏览器地址代表的那个网站代码在自己本地任意执行。如果没有浏览器的安全机制限制，XSS代码可以在用户浏览器为所欲为。</li>
</ul>
<p>CSRF重点在<strong>请求</strong>,XSS重点在<strong>脚本</strong></p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p><strong>RPC（Remote Procedure Call Protocol）——远程过程调用协议</strong>。</p>
<p>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。<strong>RPC是一个分布式计算的CS模式，总是由Client向Server发出一个执行若干过程请求，Server接受请求，使用客户端提供的参数，计算完成之后将结果返回给客户端。</strong></p>
<p><strong>RPC是面向过程，Restful是面向资源</strong>，并且使用了Http动词。从这个维度上看，Restful风格的url在表述的精简性、可读性上都要更好。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RPC风格</span></span><br><span class="line">/queryOrder?orderId=123</span><br><span class="line"></span><br><span class="line"><span class="comment"># Restful风格</span></span><br><span class="line">Get  </span><br><span class="line">/order/<span class="number">123</span></span><br></pre></td></tr></tbody></table></figure>
<p>RPC原理：</p>
<p>比如 A (client) 调用 B (server) 提供的<code>remoteAdd</code>方法：</p>
<ol>
<li>首先A与B之间建立一个TCP连接；</li>
<li>然后A把需要调用的方法名（这里是remoteAdd）以及方法参数（10， 20）<strong>序列化成字节流发送出去；</strong></li>
<li>B接受A发送过来的字节流，然后<strong>反序列化得到目标方法名，方法参数</strong>，接着执行相应的方法调用（可能是localAdd）并把结果30返回；</li>
<li>A接受远程调用结果,输出30。</li>
</ol>
<p><strong>进化的顺序: RPC -&gt; SOAP -&gt; RESTful</strong></p>
<h2 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h2><ol>
<li>SOAP（原为<strong>Simple Object Access Protocol</strong>的首字母缩写，即<strong>简单对象访问协议</strong>）是交换数据的一种协议规范，<strong>使用在计算机网络Web服务（web service）中</strong>，交换带结构信息。</li>
<li>SOAP为了简化<strong>网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间</strong>。不同应用程序之间按照<strong>HTTP通信协议，遵从XML格式执行资料互换</strong>，使其抽象于语言实现、平台和硬件。</li>
</ol>
<h2 id="RESTful架构-SOAP-RPC"><a href="#RESTful架构-SOAP-RPC" class="headerlink" title="RESTful架构(SOAP,RPC)"></a>RESTful架构(SOAP,RPC)</h2><p>推荐: <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>
<p>Representational State Transfer：表现层状态转移</p>
<p>RESTful架构，<strong>就是目前最流行的一种互联网软件架构</strong>。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p>
<p>总结一下什么是RESTful架构：</p>
<p>（1）<strong>每一个URI代表一种资源；</strong></p>
<p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p>
<p>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”<strong>表现层状态转化</strong>“。</p>
<h2 id="CGI和WSGI"><a href="#CGI和WSGI" class="headerlink" title="CGI和WSGI"></a>CGI和WSGI</h2><ul>
<li><p>CGI(Common Gateway Interface)是<strong>通用网关接口</strong>，是连接web服务器和应用程序的接口，用户通过CGI来获取<strong>动态数据或文件</strong>等。<br>CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。</p>
</li>
<li><p>WSGI(Web Server Gateway Interface)<strong>Web服务器网关接口</strong>，是<strong>Python应用程序或框架和Web服务器</strong>之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p>
<p>它不是服务器,也不是python模块,<strong>它是一种规范,描述Web服务器和应用之间的交互</strong>.通俗来讲, 它就是一条纽带,连接着Web服务器和应用。</p>
</li>
</ul>
<p>官方说明：<a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">PEP-3333</a></p>
<h2 id="简述浏览器通过WSGI请求动态资源的过程"><a href="#简述浏览器通过WSGI请求动态资源的过程" class="headerlink" title="简述浏览器通过WSGI请求动态资源的过程"></a>简述浏览器通过WSGI请求动态资源的过程</h2><ul>
<li>静态服务器加载的是一个静态html页面，或是存在服务器中的静态数据。</li>
<li><p>动态服务器是，当客户端发送一个请求，<strong>服务器拿到这个请求找到相关的程序代码执行，将执行结果返回给客户端的一个过程</strong></p>
</li>
<li><p>WSGI</p>
<p>怎么在你刚刚建立的web服务器上运行一个Django应用和一个Flask应用呢。如何做不做任何改变而适应不同的web架构呢：WSGI</p>
</li>
</ul>
<ol>
<li>浏览器发送http请求动态资源给web服务器（flask）</li>
<li>web服务器收到请求后<strong>通过WSGI调用一个属性给应用程序框架</strong></li>
<li>应用程序框架通过引用WSGI调用Web服务器，<strong>设置返回的状态和头信息</strong></li>
<li>调用后返回，此时Web服务器保存了刚刚设置的信息</li>
<li><strong>应用程序查询数据库，生成动态页面的body信息</strong></li>
<li><strong>把生成的body信息返回给Web服务器</strong></li>
<li>Web服务器把数据返回给浏览器</li>
</ol>
<p><img data-src="/images/data/截屏2020-11-17 16.52.08.png" alt="截屏2020-11-17 16.52.08"></p>
<h2 id="WSGI与Flask之间的关系"><a href="#WSGI与Flask之间的关系" class="headerlink" title="WSGI与Flask之间的关系"></a>WSGI与Flask之间的关系</h2><ol>
<li>使用<code>app.run()</code>方法来启动flask应用（<code>app.run()</code>代码隐藏着创建一个服务器），<strong>app应用本身会作为参数传递到WSGI服务器中</strong>。</li>
<li>在客户端（这里就是浏览器）输入网址（发送一个请求），服务器使用WSGI 中间件来处理这个请求。</li>
<li>WSGI 处理请求对应着<code>wsgi_app(self, environ, start_response)</code>方法，<code>self</code>参数对应着<code>app</code>，即flask程序；<code>environ</code>和 <code>start_response</code>由服务器提供。</li>
<li><code>wsgi_app()</code>作用就是调用各种请求处理函数来处理请求，然后返回处理结果。即用户输入网址后，看到了网页响应。</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)  </span><br><span class="line"><span class="comment">#生成app实例，传递 __name__参数，__name__ 就是当前模块名字。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"2017-08-21"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://blog.csdn.net/sinat_36651044/article/details/77462831" target="_blank" rel="noopener">https://blog.csdn.net/sinat_36651044/article/details/77462831</a></p>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>在<strong>GFW(Great Firewall: 中国国家防火墙)</strong>里屡见不鲜的,呵呵.</p>
<p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指<strong>攻击者与通讯的两端分别创建独立的联系</strong>，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p>
<h2 id="c10k问题"><a href="#c10k问题" class="headerlink" title="c10k问题"></a>c10k问题</h2><p>所谓<strong>c10k</strong>问题，指的是<strong>服务器同时支持成千上万个客户端</strong>的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。</p>
<p>解决方法：</p>
<ol>
<li><strong>每个连接分配一个独立的线程/进程</strong>：该思路最为直接，但是申请进程/线程是需要系统资源的，且系统需要管理这些进程/线程，所以<strong>会使资源占用过多，可扩展性差</strong></li>
<li><strong>同一个线程/进程同时处理多个连接（I/O多路复用）</strong>：select方式、poll方式、epoll方式、异步I/O以及Windows</li>
</ol>
<p><a href="https://my.oschina.net/xianggao/blog/664275" target="_blank" rel="noopener">https://my.oschina.net/xianggao/blog/664275</a></p>
<p><a href="https://www.jianshu.com/p/ba7fa25d3590" target="_blank" rel="noopener">C10K问题及其解决方法</a></p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>AJAX(Asynchronous JavaScript and XML)（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与<strong>服务器交换数据并更新部分网页的技术</strong>。</p>
<h2 id="描述用浏览器访问www-baidu-com的过程"><a href="#描述用浏览器访问www-baidu-com的过程" class="headerlink" title="描述用浏览器访问www.baidu.com的过程"></a>描述用浏览器访问www.baidu.com的过程</h2><ol>
<li>浏览器获取用户输入的域名：www.baidu.com</li>
<li><p>浏览器<strong>向域名解析器DNS获取www.baidu.com的IP地址</strong></p>
</li>
<li><p>DNS解析出IP地址</p>
</li>
<li>浏览器与服务器<strong>建立TCP连接</strong>（默认端口号80）</li>
<li><p><strong>浏览器发出HTTP请求</strong>，请求百度页面</p>
</li>
<li><p><strong>服务器通过HTTP响应</strong>把首页内容发送给浏览器</p>
</li>
<li><p>TCP连接释放</p>
</li>
<li><strong>浏览器解析首页文件</strong>，并将WEB页面显示给用户</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Zh">
    <link itemprop="mainEntityOfPage" href="https://unknown.yuzhouwan.com/posts/22488/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Grace Koo">
      <meta itemprop="description" content="正在深入学习各种CV知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Grace Koo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/22488/" class="post-title-link" itemprop="url">数据库基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-29 23:55:00" itemprop="dateCreated datePublished" datetime="2020-01-29T23:55:00Z">2020-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 08:34:52" itemprop="dateModified" datetime="2020-11-19T08:34:52Z">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Basic/" itemprop="url" rel="index"><span itemprop="name">Computer Basic</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Basic/Interview/" itemprop="url" rel="index"><span itemprop="name">Interview</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>8.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>数据库事务(Database Transaction) ，是指为访问并可能操作各个数据项的<strong>一个数据库操作序列，这些操作要么全部执行，要么全部不执行</strong>，是一个不可分割的工作单位。事务由事务开始与结束之间执行的全部数据库操作组成。</p>
<p>如：我们去银行转账，操作可能分为以下两个环节：</p>
<p>（1）从第一个账户划出款项</p>
<p>（2）将款项存入第二个账户</p>
<p>这两个环节是关联的，如果第二个环节没有完成，那么所有的环节都应该取消。</p>
<p>性质：</p>
<p>A：原子性（Atomicity）事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全部不执行。</p>
<p>C：一致性（Consistency）几个并行执行的事务，其执行结果必须与按某一顺序 串行执行的结果相一致。</p>
<p>I：隔离性（Isolation）事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。</p>
<p>D：持久性（Durability）对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。</p>
<p>彻底理解数据库事务: <a href="http://www.hollischuang.com/archives/898" target="_blank" rel="noopener">http://www.hollischuang.com/archives/898</a></p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="主键-超键-候选键-外键"><a href="#主键-超键-候选键-外键" class="headerlink" title="主键 超键 候选键 外键"></a>主键 超键 候选键 外键</h3><ul>
<li><p><strong>主键</strong>：指的是<strong>一个列或多列的组合，其值能唯一地标识表中的每一行</strong>，通过它可强制表的实体完整性。主键主要是用与其他表的外键关联，以及本记录的修改与删除。</p>
<p>身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。 所以，选取主键的一个基本原则是：<strong>不使用任何业务相关的字段作为主键</strong>。 因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。</p>
</li>
<li><p><strong>外键</strong>：关系模式R1中的某属性集不是R1的主键，而是另一个<strong>关系R2的主键</strong>则该属性集是关系模式<strong>R1的外键</strong>。</p>
</li>
<li><p><strong>超键</strong>：<strong>在关系中能唯一标识元组的属性集称为关系模式的超键</strong>。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。<strong>超键包含候选键和主键。</strong></p>
</li>
<li><p><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</p>
</li>
</ul>
<p>例子：</p>
<blockquote>
<p>假设有如下两个表：</p>
<p>学生（学号，姓名，性别，身份证号，教师编号）</p>
<p>教师（教师编号，姓名，工资）</p>
</blockquote>
<p><strong>超键：</strong></p>
<p>由超键的定义可知，学生表中含有学号或者身份证号的任意组合都为此表的超键。如：（学号）、（学号，姓名）、（身份证号，性别）等。</p>
<p><strong>候选键：</strong></p>
<p>候选键属于超键，它是最小的超键，就是说如果再去掉候选键中的任何一个属性它就不再是超键了。学生表中的候选键为：（学号）、（身份证号）。</p>
<p><strong>主键：</strong></p>
<p>主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，教师表中让“教师编号”做主键。</p>
<p><strong>外键：</strong></p>
<p>外键比较简单，学生表中的外键就是“教师编号”。外键主要是用来描述两个表的关系。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li>索引是关系数据库中对<strong>某一列或多个列的值进行预排序的数据结构</strong>。通过使用索引，可以让数据库系统不必扫描整个表，而是<strong>直接定位到符合条件的记录，这样就大大加快了查询速度。</strong></li>
</ul>
<p>索引的效率<strong>取决于索引列的值是否散列</strong>，即该<strong>列的值如果越不相同，那么索引效率越高</strong>。反过来，如果记录的列存在大量相同的值。例如gender列，那对该列创建索引就没有意义。</p>
<p>例如：创建名称为idx_score，使用列score的索引。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_score (score)</span><br></pre></td></tr></tbody></table></figure>
<p>推荐:<a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1218728442198976" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1177760294764384/1218728442198976</a></p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p>
<p>聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理</p>
<ul>
<li>数据库索引，<strong>是数据库管理系统中一个排序的数据结构，以协助快速查询</strong>，更新数据库表中数据。索引的实现通常使用<strong>B树($O(Log_2N)$)以其变种B+树</strong>。</li>
</ul>
<p>在数据之外，数据库系统还维护着<strong>满足特定查找算法的数据结构</strong>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。<strong>这种数据结构，就是索引</strong>。</p>
<p>为表设置索引要付出代价的：<strong>一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间（因为索引也要随之变动）</strong></p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul>
<li><strong>视图是虚拟的表，主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</strong>隐藏具体的细节，保护数据; 视图创建后，可以使用与表相同的方式利用它们。</li>
</ul>
<p>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by则对视图再次order by将被覆盖。</p>
<blockquote>
<p>创建视图： create view xxx as xxxxxx</p>
</blockquote>
<p>优点：</p>
<ol>
<li>使用视图，可以定制用户数据，聚焦特定的数据。</li>
<li>使用视图，可以简化数据操作。</li>
<li>使用视图，基表中的数据就有了一定的安全性</li>
</ol>
<p><a href="https://www.jianshu.com/p/6a2c7407be4c" target="_blank" rel="noopener">https://www.jianshu.com/p/6a2c7407be4c</a></p>
<h3 id="drop-truncate-delete的区别"><a href="#drop-truncate-delete的区别" class="headerlink" title="drop, truncate, delete的区别"></a>drop, truncate, delete的区别</h3><ul>
<li><p>drop直接删掉表</p>
</li>
<li><p>truncate删除表中数据，<strong>再插入时自增长id又从1开始</strong></p>
<p>truncate table则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，<strong>删除行是不能恢复的</strong>。并且在删除的过程中不会激活与表有关的删除触发器，执行速度快；</p>
</li>
<li><p>delete删除表中数据，<strong>可以加where字句</strong></p>
<p>delete 语句执行删除的过程是<strong>每次从表中删除一行</strong>，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。</p>
</li>
</ul>
<ol>
<li><p>表和索引所占空间：drop语句将表所占用的空间全释放掉；当表被truncate后，这个表和索引所占用的空间会恢复到初始大小，而delete操作不会减少表或索引所占用的空间。</p>
</li>
<li><p>一般而言，drop&gt;truncate&gt;delete</p>
</li>
<li><p>应用范围。truncate只能对table，delete可以是table和view</p>
</li>
<li><p>truncate和delete只删除数据，而drop则删除整个表<strong>（结构和数据)</strong></p>
</li>
<li><p>truncate与不带where的delete:只删除数据，<strong>而不删除表的结构（定义）</strong>drop语句将删除表的结构被依赖的<strong>约束(constrain),触发器（trigger)索引(index)</strong>;依赖于该表的存储过程/函数将被保留，但其状态会变为:invalid.</p>
</li>
</ol>
<h3 id="连接的种类：内连接、外连接、交叉连接"><a href="#连接的种类：内连接、外连接、交叉连接" class="headerlink" title="连接的种类：内连接、外连接、交叉连接"></a>连接的种类：内连接、外连接、交叉连接</h3><p>join_type 指出连接类型。join_condition指连接条件。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM  join_table join_type join_table[ON (join_condition)]</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><strong>内连接（inner join）</strong>：使用比较运算符（包括=、&gt;、&lt;、&lt;&gt;、&gt;=、&lt;=、!&gt;和!&lt;）进行表间的比较操作，查询与连接条件相匹配的数据</p>
<ul>
<li>等值连接（=）</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_student s, T_class c <span class="keyword">where</span> s.classID = c.classID</span><br><span class="line">等于</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_student s <span class="keyword">inner</span> <span class="keyword">join</span> T_class <span class="keyword">on</span> s.classID = c.classID</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>自然连接：与等值相同，<strong>但是会删除表中的重复列</strong></li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.*,c.className <span class="keyword">from</span> T_student s <span class="keyword">inner</span> <span class="keyword">join</span> T_class c <span class="keyword">on</span> s.classId = c.classId</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>不等连接（&lt;, &gt;, &lt;&gt;, &gt;=, &lt;=, !&gt;, !&lt;）</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_student s <span class="keyword">inner</span> <span class="keyword">join</span> T_class c <span class="keyword">on</span> s.classId &lt;&gt; c.classId</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><strong>外连接</strong>（left join、right join、full join）</p>
<ul>
<li><p><strong>左连接</strong>（LEFT JOIN）：返回左表中的所有行，如果左表中行在右表中没有匹配行，则结果中右表中的列返回空值。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span>  T_student s <span class="keyword">left</span> <span class="keyword">join</span> T_class c <span class="keyword">on</span> s.classId = c.classId</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>左外连接（LEFT OUTER JOIN）:</p>
</li>
<li><p><strong>右连接</strong>（RIGHT JOIN）: 与左连接相反</p>
</li>
<li><p>右外连接（RIGHT OUTER JOIN）</p>
</li>
<li><p><strong>全连接</strong>（FULL JOIN）: 返回左表和右表中的所有行。当某行在另一表中没有匹配行，则另一表中的列返回空值</p>
</li>
<li><p>全外连接（FULL OUTER JOIN）</p>
</li>
</ul>
</li>
<li><p><strong>交叉连接</strong>：笛卡尔积（cross join）</p>
<p>不带WHERE条件子句，<strong>它将会返回被连接的两个表的笛卡尔积</strong>，返回结果的行数等于两个表行数的乘积（例如：T_student和T_class，返回4*4=16条记录）；如果带where，返回或显示的是匹配的行数。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_student s <span class="keyword">cross</span> <span class="keyword">join</span> T_class c <span class="keyword">where</span> s.classId = c.classId</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="存储过程与触发器的区别"><a href="#存储过程与触发器的区别" class="headerlink" title="存储过程与触发器的区别"></a>存储过程与触发器的区别</h3><ul>
<li>存储过程：用户调用的时候才会执行</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 创建的存储过程名字(<span class="keyword">OUT</span>|<span class="keyword">IN</span>|INOUT 参数名 数据类型,...,...) 特征 过程体</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>触发器：对表进行诸如UPDATE、INSERT、DELETE等时，<strong>SqlServer自动执行触发器定义的SQL语句</strong>，通过事件触发</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 创建的触发器名字 BEFFOR|<span class="keyword">AFTER</span>  <span class="keyword">INSERT</span>|<span class="keyword">UPDATE</span>|<span class="keyword">DELETE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> 表名字 <span class="keyword">FOR</span>  触发器的执行间隔   触发器的<span class="keyword">SQL</span>语句</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数据库优化的思路"><a href="#数据库优化的思路" class="headerlink" title="数据库优化的思路"></a>数据库优化的思路</h3><ol>
<li><p>SQL语句优化</p>
<ul>
<li>应尽量避免在 where 子句中对字段进行 <strong>null 值</strong>判断，否则将导致<strong>引擎放弃使用索引而进行全表扫描</strong></li>
<li>应尽量避免在 where 子句中使用<strong>!=或&lt;&gt;操作符</strong>，否则将<strong>引擎放弃使用索引而进行全表扫描</strong></li>
</ul>
</li>
<li><p>索引优化</p>
<ul>
<li>创建索引：<strong>对经常需要搜索的列上</strong>，可以加快搜索的速度；<strong>在经常需要排序的列上创建索引</strong>，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>
<li>不应该创建索引：对于那些在查询中很少使用或者参考的列不应该创建索引；当修改性能远远大于检索性能时，不应该创建索引</li>
</ul>
</li>
<li><p>数据库结构优化</p>
<ul>
<li>范式优化：消除冗余（节省空间）</li>
<li>反范式优化：适当增加冗余（减少join）</li>
</ul>
</li>
<li><p>服务器硬件优化</p>
<p>花钱</p>
</li>
</ol>
<p><a href="https://www.jishuchi.com/read/mysql-interview/2810" target="_blank" rel="noopener">https://www.jishuchi.com/read/mysql-interview/2810</a></p>
<h3 id="MySQL引擎：InnoDB、MyIASM和MEMORY"><a href="#MySQL引擎：InnoDB、MyIASM和MEMORY" class="headerlink" title="MySQL引擎：InnoDB、MyIASM和MEMORY"></a>MySQL引擎：InnoDB、MyIASM和MEMORY</h3><p>MySQL支持三个引擎：InnoDB、MyIASM和MEMORY</p>
<p><strong>InnoDB 和 MyISAM之间的区别：</strong></p>
<ul>
<li><p>两者索引<strong>都使用B+树</strong>，InnoDB是MySQL默认的存储引擎</p>
</li>
<li><p>InnoDB<strong>支持事务</strong>，而MyISAM不支持事务</p>
</li>
<li>InnoDB<strong>支持外键</strong>，而MyISAM不支持</li>
<li>InnoDB<strong>支持MVCC,</strong> 而MyISAM不支持</li>
<li>InnoDB<strong>不支持全文索引</strong>，而MyISAM支持</li>
</ul>
<p><strong>InnoDB</strong> ：如果要提供提交、回滚、崩溃恢复的事务安全能力，用InnoDB</p>
<p><strong>MyISAM</strong>：如果数据表主要用来<strong>插入和查询</strong>记录，MyISAM能提供较高的处理速度</p>
<p><strong>MEMORY：</strong>如果只是临时存放数据，数据量不大，不需要较高的安全性，可以选择将数据保存在内存中的MEMORY引擎</p>
<p>mysql 数据库引擎: <a href="http://www.cnblogs.com/0201zcr/p/5296843.html" target="_blank" rel="noopener">http://www.cnblogs.com/0201zcr/p/5296843.html</a><br>MySQL存储引擎－－MyISAM与InnoDB区别: <a href="https://segmentfault.com/a/1190000008227211" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008227211</a></p>
<h3 id="？-MySQL的innodb引擎是如何实现MVCC的"><a href="#？-MySQL的innodb引擎是如何实现MVCC的" class="headerlink" title="？ MySQL的innodb引擎是如何实现MVCC的"></a>？ <a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">MySQL</a>的innodb引擎是如何实现MVCC的</h3><blockquote>
<p>​    全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，<strong>每个读操作会看到一个一致性的snapshot</strong>，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。</p>
</blockquote>
<p>innodb会为每一行添加两个字段，分别表示该行<strong>创建的版本</strong>和<strong>删除的版本</strong>，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（<a href="http://blog.csdn.net/chosen0ne/article/details/10036775" target="_blank" rel="noopener">事务的隔离级别请看这篇文章</a>）下，具体各种数据库操作的实现：</p>
<ul>
<li>select：满足以下两个条件innodb会返回该行数据：<ul>
<li>该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。</li>
<li>该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。</li>
</ul>
</li>
<li>insert：将新插入的行的创建版本号设置为当前系统的版本号。</li>
<li>delete：将要删除的行的删除版本号设置为当前系统的版本号。</li>
<li>update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。</li>
</ul>
<p>其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。</p>
<p>​    由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。</p>
<p>通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。</p>
<h3 id="MySQL怎么限制IP访问？"><a href="#MySQL怎么限制IP访问？" class="headerlink" title="MySQL怎么限制IP访问？"></a>MySQL怎么限制IP访问？</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> priviledge <span class="keyword">on</span> <span class="string">"*"</span> <span class="keyword">to</span> <span class="string">"用户名@ip地址"</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">"数据库密码"</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'admin@192.168.0.1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改密码</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> <span class="keyword">for</span> <span class="string">'admin@192.168.0.1'</span> = <span class="keyword">password</span>(<span class="string">"admin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权：只有来自192.168.0.1的用户才能通过admin访问服务器</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> priviledges <span class="keyword">on</span> <span class="string">"*"</span> <span class="keyword">to</span> <span class="string">"admin@192.168.0.1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line"><span class="keyword">flush</span> priviledges</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h3><ol>
<li>是一个完全开源免费的<strong>key-value内存数据库</strong> </li>
<li>通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets</li>
</ol>
<h3 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h3><blockquote>
<p>​    通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用<strong>来处理高并发的数据库操作</strong></p>
</blockquote>
<ul>
<li>速度快：使用标准C写，<strong>所有数据都在内存中完成</strong>，读写速度分别达到10万/20万 </li>
<li>持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof) </li>
<li>自动操作：对不同数据类型的操作都是自动的，很安全 </li>
<li><strong>快速的主—从复制</strong>，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。 </li>
<li>Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。</li>
</ul>
<h3 id="Redis缺点"><a href="#Redis缺点" class="headerlink" title="Redis缺点"></a>Redis缺点</h3><ul>
<li><strong>是数据库容量受到物理内存的限制,</strong> 不能用作海量数据的高性能读写, 因此Redis适合的场景主要<strong>局限在较小数据量的高性能操作和运算上。</strong></li>
<li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h3 id="Redis宕机怎么解决"><a href="#Redis宕机怎么解决" class="headerlink" title="Redis宕机怎么解决"></a>Redis宕机怎么解决</h3><p>宕机:服务器停止服务</p>
<p><strong>如果只有一台redis，肯定会造成数据丢失，无法挽救</strong></p>
<p>多台redis或者是redis集群，宕机则需要分为在主从模式下区分来看：</p>
<ul>
<li><p>slave从redis宕机：配置主从复制的时候才配置从的redis，从的会从主的redis中读取主的redis的操作日志，在redis中从库重新启动后会自动加入到主从架构中，自动完成同步数据;</p>
</li>
<li><p>主redis宕机：如果从数据库实现了持久化，此时千万不要立马重启服务，否则可能会造成数据丢失，正确的操作如下：<strong>在slave</strong>数据上执行SLAVEOF ON ONE, <strong>来断开主从关系并把slave升级为主库</strong>，此时重新启动主数据库，执行SLAVEOF，<strong>把主库设置为从库</strong>，连接到主的redis上面做主从复制，自动备份数据。</p>
</li>
</ul>
<p>以上过程很容易配置错误，可以使用redis提供的哨兵机制来简化上面的操作。简单的方法: <strong>redis的哨兵(sentinel)</strong>的功能</p>
<h3 id="Redis和mecached的区别，以及使用场景"><a href="#Redis和mecached的区别，以及使用场景" class="headerlink" title="Redis和mecached的区别，以及使用场景"></a>Redis和mecached的区别，以及使用场景</h3><p>总结</p>
<p>都是内存数据库</p>
<p>redis挂掉后会备份，并实现了持久化，除了k/v，还支持多种类型的数据存储。</p>
<p>memcache挂掉后，数据不可恢复，仅支持k/v。</p>
<p>使用场景</p>
<ol>
<li><p>如果有<strong>持久方面的需求</strong>或对<strong>数据类型和处理有要求</strong>的应该选择redis</p>
</li>
<li><p>如果<strong>简单的key/value存储应该选择memcached</strong>.</p>
</li>
</ol>
<p>区别</p>
<p>1、redis和Memcache都是<strong>将数据存放在内存中，都是内存数据库</strong>。不过memcache还可以用于缓存其他东西，例如图片，视频等等</p>
<p>2、Redis不仅仅支持简单的<strong>k/v类型的数据</strong>，同时还提供<strong>list,set,hash等数据结构的存储</strong></p>
<p>3、虚拟内存-redis当物流内存用完时，可以将一些很久没用的value交换到磁盘</p>
<p>4、过期策略-memcache在set时就指定，例如set key1 0 0 8，即永不过期。Redis可以通过例如expire设定，例如expire name 10</p>
<p>5、分布式-设定memcache集群，利用magent做一主多从，redis可以做一主多从。都可以一主一从</p>
<p>6、存储数据安全-<strong>memcache挂掉后，数据没了</strong>。<strong>redis可以定期保存到磁盘(持久化)</strong></p>
<p>7、灾难恢复-<strong>memcache挂掉后，数据不可恢复</strong>。redis数据丢失后可以通过aof恢复</p>
<p>8、Redis支持数据的备份，即master-slave模式的数据备份</p>
<p>9、应用场景不一样，redis除了作为NoSQL数据库使用外，还能用做消息队列，数据堆栈和数据缓存等; Memcache适合于缓存SQL语句，数据集，用户临时性数据，延迟查询数据和session等</p>
<h3 id="Redis集群方案该怎么做-都有哪些方案"><a href="#Redis集群方案该怎么做-都有哪些方案" class="headerlink" title="Redis集群方案该怎么做?都有哪些方案?"></a>Redis集群方案该怎么做?都有哪些方案?</h3><ol>
<li><p>codis</p>
<p>目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在节点数量改变情况下，旧节点数据客恢复到新hash节点</p>
</li>
<li><p>redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方介绍</p>
</li>
<li><p>在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key进行hash计算，然后去对应的redis实例操作数据。这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的字典脚本恢复，实例的监控，等等</p>
</li>
</ol>
<h3 id="Redis回收进程是如何工作的"><a href="#Redis回收进程是如何工作的" class="headerlink" title="Redis回收进程是如何工作的"></a>Redis回收进程是如何工作的</h3><p>一个客户端运行了新的命令，添加了新的数据。</p>
<p>redis检查内存使用情况，如果大于maxmemory的限制，则根据<strong>设定好的策略</strong>进行回收。</p>
<p>一个新的命令被执行等等，所以我们不断地穿越内存限制的边界，通过<strong>不断达到边界然后不断回收回到边界以下</strong>。</p>
<p>如果一个命令的结果导致大量内存被使用(例如很大的集合的交集保存到一个新的键)，不用多久内存限制就会被这个内存使用量超越。</p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="211-MongoDB中对多条记录做更新操作命令是什么？"><a href="#211-MongoDB中对多条记录做更新操作命令是什么？" class="headerlink" title="211.MongoDB中对多条记录做更新操作命令是什么？"></a>211.MongoDB中对多条记录做更新操作命令是什么？</h3><h3 id="212-MongoDB如何才会拓展到多个shard里？"><a href="#212-MongoDB如何才会拓展到多个shard里？" class="headerlink" title="212.MongoDB如何才会拓展到多个shard里？"></a>212.MongoDB如何才会拓展到多个shard里？</h3><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Zh">
    <link itemprop="mainEntityOfPage" href="https://unknown.yuzhouwan.com/posts/22398/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Grace Koo">
      <meta itemprop="description" content="正在深入学习各种CV知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Grace Koo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/posts/22398/" class="post-title-link" itemprop="url">软件测试基础</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-28 23:55:00" itemprop="dateCreated datePublished" datetime="2020-01-28T23:55:00Z">2020-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-19 08:34:39" itemprop="dateModified" datetime="2020-11-19T08:34:39Z">2020-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Basic/" itemprop="url" rel="index"><span itemprop="name">Computer Basic</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Basic/Interview/" itemprop="url" rel="index"><span itemprop="name">Interview</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="软件测试理论"><a href="#软件测试理论" class="headerlink" title="软件测试理论"></a>软件测试理论</h1><h2 id="软件测试的生命周期"><a href="#软件测试的生命周期" class="headerlink" title="软件测试的生命周期"></a>软件测试的生命周期</h2><p>软件测试生命周期是指从项目计划建立到BUG提交的整个测试过程，包括：</p>
<ol>
<li>软件项目测试计划</li>
<li>测试需求分析</li>
<li>测试用例设计</li>
<li>测试用例执行</li>
<li>BUG提交</li>
</ol>
<h2 id="软件的三个要素是什么"><a href="#软件的三个要素是什么" class="headerlink" title="软件的三个要素是什么"></a>软件的三个要素是什么</h2><p>程序+数据+文档</p>
<h2 id="软件的产品质量"><a href="#软件的产品质量" class="headerlink" title="软件的产品质量"></a>软件的产品质量</h2><p>参考质量模型部分</p>
<h2 id="软件测试的目的"><a href="#软件测试的目的" class="headerlink" title="软件测试的目的"></a>软件测试的目的</h2><ol>
<li>验证软件是否满足软件开发合同或者项目<strong>开发计划，软件需求规格说明书，软件产品说明</strong>等规定的软件质量要求</li>
<li>通过测试，发现软件中迄今为止尚未发现的缺陷</li>
<li>为软件产品的质量测量和评价提供依据</li>
</ol>
<h2 id="软件测试过程中的四个基本活动"><a href="#软件测试过程中的四个基本活动" class="headerlink" title="软件测试过程中的四个基本活动"></a>软件测试过程中的四个基本活动</h2><ol>
<li><strong>测试策划</strong>：进行测试的需求分析和测试计划的编写</li>
<li><strong>测试设计</strong>：依据测试需求，分析并选用已有的测试用例或者设计新的测试用例，进行用例评审</li>
<li><strong>测试执行</strong>：执行测试用例，获取测试结果，分析并判定测试结果</li>
<li><strong>测试总结</strong>：整理和分析测试数据，描述测试状态，最后完成软件测试报告并通过测试评审</li>
</ol>
<h2 id="测试用例设计的基本原则"><a href="#测试用例设计的基本原则" class="headerlink" title="测试用例设计的基本原则"></a>测试用例设计的基本原则</h2><p>case的设计应该符合以下几点：</p>
<ol>
<li>一个case一个功能点：每个case都要有个测点，找准一个测点即可，不能同时覆盖很多功能点</li>
<li>case的执行粒度：粒度越小越好</li>
<li>步骤清晰：一个case多个步骤，指明怎么去操作</li>
<li>总体设计：先正常，后异常，这样可以确保正常情况下功能能够走通</li>
</ol>
<h1 id="软件按照生命周期可以分为哪些测试"><a href="#软件按照生命周期可以分为哪些测试" class="headerlink" title="软件按照生命周期可以分为哪些测试"></a>软件按照生命周期可以分为哪些测试</h1><ol>
<li><strong>单元测试</strong>：基于软件设计文档</li>
<li><strong>集成测试</strong>：基于软件结构设计文档</li>
<li>配置项测试：基于需求规格说明书、接口需求规格说明</li>
<li>系统测试：用于用户需求</li>
<li>验收测试：软件研制合同</li>
<li><strong>回归测试</strong>：可以分布在上述每个测试类别中，贯穿整个软件生命周期，所以单独分类描述</li>
</ol>
<p><strong>一般单元测试采用白盒测试，配置项或者系统测试采用黑盒测试。</strong></p>
<h1 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h1><p><strong>黑盒测试：功能测试</strong>，数据驱动测试或者基于规格说明书的测试。这种测试<strong>不必了解程序的内部逻辑结构</strong>，而是<strong>根据需求说明书中的功能来设计测试用例。</strong>具体方法分为：等价类划分法、边界值分析法、判定表法、因果图法、错误推测法</p>
<h3 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h3><ol>
<li>定义：等价类划分是在分析需求规格说明的基础上，把<strong>程序的输入域划分成若干个部分，然后在每部分选取代表性的数据形成测试用例</strong></li>
<li>等价类划分法的步骤如下：<ol>
<li><strong>划分有效等价类</strong>：对规格说明是有意义的、合理的输入数据所构成的集合。利用有效等价类可以检验程序是否满足规格说明所规定的<strong>功能和性能</strong>。</li>
<li><strong>划分无效等价类</strong>：不合理的输入数据所构成的集合。使用无效等价类可以<strong>测试程序/系统的容错性</strong>—对异常输入情况的处理。</li>
</ol>
</li>
</ol>
<h3 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h3><ol>
<li>定义：边界值分析法是针对边界值进行测试的，使用等于、大于或者小于边界值的数据对程序进行测试的方法</li>
<li>边界值分析法的步骤：<ol>
<li>通过分析规格说明书找出所有可能的边界条件</li>
<li>对每个边界条件给出满足和不满足的输入数据</li>
<li>设计相应的测试用例</li>
</ol>
</li>
</ol>
<h2 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h2><h1 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h1><p><strong>白盒测试：又称为结构测试</strong>、逻辑驱动测试或者基于程序的测试。这种测试应该了解软件程序的内部构造，并且根据程序的内部结构来设计测试用例。<strong>白盒测试是基于覆盖的测试，尽可能覆盖程序的结构特征和逻辑路径。</strong>其具体方法有逻辑覆盖、循环覆盖、基本路径覆盖。逻辑覆盖又可分为语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖。</p>
<h2 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h2><h2 id="循环覆盖"><a href="#循环覆盖" class="headerlink" title="循环覆盖"></a>循环覆盖</h2><h2 id="基本路径覆盖"><a href="#基本路径覆盖" class="headerlink" title="基本路径覆盖"></a>基本路径覆盖</h2><h1 id="静态测试、动态测试"><a href="#静态测试、动态测试" class="headerlink" title="静态测试、动态测试"></a>静态测试、动态测试</h1><ol>
<li>静态测试：又称为静态分析结束，其基本特征是不执行被测软件，根据检查列表，<strong>对需求分析说明书、软件设计说明书以及源程序做结构检查、流程图分析等找出软件错误</strong>。静态测试一般采用人工分析（针对文档），也可以用静态分析测试工具来进行（代码扫描）。</li>
<li>动态测试：其基本特征是执行被测试程序。通过执行结果，分析软件可能出现的错误 ，一般由人工设计程序测试用例，也可以由测试工具做检查和分析。</li>
</ol>
<h1 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h1><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><p>ANSI/IEEE 定义软件质量为：“与软件产品满足规定的和隐含的需求的能力有关的特征或特性的全体”。</p>
<h2 id="ISO-IEC-9126质量模型"><a href="#ISO-IEC-9126质量模型" class="headerlink" title="ISO/IEC 9126质量模型"></a>ISO/IEC 9126质量模型</h2><p>测试是对软件质量的度量，那么如何度量，从哪些角度度量。</p>
<p>我们需要一套标准，或者说模型来作参考，赋予不同指标不同的权重，通过计算软件质量的得分，便可以评判出质量的好坏。</p>
<p>ISO/IEC 9126在1991年12月发布，将软件质量归为6大特性和27个子特性。</p>
<p><img data-src="/images/data/Screen Shot 2020-11-10 at 11.44.26.png" alt="Screen Shot 2020-11-10 at 11.44.26"></p>
<p>功能性：软件产品提供满足明确和隐含需求功能的能力</p>
<ul>
<li>适合性：为规定任务提供一组合适功能的功能，即做了该做的事</li>
<li>准确性：得到正确或相符的预期结果的能力</li>
<li>互操作性：与其他系统软件交互的能力</li>
<li>保密安全性：防止对程序及数据的非授权的故意或意外访问的能力</li>
</ul>
<p>可靠性：软件产品维护规定的性能级别的能力</p>
<ul>
<li>成熟性：避免软件内部的错误扩散而导致系统失效的能力</li>
<li>容错性：防止外部接口错误扩散而导致系统失效的能力</li>
<li>易恢复性：系统失效后，重新恢复原有的功能和性能的能力</li>
</ul>
<p>易用性：软件产品被理解、学习、使用及吸引用户的能力</p>
<ul>
<li>易理解性：交互性要清晰、准确和易懂</li>
<li>易学性：用户学习软件所花努力的属性</li>
<li>易操作性：用户操作和控制软件的能力</li>
<li>吸引性：吸引用户的能力</li>
</ul>
<p><strong>性能效率</strong>：相对于所用资源的数量，软件产品可提供适当性能的能力</p>
<ul>
<li><strong>时间特性</strong>：软件执行功能时的响应、处理时间和吞吐率</li>
<li><strong>资源特性</strong>：软件执行功能时所使用的资源数量和类型</li>
</ul>
<p>维护性：软件产品可以被修改的能力，修改可能包括修改、改进或者适应环境、需求和功能规约的变化</p>
<ul>
<li>易分析性：诊断缺陷或失效原因所需努力的属性</li>
<li>易改变性：进行修改、排除错误或适应环境变化的能力</li>
<li>稳定性：避免软件修改而造成意外结果的能力</li>
<li>易测试性：提供辅助性手段帮助测试人员实现其测试意图</li>
</ul>
<p>可移植性：软件产品从一个环境迁移到另一个环境的能力</p>
<ul>
<li>适应性：无需相应变动就能适应不同环境的能力</li>
<li>易安装性：尽可能少的提供选择，方便用户直接安装</li>
<li>共存性：与其他公共软件共存</li>
<li>易替换性：同等环境下，替换其他同类产品的能力</li>
</ul>
<h2 id="GB-T-25000质量模型"><a href="#GB-T-25000质量模型" class="headerlink" title="GB/T 25000质量模型"></a>GB/T 25000质量模型</h2><p>于2016年发布，(新增兼容性和信息安全)，大方向没有改变，新增的2大特性（信息安全性、兼容性）也是从原有的功能性和可移植性中分裂出来。</p>
<p><img data-src="/images/data/Screen Shot 2020-11-10 at 11.54.54.png" alt="Screen Shot 2020-11-10 at 11.54.54"></p>
<p>信息安全性，产品或系统保护信息和数据的程序，以使用户、其他产品或系统具有与其授权和授权级别一致的数据访问度</p>
<ul>
<li>保密性，产品或系统确保数据只有在被授权时才能被访问的程度</li>
<li>完整性，系统、产品或组件防止未授权访问、篡改计算机程序或数据的程度</li>
<li>抗抵赖性，活动或事件发生后可以被证实且不可被否认的程度</li>
<li>可核查性，实体的活动可以被唯一地追溯到该实体的程度</li>
<li>真实性，对象或资源的身份标识能够被证实符合其声明的程度</li>
</ul>
<p><a href="https://juejin.im/post/6844903878354272269" target="_blank" rel="noopener">从纺锤模型到金字塔模型</a></p>
<h1 id="软件开发中之敏捷开发：DevOps"><a href="#软件开发中之敏捷开发：DevOps" class="headerlink" title="软件开发中之敏捷开发：DevOps"></a>软件开发中之敏捷开发：DevOps</h1><p>DevOps是一套实践方法论和文化，提倡打破原有组织和限制，职能团队开始拥抱和接受<strong>DevOps所倡导的高度协同，研发、测试、运维及交付一体化的思维</strong>。随着DevOps和敏捷热度的不断提升，无论是互联网企业还是传统软件企业都开始拥抱<strong>敏捷</strong>，实践DevOps。<strong>持续集成CI（Continuous integration）、持续交付CD（Continuous delivery ）</strong>作为DevOps的最佳实践，越来越受到重视。</p>
<h1 id="软件开发中之微服务架构"><a href="#软件开发中之微服务架构" class="headerlink" title="软件开发中之微服务架构"></a>软件开发中之微服务架构</h1><p>微服务架构源起于DevOps意识形态和实践中，是一种软件架构风格。微服务架构带来了一系列好处，例如<strong>可部署性、可靠性、可用性</strong>等等。虽然原则上可以使用任何架构来实践DevOps，但微服务架构<strong>正在成为构建持续部署 (CD)</strong>系统的标准<strong>架构风格</strong>。由于<strong>每项服务的规模都很小</strong>，它允许通过<strong>连续重构来实现单个服务</strong>的体系结构，因此<strong>减少了对大型项目前期设计的需求，允许尽早发布软件并且持续交付</strong>。微服务和DevOps是天然的共同体，结合起来共同实现软件开发行业的变革。</p>
<h1 id="分层理论：金字塔模型"><a href="#分层理论：金字塔模型" class="headerlink" title="分层理论：金字塔模型"></a>分层理论：金字塔模型</h1><p>随着敏捷和微服务架构的引入，<strong>CI/CD成为构建和部署的标准</strong>。传统的手工测试方式在人员和效率上都存在严重不足，因此自动化测试已经成为现代软件研发过程中一个关键组成部分。<strong>自动化测试是打通持续集成和持续交付的核心</strong>，没有有效的自动化测试保证，持续集成和持续交付就仅仅是一个没有灵魂的躯壳。</p>
<p>Martin Fowler描述<strong>测试金字塔</strong>分为单元、服务和UI三个层级。</p>
<p><strong>1)单元测试</strong></p>
<p>单元测试是针对<strong>代码单元（通常是类/方法）</strong>的测试，单元测试的价值在于能提供最快的反馈，在开发过程中就可以对逻辑单元进行验证。好的单元测试可以帮助改善既有设计，在团队掌握 TDD的前提下，单元测试能辅助重构，帮助提升代码整洁度。</p>
<p><strong>2)接口（服务/API）测试</strong></p>
<p><strong>接口测试是针对业务接口进行的测试</strong>，主要测试内部接口功能实现是否完整。比如内部逻辑是否正常、异常处理是否正确。接口测试的主要价值在于接口定义相对稳定，不像界面或底层代码会经常发生变化，所以接口测试比较容易编写，用例的维护成本也相对较低。在接口层面准备测试的性价比相对较高。</p>
<p><strong>3)集成（UI）测试</strong></p>
<p><strong>集成测试从用户的角度验证产品功能的正确性，测的是端到端的流程</strong>，并且加入用户场景和数据，验证整个过程是否健康流畅。集成测试的业务价值最高，它验证的是一个完整的流程，但因为需要验证完整流程，在环境部署、准备用例及实施等方面成本较高，实施起来并不容易。</p>
<h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><h2 id="自动化测试分层及占比"><a href="#自动化测试分层及占比" class="headerlink" title="自动化测试分层及占比"></a>自动化测试分层及占比</h2><p>先来看一般的功能测试如何进行：设计并编写用例文档，描述测试步骤和预期结果；测试人员根据测试用例描述按步骤操作，然后判断实际结果与预期是否一致。如果一致，测试通过；如果不符，测试失败。</p>
<p><strong>自动化测试要做的事情与功能测试是一致的。分层理论和自动化测试方法结合，出现了三个层面的自动化：单元测试自动化、接口测试自动化和UI测试自动化。</strong>当然，不同层面的自动化关注点是不一样的。所以，从测试的行为本质上来看，功能测试与单元自动化测试、接口自动化测试和UI自动化测试并没有区别。唯一的区别是，一个由人来执行，一个由代码或工具执行。</p>
<ul>
<li>单元自动化测试</li>
</ul>
<p>单元测试关注的是代码的实现与逻辑。单元测试是最基本的测试，也是测试中的最小单元，它的对象是函数对象，也可以包含输入输出，针对的是函数功能或者函数内部的代码逻辑，并不包含业务逻辑。</p>
<p>该类测试一般由研发人员完成，需要借助单元测试框架，如java的Junit、TestNG，python的<strong>unittest</strong>等。</p>
<ul>
<li>接口自动化测试</li>
</ul>
<p>接口自动化测试，主要验证<strong>模块间的调用返回以及不同系统、服务间的数据交换</strong>。</p>
<p>根据接口文档是RESTful还是RPC，最终断言返回的结果是否等于预期结果。如果相等，测试通过；如果不相等，测试失败。</p>
<p>常见的接口测试工具有<strong>postman、jmeter、loadrunner</strong>等。</p>
<ul>
<li>集成自动化测试</li>
</ul>
<p>UI层是用户使用产品的入口，所有功能通过这一层提供给用户。</p>
<p>当UI自动化登录成功后，就去获取这个数据进行断言，断言如果相等，测试通过；如果不相等，测试失败。</p>
<p>所以，UI自动化的关注点用户操作形为，以及UI上各种组件是否可用。常见的测试工具有<strong>UFT、Robot Framework、Selenium、Appium</strong>等。</p>
<p>按照测试金字塔模型以及投入/产出比，我们得知越向下回报率越高，<strong>所以应该使用大量的单元测试和全面的接口测试来覆盖产品提供的基本逻辑和功能，使用少量的集成（UI）测试来进行前端界面的功能验证。</strong></p>
<p>都说业内最佳实践看Google，Google的自动化分层投入占比是：<strong>单元测试（Unit）：占比70%；接口测试（Service）：占比20%；集成测试（UI）：占比10%.</strong></p>
<h2 id="自动化最佳实践：纺锤模型"><a href="#自动化最佳实践：纺锤模型" class="headerlink" title="自动化最佳实践：纺锤模型"></a>自动化最佳实践：纺锤模型</h2><p><strong>对现阶段公司大部分团队来说，更符合实际测试模式是纺锤模型</strong>。新项目中，可能由于时限原因或者开发人员习惯问题，一开始并没有把单元测试准备得很完善；而某些遗留老项目，可能原本就没有多少单元测试。</p>
<p>在上述情况下，一般的做法是先将重心放在中间层的测试上，原因有以下两点：</p>
<ul>
<li>第一，中间层<strong>投入产出比较高</strong>，可以实现较高的自动化率；</li>
<li>第二，可以帮助加强<strong>开发跟测试人员之间的协作</strong>，提高测试质量。这一层需要开发跟测试人员共同定义，因为开发知道内部实现的细节，测试掌握业务场景。</li>
</ul>
<p>当项目进行一段时间以后，各层测试占比有必要向理想型的金字塔型过渡，这时需要关注以下三个方面：</p>
<ul>
<li>开发与测试互相传递能力；</li>
<li>全员关注产品设计跟代码的质量；</li>
<li>让用例逐步下沉，最后逐步过渡到理想型。</li>
</ul>
<p><img data-src="/images/data/Screen Shot 2020-11-10 at 13.09.44.png" alt="Screen Shot 2020-11-10 at 13.09.44"></p>
<h2 id="Python自动化测试框架"><a href="#Python自动化测试框架" class="headerlink" title="Python自动化测试框架"></a>Python自动化测试框架</h2><ol>
<li><p>python+selenium+unittest+htmltestrunner</p>
</li>
<li><p>python+selenium+pytest+allure</p>
</li>
<li><p>robotframework+Selenium2Library</p>
</li>
</ol>
<p>介绍第二种：</p>
<p>pytest是一个非常成熟的Python测试框架</p>
<ol>
<li>能够支持简单的单元测试和复杂的功能测试，还可以用来做selenium/appnium等自动化测试，接口自动化测试（pytest+request）</li>
<li>pytest具有很多第三方插件，并且可以自定义扩展，常用的插件有：<ol>
<li>pytest-selenium（集成selenium）</li>
<li>pytest-html（完美html测试报告生成）</li>
<li>pytest-rerunfailures（失败case重复执行）</li>
<li>pytest-xdist（多CPU分发）</li>
</ol>
</li>
</ol>
<p><a href="https://www.cnblogs.com/mytianying/p/12466302.html" target="_blank" rel="noopener">https://www.cnblogs.com/mytianying/p/12466302.html</a></p>
<p><strong>在selenium自动化测试中，你一般完成什么类型的测试？自动化覆盖率？</strong></p>
<p>主要是冒烟测试和回归测试。回归测试主要写一些功能稳定的场景，通过自动化手段去实现，节约测试时间。因为自动化测试用例也是在不断的更新和迭代，没有刻意去统计，大概在30%-40%左右！</p>
<p><strong>什么是PO模式，为什么要使用它</strong></p>
<p>PO是Page Object 模式的简称，它是一种设计思想，意思是，把一个页面，当做一个对象，页面的元素和元素之间操作方法就是页面对象的属性和行为，PO模式一般使用三层架构，分别为：基础封装层BasePage，PO页面对象层，TestCase测试用例层。</p>
<h1 id="算法测试"><a href="#算法测试" class="headerlink" title="算法测试"></a>算法测试</h1><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><h2 id="算法鲁棒性"><a href="#算法鲁棒性" class="headerlink" title="算法鲁棒性"></a>算法鲁棒性</h2><h2 id="模型安全"><a href="#模型安全" class="headerlink" title="模型安全"></a>模型安全</h2><h2 id="响应速度"><a href="#响应速度" class="headerlink" title="响应速度"></a>响应速度</h2><h1 id="测试质量评估"><a href="#测试质量评估" class="headerlink" title="测试质量评估"></a>测试质量评估</h1><p>关于度量，不要用单一的指标去评估测试和产品质量，比如用例通过率、代码覆盖率等都无法独立地评估产品质量。</p>
<p>评估测试质量时要关心以下几个方面：</p>
<ul>
<li>第一是<strong>用例比例</strong>，即每一层的用例比例是多少。</li>
<li>第二是<strong>测试覆盖率</strong>。</li>
<li>第三是<strong>测试总运行时间</strong>，因为经过优化以后，总运行时间一定是越来越少。</li>
<li>第四是<strong>代码质量指标，反映代码的质量和整洁度</strong>。</li>
</ul>
<h1 id="测试问题"><a href="#测试问题" class="headerlink" title="测试问题"></a>测试问题</h1><h2 id="编写测试计划的目的是"><a href="#编写测试计划的目的是" class="headerlink" title="编写测试计划的目的是"></a>编写测试计划的目的是</h2><h2 id="对关键词触发模块进行测试"><a href="#对关键词触发模块进行测试" class="headerlink" title="对关键词触发模块进行测试"></a>对关键词触发模块进行测试</h2><h2 id="其他常用笔试题目网址汇总"><a href="#其他常用笔试题目网址汇总" class="headerlink" title="其他常用笔试题目网址汇总"></a>其他常用笔试题目网址汇总</h2><h2 id="测试人员在软件开发过程中的任务是什么"><a href="#测试人员在软件开发过程中的任务是什么" class="headerlink" title="测试人员在软件开发过程中的任务是什么"></a>测试人员在软件开发过程中的任务是什么</h2><h2 id="一条软件Bug记录都包含了哪些内容？"><a href="#一条软件Bug记录都包含了哪些内容？" class="headerlink" title="一条软件Bug记录都包含了哪些内容？"></a>一条软件Bug记录都包含了哪些内容？</h2><h2 id="简述黑盒测试和白盒测试的优缺点"><a href="#简述黑盒测试和白盒测试的优缺点" class="headerlink" title="简述黑盒测试和白盒测试的优缺点"></a>简述黑盒测试和白盒测试的优缺点</h2><h2 id="请列出你所知道的软件测试种类，至少5项"><a href="#请列出你所知道的软件测试种类，至少5项" class="headerlink" title="请列出你所知道的软件测试种类，至少5项"></a>请列出你所知道的软件测试种类，至少5项</h2><h2 id="Alpha测试与Beta测试的区别是什么？"><a href="#Alpha测试与Beta测试的区别是什么？" class="headerlink" title="Alpha测试与Beta测试的区别是什么？"></a>Alpha测试与Beta测试的区别是什么？</h2><h2 id="举例说明什么是Bug？一个bug-report应包含什么关键字？"><a href="#举例说明什么是Bug？一个bug-report应包含什么关键字？" class="headerlink" title="举例说明什么是Bug？一个bug report应包含什么关键字？"></a>举例说明什么是Bug？一个bug report应包含什么关键字？</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Grace Koo</p>
  <div class="site-description" itemprop="description">正在深入学习各种CV知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GraceKoo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GraceKoo" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-nd.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://yuzhouwan.com/" title="https:&#x2F;&#x2F;yuzhouwan.com" rel="noopener" target="_blank">宇宙湾</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">unknown.yuzhouwan.com</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="Symbols count total">360k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">5:27</span>
</div>

        <meta name="referrer" content="always">
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  

  

  

</body>
</html>
