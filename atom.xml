<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Grace Koo&#39;s Blog</title>
  
  <subtitle>LaLaLa~~~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://unknown.yuzhouwan.com/"/>
  <updated>2020-11-08T16:03:02.617Z</updated>
  <id>https://unknown.yuzhouwan.com/</id>
  
  <author>
    <name>Grace Koo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode_&amp;_Algorithm</title>
    <link href="https://unknown.yuzhouwan.com/posts/55663/"/>
    <id>https://unknown.yuzhouwan.com/posts/55663/</id>
    <published>2020-02-05T12:00:00.000Z</published>
    <updated>2020-11-08T16:03:02.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><div class="table-container"><table><thead><tr><th style="text-align:left">题目类型</th><th style="text-align:left">题目</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Hash">Hash</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#twoSum">twoSum</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#valid-sudoku">valid-sudoku</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#first-missing-positive">first-missing-positive</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#LinkNode">LinkNode</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#add-two-numbers">add-two-numbers</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#merge-two-sorted-lists">merge-two-sorted-lists</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#swap-nodes-in-pairs">swap-nodes-in-pairs</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#reverse-nodes-in-k-group">reverse-nodes-in-k-group</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#rotate-list">rotate-list</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#remove-duplicates-from-sorted-list-ii">remove-duplicates-from-sorted-list-ii</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#remove-duplicates-from-sorted-list">remove-duplicates-from-sorted-list</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#partition-list">partition-list</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#reverse-linked-list-ii">reverse-linked-list-ii</a></td></tr></tbody></table></div><a id="more"></a><div class="table-container"><table><thead><tr><th style="text-align:left">题目类型</th><th style="text-align:left">题目</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Hash">Hash</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#twoSum">twoSum</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#valid-sudoku">valid-sudoku</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#first-missing-positive">first-missing-positive</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#LinkNode">LinkNode</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#add-two-numbers">add-two-numbers</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#merge-two-sorted-lists">merge-two-sorted-lists</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#swap-nodes-in-pairs">swap-nodes-in-pairs</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#reverse-nodes-in-k-group">reverse-nodes-in-k-group</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#rotate-list">rotate-list</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#remove-duplicates-from-sorted-list-ii">remove-duplicates-from-sorted-list-ii</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#remove-duplicates-from-sorted-list">remove-duplicates-from-sorted-list</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#partition-list">partition-list</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#reverse-linked-list-ii">reverse-linked-list-ii</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#BackTrack">BackTrack</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#find-median-sorted-array">find-median-sorted-array</a> — Recursion</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#sudoku-solver">sudoku-solver</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#combination-sum">combination-sum</a> — Recursion</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#permutations">permutations</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#permutations-ii">permutations-ii</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#powx-n">powx-n</a> — Recursion</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#n-queens">n-queens</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#n-queens-ii">n-queens-ii</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">combinations</a>— Recursion</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#subsets">subsets</a>— Recursion</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#subsets-ii">subsets-ii</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#word-search">word-search</a>— Recursion</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#gray-code">gray-code</a>— Recursion</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#restore-ip-addresses">restore-ip-addresses</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#scramble-string">scramble-string</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#different-ways-to-add-parentheses">different-ways-to-add-parentheses</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#letter-case-permutation">letter-case-permutation</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#palindrome-partitioning">palindrome-partitioning</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#2DMatric">2DMatric</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#longest-palindrome">longest-palindrome</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#rotate-image">rotate-image</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#spiral-matrix">spiral-matrix</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#spiral-matrix-ii">spiral-matrix-ii</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#set-matrix-zeroes">set-matrix-zeroes</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Regular Expression">Regular Expression</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#string-to-integer-atoi">string-to-integer-atoi</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#regular-expression-matchin">regular-expression-matchin</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#valid-number">valid-number</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Stack">Stack</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#valid-parentheses">valid-parentheses</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#largest-rectangle-in-histogram">largest-rectangle-in-histogram</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#maximal-rectangle">maximal-rectangle</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#BinaryTree">BinaryTree</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#generate-parentheses">generate-parentheses</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Queue">Queue</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#merge-k-sorted-lists">merge-k-sorted-lists</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Bit Operation">Bit Operation</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#divide-two-integers">divide-two-integers</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#gray-code">gray-code</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#convert-a-number-to-hexadecimal">convert-a-number-to-hexadecimal</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#binary-watch">binary-watch</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Binary Search">Binary Search</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#find-first-and-last-position-of-element-in-sorted-array">find-first-and-last-position-of-element-in-sorted-array</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#sqrtx">sqrtx</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#search-a-2d-matrix">search-a-2d-matrix</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#search-in-rotated-sorted-array-ii">search-in-rotated-sorted-array</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Double Pointer">Double Pointer</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#trapping-rain-water">trapping-rain-water</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#sort-colors">sort-colors</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#minimum-window-substring">minimum-window-substring</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#remove-duplicates-from-sorted-array-ii">remove-duplicates-from-sorted-array-ii</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#merge-sorted-array">merge-sorted-array</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Dynamic Programming">Dynamic Programming</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#wildcard-matching">wildcard-matching</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#maximum-subarray">maximum-subarray</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#jump-game">jump-game</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#unique-paths">unique-paths</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#unique-paths-ii">unique-paths-ii</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#minimum-path-sum">minimum-path-sum</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#climbing-stairs">climbing-stairs</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#edit-distance">edit-distance</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#decode-ways">decode-ways</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interleaving-string">interleaving-string</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#split-array-with-equal-sum">split-array-with-equal-sum</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Greedy Algorithm">Greedy Algorithm</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#jump-game-ii">jump-game-ii</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#maximum-subarray">maximum-subarray</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#merge-intervals">merge-intervals</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#insert-interval">insert-interval</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#queue-reconstruction-by-height">queue-reconstruction-by-height</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#String">String</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#valid-number">valid-number</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#text-justification">text-justification</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#simplify-path">simplify-path</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#Tree">Tree</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#binary-tree-inorder-traversal">binary-tree-inorder-traversal</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#unique-binary-search-trees-ii">unique-binary-search-trees-ii</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#unique-binary-search-trees">unique-binary-search-trees</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#validate-binary-search-tree">validate-binary-search-tree</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#recover-binary-search-tree">recover-binary-search-tree</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#same-tree">same-tree</a></td></tr><tr><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#sort">sort</a></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#largest-number">largest-number</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#kth-largest-element-in-an-array">kth-largest-element-in-an-array</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#sort-an-array">sort-an-array</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#contains-duplicate-iii">contains-duplicate-iii</a> — bucket</td></tr></tbody></table></div><!--more--><h1 id="剑指Offer"><a href="#剑指Offer" class="headerlink" title="剑指Offer"></a>剑指Offer</h1><div class="table-container"><table><thead><tr><th>序号</th><th style="text-align:left">题目</th><th>类型</th></tr></thead><tbody><tr><td>1</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_1">二维数组中的查找</a></td><td>数组、查找</td></tr><tr><td>7</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_7">斐波那契数列</a></td><td>数组</td></tr><tr><td>13</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_13">调整数组顺序使奇数位于偶数前面</a></td><td>数组</td></tr><tr><td>19</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_19">顺时针打印矩阵</a></td><td>数组</td></tr><tr><td>29</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_29">最小的K个数</a></td><td>数组、高级算法</td></tr><tr><td>32</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_32">把数组排成最小的数</a></td><td>数组</td></tr><tr><td>35</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_35">数组中的逆序对</a></td><td>数组</td></tr><tr><td>37</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_37">数字在排序数组中出现的次数</a></td><td>数组、二分</td></tr><tr><td>42</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_42">和为S的两个数字</a></td><td>数组、双指针</td></tr><tr><td>49</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_49">把字符串转换成整数</a></td><td>数组</td></tr><tr><td>50</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_50">数组中重复的数字</a></td><td>数组</td></tr><tr><td>51</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_51">构建乘积数组</a></td><td>数组</td></tr><tr><td>66</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_66">机器人的运动范围</a></td><td>数组</td></tr><tr><td>67</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_67">剪绳子</a></td><td>数组、贪心、高级算法</td></tr><tr><td>2</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_2">替换空格</a></td><td>字符串</td></tr><tr><td>27</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_27">字符串的排列</a></td><td>字符串、动态规划</td></tr><tr><td>34</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_34">第一个只出现一次的字符位置</a></td><td>字符串</td></tr><tr><td>43</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_43">左旋转字符串</a></td><td>字符串</td></tr><tr><td>44</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_44">翻转单词顺序列</a></td><td>字符串</td></tr><tr><td>45</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_45">扑克牌顺子</a></td><td>字符串</td></tr><tr><td>48</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_48">不用加减乘除做加法</a></td><td>字符串、数学</td></tr><tr><td>52</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_52">正则表达式匹配</a></td><td>字符串</td></tr><tr><td>53</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_53">表示数值的字符串</a></td><td>字符串</td></tr><tr><td>54</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_54">字符流中第一个不重复的字符</a></td><td>字符串</td></tr><tr><td>3</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_3">从尾到头打印链表</a></td><td>链表</td></tr><tr><td>14</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_14">链表中倒数第K个结点</a></td><td>链表、双指针</td></tr><tr><td>15</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_15">反转链表</a></td><td>链表</td></tr><tr><td>25</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_25">复杂链表的复制</a></td><td>链表</td></tr><tr><td>36</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_36">两个链表的第一个公共结点</a></td><td>链表</td></tr><tr><td>46</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_46">圆圈中最后剩下的元素</a></td><td>链表</td></tr><tr><td>55</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_55">链表中环的入口结点</a></td><td>链表</td></tr><tr><td>56</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_56">删除链表中重复的结点</a></td><td>链表</td></tr><tr><td>4</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_4">重建二叉树</a></td><td>树、dfs、数组</td></tr><tr><td>17</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_17">树的子结构</a></td><td>树</td></tr><tr><td>18</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_18">二叉树的镜像</a></td><td>树</td></tr><tr><td>22</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_22">从上往下打印二叉树</a></td><td>树、队列</td></tr><tr><td>23</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_23">二叉搜索树的后序遍历序列</a></td><td>树、栈</td></tr><tr><td>24</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_24">二叉树中和为某一值的路径</a></td><td>树</td></tr><tr><td>38</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_38">二叉树的深度</a></td><td>树</td></tr><tr><td>39</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_39">平衡二叉树</a></td><td>树、dfs</td></tr><tr><td>57</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_57">二叉树的下一个结点</a></td><td>树</td></tr><tr><td>58</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_58">对称的二叉树</a></td><td>树</td></tr><tr><td>59</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_59">按之字形顺序打印二叉树</a></td><td>树、栈</td></tr><tr><td>60</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_60">把二叉树打印成多行</a></td><td>树、bfs</td></tr><tr><td>61</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_61">序列化二叉树</a></td><td>树、队列</td></tr><tr><td>62</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_62">二叉搜索树的第K个结点</a></td><td>树</td></tr><tr><td>5</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_5">用两个栈实现队列</a></td><td>栈</td></tr><tr><td>20</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_20">包含min函数的栈</a></td><td>栈</td></tr><tr><td>21</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_21">栈的压入、弹出序列</a></td><td>栈</td></tr><tr><td>6</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_6">旋转数组的最小数字</a></td><td>二分</td></tr><tr><td>8</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_8">跳台阶</a></td><td>递归</td></tr><tr><td>10</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_10">矩形覆盖</a></td><td>递归</td></tr><tr><td>9</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_9">变态跳台阶</a></td><td>贪心</td></tr><tr><td>11</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_11">二进制中1的个数</a></td><td>数学</td></tr><tr><td>12</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_12">数值的整数次方</a></td><td>数学</td></tr><tr><td>33</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_33">丑数</a></td><td>数学、动态规划</td></tr><tr><td>47</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_47">求1+2+….+n</a></td><td>数学</td></tr><tr><td>16</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_16">合并两个排序的链表</a></td><td>分治</td></tr><tr><td>26</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_26">二叉搜索树与双向链表</a></td><td>分治</td></tr><tr><td>28</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_28">数组中出现次数超过一半的数字</a></td><td>分治、位运算</td></tr><tr><td>30</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_30">连续子数组的最大和</a></td><td>分治、动态规划</td></tr><tr><td>31</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_31">整数中1出现的次数（从1到n）</a></td><td>查找</td></tr><tr><td>40</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_40">数组中只出现一次的数字</a></td><td>位运算、哈希</td></tr><tr><td>41</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_41">和为S的连续正数序列</a></td><td>穷举、滑动窗口</td></tr><tr><td>63</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_63">数据流中的中位数</a></td><td>堆、排序</td></tr><tr><td>64</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_64">滑动窗口的最大值</a></td><td>堆、双指针</td></tr><tr><td>65</td><td style="text-align:left"><a href="https://unknown.yuzhouwan.com/posts/55663/#interview_65">矩阵中的路径</a></td><td>dfs、回溯</td></tr></tbody></table></div><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><h2 id="twoSum"><a href="#twoSum" class="headerlink" title="twoSum"></a>twoSum</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2019/9/106:55 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File:  1_twoSum.py</span></span><br><span class="line"><span class="comment"># @Desc: HashMap{num1:loc1,num2:loc2......}</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        hashmap = {}</span><br><span class="line">        <span class="keyword">for</span> loc, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> hashmap.get(target - num) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> [hashmap.get(target - num), loc]</span><br><span class="line">            hashmap[num] = loc</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>]</span><br><span class="line">so = Solution()</span><br><span class="line">start = timeit.default_timer()</span><br><span class="line">print(so.twoSum(nums, <span class="number">8</span>))</span><br><span class="line">end = timeit.default_timer()</span><br><span class="line">print(str((end - start) * <span class="number">1000</span>), <span class="string">"s"</span>)  <span class="comment"># 0.052050003432668746 s</span></span><br></pre></td></tr></tbody></table></figure><h2 id="valid-sudoku"><a href="#valid-sudoku" class="headerlink" title="valid-sudoku"></a>valid-sudoku</h2><p>解题思路：</p><ul><li>行中没有重复的数字。</li><li>列中没有重复的数字。</li><li><code>3 x 3</code> 子数独内没有重复的数字。<ul><li>可以使用 <code>box_index = (row // 3) * 3 + columns // 3</code>作为子数独的索引号</li></ul></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/3 11:18 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 36_valid-sudoku.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/valid-sudoku/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span> -&gt; bool:</span></span><br><span class="line">        rows = [{} <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">9</span>)]  <span class="comment"># rows记录每行的数据情况</span></span><br><span class="line">        columns = [{} <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">9</span>)]  <span class="comment"># rows记录每列的数据情况</span></span><br><span class="line">        boxes = [{} <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">9</span>)]  <span class="comment"># rows记录每个3*3子块的数据情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">9</span>):</span><br><span class="line">                number = board[row][column]</span><br><span class="line">                <span class="keyword">if</span> number != <span class="string">"."</span>:</span><br><span class="line">                    number = int(number)</span><br><span class="line">                    box_index = (row // <span class="number">3</span>) * <span class="number">3</span> + column // <span class="number">3</span>  <span class="comment"># 对应(0,1,2,3,4,5,6,7,8,9)个子单元</span></span><br><span class="line">                    rows[row][number] = rows[row].get(number, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    columns[column][number] = columns[column].get(number, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    boxes[box_index][number] = boxes[box_index].get(number, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> rows[row][number] &gt; <span class="number">1</span> <span class="keyword">or</span> columns[column][number] &gt; <span class="number">1</span> <span class="keyword">or</span> boxes[box_index][number] &gt; <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isValidSudoku([</span><br><span class="line">    [<span class="string">"8"</span>, <span class="string">"3"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"7"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"1"</span>, <span class="string">"9"</span>, <span class="string">"5"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"3"</span>],</span><br><span class="line">    [<span class="string">"4"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"3"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"1"</span>],</span><br><span class="line">    [<span class="string">"7"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"2"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"2"</span>, <span class="string">"8"</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"4"</span>, <span class="string">"1"</span>, <span class="string">"9"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"5"</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"7"</span>, <span class="string">"9"</span>]</span><br><span class="line">]))</span><br><span class="line">print(so.isValidSudoku([</span><br><span class="line">    [<span class="string">"5"</span>, <span class="string">"3"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"7"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"1"</span>, <span class="string">"9"</span>, <span class="string">"5"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"3"</span>],</span><br><span class="line">    [<span class="string">"4"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"3"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"1"</span>],</span><br><span class="line">    [<span class="string">"7"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"2"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"2"</span>, <span class="string">"8"</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"4"</span>, <span class="string">"1"</span>, <span class="string">"9"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"5"</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"7"</span>, <span class="string">"9"</span>]</span><br><span class="line">]</span><br><span class="line">))</span><br></pre></td></tr></tbody></table></figure><h2 id="first-missing-positive"><a href="#first-missing-positive" class="headerlink" title="first-missing-positive"></a>first-missing-positive</h2><p>解题思路：使用索引作为哈希键 以及 元素的符号作为哈希值 来实现是否存在的检测。</p><blockquote><p>例如，<code>nums[2]</code> 元素的负号意味着数字 <code>2</code> 出现在 <code>nums</code> 中。<code>nums[3]</code>元素的正号表示 <code>3</code> 没有出现在 <code>nums</code> 中。</p></blockquote><p>解题步骤：</p><ul><li>检查 1 是否存在于数组中。如果没有，则已经完成，1 即为答案。</li><li>如果 nums = [1]，答案即为 2 。</li><li>第一次遍历：将负数，零，和大于 n 的数替换为 1 。</li><li>第二次遍历：遍历数组。当读到数字 a 时，替换第 a 个元素的符号。注意重复元素：只能改变一次符号。由于没有下标 n ，使用下标 0 的元素保存是否存在数字 n。</li><li>第三次遍历：返回第一个正数元素的下标。</li><li>如果 nums[0] &gt; 0，则返回 n 。<br>如果之前的步骤中没有发现 nums 中有正数元素，则返回n + 1。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/11 8:36 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 41_first-missing-positive.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/first-missing-positive/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        len_nums = len(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> len_nums == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一次遍历：将所有非法数字置为1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len_nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= <span class="number">0</span> <span class="keyword">or</span> nums[i] &gt;= len_nums:</span><br><span class="line">                nums[i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二次遍历：更改对应位置的符号</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len_nums):</span><br><span class="line">            val = abs(nums[i])</span><br><span class="line">            nums[val] = -abs(nums[val])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第三次遍历：遍历数组符号</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len_nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最后检查nums[0]</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> len_nums</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> len_nums + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.firstMissingPositive([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-28"><a href="#interview-28" class="headerlink" title="interview_28"></a>interview_28</h2><ol><li>Hash法：时间复杂度O(n)</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/28 19:45 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_28.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/</span></span><br><span class="line"><span class="comment"># shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count_dict = dict()</span><br><span class="line">        len_nums = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_nums):</span><br><span class="line">            count_dict[nums[i]] = count_dict.setdefault(nums[i], <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        result_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> count_dict.keys():</span><br><span class="line">            <span class="keyword">if</span> count_dict[key] &gt; result_count:</span><br><span class="line">                result_count, result_key = count_dict[key], key</span><br><span class="line">        <span class="keyword">if</span> result_count &gt;= (len_nums // <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">return</span> result_key</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.majorityElement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]))</span><br></pre></td></tr></tbody></table></figure><ol><li>摩尔投票法</li></ol><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/solution/mian-shi-ti-39-shu-zu-zhong-chu-xian-ci-shu-chao-3/" target="_blank" rel="noopener">解题思路</a></p><p><img data-src="/images/algorithm/interview_28.png" alt="vote"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/28 19:45 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File:interview_28.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/</span></span><br><span class="line"><span class="comment"># shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        votes = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> votes == <span class="number">0</span>:</span><br><span class="line">                x = num</span><br><span class="line">            votes += <span class="number">1</span> <span class="keyword">if</span> num == x <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># &nbsp;验证x是否为众数</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> _ == x:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> count &gt; len(nums) // <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.majorityElement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-34"><a href="#interview-34" class="headerlink" title="interview_34"></a>interview_34</h2><ol><li>遍历字符串 <code>s</code> ，使用哈希表统计 “各字符数量是否 &gt;1 ”。</li><li>再遍历字符串 <code>s</code> ，在哈希表中找到首个 “数量为 1 的字符”，并返回。</li></ol><blockquote><p>Python 3.6 后，默认字典就是有序的，因此无需使用 <code>OrderedDict()</code></p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/7 10:56 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_34.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        result_dict = {}</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">            result_dict[item] = item <span class="keyword">not</span> <span class="keyword">in</span> result_dict</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> result_dict.items():</span><br><span class="line">            <span class="keyword">if</span> v:</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.firstUniqChar(<span class="string">"NXWtnzyoHoBhUJaPauJaAitLWNMlkKwDYbbigdMMaYfkVPhGZcrEwp"</span>))</span><br></pre></td></tr></tbody></table></figure><h1 id="LinkNode"><a href="#LinkNode" class="headerlink" title="LinkNode"></a>LinkNode</h1><h2 id="add-two-numbers"><a href="#add-two-numbers" class="headerlink" title="add_two_numbers"></a>add_two_numbers</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2019/9/1111:11 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File:  2_add_two_numbers.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">elif</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        tmp = ListNode(<span class="number">0</span>)</span><br><span class="line">        res = tmp</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            tmp_sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                tmp_sum += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                tmp_sum += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            flag = (tmp_sum + flag) // <span class="number">10</span></span><br><span class="line">            tmp_sum = (tmp_sum + flag) % <span class="number">10</span></span><br><span class="line">            res.next = ListNode(tmp_sum)</span><br><span class="line">            res = res.next</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            res.mext = ListNode(<span class="number">1</span>)</span><br><span class="line">        res = tmp.next</span><br><span class="line">        <span class="keyword">del</span> tmp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h2 id="merge-two-sorted-lists"><a href="#merge-two-sorted-lists" class="headerlink" title="merge-two-sorted-lists"></a>merge-two-sorted-lists</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/1 9:04 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 21_merge-two-sorted-lists.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/merge-two-sorted-lists/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        head_pre = ListNode(<span class="number">-1</span>)</span><br><span class="line">        pre = head_pre</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.value &lt; l2.value:</span><br><span class="line">                pre.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            <span class="comment"># pre指向当前计算节点的上一个节点，运算结束后需指向下一个</span></span><br><span class="line">            pre = pre.next</span><br><span class="line">        pre.next = l1 <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> l2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head_pre.next</span><br></pre></td></tr></tbody></table></figure><h2 id="swap-nodes-in-pairs"><a href="#swap-nodes-in-pairs" class="headerlink" title="swap-nodes-in-pairs"></a>swap-nodes-in-pairs</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/6 5:15 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 24_swap-nodes-in-pairs.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/swap-nodes-in-pairs/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        head_pre = ListNode(<span class="number">-1</span>)</span><br><span class="line">        head_pre.next = head</span><br><span class="line">        tmp = head_pre</span><br><span class="line">        <span class="keyword">while</span> tmp.next <span class="keyword">and</span> tmp.next.next:</span><br><span class="line">            a, b = tmp.next, tmp.next.next</span><br><span class="line">            tmp.next, a.next = b, b.next</span><br><span class="line">            b.next = a</span><br><span class="line">            tmp = tmp.next.next</span><br><span class="line">        <span class="keyword">return</span> head_pre.next</span><br></pre></td></tr></tbody></table></figure><h2 id="reverse-nodes-in-k-group"><a href="#reverse-nodes-in-k-group" class="headerlink" title="reverse-nodes-in-k-group"></a>reverse-nodes-in-k-group</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/8 10:03 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 25_reverse-nodes-in-k-group.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        tmp_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp_head.next = head</span><br><span class="line">        pre = tail = tmp_head</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            count = k</span><br><span class="line">            <span class="comment"># 将tail移动k个节点</span></span><br><span class="line">            <span class="keyword">while</span> count <span class="keyword">and</span> tail:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">                tail = tail.next</span><br><span class="line">            <span class="comment"># 如果tail为空，则当前的这组节点数量小于k个，跳出，不进行反转</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 否则反转这k个节点</span></span><br><span class="line">            head = pre.next  <span class="comment"># head 用于记录当前这组翻转节点的第一个节点</span></span><br><span class="line">            <span class="keyword">while</span> pre.next != tail:</span><br><span class="line">                current_node = pre.next  <span class="comment"># current_node 指向当前正在准备移动的节点</span></span><br><span class="line">                pre.next = current_node.next</span><br><span class="line">                current_node.next = tail.next</span><br><span class="line">                tail.next = current_node</span><br><span class="line">                pre = pre.next</span><br><span class="line">            pre, tail = head  <span class="comment"># 指向上组移动的第一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmp_head.next</span><br></pre></td></tr></tbody></table></figure><h2 id="rotate-list"><a href="#rotate-list" class="headerlink" title="rotate-list"></a>rotate-list</h2><p>解题思路：</p><ol><li>先需旋转链表，假设旋转的步长k=2，首先循环链表得到链表的长度length_of_nodes</li></ol><pre class="mermaid">graph LRid2((1)) --&gt; id3((2))id3((2)) --&gt; id4((3))id4((3)) --&gt; id5((4))id5((4)) --&gt; id6((5))id6((5)) --&gt; id7((6))</pre><ol><li><p>得到倒数第二个节点的索引为length_of_nodes - k，即为新的头节点</p><p>新的尾节点的索引为length_of_nodes - k - 1</p><p>如果k&gt;n：</p><p>那么新的头节点的索引为length_of_nodes - k % length_of_nodes</p><p>新的尾节点的索引为length_of_nodes - k % length_of_nodes - 1</p></li></ol><pre class="mermaid">graph LRid2((1)) --&gt; id3((2))id3((2)) --&gt; id4((3))id4((3)) --&gt; id5((4))id5((4)) -.end.-&gt; id6((5))id6((5)) --&gt; id7((6))id7((6)) --&gt; id2((1))</pre><ol><li>串联成新的链表</li></ol><pre class="mermaid">graph LRid2((1)) --&gt; id3((2))id3((2)) --&gt; id4((3))id4((3)) --&gt; id5((4))id6((5)) --&gt; id7((6))id7((6)) --&gt; id2((1))</pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/4 11:55</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 61_rotate-list.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/rotate-list/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        length_of_nodes = <span class="number">1</span></span><br><span class="line">        old_tail = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.compute the length of nodes</span></span><br><span class="line">        <span class="keyword">while</span> old_tail.next:</span><br><span class="line">            length_of_nodes += <span class="number">1</span></span><br><span class="line">            old_tail = old_tail.next</span><br><span class="line">        old_tail.next = head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2.find the length_of_nodes - k % length_of_nodes -1 node,which is the last node</span></span><br><span class="line">        new_tail = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length_of_nodes - k % length_of_nodes - <span class="number">1</span>):</span><br><span class="line">            new_tail = new_tail.next</span><br><span class="line">        new_head = new_tail.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></tbody></table></figure><h2 id="remove-duplicates-from-sorted-list-ii"><a href="#remove-duplicates-from-sorted-list-ii" class="headerlink" title="remove-duplicates-from-sorted-list-ii"></a>remove-duplicates-from-sorted-list-ii</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/26 19:29 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 82_remove-duplicates-from-sorted-list-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        tmp_head = ListNode(<span class="string">"head"</span>)</span><br><span class="line">        tmp_head.next = head</span><br><span class="line">        pre, cur = <span class="literal">None</span>, tmp_head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            pre = cur  <span class="comment"># pre指向不重复的节点， cur指向当前节点</span></span><br><span class="line">            cur = cur.next  <span class="comment"># cur指向pre的下一个节点</span></span><br><span class="line">            <span class="keyword">while</span> cur <span class="keyword">and</span> cur.next <span class="keyword">and</span> cur.next.val == cur.val:</span><br><span class="line">                value = cur.val</span><br><span class="line">                <span class="comment"># 找到不重复的节点</span></span><br><span class="line">                <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val == value:</span><br><span class="line">                    cur = cur.next</span><br><span class="line">            pre.next = cur</span><br><span class="line">        <span class="keyword">return</span> tmp_head.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">first_node = ListNode(<span class="number">0</span>)</span><br><span class="line">first_node.next = ListNode(<span class="number">2</span>)</span><br><span class="line">first_node.next.next = ListNode(<span class="number">2</span>)</span><br><span class="line">print(first_node.val, first_node.next.val, first_node.next.next.val)</span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">last_node = so.deleteDuplicates(first_node)</span><br><span class="line"><span class="keyword">while</span> last_node:</span><br><span class="line">    print(last_node.val)</span><br><span class="line">    last_node = last_node.next</span><br></pre></td></tr></tbody></table></figure><h2 id="remove-duplicates-from-sorted-list"><a href="#remove-duplicates-from-sorted-list" class="headerlink" title="remove-duplicates-from-sorted-list"></a>remove-duplicates-from-sorted-list</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/26 23:28 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 83_remove-duplicates-from-sorted-list.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        tmp = head</span><br><span class="line">        <span class="keyword">while</span> tmp <span class="keyword">and</span> tmp.next:</span><br><span class="line">            <span class="keyword">if</span> tmp.val == tmp.next.val:</span><br><span class="line">                tmp.next = tmp.next.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = tmp.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">first_node = ListNode(<span class="number">0</span>)</span><br><span class="line">first_node.next = ListNode(<span class="number">2</span>)</span><br><span class="line">first_node.next.next = ListNode(<span class="number">2</span>)</span><br><span class="line">print(first_node.val, first_node.next.val, first_node.next.next.val)</span><br><span class="line">so = Solution()</span><br><span class="line">last_node = so.deleteDuplicates(first_node)</span><br><span class="line"><span class="keyword">while</span> last_node:</span><br><span class="line">    print(last_node.val)</span><br><span class="line">    last_node = last_node.next</span><br></pre></td></tr></tbody></table></figure><h2 id="partition-list"><a href="#partition-list" class="headerlink" title="partition-list"></a>partition-list</h2><p>解题思路：</p><ol><li><p>before，after分别指向链表中值小于x的节点</p></li><li><p>创建before，after的哑节点：before_node、after_node</p></li><li><p>遍历链表，最后进行合并</p></li></ol><blockquote><p>after.next = None<br>before.next = after_node.next</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># before_node、after_node是哑节点</span></span><br><span class="line">        before = before_node = ListNode(<span class="number">0</span>)</span><br><span class="line">        after = after_node = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val &gt; x:</span><br><span class="line">                after.next = head</span><br><span class="line">                after = after.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                before.next = head</span><br><span class="line">                before = before.next</span><br><span class="line">            head = head.next</span><br><span class="line">        after.next = <span class="literal">None</span></span><br><span class="line">        before.next = after_node.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> before_node.next</span><br></pre></td></tr></tbody></table></figure><h2 id="reverse-linked-list-ii"><a href="#reverse-linked-list-ii" class="headerlink" title="reverse-linked-list-ii"></a>reverse-linked-list-ii</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/6 00:06 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 92_reverse-linked-list-ii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/reverse-linked-list-ii/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> m == n:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        a, d = dummy, dummy</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(m - <span class="number">1</span>):</span><br><span class="line">            a = a.next</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            d = d.next</span><br><span class="line">        b, c = a.next, d.next</span><br><span class="line">        <span class="comment"># pre, cur, next用于遍历子链表</span></span><br><span class="line">        pre = b</span><br><span class="line">        cur = pre.next</span><br><span class="line">        <span class="keyword">while</span> cur != c:</span><br><span class="line">            cur.next, pre, cur = pre, cur, cur.next</span><br><span class="line">            <span class="comment"># 以上写法等价于</span></span><br><span class="line">            <span class="comment"># next = cur.next</span></span><br><span class="line">            <span class="comment"># cur.next = pre</span></span><br><span class="line">            <span class="comment"># pre = cur</span></span><br><span class="line">            <span class="comment"># cur = next</span></span><br><span class="line">        <span class="comment">#  首尾相接</span></span><br><span class="line">        a.next = d</span><br><span class="line">        b.next = c</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">head = ListNode(<span class="number">1</span>)</span><br><span class="line">head.next = ListNode(<span class="number">2</span>)</span><br><span class="line">head.next.next = ListNode(<span class="number">3</span>)</span><br><span class="line">head.next.next.next = ListNode(<span class="number">4</span>)</span><br><span class="line">head_tmp = head</span><br><span class="line"><span class="keyword">while</span> head_tmp:</span><br><span class="line">    print(head_tmp.val)</span><br><span class="line">    head_tmp = head_tmp.next</span><br><span class="line">so = Solution()</span><br><span class="line">return_head = so.reverseBetween(head, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">return_head_tmp = return_head</span><br><span class="line"><span class="keyword">while</span> return_head_tmp:</span><br><span class="line">    print(return_head_tmp.val)</span><br><span class="line">    return_head_tmp = return_head_tmp.next</span><br></pre></td></tr></tbody></table></figure><h2 id="从头到尾打印链表"><a href="#从头到尾打印链表" class="headerlink" title="从头到尾打印链表"></a>从头到尾打印链表</h2><ul><li>解题思路：从头到尾打印，考虑使用栈结构，也可以进行递归，但是当数据量比较大时，<strong>可能出现栈溢出</strong>，所以直接使用栈更合适。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/9 23:22 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: printListFromTailToHead.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="comment"># 链表的构造 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, list_node: ListNode)</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> list_node:</span><br><span class="line">            stack.append(list_node.val)</span><br><span class="line">            list_node = list_node.next</span><br><span class="line">        <span class="comment"># 将栈进行弹出</span></span><br><span class="line">        <span class="comment"># return stack[::-1]</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            print(stack.pop())</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-25"><a href="#interview-25" class="headerlink" title="interview_25"></a>interview_25</h2><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/lian-biao-de-shen-kao-bei-by-z1m/" target="_blank" rel="noopener">解题思路</a></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">“”“第一部分”“”</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(head)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> visited[head]</span><br><span class="line">            <span class="comment"># 创建新结点</span></span><br><span class="line">            copy = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            visited[head] = copy</span><br><span class="line">            copy.next = dfs(head.next)</span><br><span class="line">“”“第二部分”“”</span><br><span class="line">            copy.random = dfs(head.random)</span><br><span class="line">            <span class="keyword">return</span> copy</span><br></pre></td></tr></tbody></table></figure><ol><li>首先反复运行第一部分，copy.next = dfs(head.next) 会递归得越来越深，，当 碰到 head == None 时，开始运行第二部分，准备从尾结点回溯；</li><li>回溯时，先从尾结点开始回溯：调用dfs(head.ranom)时，由于结点都保存在了哈希表中，因此 return visited[head]，这时完成random指针，完成了最后一个结点，故return copy。再进行倒数第二个结点的回溯：调用dfs(head.random)，return visited[head]，return copy…….</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/19 10:28 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_25.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x: int, next: <span class="string">'Node'</span> = None, random: <span class="string">'Node'</span> = None)</span>:</span></span><br><span class="line">        self.val = int(x)</span><br><span class="line">        self.next = next</span><br><span class="line">        self.random = random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(head)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> visited[head]</span><br><span class="line">            copy = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            visited[head] = copy</span><br><span class="line">            copy.next = dfs(head.next)</span><br><span class="line">            copy.random = dfs(head.random)</span><br><span class="line">            <span class="keyword">return</span> copy</span><br><span class="line">        visited = {}</span><br><span class="line">        <span class="keyword">return</span> dfs(head)</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-3"><a href="#interview-3" class="headerlink" title="interview_3"></a>interview_3</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/9 23:22</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_3.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;</span></span><br><span class="line"><span class="comment"># qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="comment"># 链表的构造 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, list_node: ListNode)</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> list_node:</span><br><span class="line">            stack.append(list_node.val)</span><br><span class="line">            list_node = list_node.next</span><br><span class="line">        <span class="comment"># 将栈进行弹出</span></span><br><span class="line">        <span class="comment"># return stack[::-1]</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            print(stack.pop())</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-14"><a href="#interview-14" class="headerlink" title="interview_14"></a>interview_14</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 16:28</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_14.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 让p，q相隔k个</span></span><br><span class="line">        p = head</span><br><span class="line">        q = head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            p = p.next</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># count至少大于等于2的时候才p才走</span></span><br><span class="line">            <span class="keyword">if</span> count &gt;= k + <span class="number">1</span>:</span><br><span class="line">                q = q.next</span><br><span class="line">        <span class="comment"># 当k的长度比链表都长时，直接返回None</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; count:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> q</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-15"><a href="#interview-15" class="headerlink" title="interview_15"></a>interview_15</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 16:29 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_15.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        pre_node = <span class="literal">None</span></span><br><span class="line">        current_node = head</span><br><span class="line">        <span class="keyword">while</span> current_node:</span><br><span class="line">            current_node.next, pre_node, current_node = (</span><br><span class="line">                pre_node,</span><br><span class="line">                current_node,</span><br><span class="line">                current_node.next,</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> pre_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">first_node = ListNode(<span class="number">0</span>)</span><br><span class="line">first_node.next = ListNode(<span class="number">1</span>)</span><br><span class="line">first_node.next.next = ListNode(<span class="number">2</span>)</span><br><span class="line">print(first_node.val, first_node.next.val, first_node.next.next.val)</span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">last_node = so.reverseList(first_node)</span><br><span class="line">print(last_node.val, last_node.next.val, last_node.next.next.val)</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-16"><a href="#interview-16" class="headerlink" title="interview_16"></a>interview_16</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 16:41 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_16.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        head_pre = ListNode(<span class="number">-1</span>)</span><br><span class="line">        pre = head_pre</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                pre.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            <span class="comment"># pre指向当前计算节点的上一个节点，运算结束后需指向下一个</span></span><br><span class="line">            pre = pre.next</span><br><span class="line">        pre.next = l1 <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> l2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head_pre.next</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-25-1"><a href="#interview-25-1" class="headerlink" title="interview_25"></a>interview_25</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/19 10:28</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_25.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x: int, next: <span class="string">"Node"</span> = None, random: <span class="string">"Node"</span> = None)</span>:</span></span><br><span class="line">        self.val = int(x)</span><br><span class="line">        self.next = next</span><br><span class="line">        self.random = random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head: <span class="string">"Node"</span>)</span> -&gt; "Node":</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(head)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> visited[head]</span><br><span class="line">            copy = Node(head.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            visited[head] = copy</span><br><span class="line">            copy.next = dfs(head.next)</span><br><span class="line">            copy.random = dfs(head.random)</span><br><span class="line">            <span class="keyword">return</span> copy</span><br><span class="line"></span><br><span class="line">        visited = {}</span><br><span class="line">        <span class="keyword">return</span> dfs(head)</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-36"><a href="#interview-36" class="headerlink" title="interview_36"></a>interview_36</h2><p>直观思路：先统计出两个链表的长度；然后让长度较长的那个链表先走Len个节点，Len表示长度差。<br>然后让两个指针同时向后走，如果有共同节点，那么一定会让这两个指针指向同一个节点。—  <a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/shuang-zhi-zhen-tong-ji-chang-du-by-bai-ye-5/" target="_blank" rel="noopener">from this</a></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        temphead = headA</span><br><span class="line">        lenA = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> temphead:</span><br><span class="line">            temphead = temphead.next</span><br><span class="line">            lenA += <span class="number">1</span></span><br><span class="line">        temphead = headB</span><br><span class="line">        lenB = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> temphead:</span><br><span class="line">            temphead = temphead.next</span><br><span class="line">            lenB += <span class="number">1</span></span><br><span class="line">        dLen = abs(lenA-lenB)</span><br><span class="line">        <span class="keyword">if</span> lenA - lenB &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="comment">#分别表示较长的链表和较短的链表</span></span><br><span class="line">            headl,heads = headA,headB</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            headl,heads = headB,headA</span><br><span class="line">        <span class="keyword">while</span> dLen &gt; <span class="number">0</span>:</span><br><span class="line">            headl = headl.next</span><br><span class="line">            dLen -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> headl <span class="keyword">and</span> heads:</span><br><span class="line">            <span class="keyword">if</span> headl == heads:</span><br><span class="line">                <span class="keyword">return</span> headl</span><br><span class="line">            headl = headl.next</span><br><span class="line">            heads = heads.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure><p>进阶思路：两个链表长度分别为L1+C、L2+C， C为公共部分的长度。node1走了L1+C步后，回到node2起点走L2步；node2走了L2+C步后，回到node1起点走L1步。 当两个node走的步数都为L1+L2+C时就两个node就相遇了。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/8/24 19:56 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_36.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA: ListNode, headB: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        node1, node2 = headA, headB</span><br><span class="line">        <span class="keyword">while</span> node1 != node2:</span><br><span class="line">            node1 = node1.next <span class="keyword">if</span> node1 <span class="keyword">else</span> headB</span><br><span class="line">            node2 = node2.next <span class="keyword">if</span> node2 <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> node1</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-55"><a href="#interview-55" class="headerlink" title="interview_55"></a>interview_55</h2><p>两个结论：(<a href="https://zhuanlan.zhihu.com/p/103626709" target="_blank" rel="noopener">参考链接</a>)</p><ol><li>设置快慢指针，假如有环，他们最后一定相遇在环中。</li><li>两个指针相遇后，让两个指针分别从链表头和相遇点重新出发，每次走一步，最后一定相遇于环入口。</li></ol><p><strong>证明结论1</strong>：设置快慢指针fast和slow，fast每次走两步，low每次走一步。假如有环，两者一定在环中相遇。（因为low指针一旦进环，可以看作是fast指针在追slow指针，因为fast指针每次走两步，slow指针每次走一步，所以最后一定能追上（相遇））。</p><p><strong>证明结论2</strong>：</p><p>假设</p><p>链表头到环入口长度为——a，</p><p>环入口到相遇点长度为——b，</p><p>相遇点到环入口长度为——c，如图所示：</p><p><img data-src="/images/algorithm/interview_55.png" alt="快慢指针"></p><p>则相遇时，</p><p><strong>快指针路程=a+（b+c）k+b，k&gt;=1</strong>，其中b+c为环的长度，k为环的圈数（k&gt;=1，即最少一圈，不能是0圈，不然快慢指针走的路程一样，矛盾）。</p><p><strong>慢指针路程=a+b</strong>。</p><p>因为快指针的路程是慢指针的路程的两倍，所以：<strong>（a+b）*2=a+（b+c）k+b</strong>。</p><p>化简得：</p><p><strong>a=（k-1）（b+c）+c</strong>，这个式子的意思是：<strong>链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈数环长度</strong>。其中k&gt;=1，所以k-1&gt;=0圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 16:16</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_55.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead == <span class="literal">None</span> <span class="keyword">and</span> pHead.next == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        onestep = pHead</span><br><span class="line">        twostep = pHead</span><br><span class="line">        <span class="comment"># 之所以不用写twostep.next.next， 是因为如果twostep.next.next为None，则下次循环twostep就为None了，就会退出</span></span><br><span class="line">        <span class="keyword">while</span> twostep <span class="keyword">and</span> twostep.next:</span><br><span class="line">            onestep = onestep.next</span><br><span class="line">            twostep = twostep.next.next</span><br><span class="line">            <span class="keyword">if</span> onestep == twostep:</span><br><span class="line">                onestep = pHead</span><br><span class="line">                <span class="keyword">while</span> onestep != twostep:</span><br><span class="line">                    onestep = onestep.next</span><br><span class="line">                    twostep = twostep.next</span><br><span class="line">                <span class="keyword">return</span> onestep</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure><h2 id="interview-56"><a href="#interview-56" class="headerlink" title="interview_56"></a>interview_56</h2><p>解题思路：因为重复的节点都要删除，因此需要标记重复开始前的上一个节点，又因为头结点有可能是重复的节点，为了操作方便，我们可以再链表前面设置一个空节点作为头结点，因此需要设置3个指针，第一个head指向头结点。第二个p用来标记重复节点的前面一个节点，第三个cur用来寻找重复的节点，一旦找到p就不移动了，cur继续往后寻找直到不是重复的节点。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 16:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_56.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;</span></span><br><span class="line"><span class="comment"># qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        head = ListNode(<span class="number">-1</span>)  <span class="comment"># 指向头节点</span></span><br><span class="line">        p = head  <span class="comment"># 指向不重复的结点</span></span><br><span class="line">        p.next = pHead</span><br><span class="line">        cur = pHead  <span class="comment"># 负责找到重复结点</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.next:</span><br><span class="line">            <span class="keyword">if</span> cur.val != cur.next.val:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                p = p.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur_val = cur.val</span><br><span class="line">                <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val == cur_val:</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                <span class="comment"># 不相同则令p指向不重复的元素,如果cur不存在，则p指向None就好了</span></span><br><span class="line">                p.next = cur</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></tbody></table></figure><h1 id="BackTrack"><a href="#BackTrack" class="headerlink" title="BackTrack"></a>BackTrack</h1><p>回溯思想的模板为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></tbody></table></figure><h2 id="find-median-sorted-array"><a href="#find-median-sorted-array" class="headerlink" title="find_median_sorted_array"></a>find_median_sorted_array</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/4 12:14 上午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 4_find_median_sorted_array.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span> -&gt; float:</span></span><br><span class="line">        m = len(nums1)</span><br><span class="line">        n = len(nums2)</span><br><span class="line">        k = (m + n) % <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.find_k(nums1, nums2, (m + n) // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                self.find_k(nums1, nums2, (m + n) // <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">                + self.find_k(nums1, nums2, (m + n) // <span class="number">2</span>)</span><br><span class="line">            ) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_k</span><span class="params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums1:</span><br><span class="line">            <span class="keyword">return</span> nums2[k]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums2:</span><br><span class="line">            <span class="keyword">return</span> nums1[k]</span><br><span class="line">        <span class="comment"># print("len nums1:", len(nums1), "len nums2:", len(nums2))</span></span><br><span class="line">        i = len(nums1) // <span class="number">2</span></span><br><span class="line">        j = len(nums2) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># print(i, j, k)</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; i + j:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                <span class="keyword">return</span> self.find_k(nums1, nums2[j + <span class="number">1</span> :], k - j - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.find_k(nums1[i + <span class="number">1</span> :], nums2, k - i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                <span class="keyword">return</span> self.find_k(nums1[:i], nums2, k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.find_k(nums1, nums2[:j], k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    so = Solution()</span><br><span class="line">    nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    nums2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    start = timeit.default_timer()</span><br><span class="line">    print(so.findMedianSortedArrays(nums1, nums2))</span><br><span class="line">    end = timeit.default_timer()</span><br><span class="line">    print(str((end - start) * <span class="number">1000</span>), <span class="string">"s"</span>)</span><br><span class="line">    nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    nums2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    print(so.findMedianSortedArrays(nums1, nums2))</span><br><span class="line">    nums1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    nums2 = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    print(so.findMedianSortedArrays(nums1, nums2))</span><br><span class="line">    nums1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line">    nums2 = [<span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">    print(so.findMedianSortedArrays(nums1, nums2))</span><br></pre></td></tr></tbody></table></figure><h2 id="sudoku-solver"><a href="#sudoku-solver" class="headerlink" title="sudoku-solver"></a>sudoku-solver</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/5 9:44 上午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 37_sudoku-solver.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/sudoku-solver/</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, board)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        rows_available = [set(range(<span class="number">1</span>, <span class="number">10</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)] <span class="comment"># 行剩余可用数字</span></span><br><span class="line">        columns_available = [set(range(<span class="number">1</span>, <span class="number">10</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]  <span class="comment"># 列剩余可用数字</span></span><br><span class="line">        boxes_available = [set(range(<span class="number">1</span>, <span class="number">10</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">9</span>)]  <span class="comment"># 块剩余可用数字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据board数据统计每行每列可用的数字</span></span><br><span class="line">        empty = []</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[row][column] == <span class="string">"."</span>:</span><br><span class="line">                    empty.append((row, column))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    num = int(board[row][column])</span><br><span class="line">                    rows_available[row].remove(num)</span><br><span class="line">                    columns_available[column].remove(num)</span><br><span class="line">                    boxes_available[(row // <span class="number">3</span>) * <span class="number">3</span> + column // <span class="number">3</span>].remove(num)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 回溯函数，如果当前添加的数字个数已经等于空格的个数，则证明已添加到最后一个空格，即找到答案</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(interation = <span class="number">0</span>)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> interation == len(empty):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            i, j = empty[interation]  <span class="comment"># 依次取出待填入空格的坐标</span></span><br><span class="line">            <span class="keyword">for</span> value <span class="keyword">in</span> rows_available[i] &amp; columns_available[j] &amp; boxes_available[(i // <span class="number">3</span>) * <span class="number">3</span> + j // <span class="number">3</span>]:</span><br><span class="line">                rows_available[i].remove(value)</span><br><span class="line">                columns_available[j].remove(value)</span><br><span class="line">                boxes_available[(i // <span class="number">3</span>) * <span class="number">3</span> + j // <span class="number">3</span>].remove(value)</span><br><span class="line">                board[i][j] = value</span><br><span class="line">                <span class="keyword">if</span> backtrack(interation + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="comment"># 如果没找到答案，则进行回溯</span></span><br><span class="line">                rows_available[i].add(value)</span><br><span class="line">                columns_available[j].add(value)</span><br><span class="line">                boxes_available[(i // <span class="number">3</span>) * <span class="number">3</span> + j // <span class="number">3</span>].add(value)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="keyword">return</span> board</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.solveSudoku([</span><br><span class="line">    [<span class="string">"5"</span>, <span class="string">"3"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"7"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"1"</span>, <span class="string">"9"</span>, <span class="string">"5"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"3"</span>],</span><br><span class="line">    [<span class="string">"4"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"3"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"1"</span>],</span><br><span class="line">    [<span class="string">"7"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"2"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"6"</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"6"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"2"</span>, <span class="string">"8"</span>, <span class="string">"."</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"4"</span>, <span class="string">"1"</span>, <span class="string">"9"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"5"</span>],</span><br><span class="line">    [<span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"8"</span>, <span class="string">"."</span>, <span class="string">"."</span>, <span class="string">"7"</span>, <span class="string">"9"</span>]</span><br><span class="line">]</span><br><span class="line">))</span><br></pre></td></tr></tbody></table></figure><h2 id="combination-sum"><a href="#combination-sum" class="headerlink" title="combination-sum"></a>combination-sum</h2><p>解题思路：（注：<a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/" target="_blank" rel="noopener">参考链接</a>）</p><ul><li>以 <code>target = 7</code> 为根结点，每一个分支做减法。减到 00 或者负数的时候，剪枝。其中，减到 0的时候添加结果。</li><li>为了能够去重：把候选数组排个序，即后面选取的数不能比前面选的数还要小。</li></ul><p><img data-src="/images/algorithm/leetcode-39.png" alt="leetcode-39"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/9 11:55 上午 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 39_combination-sum.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/combination-sum/solution/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates <span class="keyword">or</span> <span class="keyword">not</span> target:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        output_list = []</span><br><span class="line">        path = []</span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line">        size = len(candidates)</span><br><span class="line">        self._dfs(candidates, begin, size, path, output_list, target)</span><br><span class="line">        <span class="keyword">return</span> output_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(self, candidates, begin, size, path, output_list, target)</span>:</span></span><br><span class="line">        <span class="comment"># 递归终止的条件</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            output_list.append(path[:])</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(begin, size):</span><br><span class="line">            residue = target - candidates[index]</span><br><span class="line">            <span class="keyword">if</span> residue &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            path.append(candidates[index])</span><br><span class="line">            self._dfs(candidates, index, size, path, output_list, residue)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    candidates = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">    target = <span class="number">7</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    result = solution.combinationSum(candidates, target)</span><br><span class="line">    print(result)</span><br></pre></td></tr></tbody></table></figure><h2 id="permutations"><a href="#permutations" class="headerlink" title="permutations"></a>permutations</h2><p><img data-src="/images/algorithm/permutations.png" alt="permutations"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/13 6:40 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 46_permutations.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/permutations/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(nums, num)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                output_list.append(num)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                backtrack(nums[:i] + nums[i + <span class="number">1</span> :], num + [nums[i]])</span><br><span class="line"></span><br><span class="line">        output_list = []</span><br><span class="line">        backtrack(nums, [])</span><br><span class="line">        <span class="keyword">return</span> output_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.permute([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="permutations-ii"><a href="#permutations-ii" class="headerlink" title="permutations-ii"></a>permutations-ii</h2><p>去除重复元素，两个要点</p><ul><li>排序</li><li>去重</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/18 6:40 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 47_permutations-ii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/permutations/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(nums, num)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                output_list.append(num)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:  </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                backtrack(nums[:i] + nums[i + <span class="number">1</span>:], num + [nums[i]])</span><br><span class="line"></span><br><span class="line">        nums.sort()  <span class="comment"># 数组先排序</span></span><br><span class="line">        output_list = []</span><br><span class="line">        backtrack(nums, [])</span><br><span class="line">        <span class="keyword">return</span> output_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.permuteUnique([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-27"><a href="#interview-27" class="headerlink" title="interview_27"></a>interview_27</h2><p><img data-src="/images/algorithm/interview_27.png" alt="permutations"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/27 14:35 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_27.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/</span></span><br><span class="line"><span class="comment"># zi-fu-chuan-de-pai-lie-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># nums存放需要继续遍历的字符，tmp存放当前遍历的结果</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(nums, tmp)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                result.add(tmp)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                backtrack(nums[:i] + nums[i+<span class="number">1</span>:], tmp+nums[i])</span><br><span class="line"></span><br><span class="line">        result = set()</span><br><span class="line">        backtrack(s, <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> list(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.permutation(<span class="string">"ryawrowv"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="powx-n"><a href="#powx-n" class="headerlink" title="powx-n"></a>powx-n</h2><p>解题思路</p><ul><li>若n为偶数：$x^n = x^{\frac{n}{2}} \, \dot \, x^{\frac{n}{2}}$</li><li>若n为奇数：$x ^ n = x ^ {\frac{n}{2}} \, \dot \, x^ {\frac{n}{2}} \, \dot \, x$</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/21 23:37</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 50_powx-n.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/powx-n/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / x</span><br><span class="line">        half = self.myPow(x, n // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> half * half</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> half * half * x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.myPow(<span class="number">2.00000</span>, <span class="number">-10</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="n-queens"><a href="#n-queens" class="headerlink" title="n-queens"></a>n-queens</h2><p>一、因为：</p><blockquote><p>对于所有的主对角线有 <code>行号 + 列号 = 常数</code></p><p>对于所有的次对角线有 <code>行号 - 列号 = 常数</code></p></blockquote><p>所以，所有的主对象线元素可以用<code>2 * n  - 1</code>个元素来表示，比如<code>main_diagonals[0]</code>就可以表示待解queen_map中，第<code>queen_map[0][0]</code>个元素的<strong>所有</strong>主对角线元素。</p><p>二、解题思路 （注：<a href="https://leetcode-cn.com/problems/n-queens/solution/nhuang-hou-by-leetcode/" target="_blank" rel="noopener">参考链接</a>）</p><ul><li>从第一个 row = 0 开始.</li><li>循环列并且试图在每个 column 中放置皇后.<ul><li>如果方格 (row, column) 不在攻击范围内<ul><li>在 (row, column) 方格上放置皇后。</li><li>排除对应行，列和两个对角线的位置。</li><li>If 所有的行被考虑过，row == N<br>意味着我们找到了一个解</li><li>Else<br>继续考虑接下来的皇后放置 backtrack(row + 1).</li><li>回溯：将在 (row, column) 方格的将皇后移除。</li></ul></li></ul></li></ul><p><img data-src="/images/algorithm/leetcode-51.png" alt="leetcode-51"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/24 13:55</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 51_n-queens.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/n-queens/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="comment"># 判断当前位置是否可用，由当前列，主对角线，副对角线共同决定</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">could_place</span><span class="params">(row, col)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> cols[col] + main_diagonals[row - col] + counter_diagonals[row + col]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 放置皇后</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">place_queen</span><span class="params">(row, col)</span>:</span></span><br><span class="line">            queens_position.add((row, col))</span><br><span class="line">            cols[col] = <span class="number">1</span></span><br><span class="line">            main_diagonals[row - col] = <span class="number">1</span></span><br><span class="line">            counter_diagonals[row + col] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 消除皇后</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">remove_queen</span><span class="params">(row, col)</span>:</span></span><br><span class="line">            queens_position.remove((row, col))</span><br><span class="line">            cols[col] = <span class="number">0</span></span><br><span class="line">            main_diagonals[row - col] = <span class="number">0</span></span><br><span class="line">            counter_diagonals[row + col] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 增加解</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add_solution</span><span class="params">()</span>:</span></span><br><span class="line">            solution = []</span><br><span class="line">            <span class="keyword">for</span> _, col <span class="keyword">in</span> sorted(queens_position):</span><br><span class="line">                solution.append(<span class="string">'.'</span> * col + <span class="string">'Q'</span> + <span class="string">'.'</span> * (n - col - <span class="number">1</span>))</span><br><span class="line">            output.append(solution)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(row=<span class="number">0</span>)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> could_place(row, col):</span><br><span class="line">                    place_queen(row, col)</span><br><span class="line">                    <span class="keyword">if</span> row + <span class="number">1</span> == n:</span><br><span class="line">                        add_solution()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        backtrack(row + <span class="number">1</span>)</span><br><span class="line">                    remove_queen(row, col)</span><br><span class="line">        cols = [<span class="number">0</span>] * n  <span class="comment"># 每列的Queen</span></span><br><span class="line">        main_diagonals = [<span class="number">0</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)  <span class="comment"># 共需要7个元素可以表示全部的主对角线元素</span></span><br><span class="line">        counter_diagonals = [<span class="number">0</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)  <span class="comment"># 共需要7个元素可以表示全部的副对角线元素</span></span><br><span class="line">        queens_position = set() <span class="comment"># 用于记录当前已经摆放的位置</span></span><br><span class="line">        output = []</span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.solveNQueens(<span class="number">4</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="n-queens-ii"><a href="#n-queens-ii" class="headerlink" title="n-queens-ii"></a>n-queens-ii</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/24 19:35</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 52_n-queens-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/n-queens-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 判断当前位置是否可用，由当前列，主对角线，副对角线共同决定</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">could_place</span><span class="params">(row, col)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                <span class="keyword">not</span> cols[col] + main_diagonals[row - col] + counter_diagonals[row + col]</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 放置皇后</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">place_queen</span><span class="params">(row, col)</span>:</span></span><br><span class="line">            cols[col] = <span class="number">1</span></span><br><span class="line">            main_diagonals[row - col] = <span class="number">1</span></span><br><span class="line">            counter_diagonals[row + col] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 消除皇后</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">remove_queen</span><span class="params">(row, col)</span>:</span></span><br><span class="line">            cols[col] = <span class="number">0</span></span><br><span class="line">            main_diagonals[row - col] = <span class="number">0</span></span><br><span class="line">            counter_diagonals[row + col] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(row=<span class="number">0</span>, output = <span class="number">0</span>)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> could_place(row, col):</span><br><span class="line">                    place_queen(row, col)</span><br><span class="line">                    <span class="keyword">if</span> row + <span class="number">1</span> == n:</span><br><span class="line">                        output += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        output = backtrack(row + <span class="number">1</span>, output)</span><br><span class="line">                    remove_queen(row, col)</span><br><span class="line">            <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">        cols = [<span class="number">0</span>] * n  <span class="comment"># 每列的Queen</span></span><br><span class="line">        main_diagonals = [<span class="number">0</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)  <span class="comment"># 共需要7个元素可以表示全部的主对角线元素</span></span><br><span class="line">        counter_diagonals = [<span class="number">0</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)  <span class="comment"># 共需要7个元素可以表示全部的副对角线元素</span></span><br><span class="line">        <span class="keyword">return</span> backtrack()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.totalNQueens(<span class="number">4</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="combinations"><a href="#combinations" class="headerlink" title="combinations"></a>combinations</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/22 22:32</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 77_combinations.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/combinations/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> n &lt; k:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        self.__dfs(<span class="number">1</span>, k, n, [], result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dfs</span><span class="params">(self, index, k, n, pre, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(pre) == k:</span><br><span class="line">            result.append(pre[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index, n + <span class="number">1</span>):</span><br><span class="line">            pre.append(i)</span><br><span class="line">            self.__dfs(i + <span class="number">1</span>, k, n, pre, result)</span><br><span class="line">            pre.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.combine(<span class="number">4</span>, <span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="subsets"><a href="#subsets" class="headerlink" title="subsets"></a>subsets</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/24 11:57</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 78_subsets.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/subsets/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(start, result_tmp)</span>:</span></span><br><span class="line">            result.append(result_tmp)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, n):</span><br><span class="line">                backtrack(i + <span class="number">1</span>, result_tmp + [nums[i]])</span><br><span class="line"></span><br><span class="line">        backtrack(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.subsets([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="subsets-ii"><a href="#subsets-ii" class="headerlink" title="subsets-ii"></a>subsets-ii</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/4 22:57</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 90_subsets-ii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/subsets-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">track_back</span><span class="params">(i, tmp)</span>:</span></span><br><span class="line">            res.append(tmp)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">                <span class="keyword">if</span> j &gt; i <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                track_back(j + <span class="number">1</span>, tmp + [nums[j]])</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        track_back(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.subsetsWithDup([<span class="number">0</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="word-search"><a href="#word-search" class="headerlink" title="word-search"></a>word-search</h2><p>可以参考<a href="https://unknown.yuzhouwan.com/posts/55663/#interview_65">interview_65</a>写法更清楚明了。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/24 21:06 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 79_word-search.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/word-search/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    derections = [(<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        rows = len(board)</span><br><span class="line">        cols = len(board[<span class="number">0</span>])</span><br><span class="line">        marked = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(cols)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(rows)]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> self.__search_word(board, word, <span class="number">0</span>, row, col, marked, rows, cols):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__search_word</span><span class="params">(self, board, word, index_word, row, col, marked, rows, cols)</span>:</span></span><br><span class="line">        <span class="comment"># 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> len(word) - <span class="number">1</span> == index_word:</span><br><span class="line">            <span class="keyword">return</span> board[row][col] == word[index_word]</span><br><span class="line">        <span class="keyword">if</span> board[row][col] == word[index_word]:</span><br><span class="line">            marked[row][col] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> derection <span class="keyword">in</span> self.derections:</span><br><span class="line">                next_x, next_y = row + derection[<span class="number">0</span>], col + derection[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= next_x &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= next_y &lt; cols <span class="keyword">and</span> <span class="keyword">not</span> marked[next_x][next_y] \</span><br><span class="line">                    <span class="keyword">and</span> self.__search_word(board, word,</span><br><span class="line">                                           index_word + <span class="number">1</span>,</span><br><span class="line">                                           next_x, next_y,</span><br><span class="line">                                           marked, rows, cols):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            marked[row][col] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.exist([</span><br><span class="line">    [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'E'</span>],</span><br><span class="line">    [<span class="string">'S'</span>, <span class="string">'F'</span>, <span class="string">'C'</span>, <span class="string">'S'</span>],</span><br><span class="line">    [<span class="string">'A'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'E'</span>]</span><br><span class="line">], <span class="string">"ABCCED"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-65"><a href="#interview-65" class="headerlink" title="interview_65"></a>interview_65</h2><p>此题同<a href="https://unknown.yuzhouwan.com/posts/55663/#word-search">word_search</a></p><p>对比<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/" target="_blank" rel="noopener">参考链接</a>，其方法更加简洁。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:58</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_65.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, k)</span>:</span></span><br><span class="line">            <span class="comment"># 递归异常退出的条件：索引超出范围或者与当前字母不匹配</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; len(board) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; len(board[<span class="number">0</span>]) <span class="keyword">or</span> word[k] != board[i][j] <span class="keyword">or</span> board[i][j] == <span class="string">"*"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 递归成功退出的条件</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word)<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 继续向上下左右进行遍历</span></span><br><span class="line">            tmp = board[i][j]</span><br><span class="line">            board[i][j] = <span class="string">"*"</span>  <span class="comment"># *表示已经遍历过</span></span><br><span class="line"></span><br><span class="line">            result = dfs(i<span class="number">-1</span>, j, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(i+<span class="number">1</span>, j, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(i, j<span class="number">-1</span>, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(i, j+<span class="number">1</span>, k+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            board[i][j] = tmp  <span class="comment"># 不管遍历结果如何，都需要恢复相应字符</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从不同的起点出发, k代表当前遍历到的单词字母的索引</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></tbody></table></figure><p>牛客网上的要求略有不同。</p><ol><li>给出的是字符串，需要将<code>matrix[row][col]</code>写成<code>matrix[row*cols+col]</code>来定位</li><li>字符串是不可变变量，需要将matrix先转化为list(matrix)</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(row, col, k)</span>:</span></span><br><span class="line">            <span class="comment"># 递归异常退出的出口</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span>&lt;= row &lt; rows <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= col &lt; cols <span class="keyword">or</span> k &gt;= len(path) <span class="keyword">or</span> path[k] != matrix[row*cols + col] <span class="keyword">or</span> matrix[row*cols + col] == <span class="string">"*"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 递归正常退出的出口</span></span><br><span class="line">            <span class="keyword">if</span> matrix[row*cols + col] == path[k] <span class="keyword">and</span> k == len(path) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 继续递归</span></span><br><span class="line">            tmp = matrix[row*cols + col]</span><br><span class="line">            matrix[row*cols + col] = <span class="string">"*"</span> <span class="comment"># 先把已经遍历的字母赋值为"*"</span></span><br><span class="line">            <span class="keyword">if</span> dfs(row+<span class="number">1</span>, col, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(row, col+<span class="number">1</span>, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(row<span class="number">-1</span>, col, k+<span class="number">1</span>) <span class="keyword">or</span> dfs(row, col<span class="number">-1</span>, k+<span class="number">1</span>):</span><br><span class="line">                matrix[row*cols + col] = tmp</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            matrix[row*cols + col] = tmp</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">        matrix = list(matrix)</span><br><span class="line">        <span class="comment"># 起点是matrix的每个点</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> dfs(row, col, <span class="number">0</span>):</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></tbody></table></figure><h2 id="interview-66"><a href="#interview-66" class="headerlink" title="interview_66"></a>interview_66</h2><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/bfs-by-z1m/" target="_blank" rel="noopener">参考链接</a></p><p>广度优先搜索：一般使用<strong>队列</strong>来实现</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:58</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_66.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount_BFS</span><span class="params">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 用于计算数位和</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sum_step</span><span class="params">(row, col)</span>:</span></span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> row &gt; <span class="number">0</span>:</span><br><span class="line">                result += row % <span class="number">10</span></span><br><span class="line">                row = row // <span class="number">10</span></span><br><span class="line">            <span class="keyword">while</span> col &gt; <span class="number">0</span>:</span><br><span class="line">                result += col % <span class="number">10</span></span><br><span class="line">                col = col // <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 广度优先搜索</span></span><br><span class="line">        de = deque()  <span class="comment"># 用于广度优先搜索格子的坐标</span></span><br><span class="line">        de.append((<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        marked = set()  <span class="comment"># 用于记录已经走过的坐标</span></span><br><span class="line">        <span class="keyword">while</span> de:</span><br><span class="line">            x, y = de.popleft()</span><br><span class="line">            <span class="comment"># 如果当前坐标还没有走过，并且数位和小于等于k</span></span><br><span class="line">            <span class="keyword">if</span> (x, y) <span class="keyword">not</span> <span class="keyword">in</span> marked <span class="keyword">and</span> sum_step(x, y) &lt;= k:</span><br><span class="line">                marked.add((x, y))</span><br><span class="line">                <span class="comment"># 只考虑向下和向右即可</span></span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>)]:</span><br><span class="line">                    <span class="keyword">if</span> x + dx &lt; m <span class="keyword">and</span> y + dy &lt; n:</span><br><span class="line">                        de.append((x+dx, y+dy))</span><br><span class="line">        <span class="keyword">return</span> len(marked)</span><br></pre></td></tr></tbody></table></figure><p>深度优先搜索：一般使用<strong>栈</strong>来实现</p><p>定义一个递归函数 <code>dfs()</code>，如果坐标不满足条件，结束递归状态，否则将下一步满足条件的坐标代入递归函数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:58</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_66.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 用于计算数位和</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sum_step</span><span class="params">(row, col)</span>:</span></span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> row &gt; <span class="number">0</span>:</span><br><span class="line">                result += row % <span class="number">10</span></span><br><span class="line">                row = row // <span class="number">10</span></span><br><span class="line">            <span class="keyword">while</span> col &gt; <span class="number">0</span>:</span><br><span class="line">                result += col % <span class="number">10</span></span><br><span class="line">                col = col // <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            <span class="comment"># 递归退出的条件</span></span><br><span class="line">            <span class="comment"># 坐标超出范围、数位和大于k、当前坐标已经走过</span></span><br><span class="line">            <span class="keyword">if</span> x &gt;= m <span class="keyword">or</span> y &gt;= n <span class="keyword">or</span> sum_step(x, y) &gt; k <span class="keyword">or</span> (x, y) <span class="keyword">in</span> marked:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            marked.add((x, y))</span><br><span class="line">            dfs(x + <span class="number">1</span>, y)  <span class="comment"># 向下走</span></span><br><span class="line">            dfs(x, y + <span class="number">1</span>)  <span class="comment"># 向右走</span></span><br><span class="line"></span><br><span class="line">        marked = set()  <span class="comment"># 记录已经走过的坐标</span></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> len(marked)</span><br></pre></td></tr></tbody></table></figure><h2 id="restore-ip-addresses"><a href="#restore-ip-addresses" class="headerlink" title="restore-ip-addresses"></a>restore-ip-addresses</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/7 23:22 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 93_restore-ip-addresses.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/restore-ip-addresses/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        r = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">restore</span><span class="params">(count=<span class="number">0</span>, ip=<span class="string">''</span>, s=<span class="string">''</span>)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> s == <span class="string">''</span>:</span><br><span class="line">                    r.append(ip[:<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> len(s) &gt; <span class="number">0</span>:</span><br><span class="line">                restore(count+<span class="number">1</span>, ip+s[<span class="number">0</span>]+<span class="string">'.'</span>, s[<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">if</span> len(s) &gt; <span class="number">1</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">'0'</span>:</span><br><span class="line">                restore(count+<span class="number">1</span>, ip+s[:<span class="number">2</span>]+<span class="string">'.'</span>, s[<span class="number">2</span>:])</span><br><span class="line">            <span class="keyword">if</span> len(s) &gt; <span class="number">2</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">'0'</span> <span class="keyword">and</span> int(s[<span class="number">0</span>:<span class="number">3</span>]) &lt; <span class="number">256</span>:</span><br><span class="line">                restore(count+<span class="number">1</span>, ip+s[:<span class="number">3</span>]+<span class="string">'.'</span>, s[<span class="number">3</span>:])</span><br><span class="line">        restore(<span class="number">0</span>, <span class="string">''</span>, s)</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.restoreIpAddresses(<span class="string">"25525511135"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="scramble-string"><a href="#scramble-string" class="headerlink" title="scramble-string"></a>scramble-string</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/9 23:07 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 87_scramble-string.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/scramble-string/</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="meta">    @functools.lru_cache(None)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) != len(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> s1 == s2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> sorted(s1) != sorted(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s1)):</span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i], s2[:i]) <span class="keyword">and</span> self.isScramble(s1[i:], s2[i:]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i], s2[-i:]) <span class="keyword">and</span> self.isScramble(s1[i:], s2[:-i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isScramble(<span class="string">"great"</span>, <span class="string">"rgtae"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="different-ways-to-add-parentheses"><a href="#different-ways-to-add-parentheses" class="headerlink" title="different-ways-to-add-parentheses"></a>different-ways-to-add-parentheses</h2><p> 分治三步法：</p><ul><li>分解：按运算符分成左右两部分，分别求解</li><li>解决：实现一个递归函数，输入算式，返回算式解</li><li>合并：根据运算符合并左右两部分的解，得出最终解</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/17 12:40</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 241_different-ways-to-add-parentheses.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/different-ways-to-add-parentheses/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diffWaysToCompute</span><span class="params">(self, input: str)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> input.isdigit():</span><br><span class="line">            <span class="keyword">return</span> [int(input)]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(input):</span><br><span class="line">            <span class="keyword">if</span> value <span class="keyword">in</span> [<span class="string">"+"</span>, <span class="string">"-"</span>, <span class="string">"*"</span>]:</span><br><span class="line">                left = self.diffWaysToCompute(input[:index])</span><br><span class="line">                right = self.diffWaysToCompute(input[index + <span class="number">1</span> :])</span><br><span class="line">                <span class="comment"># 合并结果</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        <span class="keyword">if</span> value == <span class="string">"+"</span>:</span><br><span class="line">                            res.append(l + r)</span><br><span class="line">                        <span class="keyword">elif</span> value == <span class="string">"-"</span>:</span><br><span class="line">                            res.append(l - r)</span><br><span class="line">                        <span class="keyword">elif</span> value == <span class="string">"*"</span>:</span><br><span class="line">                            res.append(l * r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.diffWaysToCompute(<span class="string">"2*3-4*5"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="letter-case-permutation"><a href="#letter-case-permutation" class="headerlink" title="letter-case-permutation"></a>letter-case-permutation</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/21 20:38</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 784_letter-case-permutation.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/letter-case-permutation/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCasePermutation</span><span class="params">(self, S: str)</span> -&gt; List[str]:</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(s, pre)</span>:</span></span><br><span class="line">            <span class="comment"># 递归退出条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                result.append(<span class="string">""</span>.join(pre))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>].isalpha():</span><br><span class="line">                helper(s[<span class="number">1</span>:], pre + [s[<span class="number">0</span>].upper()])</span><br><span class="line">                helper(s[<span class="number">1</span>:], pre + [s[<span class="number">0</span>].lower()])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                helper(s[<span class="number">1</span>:], pre + [s[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">        helper(S, [])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.letterCasePermutation(<span class="string">"a1b2"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="palindrome-partitioning"><a href="#palindrome-partitioning" class="headerlink" title="palindrome-partitioning"></a>palindrome-partitioning</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/23 00:22</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 131_palindrome-partitioning.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/palindrome-partitioning/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s: str)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(s, tmp)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">                result.append(tmp)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[:i] == s[:i][::<span class="number">-1</span>]:</span><br><span class="line">                    backtrack(s[i:], tmp + [s[:i]])</span><br><span class="line"></span><br><span class="line">        backtrack(s, [])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.partition(<span class="string">"aab"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="fibonacci-number"><a href="#fibonacci-number" class="headerlink" title="fibonacci-number"></a>fibonacci-number</h2><p>方法一：递归（递归树如下）</p><p><img data-src="/images/algorithm/fibonacci-number.png" alt="fibonacci-number"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/14 12:38 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 509_fibonacci-number.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/fibonacci-number/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.fib(N<span class="number">-1</span>) + self.fib(N<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.fib(<span class="number">5</span>))</span><br></pre></td></tr></tbody></table></figure><p>递归虽然有简洁的优点，但是递归是函数调用自身，而函数调用是有时间和空间消耗的，每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而往栈里压入数据和弹出数据都需要时间。另外，递归中有可能很多计算都是重复的，从而也会对性能产生影响。</p><p>方法二：记忆化自底向上的方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/14 12:38 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 509_fibonacci-number.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/fibonacci-number/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        f_dict = {<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>}</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, N):</span><br><span class="line">            f_dict[i] = f_dict[i - <span class="number">1</span>] + f_dict[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> f_dict[N - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.fib(<span class="number">4</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="Interview-10"><a href="#Interview-10" class="headerlink" title="Interview_10"></a>Interview_10</h2><p>解题思路：</p><p>类似于青蛙跳台阶,当n=1时，只有一种横向排列的方式。</p><p>当n等于二时，2*2有两种选择，横向或者是竖向。</p><p>当n等于3的时候对于2*3来说,如果选择的是竖向排列，则剩下的就是2*2排列。</p><p>如果选择的是横向,则对于2*n剩下的则只有1*n的一种选择。</p><p>2*n的大矩形就相当于“跳台阶“问题中的台阶，大矩形的长度n相当于台阶的个数n；从左至右的去覆盖，<strong>把小矩形竖着放相当于跳一个台阶，把小矩阵横着放相当于跳两个台阶</strong>。故：当前n的覆盖种数 = 当前n-1的覆盖总数 + 当前n-2的覆盖总数。即：f (n) = f (n-1) + f (n-2)</p><p><img data-src="/images/algorithm/rectCover.png" alt="rectCover"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/27 12:48 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: rectCover.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> self.rectCover(number<span class="number">-1</span>) + self.rectCover(number<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.rectCover(<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><p>或着使用自底向上的方法，节省空间</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(number)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></tbody></table></figure><h1 id="2DMatric"><a href="#2DMatric" class="headerlink" title="2DMatric"></a>2DMatric</h1><h2 id="longest-palindrome"><a href="#longest-palindrome" class="headerlink" title="longest_palindrome"></a>longest_palindrome</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/17 9:07 上午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 5_longest_palindrome.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        longest_str = <span class="string">""</span></span><br><span class="line">        longestLen = <span class="number">0</span></span><br><span class="line">        matrics = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s))] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s))]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(s)):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, j + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j - i &lt;= <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                        matrics[i][j] = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> longestLen &lt; j - i + <span class="number">1</span>:</span><br><span class="line">                            longestLen = j - i + <span class="number">1</span></span><br><span class="line">                            longest_str = s[i : j + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> matrics[i + <span class="number">1</span>][j - <span class="number">1</span>]:</span><br><span class="line">                        matrics[i][j] = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> longestLen &lt; j - i + <span class="number">1</span>:</span><br><span class="line">                            longestLen = j - i + <span class="number">1</span></span><br><span class="line">                            longest_str = s[i : j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> longest_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">"abccba"</span></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.longestPalindrome(s))</span><br></pre></td></tr></tbody></table></figure><h2 id="rotate-image"><a href="#rotate-image" class="headerlink" title="rotate-image"></a>rotate-image</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/19 15:23</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 48_rotate-image.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/rotate-image/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ero_matrics</span><span class="params">(self, matric)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matric:</span><br><span class="line">            <span class="keyword">return</span> matric</span><br><span class="line">        <span class="comment"># 先转置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(matric)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(matric)):</span><br><span class="line">                tmp = matric[i][j]</span><br><span class="line">                matric[i][j] = matric[j][i]</span><br><span class="line">                matric[j][i] = tmp</span><br><span class="line">        <span class="comment"># 再反转每一行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(matric)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(matric) // <span class="number">2</span>):</span><br><span class="line">                tmp = matric[i][j]</span><br><span class="line">                matric[i][j] = matric[i][len(matric) - j - <span class="number">1</span>]</span><br><span class="line">                matric[i][len(matric) - j - <span class="number">1</span>] = tmp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matric</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.ero_matrics([[<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>],</span><br><span class="line">                      [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">                      [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">14</span>],</span><br><span class="line">                      [<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">13</span>]]))</span><br><span class="line">print(so.ero_matrics([</span><br><span class="line">                      [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>],</span><br><span class="line">                      [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">                      [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>]]))</span><br></pre></td></tr></tbody></table></figure><h2 id="spiral-matrix"><a href="#spiral-matrix" class="headerlink" title="spiral-matrix"></a>spiral-matrix</h2><p>解题思路来源于leetcode官网：按层模拟（注：<a href="https://leetcode-cn.com/problems/spiral-matrix/solution/luo-xuan-ju-zhen-by-leetcode/" target="_blank" rel="noopener">参考链接</a>）</p><p><img data-src="/images/algorithm/leetcode-54.png" alt="leetcode-54"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/26 14:27</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 54_spiral-matrix.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/spiral-matrix/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">spiral_matrix</span><span class="params">(r1, c1, r2, c2)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(c1, c2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">yield</span> r1, c</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> range(r1 + <span class="number">1</span>, r2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">yield</span> r, c2</span><br><span class="line">            <span class="keyword">if</span> r1 &lt; r2 <span class="keyword">and</span> c1 &lt; c2:</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> range(c2 - <span class="number">1</span>, c1, <span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">yield</span> r2, c</span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> range(r2, r1, <span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">yield</span> r, c1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        output = []</span><br><span class="line">        r1, r2 = <span class="number">0</span>, len(matrix) - <span class="number">1</span></span><br><span class="line">        c1, c2 = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r1 &lt;= r2 <span class="keyword">and</span> c1 &lt;= c2:</span><br><span class="line">            <span class="keyword">for</span> r, c <span class="keyword">in</span> spiral_matrix(r1, c1, r2, c2):</span><br><span class="line">                output.append(matrix[r][c])</span><br><span class="line">            r1 += <span class="number">1</span></span><br><span class="line">            r2 -= <span class="number">1</span></span><br><span class="line">            c1 += <span class="number">1</span></span><br><span class="line">            c2 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.spiralOrder([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">]))</span><br></pre></td></tr></tbody></table></figure><h2 id="spiral-matrix-ii"><a href="#spiral-matrix-ii" class="headerlink" title="spiral-matrix-ii"></a>spiral-matrix-ii</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/1 18:14</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 59_spiral-matrix-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/spiral-matrix-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">spiral_matrix</span><span class="params">(r1, c1, r2, c2)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(c1, c2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">yield</span> r1, c</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> range(r1 + <span class="number">1</span>, r2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">yield</span> r, c2</span><br><span class="line">            <span class="keyword">if</span> r1 &lt; r2 <span class="keyword">and</span> c1 &lt; c2:</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> range(c2 - <span class="number">1</span>, c1, <span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">yield</span> r2, c</span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> range(r2, r1, <span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">yield</span> r, c1</span><br><span class="line"></span><br><span class="line">        output_matrix = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        r1, r2 = <span class="number">0</span>, len(output_matrix) - <span class="number">1</span></span><br><span class="line">        c1, c2 = <span class="number">0</span>, len(output_matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        number = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r1 &lt;= r2 <span class="keyword">and</span> c1 &lt;= c2:</span><br><span class="line">            <span class="keyword">for</span> r, c <span class="keyword">in</span> spiral_matrix(r1, c1, r2, c2):</span><br><span class="line">                output_matrix[r][c] = number</span><br><span class="line">                number += <span class="number">1</span></span><br><span class="line">            r1 += <span class="number">1</span></span><br><span class="line">            r2 -= <span class="number">1</span></span><br><span class="line">            c1 += <span class="number">1</span></span><br><span class="line">            c2 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output_matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.generateMatrix(<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="set-matrix-zeroes"><a href="#set-matrix-zeroes" class="headerlink" title="set-matrix-zeroes"></a>set-matrix-zeroes</h2><p>解题思路如下：</p><blockquote><p>matrics第一行与第一列用于存储对应行或列是否有0</p><p>flag用于存储第一行或者第一列是否存在0</p></blockquote><ul><li>首先遍历第一行与第一列是否存在0，若存在将flag置为0</li><li>再遍历其他行，若存在0，将相应第一行和第一列的元素置为0</li><li>再次遍历第一行与第一列，将0所在的行和列中的所有元素置为0</li><li>最后，若flag为0，则把第一行和第一列的所有元素置为0。否则直接退出</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/17 12:08</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 73_set-matrix-zeroes.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/set-matrix-zeroes/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        flag_col = <span class="literal">False</span></span><br><span class="line">        rows = len(matrix)</span><br><span class="line">        cols = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">if</span> matrix[row][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                flag_col = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">1</span>, cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[row][col] == <span class="number">0</span>:</span><br><span class="line">                    matrix[row][<span class="number">0</span>] = matrix[<span class="number">0</span>][col] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(rows - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(cols - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> matrix[row][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> matrix[<span class="number">0</span>][col] == <span class="number">0</span>:</span><br><span class="line">                    matrix[row][col] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> flag_col:</span><br><span class="line">                matrix[row][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.setZeroes([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-1"><a href="#interview-1" class="headerlink" title="interview_1"></a>interview_1</h2><p>如果从左上角开始找，“从上到下”和“从左到右”，遇到的数字都是逐渐增大的；</p><p>如果从右下角开始找，“从下到上”和“从右到左”，遇到的数字都是逐渐减小的；</p><p>所以，可以从左下或者右上开始搜索，以保证不走“回头路”</p><p><img data-src="/images/algorithm/er-wei-shu-zu-zhong-de-cha-zhao-lcof.png" alt="er-wei-shu-zu-zhong-de-cha-zhao-lcof"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/7 12:31 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> target <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        rows = len(matrix)</span><br><span class="line">        cols = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> rows == <span class="number">0</span> <span class="keyword">or</span> cols == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从右上角开始搜索</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        y = cols - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> x &lt; rows <span class="keyword">and</span> y &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> matrix[x][y] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 从matrix[x][y]的左下角部分进行搜索</span></span><br><span class="line">            <span class="keyword">if</span> matrix[x][y] &gt; target:</span><br><span class="line">                y -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findNumberIn2DArray([</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">4</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],</span><br><span class="line">  [<span class="number">2</span>,   <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>],</span><br><span class="line">  [<span class="number">3</span>,   <span class="number">6</span>,  <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>],</span><br><span class="line">  [<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>]</span><br><span class="line">], <span class="number">21</span></span><br><span class="line">))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-19"><a href="#interview-19" class="headerlink" title="interview_19"></a>interview_19</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 17:32</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_19.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 生成器</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">spiral_matrix</span><span class="params">(r1, c1, r2, c2)</span>:</span></span><br><span class="line">            <span class="comment"># 先输出r1行的坐标</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(c1, c2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">yield</span> r1, c</span><br><span class="line">            <span class="comment"># 再输出c2列的坐标</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> range(r1 + <span class="number">1</span>, r2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">yield</span> r, c2</span><br><span class="line">            <span class="comment"># 判断r1与r2，c1与c2是否重合</span></span><br><span class="line">            <span class="keyword">if</span> r1 &lt; r2 <span class="keyword">and</span> c1 &lt; c2:</span><br><span class="line">                <span class="comment"># 先输出r2行的坐标</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> range(c2 - <span class="number">1</span>, c1, <span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">yield</span> r2, c</span><br><span class="line">                <span class="comment"># 再输出c1列的坐标</span></span><br><span class="line">                <span class="keyword">for</span> r <span class="keyword">in</span> range(r2, r1, <span class="number">-1</span>):</span><br><span class="line">                    <span class="keyword">yield</span> r, c1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        output = []</span><br><span class="line">        r1, r2 = <span class="number">0</span>, len(matrix) - <span class="number">1</span></span><br><span class="line">        c1, c2 = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 控制大局（矩形范围）：r1、r2、c1、c2</span></span><br><span class="line">        <span class="keyword">while</span> r1 &lt;= r2 <span class="keyword">and</span> c1 &lt;= c2:</span><br><span class="line">            <span class="comment"># 用for去遍历这个生成器</span></span><br><span class="line">            <span class="keyword">for</span> r, c <span class="keyword">in</span> spiral_matrix(r1, c1, r2, c2):</span><br><span class="line">                output.append(matrix[r][c])</span><br><span class="line">            r1 += <span class="number">1</span></span><br><span class="line">            r2 -= <span class="number">1</span></span><br><span class="line">            c1 += <span class="number">1</span></span><br><span class="line">            c2 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.spiralOrder([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-51"><a href="#interview-51" class="headerlink" title="interview_51"></a>interview_51</h2><p><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/solution/mian-shi-ti-66-gou-jian-cheng-ji-shu-zu-biao-ge-fe/" target="_blank" rel="noopener">参考链接</a></p><p><img data-src="/images/algorithm/interview_51_1.png" alt="计算下三角"></p><p><img data-src="/images/algorithm/interview_51.png" alt="计算上三角"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/25 14:37 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_51.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructArr</span><span class="params">(self, a: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        b, tmp = [<span class="number">1</span>] * len(a), <span class="number">1</span></span><br><span class="line">        <span class="comment"># 先计算下三角</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)):</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 再计算上三角</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a) - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            tmp *= a[i + <span class="number">1</span>]</span><br><span class="line">            b[i] *= tmp</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.constructArr([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-35"><a href="#interview-35" class="headerlink" title="interview_35"></a>interview_35</h2><p>方法一：暴力法</p><p>时间复杂度$O(n^2)$</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/8/24 20:27</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_35.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        len_nums = len(nums)</span><br><span class="line">        <span class="keyword">if</span> len_nums &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 冒泡排序，寻找逆序数对</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_nums):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len_nums):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    result += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reversePairs([<span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><p>方法二：归并排序</p><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/" target="_blank" rel="noopener">解题思路</a></p><p>归并排序的时间复杂度是$O(NlogN)$</p><p>首先复习下归并排序：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">用于分解</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    len_nums = len(nums)</span><br><span class="line">    <span class="comment"># 递归的出口</span></span><br><span class="line">    <span class="keyword">if</span> len_nums &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = len_nums // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 分解成两个更小的数组</span></span><br><span class="line">    nums1 = mergeSort(nums[:mid])</span><br><span class="line">    nums2 = mergeSort(nums[mid:]</span><br><span class="line">    <span class="keyword">return</span> merge(nums1, nums2)</span><br><span class="line">                      </span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">用于合并:将产生一个排好序的数组</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums1, nums2)</span>:</span></span><br><span class="line">    sum_nums = []  <span class="comment"># 用于存储两个列表合并后的结果</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 两个列表，逐个元素进行对比，较小的元素将添加到结果中</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(nums1) <span class="keyword">and</span> j &lt; len(nums2):</span><br><span class="line">        <span class="keyword">if</span> nums1[i] &lt;= nums2[j]:</span><br><span class="line">            sum_nums.append(nums1[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sum_nums.append(nums2[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将未添加完的元素增加到result_list后面，</span></span><br><span class="line">    <span class="comment"># 因为每次都要移动已经添加好的元素。此方法的时间复杂度是O(n^2)，下段代码会改进。这里为了便于理解</span></span><br><span class="line">    sum_nums += nums1[i:]</span><br><span class="line">    sum_nums += nums2[j:]</span><br><span class="line">    <span class="keyword">return</span> sum_nums</span><br></pre></td></tr></tbody></table></figure><p>在合并部分，归并是利用一个sum_nums逐个<strong>将较小</strong>的元素添加至尾部，从而得到一个顺序数组。如果<strong>现在要从数组尾部开始遍历，同样产生一个顺序数组</strong>，要怎么做呢。</p><p>可以看到，改动点只是在merge函数里，将两个列表每次比较后较大的元素，从后往前的添加到sum_nums里即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">用于分解</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    len_nums = len(nums)</span><br><span class="line">    <span class="comment"># 递归的出口</span></span><br><span class="line">    <span class="keyword">if</span> len_nums &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    mid = len_nums // <span class="number">2</span></span><br><span class="line">    <span class="comment"># 分解成两个更小的数组</span></span><br><span class="line">    nums1 = mergeSort(nums[:mid])</span><br><span class="line">    nums2 = mergeSort(nums[mid:]</span><br><span class="line">    <span class="keyword">return</span> merge(nums1, nums2)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">用于合并:将产生一个排好序的数组</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums1, nums2)</span>:</span></span><br><span class="line">    i, j = len(nums1) - <span class="number">1</span>, len(nums2) - <span class="number">1</span></span><br><span class="line">    sum_nums = [<span class="number">0</span>] * (i + j + <span class="number">2</span>)  <span class="comment"># 用于存储两个列表合并后的结果</span></span><br><span class="line">    sum_nums_index = len(sum_nums) - <span class="number">1</span>  <span class="comment"># 当前临时列表的索</span></span><br><span class="line">    <span class="comment"># 两个列表，逐个元素进行对比，大的元素将添加到结果中</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">            sum_nums[sum_nums_index] = nums1[i]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            sum_nums_index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sum_nums[sum_nums_index] = nums2[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            sum_nums_index -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将未添加完的元素增加到sum_nums前面，时间复杂度O(1)</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        sum_nums[sum_nums_index] = nums1[i]</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">        sum_nums_index -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        sum_nums[sum_nums_index] = nums2[j]</span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">        sum_nums_index -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sum_num</span><br><span class="line">mergeSort(nums)</span><br></pre></td></tr></tbody></table></figure><p>现在应该一目了然了，接下来只要增加一个变量，将每次合并过程中的逆序对进行统计就可以了。因为在每次的合并过程中，nums1与nums2都是有序的，且 i，j分别指向两个数组。假如：</p><blockquote><p>nums1 = [3, 6] nums2 = [2, 4]</p></blockquote><p>对于6而言，6小于4( nums1[ i ] &lt; nums2[ j ]  )，构成一对逆序数。又因为两个数组都是有序的，所以我们知道，6大于nums2里 j 指向的当前最大的元素4，当然也会大于比4小的2。所以对于6而言，它能构成的逆序数对为 j + 1 == 2。( j = 0,……, len(nums2) - 1）</p><p>可以这样想，sum_nums只是保存了当前数组里的大小关系，这种顺序关系是为了便于逆序对个数的快速计算，它并没有改变原数组的顺序。</p><p>完整代码如下：利用全局变量count来记录合并过程中逆序对的个数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/8/24 20:27</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_35.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span>  <span class="comment"># 用于记录逆序对的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用于分解</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(nums)</span>:</span></span><br><span class="line"></span><br><span class="line">            len_nums = len(nums)</span><br><span class="line">            <span class="comment"># 递归的出口</span></span><br><span class="line">            <span class="keyword">if</span> len_nums &lt;= <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> nums</span><br><span class="line">            mid = len_nums // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 分解成两个更小的数组</span></span><br><span class="line">            nums1 = mergeSort(nums[:mid])</span><br><span class="line">            nums2 = mergeSort(nums[mid:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> merge(nums1, nums2)</span><br><span class="line"></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用于合并:将产生一个排好序的数组</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums1, nums2)</span>:</span></span><br><span class="line">            i, j = len(nums1) - <span class="number">1</span>, len(nums2) - <span class="number">1</span></span><br><span class="line">            sum_nums = [<span class="number">0</span>] * (i + j + <span class="number">2</span>)  <span class="comment"># 用于存储两个列表合并后的结果</span></span><br><span class="line">            sum_nums_index = len(sum_nums) - <span class="number">1</span>  <span class="comment"># 当前临时列表的索引</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 两个列表，逐个元素进行对比，大的元素将添加到结果中</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 存在一对逆序</span></span><br><span class="line">                <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                    self.count += (j + <span class="number">1</span>) <span class="comment"># 记录逆序对的个数，取决于当前的j</span></span><br><span class="line">                    sum_nums[sum_nums_index] = nums1[i]</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                    sum_nums_index -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    sum_nums[sum_nums_index] = nums2[j]</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                    sum_nums_index -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将未添加完的元素增加到sum_nums后面</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">                sum_nums[sum_nums_index] = nums1[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                sum_nums_index -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                sum_nums[sum_nums_index] = nums2[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                sum_nums_index -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> sum_nums</span><br><span class="line"></span><br><span class="line">        mergeSort(nums)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reversePairs([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]))</span><br></pre></td></tr></tbody></table></figure><h1 id="Regular-Expression"><a href="#Regular-Expression" class="headerlink" title="Regular Expression"></a>Regular Expression</h1><h2 id="string-to-integer-atoi"><a href="#string-to-integer-atoi" class="headerlink" title="string-to-integer-atoi"></a>string-to-integer-atoi</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/20 1:20 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 8_string-to-integer-atoi.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/string-to-integer-atoi/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="keyword">if</span> len(s) &gt; <span class="number">0</span>:</span><br><span class="line">            pattern = <span class="string">r"[+-]?\d+"</span></span><br><span class="line">            number = re.match(pattern, s)</span><br><span class="line">            <span class="keyword">if</span> number:</span><br><span class="line">                number = int(number[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">if</span> number &lt; -pow(<span class="number">2</span>, <span class="number">31</span>):</span><br><span class="line">                    <span class="keyword">return</span> int(-pow(<span class="number">2</span>, <span class="number">31</span>))</span><br><span class="line">                <span class="keyword">elif</span> number &gt; pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> int(pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> number</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.myAtoi(<span class="string">"+123"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="regular-expression-matchin"><a href="#regular-expression-matchin" class="headerlink" title="regular-expression-matchin"></a>regular-expression-matchin</h2><p>方法一：暴力求解， offer再见法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> (re.fullmatch(p, s) != <span class="literal">None</span>)</span><br></pre></td></tr></tbody></table></figure><p>方法二：回溯求解</p><p><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/" target="_blank" rel="noopener">参考链接</a></p><p>首先，考虑只有“.”的情况。这种情况下只需要从左到右依次判断s[i]与p[i]是否匹配即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">      <span class="comment"># 如果p已经匹配完了，匹配结果取决于s是否为空</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">      </span><br><span class="line">      first_match = s <span class="keyword">and</span> (s[<span class="number">0</span>] == p[<span class="number">0</span>] <span class="keyword">or</span> p[<span class="number">0</span>] == <span class="string">"."</span>)</span><br><span class="line">      <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></tbody></table></figure><p>如果有“*”，它会出现在p[1]的位置，这时有两种情况：</p><ul><li>“<em>”匹配了0次前面的元素：这时直接比较”\</em>​”后面的元素即可。如“##”与“a*##”，即self.isMatch(s, p[2:])</li><li>“<em>”匹配了1次或多次前面的元素：这时忽略s的第一个元素，继续与p进行比较。如“aaab”与“a\</em>b”，继续比较“aab”与“a*b”，可以理解为逐步走到了第一种情况。即self.isMatch(s[1:], p)</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> len(p) &gt; <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">"*"</span>:</span><br><span class="line">  <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> \</span><br><span class="line">(first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p))</span><br></pre></td></tr></tbody></table></figure><p>完整代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/21 7:46 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 10_regular-expression-matchin.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/regular-expression-matching/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> s  <span class="comment"># 结束条件</span></span><br><span class="line"></span><br><span class="line">        first_match = s <span class="keyword">and</span> (s[<span class="number">0</span>] == p[<span class="number">0</span>] <span class="keyword">or</span> p[<span class="number">0</span>] == <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">          <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> \</span><br><span class="line">          (first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line"><span class="keyword">assert</span> so.isMatch(<span class="string">"mississippi"</span>, <span class="string">"mis*is*ip*."</span>)</span><br></pre></td></tr></tbody></table></figure><p>方法三：动态规划</p><p><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/hui-su-dong-tai-gui-hua-by-ml-zimingmeng/" target="_blank" rel="noopener">参考链接</a></p><h2 id="interview-52"><a href="#interview-52" class="headerlink" title="interview_52"></a>interview_52</h2><p>同<a href="https://unknown.yuzhouwan.com/posts/55663/#regular-expression-matchi">regular-expression-matchin</a></p><h2 id="valid-number"><a href="#valid-number" class="headerlink" title="valid-number"></a>valid-number</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/8 00:41</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 65_valid-number.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/valid-number/</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># return bool(re.match(r' *[+-]?([0-9]+(\.[0-9]*)?|\.[0-9]+)(e[+-]?[0-9]+)? *$', s))</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="comment"># 去除s两边的空白符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 去除"+"、"-"</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">"+"</span>, <span class="string">"-"</span>]:</span><br><span class="line">            s = s[<span class="number">1</span>:]</span><br><span class="line">        <span class="comment"># 判断是否含有e</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"e"</span> <span class="keyword">in</span> s:</span><br><span class="line">            s_list = s.split(<span class="string">"e"</span>)</span><br><span class="line">            <span class="comment"># 说明有两个e</span></span><br><span class="line">            <span class="keyword">if</span> len(s_list) &gt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 去掉e前面的"."</span></span><br><span class="line">            s_list[<span class="number">0</span>] = s_list[<span class="number">0</span>].replace(<span class="string">"."</span>, <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 去掉e后面的"+、"-"</span></span><br><span class="line">            <span class="keyword">if</span> len(s_list[<span class="number">1</span>]) &gt; <span class="number">0</span> <span class="keyword">and</span> s_list[<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">"+"</span>, <span class="string">"-"</span>]:</span><br><span class="line">                s_list[<span class="number">1</span>] = s_list[<span class="number">1</span>].replace(s_list[<span class="number">1</span>][<span class="number">0</span>], <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 判断是否为数字</span></span><br><span class="line">            <span class="keyword">if</span> s_list[<span class="number">0</span>].isnumeric() <span class="keyword">and</span> s_list[<span class="number">1</span>].isnumeric():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = s.replace(<span class="string">"."</span>, <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> s.isnumeric():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isNumber(<span class="string">"53.5e93"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-53"><a href="#interview-53" class="headerlink" title="interview_53"></a>interview_53</h2><p>解法一：暴力法（面试慎用）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 16:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_53.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            float(s)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>解法二：正则表达式</p><p>依次来看下面的正则表达式：</p><ul><li>从E、e来划分，先看<strong>前半部分</strong>： </li></ul><p>匹配字符串开头^，可以有多个空格\s​，且+-号只能出现一次</p><blockquote><p><code>^\s*[+-]{0,1}</code></p></blockquote><p>用于匹配诸如10.111、10.1、10等数字（小数点后面必须出现数字）</p><blockquote><p><code>(\d)+((\.)(\d)+){0,1}</code></p></blockquote><p>用于匹配.1、.111111等数字</p><blockquote><p><code>((\.)(\d)+)</code></p></blockquote><p>用于匹配10.、1.等数字（小数点后面没有数字）</p><blockquote><p><code>((\d)+(\.))</code></p></blockquote><ul><li>再看<strong>后半部分</strong>：</li></ul><p>e或E后面可以跟+-号，且后面必须跟数字。整个指数部分可以出现0-1次。</p><blockquote><p><code>([eE][+-]{0,1}(\d)+){0,1}</code></p></blockquote><p>整个字符串结束前可以跟0或多个空格</p><blockquote><p><code>\s*$</code></p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 16:16</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_53.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        matchObj = re.match(<span class="string">"^\s*[+-]{0,1}((\d)+((\.)(\d)+){0,1}|((\.)(\d)+)|((\d)+(\.)))([eE][+-]{0,1}(\d)+){0,1}\s*$"</span>,s)</span><br><span class="line">        <span class="keyword">if</span> matchObj:</span><br><span class="line">            print(<span class="string">"match --&gt; matchObj.group() : "</span>, matchObj.group())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"No match!!"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串"+100"、"5e2"、"-123"、"3.1416"、"-1E-16"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"及"12e+5.4"都不是。</span></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isNumber(<span class="string">"13.e2"</span>))</span><br></pre></td></tr></tbody></table></figure><p>解法三：<a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/solution/mian-shi-ti-20-biao-shi-shu-zhi-de-zi-fu-chuan-y-2/" target="_blank" rel="noopener">有限状态自动机</a></p><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><h2 id="valid-parentheses"><a href="#valid-parentheses" class="headerlink" title="valid-parentheses"></a>valid-parentheses</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/26 11:53 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 20_valid-parentheses.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        stack = []</span><br><span class="line">        dic = {<span class="string">"{"</span>: <span class="string">"}"</span>, <span class="string">"["</span>: <span class="string">"]"</span>, <span class="string">"("</span>: <span class="string">")"</span>}</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> dic:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> dic[stack.pop()] != c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> len(stack) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isValid(<span class="string">"()[]{}"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="largest-rectangle-in-histogram"><a href="#largest-rectangle-in-histogram" class="headerlink" title="largest-rectangle-in-histogram"></a>largest-rectangle-in-histogram</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/29 16:24 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 84_largest-rectangle-in-histogram.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">                tmp = stack.pop()</span><br><span class="line">                res = max(res, (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) * heights[tmp])</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.largestRectangleArea([<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="maximal-rectangle"><a href="#maximal-rectangle" class="headerlink" title="maximal-rectangle"></a>maximal-rectangle</h2><p>注：<a href="https://leetcode-cn.com/problems/maximal-rectangle/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-8/" target="_blank" rel="noopener">参考链接</a></p><p><img data-src="/images/algorithm/leetcode-85.png" alt="leetcode-85"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/30 22:22 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 85_maximal-rectangle.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/maximal-rectangle/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">0</span>, len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">0</span>, len(matrix[<span class="number">0</span>])):</span><br><span class="line">                dp[col] = dp[col] + <span class="number">1</span> <span class="keyword">if</span> matrix[row][col] == <span class="string">"1"</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            max_area = max(max_area, self.largestRectangleArea(dp))</span><br><span class="line">        <span class="keyword">return</span> max_area</span><br><span class="line"></span><br><span class="line">    <span class="comment"># from 84_largest-rectangle-in-histogram</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[<span class="number">-1</span>]]:</span><br><span class="line">                tmp = stack.pop()</span><br><span class="line">                res = max(res, (i - stack[<span class="number">-1</span>] - <span class="number">1</span>) * heights[tmp])</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.maximalRectangle([</span><br><span class="line">    [<span class="string">"1"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"0"</span>, <span class="string">"0"</span>],</span><br><span class="line">    [<span class="string">"1"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>],</span><br><span class="line">    [<span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>],</span><br><span class="line">    [<span class="string">"1"</span>, <span class="string">"0"</span>, <span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"0"</span>]</span><br><span class="line">]))</span><br></pre></td></tr></tbody></table></figure><h2 id="implement-queue-using-stacks"><a href="#implement-queue-using-stacks" class="headerlink" title="implement-queue-using-stacks"></a>implement-queue-using-stacks</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/12 12:40 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 232_implement-queue-using-stacks.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/implement-queue-using-stacks/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack1.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 把stack1里面的元素全部pop至stack2</span></span><br><span class="line">            <span class="keyword">while</span> len(self.stack1) != <span class="number">0</span>:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> len(self.stack1) != <span class="number">0</span>:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack1) == <span class="number">0</span> <span class="keyword">and</span> len(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></tbody></table></figure><h2 id="interview-20"><a href="#interview-20" class="headerlink" title="interview_20"></a>interview_20</h2><p>解题思路：除了一个常规列表实现栈的操作外，再开一个<strong>辅助栈</strong>用于保存当前的最小信息：</p><ul><li>入栈操作：当辅助栈为空或者新元素小于等于辅助栈顶元素时，辅助栈入栈；否则无视</li><li>出栈操作：当常规栈中待出栈的元素等于辅助栈顶元素时，辅助栈出栈一个元素，代表当前的最小值出队或者次数减1</li><li>栈顶操作：仅需从常规栈顶取元素即可</li><li>最小值操作：因为辅助栈中维护的都是当前状态下的最小值，所以从辅助栈顶取元素即可</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/7 21:36 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_20.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/</span></span><br><span class="line"><span class="comment"># bao-han-minhan-shu-de-zhan-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.mins = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.mins <span class="keyword">or</span> x &lt;= self.mins[<span class="number">-1</span>]:</span><br><span class="line">            self.mins.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x = self.stack.pop()</span><br><span class="line">        <span class="keyword">if</span> self.mins <span class="keyword">and</span> self.mins[<span class="number">-1</span>] == x:</span><br><span class="line">            self.mins.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack <span class="keyword">and</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.mins <span class="keyword">and</span> self.mins[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.min()</span></span><br></pre></td></tr></tbody></table></figure><h2 id="interview-21"><a href="#interview-21" class="headerlink" title="interview_21"></a>interview_21</h2><p><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/tan-xin-by-z1m/" target="_blank" rel="noopener">解题思路</a></p><p>我们使用一个<strong>辅助栈</strong> 来模拟该操作。将 pushed 数组中的每个数依次入栈，同时判断这个数是不是 popped 数组中下一个要 pop 的值，如果是就把它 pop 出来。最后检查栈是否为空。</p><p>算法</p><ul><li><p>初始化栈 stack，j = 0；</p></li><li><p>遍历 pushed 中的元素 x；</p><ul><li>当 j &lt; popped.size() 且栈顶元素等于 popped[j]：弹出栈顶元素；j += 1；</li></ul></li><li><p>如果栈为空，返回 True，否则返回 False。</p></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validateStackSequences</span><span class="params">(self, pushed: List[int], popped: List[int])</span> -&gt; bool:</span></span><br><span class="line">        i_pop = <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> pushed:</span><br><span class="line">            stack.append(value)</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> popped[i_pop] == stack[<span class="number">-1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                i_pop += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.validateStackSequences(pushed=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], popped=[<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-5"><a href="#interview-5" class="headerlink" title="interview_5"></a>interview_5</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 11:33 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_5.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack1.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 把stack1里面的元素全部pop至stack2</span></span><br><span class="line">            <span class="keyword">while</span> len(self.stack1) != <span class="number">0</span>:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> len(self.stack1) != <span class="number">0</span>:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(self.stack1) == <span class="number">0</span> <span class="keyword">and</span> len(self.stack2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></tbody></table></figure><h1 id="BinaryTree"><a href="#BinaryTree" class="headerlink" title="BinaryTree"></a>BinaryTree</h1><h2 id="generate-parentheses"><a href="#generate-parentheses" class="headerlink" title="generate-parentheses"></a>generate-parentheses</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/2 12:06 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 22_generate-parentheses.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/generate-parentheses/</span></span><br><span class="line"><span class="comment">#       (</span></span><br><span class="line"><span class="comment">#     (    )</span></span><br><span class="line"><span class="comment">#   )        (</span></span><br><span class="line"><span class="comment"># )            )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span>:</span></span><br><span class="line">        output_li = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_Parenthesis</span><span class="params">(s=<span class="string">""</span>, left=<span class="number">0</span>, right=<span class="number">0</span>)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(s) == <span class="number">2</span> * n:</span><br><span class="line">                output_li.append(s)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                find_Parenthesis(s + <span class="string">"("</span>, left + <span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">if</span> right &lt; left:</span><br><span class="line">                find_Parenthesis(s + <span class="string">")"</span>, left, right + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        find_Parenthesis()</span><br><span class="line">        <span class="keyword">return</span> output_li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.generateParenthesis(<span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-4"><a href="#interview-4" class="headerlink" title="interview_4"></a>interview_4</h2><p>解题思路:</p><ul><li>前序遍历的第一个节点为根节点</li><li>根据前序遍历确定的根节点，可以在中序遍历中确定其左右子树</li></ul><p><img data-src="/images/algorithm/rebuildbinarytree.png" alt="rebuildbinarytree"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/10 22:47 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_4.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 前序遍历第一个肯定为根节点</span></span><br><span class="line">        root_value = preorder[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(root_value)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据中序遍历结果确定根节点的左右子树</span></span><br><span class="line">        root_index = inorder.index(root_value)</span><br><span class="line">        <span class="comment"># 在中序列表中的左右子树</span></span><br><span class="line">        left_in_inorder = inorder[:root_index]</span><br><span class="line">        right_in_inorder = inorder[root_index+<span class="number">1</span>:]</span><br><span class="line">        <span class="comment"># 在前序列表中的左右子树</span></span><br><span class="line">        left_in_preorder = preorder[<span class="number">1</span>:root_index+<span class="number">1</span>]  <span class="comment"># 左子树数量就是root_index的个数</span></span><br><span class="line">        right_in_preorder = preorder[root_index+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归创建子树</span></span><br><span class="line">        root.left = self.buildTree(left_in_preorder, left_in_inorder)</span><br><span class="line">        root.right = self.buildTree(right_in_preorder, right_in_inorder)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-57"><a href="#interview-57" class="headerlink" title="interview_57"></a>interview_57</h2><p>输入一个节点，分析该节点的下一个节点，一共有以下情况：</p><ol><li><p>二叉树为空，则返回空；</p></li><li><p>该节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；</p></li><li><p>该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</p></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/11 19:47</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_57.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span>  <span class="comment"># 中序遍历序列的下一个节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pNode:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 如果当前节点有右节点，则下一个节点为其右节点的最左侧的节点</span></span><br><span class="line">        <span class="keyword">if</span> pNode.right:</span><br><span class="line">            pNode = pNode.right</span><br><span class="line">            <span class="keyword">while</span> pNode.left:</span><br><span class="line">                pNode = pNode.left</span><br><span class="line">            <span class="keyword">return</span> pNode</span><br><span class="line">        <span class="comment"># 如果当前节点没有右节点</span></span><br><span class="line">        <span class="keyword">while</span> pNode.next:</span><br><span class="line">            <span class="comment"># 如果当前节点位于左子树上</span></span><br><span class="line">            <span class="keyword">if</span> pNode.next.left == pNode:  <span class="comment"># pNode.next为父节点</span></span><br><span class="line">                <span class="keyword">return</span> pNode.next</span><br><span class="line">            <span class="comment"># 否则循环找，直到当前节点为其父节点的左子树</span></span><br><span class="line">            pNode = pNode.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure><h2 id="longest-univalue-path"><a href="#longest-univalue-path" class="headerlink" title="longest-univalue-path"></a>longest-univalue-path</h2><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/solution/zui-chang-tong-zhi-lu-jing-by-leetcode/" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/19 23:48 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 687_longest-univalue-path.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/longest-univalue-path/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestUnivaluePath</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">arrow_length</span><span class="params">(node: TreeNode)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left_length = arrow_length(node.left)</span><br><span class="line">            right_length = arrow_length(node.right)</span><br><span class="line">            left_arrow = right_arrow = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">and</span> node.val == node.left.val:</span><br><span class="line">                left_arrow = left_length + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">and</span> node.val == node.right.val:</span><br><span class="line">                right_arrow = right_length + <span class="number">1</span></span><br><span class="line">            self.ans = max(self.ans, left_arrow+right_arrow)</span><br><span class="line">            <span class="keyword">return</span> max(left_arrow, right_arrow)</span><br><span class="line">        arrow_length(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-17"><a href="#interview-17" class="headerlink" title="interview_17"></a>interview_17</h2><p><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/mian-shi-ti-26-shu-de-zi-jie-gou-xian-xu-bian-li-p/" target="_blank" rel="noopener">解题思路</a></p><p>若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：</p><ol><li>先序遍历树 A中的每个节点 A。（对应函数 isSubStructure(A, B)）</li><li>判断树 A 中 以A为根节点的子树 是否包含树 B 。（对应函数 recur(A, B)）</li></ol><ul><li>isSubStructure(A, B) 函数：</li></ul><p>特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false ；<br>返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<br>以 节点 A 为根节点的子树 包含树 B ，对应 recur(A, B)；<br>树 B 是 树 A 左子树 的子结构，对应 isSubStructure(A.left, B)；<br>树 B 是 树 A 右子树 的子结构，对应 isSubStructure(A.right, B)；</p><ul><li>recur(A, B) 函数：</li></ul><ol><li>终止条件：<br>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true；<br>当节点 A 为空：说明已经越过树 A 叶子节点，即匹配失败，返回 false ；<br>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li><li>返回值：<br>判断 A 和 B 的左子节点是否相等，即 recur(A.left, B.left) ；<br>判断 A 和 B 的右子节点是否相等，即 recur(A.right, B.right) ；</li></ol><p><img data-src="/images/algorithm/interview_17.png" alt="interview_17"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/2 12:32 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_17.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A: TreeNode, B: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.recure(A, B) <span class="keyword">or</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recure</span><span class="params">(self, A: TreeNode, B: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.recure(A.left, B.left) <span class="keyword">and</span> self.recure(A.right, B.right)</span><br></pre></td></tr></tbody></table></figure><h2 id="invert-binary-tree"><a href="#invert-binary-tree" class="headerlink" title="invert-binary-tree"></a>invert-binary-tree</h2><ul><li>递归解法</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/3 12:28 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 226_invert-binary-tree.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/invert-binary-tree/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.invertTree(root.left)</span><br><span class="line">        right = self.invertTree(root.right)</span><br><span class="line">        root.left = right</span><br><span class="line">        root.right = left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure><ul><li>迭代解法</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/3 12:28 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 226_invert-binary-tree.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/invert-binary-tree/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="comment"># 广度优先搜索</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">          temp_root = queue.pop()</span><br><span class="line">          temp_root.left, temp_root.right = temp_root.right, temp_root.left</span><br><span class="line">          <span class="comment"># 继续把子孩子入队</span></span><br><span class="line">          <span class="keyword">if</span> temp_root.left:</span><br><span class="line">            queue.append(temp_root.left)</span><br><span class="line">          <span class="keyword">if</span> temp_root.right:</span><br><span class="line">            queue.append(temp_root.right) </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-22-i"><a href="#interview-22-i" class="headerlink" title="interview_22_i"></a>interview_22_i</h2><p>利用队列，广度优先遍历二叉树</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/8 19:19 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_32_i.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque()</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            node = deque.popleft()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                deque.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                deque.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-22-ii"><a href="#interview-22-ii" class="headerlink" title="interview_22_ii"></a>interview_22_ii</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/8 19:28 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_32_ii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque()</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            tem = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(deque)):</span><br><span class="line">                node = deque.popleft()</span><br><span class="line">                tem.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    deque.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    deque.append(node.right)</span><br><span class="line">            res.append(tem)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-22-iii"><a href="#interview-22-iii" class="headerlink" title="interview_22_iii"></a>interview_22_iii</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/8 19:48 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_32_iii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque()</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            tem = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(deque)):</span><br><span class="line">                node = deque.popleft()</span><br><span class="line">                tem.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    deque.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    deque.append(node.right)</span><br><span class="line">            res.append(tem[::<span class="number">-1</span>] <span class="keyword">if</span> len(res) % <span class="number">2</span> <span class="keyword">else</span> tem)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-59"><a href="#interview-59" class="headerlink" title="interview_59"></a>interview_59</h2><p>此题同<a href="https://unknown.yuzhouwan.com/posts/55663/#interview_22_iii">interview_22_iii</a></p><h2 id="interview-23"><a href="#interview-23" class="headerlink" title="interview_23"></a>interview_23</h2><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/" target="_blank" rel="noopener">解题思路</a></p><p><img data-src="/images/algorithm/interview_23.png" alt="interview_23"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/15 22:18</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_23.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 待分析的区间</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="comment">#  已经对比完毕，返回True</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 根结点在最右边，左子树应该都比它小</span></span><br><span class="line">            p = i</span><br><span class="line">            <span class="keyword">while</span> postorder[p] &lt; postorder[j]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            left_end = p</span><br><span class="line">            <span class="comment"># 右子树应该都比它小</span></span><br><span class="line">            <span class="keyword">while</span> postorder[p] &gt; postorder[j]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 若是后序遍历序列，那p应该已经和j相等了; 并且遍历左右子树序列也应该是后序遍历序列</span></span><br><span class="line">            <span class="keyword">return</span> p == j <span class="keyword">and</span> recur(i, left_end - <span class="number">1</span>) <span class="keyword">and</span> recur(left_end, j - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, len(postorder) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.verifyPostorder([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-24"><a href="#interview-24" class="headerlink" title="interview_24"></a>interview_24</h2><p>本问题是典型的二叉树方案搜索问题，使用<strong>回溯法解决</strong>，其包含 <strong>先序遍历 + 路径记录</strong> 两部分。</p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/mian-shi-ti-34-er-cha-shu-zhong-he-wei-mou-yi-zh-5/" target="_blank" rel="noopener">参考链接</a></p><p><img data-src="/images/algorithm/interview_24.png" alt="interview_24"></p><blockquote><p>res.append(list(path))：记录路径时若直接执行 res.append(path) ，则是将 <code>path 列表对象</code> 加入了 res ；后续 path 对象改变时， <code>res 中的 path 对象</code> 也会随之改变（因此肯定是不对的，本来存的是正确的路径 path ，后面又 append 又 pop 的，就破坏了这个正确路径）。<code>list(path)</code> 相当于新建并复制了一个 path 列表，因此不会受到 path 变化的影响。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/15 23:03</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_24.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/solution/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res, path = [], []  <span class="comment"># 用于存放最终的结果，与当前遍历的路径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输入当前的遍历的节点，与当前的目标值</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(root, tar)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            path.append(root.val)</span><br><span class="line">            tar -= root.val</span><br><span class="line">            <span class="keyword">if</span> tar == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res.append(list(path))</span><br><span class="line">            <span class="comment"># 如果已经找到了一条路径，那么下面两行会直接return，所以这样写也没关系</span></span><br><span class="line">            recur(root.left, tar)</span><br><span class="line">            recur(root.right, tar)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        recur(root, sum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-26"><a href="#interview-26" class="headerlink" title="interview_26"></a>interview_26</h2><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/" target="_blank" rel="noopener">参考链接</a></p><p>算法流程：<br><code>dfs(cur):</code> 递归法中序遍历；</p><ol><li><p><strong>终止条件</strong>： 当节点 cur为空，代表越过叶节点，直接返回；</p></li><li><p>递归左子树，即 <code>dfs(cur.left)</code>；</p></li><li><p><strong>构建链表</strong>：</p><ol><li><strong>当 pre 为空时</strong>： 代表正在访问链表头节点，记为 head 。</li><li><p><strong>当 pre 不为空时</strong>： 修改双向节点引用，即 pre.right = cur ,cur.left = pre；</p></li><li><p><strong>保存 cur</strong> ： 更新 pre = cur ，即节点 cur 是后继节点的 pre；</p></li></ol></li><li>递归右子树，即 dfs(cur.right) ；</li></ol><p><code>treeToDoublyList(root)：</code></p><ol><li><strong>特例处理</strong>： 若节点 root为空，则直接返回；</li><li><strong>初始化</strong>： 空节点 pre；</li><li><strong>转化为双向链表</strong>： 调用 dfs(root) ；</li><li><strong>构建循环链表</strong>： 中序遍历完成后，head指向头节点， pre指向尾节点，因此修改 head 和 pre的双向节点引用即可。</li><li><strong>返回值</strong>： 返回链表的头节点 head 即可。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/22 22:33</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_26.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, left=None, right=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(current_node)</span>:</span></span><br><span class="line">            <span class="comment"># 递归出口：代表到达尾结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> current_node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(current_node.left)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果pre是空，证明当前访问的是第一个结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.pre:</span><br><span class="line">                self.head = current_node</span><br><span class="line">            <span class="comment"># 如果不是空，则证明当前结点不是头结点，可进行修改</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.pre.right, current_node.left = current_node, self.pre</span><br><span class="line">            <span class="comment"># 保存当前结点为pre</span></span><br><span class="line">            self.pre = current_node</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 再去递归右子树</span></span><br><span class="line">            dfs(current_node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dfs(pRootOfTree)</span><br><span class="line">        <span class="comment"># 最后将头结点和尾结点进行连接</span></span><br><span class="line">        self.pre.right, self.head.left = self.head, self.pre</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-18"><a href="#interview-18" class="headerlink" title="interview_18"></a>interview_18</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 16:43 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_18.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 递归</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.mirrorTree(root.left)</span><br><span class="line">        self.mirrorTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree_diedai</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 广度优先，将节点依次插入</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 先交换</span></span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-22"><a href="#interview-22" class="headerlink" title="interview_22"></a>interview_22</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/8 19:19</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_22.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res, deque = [], collections.deque()</span><br><span class="line">        deque.append(root)</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            node = deque.popleft()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                deque.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                deque.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure><h2 id="maximum-depth-of-binary-tree"><a href="#maximum-depth-of-binary-tree" class="headerlink" title="maximum-depth-of-binary-tree"></a>maximum-depth-of-binary-tree</h2><h2 id="interview-38"><a href="#interview-38" class="headerlink" title="interview_38"></a>interview_38</h2><p>此题同<a href="https://unknown.yuzhouwan.com/posts/55663/#maximum-depth-of-binary-tree">maximum-depth-of-binary-tree</a></p><ol><li>深度优先遍历DFS</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/8/26 20:27 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_38.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><ol><li>广度优先遍历BFS</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/8/26 20:27 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_38.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 遍历每层的结点</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line">            <span class="comment"># 将每层的元素重新赋值给queue</span></span><br><span class="line">            queue = tmp</span><br><span class="line">            result += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-39"><a href="#interview-39" class="headerlink" title="interview_39"></a>interview_39</h2><p><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/solution/mian-shi-ti-55-ii-ping-heng-er-cha-shu-cong-di-zhi/" target="_blank" rel="noopener">思路参考</a></p><ul><li>方法一：从顶至底</li></ul><p>思路是构造一个获取当前子树的深度的函数 <strong>depth(root)</strong> ，通过比较某子树的左右子树的深度差 <strong>abs(depth(root.left) - depth(root.right)) &lt;= 1</strong> 是否成立，来判断某子树是否是二叉平衡树。若所有子树都平衡，则此树平衡。</p><p><strong>算法流程：</strong><br>isBalanced(root) 函数： 判断树 root 是否平衡</p><p>特例处理： 若树根节点 root 为空，则直接返回 true ；<br>返回值： 所有子树都需要满足平衡树性质，因此以下三者使用与逻辑 &amp;&amp; 连接；</p><ol><li>abs(self.depth(root.left) - self.depth(root.right)) &lt;= 1 ：判断 当前子树 是否是平衡树；</li><li>self.isBalanced(root.left) ： 先序遍历递归，判断 当前子树的左子树 是否是平衡树；</li><li>self.isBalanced(root.right) ： 先序遍历递归，判断 当前子树的右子树 是否是平衡树；</li><li>depth(root) 函数： 计算树 root 的深度</li></ol><p>终止条件： 当 root 为空，即越过叶子节点，则返回高度 0 ；<br>返回值： 返回左 / 右子树的深度的最大值 +1。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 判断以root为根的二叉树是否平衡</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> abs(self.depth(root.left) - self.depth(root.right)) &lt;= <span class="number">1</span> \</span><br><span class="line">               <span class="keyword">and</span> self.isBalanced(root.left) \</span><br><span class="line">               <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算以root为根的二叉树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.depth(root.left), self.depth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><ul><li>方法二：从底至顶（见思路参考）</li></ul><h2 id="interview-58"><a href="#interview-58" class="headerlink" title="interview_58"></a>interview_58</h2><p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/solution/mian-shi-ti-28-dui-cheng-de-er-cha-shu-di-gui-qing/" target="_blank" rel="noopener">解题思路参考</a></p><ul><li><p>对称二叉树定义： 对于树中 任意两个对称节点 L和 R ，一定有：<br>L.val = R.val：即此两对称节点值相等。<br>L.left.val = R.right.val：即 L 的 左子节点 和 R 的 右子节点 对称；<br>L.right.val = R.left.val：即 L 的 右子节点 和 R 的 左子节点 对称。<br>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。</p></li><li><p>算法流程：</p><ul><li><p>isSymmetric(root) ：</p><p>特例处理<strong>：</strong> 若根节点 root 为空，则直接返回 true。<br>返回值： 即 recur(root.left, root.right) ;</p></li><li><p>recur(L, R) ：</p><p>终止条件：</p><ol><li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；</li><li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；</li><li>当节点 L 值 = 节点 R 值： 此树不对称，因此返回 false；</li></ol></li><li><p>递推工作：<br>判断两节点 L.left 和 R.right是否对称，即 recur(L.left, R.right) ；<br>判断两节点 L.right 和 R.left是否对称，即 recur(L.right, R.left) ；<br>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp;&amp; 连接。</p></li></ul></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 20:42 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_58.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(LeftNode, RightNode)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> LeftNode <span class="keyword">and</span> <span class="keyword">not</span> RightNode:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> LeftNode <span class="keyword">or</span> <span class="keyword">not</span> RightNode <span class="keyword">or</span> LeftNode.val != RightNode.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 不满足直接退出的条件，则继续向下递归</span></span><br><span class="line">            <span class="keyword">return</span> recur(LeftNode.left, RightNode.right) <span class="keyword">and</span> recur(LeftNode.right, RightNode.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(root.left, root.right) <span class="keyword">if</span> root <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><h2 id="interview-61"><a href="#interview-61" class="headerlink" title="interview_61"></a>interview_61</h2><p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/mian-shi-ti-37-xu-lie-hua-er-cha-shu-ceng-xu-bian-/" target="_blank" rel="noopener">参考链接</a></p><p>序列化操作：类似于BFS，不同之处则是需要增加空结点的处理。</p><p>反序列化操作：由于序列化时建立了一颗“满二叉树”，则可<strong>基于叶结点和父结点之间的关系</strong>，对已序列化的结果进行反序列化。关系见下：</p><ul><li>如果从下标bai从1开始存储，则编号为i的结点的主要关系为：<br>双亲：向下取整 （i/2）<br>左孩子：2i<br>右孩子：2i+1</li><li>如果从下标从0开始存储，则编号为i的结点的主要关系为：<br>双亲：向下取整 （(i-1)/2）<br>左孩子：2i+1<br>右孩子：2i+2</li></ul><p>反序列化算法逻辑为：</p><ol><li>特例处理： 若 data为空，直接返回 null；</li><li>初始化： 序列化列表 vals（先去掉首尾中括号，再用逗号隔开），指针 i = 1 ，根节点 root（值为 vals[0] ），队列 queue(包含 root）；</li><li>按层构建： 当 queue 为空时跳出；<ol><li>节点出队，记为 node；</li><li>构建 node的左子节点：node.left 的值为 vals[i]，并将 node.left入队；</li><li>执行 i+=1；</li><li>构建 node的右子节点：node.left的值为 vals[i]，并将 node.left入队；</li><li>执行 i+=1；</li></ol></li><li>返回值： 返回根节点root即可。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 20:43 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_61.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[]"</span></span><br><span class="line">        <span class="comment"># 广度优先搜索</span></span><br><span class="line">        result, de = [], deque()</span><br><span class="line">        de.append(root)</span><br><span class="line">        <span class="keyword">while</span> de:</span><br><span class="line">            <span class="comment"># for _ in range(len(de)):</span></span><br><span class="line">            <span class="comment">#     node = de.popleft()</span></span><br><span class="line">            <span class="comment">#     result.append(node.val)</span></span><br><span class="line">            <span class="comment">#     if node.left:</span></span><br><span class="line">            <span class="comment">#         de.append(node.left)</span></span><br><span class="line">            <span class="comment">#     else:</span></span><br><span class="line">            <span class="comment">#         result.append("null")</span></span><br><span class="line">            <span class="comment">#     if node.right:</span></span><br><span class="line">            <span class="comment">#         de.append(node.right)</span></span><br><span class="line">            <span class="comment">#     else:</span></span><br><span class="line">            <span class="comment">#         result.append("null")</span></span><br><span class="line">            <span class="comment"># 以上可简化为</span></span><br><span class="line">            node = de.popleft()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                result.append(str(node.val))</span><br><span class="line">                de.append(node.left)</span><br><span class="line">                de.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(<span class="string">"null"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span>+<span class="string">","</span>.join(result)+<span class="string">"]"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">"[]"</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        values, i = data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">","</span>), <span class="number">1</span>  <span class="comment"># vals存放所有结点</span></span><br><span class="line">        root = TreeNode(values[<span class="number">0</span>])</span><br><span class="line">        de = deque()  <span class="comment"># 存放各个结点</span></span><br><span class="line">        de.append(root)</span><br><span class="line">        <span class="comment"># 类广度优先遍历，建立结点之间的关系</span></span><br><span class="line">        <span class="keyword">while</span> de:</span><br><span class="line">            node = de.popleft()</span><br><span class="line">            <span class="keyword">if</span> values[i] != <span class="string">"null"</span>:</span><br><span class="line">                node.left = TreeNode(int(values[i]))</span><br><span class="line">                de.append(node.left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> values[i] != <span class="string">"null"</span>:</span><br><span class="line">                node.right = TreeNode(int(values[i]))</span><br><span class="line">                de.append(node.right)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-62"><a href="#interview-62" class="headerlink" title="interview_62"></a>interview_62</h2><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d/" target="_blank" rel="noopener">参考链接</a></p><p>二叉搜索树的<strong>中序遍历为递增序列</strong>。因此求二叉搜索树的第K大的结点为为<strong>求此二叉搜索树中序遍历倒序的第K大的结点。</strong>（即中序遍历是会产生一个从小到大的排列[1, 2, 3, 4, 5]，中序遍历的倒序则是产生一个从大到小的排列[5, 4, 3, 2, 1]）</p><p>中序遍历递归顺序为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    print(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br></pre></td></tr></tbody></table></figure><p>倒序为</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印中序遍历倒序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br><span class="line">    print(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 20:43</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_62.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.k = <span class="literal">None</span></span><br><span class="line">        self.result_node = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">      <span class="comment"># 对二叉搜索树进行反中序遍历，将产生一个从大到小的序列</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="comment"># 递归结束条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> self.k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 先遍历右结点</span></span><br><span class="line">            dfs(root.right)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对当前结点进行判断，如果当前k已经减到0了，则找到第k大的结点了，返回</span></span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                self.result_node = root.val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 再遍历左结点</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line"></span><br><span class="line">        self.k = k</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.result_node</span><br></pre></td></tr></tbody></table></figure><h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><p><img data-src="/images/algorithm/binary-tree.png" alt="binary-tree"></p><h2 id="binary-tree-inorder-traversal"><a href="#binary-tree-inorder-traversal" class="headerlink" title="binary-tree-inorder-traversal"></a>binary-tree-inorder-traversal</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/12 22:43</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 94_binary-tree-inorder-traversal.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            backtrack(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            backtrack(root.right)</span><br><span class="line">        backtrack(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = TreeNode(<span class="number">1</span>)</span><br><span class="line">root.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">root.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">so = Solution()</span><br><span class="line">print(so.inorderTraversal(root))</span><br></pre></td></tr></tbody></table></figure><h2 id="unique-binary-search-trees-ii"><a href="#unique-binary-search-trees-ii" class="headerlink" title="unique-binary-search-trees-ii"></a>unique-binary-search-trees-ii</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/14 12:28 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 95_unique-binary-search-trees-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/unique-binary-search-trees-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generate_tree</span><span class="params">(start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>, ]</span><br><span class="line">            all_trees = []</span><br><span class="line"></span><br><span class="line">            <span class="comment"># pick a root</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end+<span class="number">1</span>):</span><br><span class="line">                left_tree = generate_tree(start, i)</span><br><span class="line">                right_tree = generate_tree(i+<span class="number">1</span>, end)</span><br><span class="line">                <span class="keyword">for</span> left <span class="keyword">in</span> left_tree:</span><br><span class="line">                    <span class="keyword">for</span> right <span class="keyword">in</span> right_tree:</span><br><span class="line">                        current_tree = TreeNode(i)</span><br><span class="line">                        current_tree.left = TreeNode(left)</span><br><span class="line">                        current_tree.right = TreeNode(right)</span><br><span class="line">                        all_trees.append(current_tree)</span><br><span class="line">            <span class="keyword">return</span> all_trees</span><br><span class="line">        <span class="keyword">return</span> generate_tree(<span class="number">1</span>, n) <span class="keyword">if</span> n <span class="keyword">else</span> []</span><br></pre></td></tr></tbody></table></figure><h2 id="unique-binary-search-trees"><a href="#unique-binary-search-trees" class="headerlink" title="unique-binary-search-trees"></a>unique-binary-search-trees</h2><p>假设n个节点存在</p><p>令G(n)的从1到n可以形成二叉排序树个数</p><p>令f(i)为以i为根的二叉搜索树的个数</p><p>即有: <code>G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)</code></p><p>n为根节点，当i为根节点时，其左子树节点个数为<code>[1,2,3,...,i-1]</code>，右子树节点个数为<code>[i+1,i+2,...n]</code>，所以当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，即<code>f(i) = G(i-1)*G(n-i)</code></p><p>上面两式可得:G(n) = <code>G(0)*G(n-1) + G(1)*(n-2) +...+ G(n-1)*G(0)</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/13 18:49 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 96_unique-binary-search-trees.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/unique-binary-search-trees/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                dp[i] += dp[j] * dp[i - j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.numTrees(<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="validate-binary-search-tree"><a href="#validate-binary-search-tree" class="headerlink" title="validate-binary-search-tree"></a>validate-binary-search-tree</h2><p>需要在遍历树的同时保留结点的上界与下界，在比较时不仅比较子结点的值，也要与上下界比较。这样才能保证节点的所有左子树都小于结点值，右子树都大于结点值。</p><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/yan-zheng-er-cha-sou-suo-shu-by-leetcode/" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/14 22:59 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 98_validate-binary-search-tree.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/validate-binary-search-tree/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        stack = [(root, float(<span class="string">'-inf'</span>), float(<span class="string">'inf'</span>)), ]</span><br><span class="line">        <span class="comment"># 深度优先遍历</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root, lower, upper = stack.pop()</span><br><span class="line">            <span class="comment"># 防止append一个空子树</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            val = root.val</span><br><span class="line">            <span class="keyword">if</span> val &lt;= lower <span class="keyword">or</span> val &gt;= upper:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.append((root.right, val, upper)) <span class="comment"># 右子树的所有值都要大于根节点</span></span><br><span class="line">            stack.append((root.left, lower, val))  <span class="comment"># 左子树的所有值都要小于根节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><h2 id="recover-binary-search-tree"><a href="#recover-binary-search-tree" class="headerlink" title="recover-binary-search-tree"></a>recover-binary-search-tree</h2><p><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/solution/zhong-xu-bian-li-by-powcai/" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/16 22:36</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 99_recover-binary-search-tree.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/recover-binary-search-tree/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pre_node = TreeNode(float(<span class="string">"-inf"</span>))</span><br><span class="line">        self.second_node = <span class="literal">None</span></span><br><span class="line">        self.first_node = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 中序遍历：找到第一个大于左子树的节点赋值为first_node，第一个小于右子树的节点赋值为second_node</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            in_order(root.left)</span><br><span class="line">            <span class="keyword">if</span> self.first_node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> self.pre_node.val &gt;= root.val:</span><br><span class="line">                self.first_node = self.pre_node</span><br><span class="line">            <span class="keyword">if</span> self.first_node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self.pre_node.val &gt;= root.val:</span><br><span class="line">                self.second_node = root</span><br><span class="line">            self.pre_node = root</span><br><span class="line">            in_order(root.right)</span><br><span class="line">        in_order(root)</span><br><span class="line">        self.first_node.val, self.second_node.val = self.second_node.val, self.first_node.val</span><br></pre></td></tr></tbody></table></figure><h2 id="same-tree"><a href="#same-tree" class="headerlink" title="same-tree"></a>same-tree</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/16 12:29</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 100_same-tree.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/same-tree/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></tbody></table></figure><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="merge-k-sorted-lists"><a href="#merge-k-sorted-lists" class="headerlink" title="merge-k-sorted-lists"></a>merge-k-sorted-lists</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/7 9:25 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 23_merge-k-sorted-lists.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/merge-k-sorted-lists/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 使用优先队列(堆排序)存储每个list中的第一个节点，由优先队列返回优先级最高（值最低的元素）</span></span><br><span class="line">        head_pre = p = ListNode(<span class="number">0</span>)</span><br><span class="line">        prior_queue = PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> list_node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> list_node:</span><br><span class="line">                prior_queue.put((list_node.val, list_node))</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> prior_queue.empty():</span><br><span class="line">            node_val, node = prior_queue.get()</span><br><span class="line">            p.next = ListNode(node_val)</span><br><span class="line">            p = p.next</span><br><span class="line">            <span class="comment"># 将当前list的头指向list中的下一个节点</span></span><br><span class="line">            node = node.next</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                prior_queue.put((node.val, node))</span><br><span class="line">        <span class="keyword">return</span> head_pre.next</span><br></pre></td></tr></tbody></table></figure><h1 id="Bit-Operation"><a href="#Bit-Operation" class="headerlink" title="Bit Operation"></a>Bit Operation</h1><h2 id="divide-two-integers"><a href="#divide-two-integers" class="headerlink" title="divide-two-integers"></a>divide-two-integers</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/9 9:11 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 29_divide-two-integers.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/divide-two-integers/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line">        flag = dividend &lt; <span class="number">0</span> ^ divisor &lt; <span class="number">0</span></span><br><span class="line">        dividend, divisor = abs(dividend), abs(divisor)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        move_step = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 移动除数直到比被除数大</span></span><br><span class="line">        <span class="keyword">while</span> divisor &lt;= dividend:</span><br><span class="line">            move_step += <span class="number">1</span></span><br><span class="line">            divisor &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 移动move_step 次使得 len(divisor) &gt; len(dividend),则 move_step-1 次使得 len(divisor) &gt;  len(dividend)</span></span><br><span class="line">        <span class="keyword">while</span> move_step &gt; <span class="number">0</span>:</span><br><span class="line">            move_step -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 此时divisor比division大，应该向右移动一位</span></span><br><span class="line">            divisor &gt;&gt;= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 判断是否除尽</span></span><br><span class="line">            <span class="keyword">if</span> dividend &gt;= divisor:</span><br><span class="line">                result += <span class="number">1</span> &lt;&lt; move_step</span><br><span class="line">                dividend -= divisor</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            result = -result</span><br><span class="line">        <span class="keyword">return</span> result <span class="keyword">if</span> -(<span class="number">1</span> &lt;&lt; <span class="number">31</span>) &lt;= result &lt;= (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span> <span class="keyword">else</span> (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.divide(<span class="number">-45</span>, <span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="gray-code"><a href="#gray-code" class="headerlink" title="gray-code"></a>gray-code</h2><p>解题思路：</p><ul><li>结果是当前head的移位结果 + 已有结果的倒序（注：<a href="https://leetcode-cn.com/problems/gray-code/solution/gray-code-jing-xiang-fan-she-fa-by-jyd/" target="_blank" rel="noopener">参考链接</a>）</li></ul><p><img data-src="/images/algorithm/leetcode-89.png" alt="leetcode-89"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/2 23:45</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 89_gray-code.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/gray-code/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res, head = [<span class="number">0</span>], <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(res) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                res.append(head + res[j])</span><br><span class="line">            head &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.grayCode(<span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="convert-a-number-to-hexadecimal"><a href="#convert-a-number-to-hexadecimal" class="headerlink" title="convert-a-number-to-hexadecimal"></a>convert-a-number-to-hexadecimal</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/19 10:54</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 405_convert-a-number-to-hexadecimal.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toHex</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        num &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">        mask = <span class="number">0b1111</span></span><br><span class="line">        s = <span class="string">"0123456789abcdef"</span></span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 从num低4位开始，每隔4位依次取结果，并对应到s的相应数字</span></span><br><span class="line">            result += s[num &amp; mask]</span><br><span class="line">            num &gt;&gt;= <span class="number">4</span>  <span class="comment"># num向右移动4位</span></span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>] <span class="keyword">if</span> result <span class="keyword">else</span> <span class="string">"0"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.toHex(<span class="number">26</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="binary-watch"><a href="#binary-watch" class="headerlink" title="binary-watch"></a>binary-watch</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/20 12:38</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 401_binary-watch.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/binary-watch/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readBinaryWatch</span><span class="params">(self, num: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">count_binary_1</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> bin(i).count(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1~59分钟转换成二进制里面分别有多少1</span></span><br><span class="line">        dict_binary = {i: count_binary_1(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60</span>)}</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">60</span>):</span><br><span class="line">                <span class="comment"># hour 与 minutes 亮灯的两者之和与num相等</span></span><br><span class="line">                <span class="keyword">if</span> dict_binary[h] + dict_binary[m] == num:</span><br><span class="line">                    hour = str(h)</span><br><span class="line">                    m = str(m) <span class="keyword">if</span> m &gt; <span class="number">9</span> <span class="keyword">else</span> <span class="string">"0"</span> + str(m)</span><br><span class="line">                    res.append(hour + <span class="string">":"</span> + m)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.readBinaryWatch(<span class="number">1</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-11"><a href="#interview-11" class="headerlink" title="interview_11"></a>interview_11</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 15:41</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_11.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span>  <span class="comment"># 牛客网要求只输出该数32位二进制表示中1的个数，故利用count来计数</span></span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">and</span> count &lt;= <span class="number">32</span>:</span><br><span class="line">            res += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.hammingWeight(<span class="number">-1</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-48"><a href="#interview-48" class="headerlink" title="interview_48"></a>interview_48</h2><p><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/solution/mei-ri-suan-fa-day-66-jing-dian-mian-shi-ti-bu-yon/" target="_blank" rel="noopener">题解来源</a></p><p>因为不允许采用四则运算，所以只能考虑位运算了。</p><p>其实就是用二进制来模拟加法操作。首先将两个数最低位相加，如果都是 1 ，那么就得到 0 ，并且进位 1 ，然后接着算下一位。</p><p>但是这样一位一位模拟不方便实现，更简单的实现方法是直接把两个数对应位相加，不管进位。然后进位单独计算，如果某一位两个数都是 1 ，那么进位就会对下一位产生影响。然后接着算不进位求和加上进位的值，再计算新的进位，依次重复下去，直到进位为 0 为止。</p><p>用一个实际的例子来演示一下，计算 3+7 的值，其中 s 表示每一步不考虑进位的求和，c 表示每一步的进位，最后得到结果 1010 ，也就是十进制的 10 </p><p><img data-src="/images/algorithm/interview_48.png" alt="interview_48"></p><p><strong>Python 负数的存储：</strong><br>Python，Java 等语言中的数字都是以 补码 形式存储的。但 Python 没有 int , long 等不同长度变量，即在编程时无变量位数的概念。<br>获取负数的补码： 需要将数字与十六进制数 0xffffffff 相与。可理解为舍去此数字 32 位以上的数字（将 32 位以上都变为 00 ），从无限长度变为一个 32 位整数。<br>返回前数字还原： 若补码 a 为负数（ 0x7fffffff 是最大的正数的补码 ），需执行 ~(a ^ x) 操作，将补码还原至 Python 的存储格式。 a ^ x 运算将 1 至 32 位按位取反； ~ 运算是将整个数字取反；因此， ~(a ^ x) 是将 32 位以上的位取反，1 至 32 位不变。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/25 14:37 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_48.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, a: int, b: int)</span> -&gt; int:</span></span><br><span class="line">        a &amp;= <span class="number">0xffffffff</span></span><br><span class="line">        b &amp;= <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">            c = ((a &amp; b) &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffffff</span>  <span class="comment"># 进位用与操作</span></span><br><span class="line">            a ^= b  <span class="comment"># 不考虑进位的结果用异或操作</span></span><br><span class="line">            b = c</span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> a &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(a ^ <span class="number">0xffffffff</span>)  <span class="comment"># 负数需要恢复成原码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.add(<span class="number">-3</span>, <span class="number">-2</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-49"><a href="#interview-49" class="headerlink" title="interview_49"></a>interview_49</h2><p><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/solution/mian-shi-ti-67-ba-zi-fu-chuan-zhuan-huan-cheng-z-4/" target="_blank" rel="noopener">参考链接</a></p><p><strong>数字越界处理：</strong></p><blockquote><p>题目要求返回的数值范围应在[ -2^31, 2 ^ 31 − 1] ，因此需要考虑数字越界问题。而由于题目指出环境只能存储 32 位大小的有符号整数 ，因此判断数字越界时，要始终保持 res 在 int 类型的取值范围内。</p></blockquote><p><img data-src="/images/algorithm/interview_49.png" alt="interview_49"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/25 14:37 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_49.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span><span class="params">(self, str: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> str:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># string = str.split()[0]  # 不使用split，strip等方法可以将空间复杂度降到O(1)</span></span><br><span class="line">        result, i, sign, len_str = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, len(str)  <span class="comment"># 结果，开始的索引，正负号，str的长度</span></span><br><span class="line">        int_max, int_min, boundary = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>, <span class="number">-2</span> ** <span class="number">31</span>, <span class="number">2</span> ** <span class="number">31</span> // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 去除空格</span></span><br><span class="line">        <span class="keyword">while</span> str[i] == <span class="string">" "</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == len_str:  <span class="comment"># 空字符串</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断符号</span></span><br><span class="line">        <span class="keyword">if</span> str[i] == <span class="string">"-"</span>:</span><br><span class="line">            sign = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> str[i] <span class="keyword">in</span> (<span class="string">"+"</span>, <span class="string">"-"</span>):</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 整数拼接</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> str[i:]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">"0"</span> &lt;= c &lt;= <span class="string">"9"</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> result &gt; boundary <span class="keyword">or</span> (result == boundary <span class="keyword">and</span> c &gt; <span class="string">"7"</span>):</span><br><span class="line">                <span class="keyword">return</span> int_max <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">else</span> int_min</span><br><span class="line">            result = result * <span class="number">10</span> + ord(c) - ord(<span class="string">"0"</span>)  <span class="comment"># 结果通过字符与"0"的ASCII码求得</span></span><br><span class="line">        <span class="keyword">return</span> sign * result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.strToInt(<span class="string">"+123i adf"</span>))</span><br></pre></td></tr></tbody></table></figure><p>支持小数</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/25 14:37</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_49.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span><span class="params">(self, str: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> str:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># string = str.split()[0]  # 不使用split，strip等方法可以将空间复杂度降到O(1)</span></span><br><span class="line">        result, i, sign, len_str = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, len(str)  <span class="comment"># 结果，开始的索引，正负号，str的长度</span></span><br><span class="line">        int_max, int_min, boundary = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>, -(<span class="number">2</span> ** <span class="number">31</span>), <span class="number">2</span> ** <span class="number">31</span> // <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 去除空格</span></span><br><span class="line">        <span class="keyword">while</span> str[i] == <span class="string">" "</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == len_str:  <span class="comment"># 空字符串</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断符号</span></span><br><span class="line">        <span class="keyword">if</span> str[i] == <span class="string">"-"</span>:</span><br><span class="line">            sign = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> str[i] <span class="keyword">in</span> (<span class="string">"+"</span>, <span class="string">"-"</span>):</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 整数拼接</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> str[i:]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">"0"</span> &lt;= c &lt;= <span class="string">"9"</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> result &gt; boundary <span class="keyword">or</span> (result == boundary <span class="keyword">and</span> c &gt; <span class="string">"7"</span>):</span><br><span class="line">                <span class="keyword">return</span> int_max <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">else</span> int_min</span><br><span class="line">            result = result * <span class="number">10</span> + ord(c) - ord(<span class="string">"0"</span>)  <span class="comment"># 结果通过字符与"0"的ASCII码求得</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 求小数部分</span></span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> str[i<span class="number">-1</span>] == <span class="string">"."</span>:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> str[i:]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="string">"0"</span> &lt;= c &lt;= <span class="string">"9"</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> result &gt; boundary <span class="keyword">or</span> (result == boundary <span class="keyword">and</span> c &gt; <span class="string">"7"</span>):</span><br><span class="line">                    <span class="keyword">return</span> int_max <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">else</span> int_min</span><br><span class="line">                result = result + (ord(c) - ord(<span class="string">"0"</span>)) * <span class="number">0.1</span> ** x</span><br><span class="line">                x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sign * result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.strToInt(<span class="string">"+12.3"</span>))</span><br></pre></td></tr></tbody></table></figure><h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><h2 id="find-first-and-last-position-of-element-in-sorted-array"><a href="#find-first-and-last-position-of-element-in-sorted-array" class="headerlink" title="find-first-and-last-position-of-element-in-sorted-array"></a>find-first-and-last-position-of-element-in-sorted-array</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/2 11:18 上午 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 34_find-first-and-last-position-of-element-in-sorted-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_left_right_index</span><span class="params">(self, nums, target, left_right_flag)</span>:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target <span class="keyword">or</span> (left_right_flag <span class="keyword">and</span> nums[mid] == target):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target: int)</span>:</span></span><br><span class="line">        <span class="comment"># 找到左边界</span></span><br><span class="line">        left_index = self.find_left_right_index(nums, target, <span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> left_index == len(nums) <span class="keyword">or</span> nums[left_index] != target:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 找到右边界</span></span><br><span class="line">        <span class="keyword">return</span> [left_index, self.find_left_right_index(nums, target, <span class="literal">False</span>) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.searchRange([<span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>], <span class="number">8</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="sqrtx"><a href="#sqrtx" class="headerlink" title="sqrtx"></a>sqrtx</h2><p>当<code>x ≥ 2</code> 时，它的整数平方根一定小于 <code>x / 2</code>。由于结果一定是整数，此问题可以转换成在有序整数集中寻找一个特定值，因此可以使用二分查找。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/11 11:57</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 69_sqrtx.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/sqrtx/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        left = <span class="number">2</span></span><br><span class="line">        right = x // <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> middle * middle &gt; x:</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> middle * middle &lt; x:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> middle</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.mySqrt(<span class="number">8</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="search-a-2d-matrix"><a href="#search-a-2d-matrix" class="headerlink" title="search-a-2d-matrix"></a>search-a-2d-matrix</h2><p>将整个matric当做一个列表，进行二分查找。其中对应的元素与其行列的索引为：</p><blockquote><p>middle = (left + right) // 2</p><p>row_index = middle // cols</p><p>col_index = middle % cols</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/17 19:59 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 74_search-a-2d-matrix.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/search-a-2d-matrix/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> len(matrix) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rows = len(matrix)</span><br><span class="line">        cols = len(matrix[<span class="number">0</span>])</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = rows * cols - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = (left + right) // <span class="number">2</span></span><br><span class="line">            row = middle // cols</span><br><span class="line">            col = middle % cols</span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] &gt; target:</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.searchMatrix([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>],</span><br><span class="line">    [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">    [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">], <span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="search-in-rotated-sorted-array"><a href="#search-in-rotated-sorted-array" class="headerlink" title="search-in-rotated-sorted-array"></a>search-in-rotated-sorted-array</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/1 4:43 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 33_search-in-rotated-sorted-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="comment"># 右半部分是有序的</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="comment"># target在右半部分里</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt; nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 左半部分是有序的</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># target在左半部分里</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt; target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.search([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">0</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="find-minimum-in-rotated-sorted-array"><a href="#find-minimum-in-rotated-sorted-array" class="headerlink" title="find-minimum-in-rotated-sorted-array"></a>find-minimum-in-rotated-sorted-array</h2><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/xun-zhao-xuan-zhuan-pai-lie-shu-zu-zhong-de-zui-xi/" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/26 12:39</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 153_find-minimum-in-rotated-sorted-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        len_nums = len(nums)</span><br><span class="line">        <span class="keyword">if</span> len_nums &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len_nums - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            middle = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 退出条件</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle - <span class="number">1</span>] &gt; nums[middle]:</span><br><span class="line">                <span class="keyword">return</span> nums[middle]</span><br><span class="line">            <span class="keyword">if</span> nums[middle] &gt; nums[middle + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[middle + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 左边为有序，寻找在右边的变化点</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &gt; nums[left]:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 右边为有序，寻找在左边的变化点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = middle - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findMin([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="search-in-rotated-sorted-array-ii"><a href="#search-in-rotated-sorted-array-ii" class="headerlink" title="search-in-rotated-sorted-array-ii"></a>search-in-rotated-sorted-array-ii</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/26 19:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 81_search-in-rotated-sorted-array-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 右半部分是有序的</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="comment"># target在右半部分里</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt; nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 左半部分是有序的</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># target在左半部分里</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt; target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.search([<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="min-value-in-rotated-array"><a href="#min-value-in-rotated-array" class="headerlink" title="min-value-in-rotated-array"></a>min-value-in-rotated-array</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/25 12:37 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: min-value-in-rotated-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        len_rotatearray = len(rotateArray)</span><br><span class="line">        <span class="keyword">if</span> len_rotatearray &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> rotateArray</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len_rotatearray - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            middle = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[middle] &gt; rotateArray[right]:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = middle</span><br><span class="line">        <span class="keyword">return</span> rotateArray[left]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.minNumberInRotateArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]))</span><br><span class="line">print(so.minNumberInRotateArray([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">print(so.minNumberInRotateArray([<span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="find-peak-element"><a href="#find-peak-element" class="headerlink" title="find-peak-element"></a>find-peak-element</h2><ul><li>时间复杂度 : O(log_2(n))。 每一步都将搜索空间减半。因此，总的搜索空间只需要 log_2(n)步。其中 n 为 num 数组的长度。</li><li>空间复杂度 : O(1)。 只使用了常数空间。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/27 12:46</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 162_find-peak-element.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/find-peak-element/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            middle = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="comment"># 从middle左侧开始找峰值</span></span><br><span class="line">            <span class="keyword">if</span> nums[middle] &gt; nums[middle + <span class="number">1</span>]:</span><br><span class="line">                right = middle</span><br><span class="line">            <span class="comment"># 从middle右侧开始找峰值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findPeakElement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-50"><a href="#interview-50" class="headerlink" title="interview_50"></a>interview_50</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/" target="_blank" rel="noopener">参考链接</a></p><ul><li>方法一：暴力</li></ul><p>时间复杂度<code>O(N)</code></p><p>空间复杂度<code>O(N)</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: [int])</span> -&gt; int:</span></span><br><span class="line">        dic = set()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic: <span class="keyword">return</span> num</span><br><span class="line">            dic.add(num)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></tbody></table></figure><ul><li>方法二：原地根据索引交换</li></ul><p>时间复杂度<code>O(N)</code></p><p>空间复杂度<code>O(1)</code></p><p>索引处存放的值为对应的索引。</p><p>注：此方法不能保证重复数字出现的先后顺序（若有两个重复数字，如果需要返回第一个重复的数字，那么此方法不能保证返回的顺序正确）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == i:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[nums[i]]:</span><br><span class="line">                <span class="keyword">return</span> nums[i]</span><br><span class="line">            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></tbody></table></figure><h2 id="interview-6"><a href="#interview-6" class="headerlink" title="interview_6"></a>interview_6</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/25 12:37</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_6.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        len_rotatearray = len(rotateArray)</span><br><span class="line">        <span class="keyword">if</span> len_rotatearray &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> rotateArray</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len_rotatearray - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            middle = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> rotateArray[middle] &gt; rotateArray[right]:</span><br><span class="line">                left = middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = middle</span><br><span class="line">        <span class="keyword">return</span> rotateArray[left]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.minNumberInRotateArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]))</span><br><span class="line">print(so.minNumberInRotateArray([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">print(so.minNumberInRotateArray([<span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-37"><a href="#interview-37" class="headerlink" title="interview_37"></a>interview_37</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/25 12:37</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_6.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;rp=1</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        len_data = len(data)</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># 先找最左边等于k的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len_data - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> data[i] == k:</span><br><span class="line">                left = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 再找最右边等于k的位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len_data - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> data[j] == k:</span><br><span class="line">                right = j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 判断临界条件</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> data[left] == k:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h1 id="Double-Pointer"><a href="#Double-Pointer" class="headerlink" title="Double Pointer"></a>Double Pointer</h1><h2 id="trapping-rain-water"><a href="#trapping-rain-water" class="headerlink" title="trapping-rain-water"></a>trapping-rain-water</h2><p> 直接思路：</p><ul><li>对于每个元素而言，它对应的水的数量由其左右两边最大的高度决定，即：<ul><li>当前元素向左扫描得到最大的高度max_left_height</li><li>当前元素向右扫描得到最大的高度max_right_height</li><li>取min(max_left_height, max_right_height)，得到min_height</li><li>再将min_height 与当前元素的height相减，即为当前元素所能注得的水量</li></ul></li><li>时间复杂度： $O(n^2)$ ，因数组中的每个元素都需要向左向右扫描。</li></ul><p>本题采用双指针法：时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ </p><p>思路如下：</p><ul><li><p>如果一端有更高的条形块（例如右端），积水的高度依赖于当前方向的高度（从左到右）。</p></li><li><p>当另一侧（左侧）的条形块高度较高时，积水的高度依赖于（从右到左）方向的高度。</p></li></ul><p>伪代码如下：</p><ul><li><p>初始化left指针为 0 并且right 指针为 size-1</p></li><li><p>While left &lt; right, do:</p><ul><li><p>If height[left] &lt; height[right]</p><ul><li><p>if height_left_max &lt;= height[left]: 更新height_left_max </p></li><li><p>else:</p></li></ul></li><li><p>result += height_left_max - height[left]</p></li><li><p>else:</p><ul><li><p>if height_right_max &lt;= height[right]: 更新height_right_max </p></li><li><p>else:</p><p>result += height_right_max - height[right]</p></li></ul></li></ul></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/14 09:11</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 42_trapping-rain-water.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/trapping-rain-water</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(height) - <span class="number">1</span></span><br><span class="line">        left_max, right_max = height[left], height[right]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 因为是从0，size-1开始比较的，每次比较相当于间接确定了height[left] &lt; height[left_max] &lt; height[right]</span></span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                <span class="keyword">if</span> height[left] &gt;= left_max:</span><br><span class="line">                    left_max = height[left]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result += (left_max - height[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># height[right] &lt; height[right_max] &lt; height[left]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> height[right] &gt;= right_max:</span><br><span class="line">                    right_max = height[right]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result += (right_max - height[right])</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.trap([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="sort-colors"><a href="#sort-colors" class="headerlink" title="sort-colors"></a>sort-colors</h2><p>解题思路：</p><ul><li>left指向0、right指向2</li><li>当nums[current] = 0或2时，跟left、right指向的元素进行交换</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/18 23:41</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 75_sort-colors.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/sort-colors</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: List[int])</span> -&gt; List:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums) - <span class="number">1</span></span><br><span class="line">        current = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">if</span> nums[current] == <span class="number">0</span>:</span><br><span class="line">                nums[left], nums[current] = nums[current], nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[current] == <span class="number">1</span>:</span><br><span class="line">                nums[right], nums[current] = nums[current], nums[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.sortColors([<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="minimum-window-substring"><a href="#minimum-window-substring" class="headerlink" title="minimum-window-substring"></a>minimum-window-substring</h2><p>解题思路：</p><p>滑动窗口的思想</p><blockquote><p>left指针仅在当前窗口满足条件之后才会移动：即当前窗口中满足要求，left会试着移动以此减少结果的长度</p><p>right 指针不停向右移动，找寻满足条件的窗口</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/21 22:48</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 76_minimum-window-substring.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/minimum-window-substring</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow1</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        length_s = len(s)</span><br><span class="line">        result = s + s  <span class="comment"># 随便设定一个比s长的字符串，便于后续处理</span></span><br><span class="line">        t_dict = Counter(t)  <span class="comment"># t各个数字的出现的次数</span></span><br><span class="line">        count_dict = defaultdict(<span class="keyword">lambda</span>: <span class="number">0</span>)  <span class="comment"># 创建一个默认值为0的字典</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断当前字典与目标字典长度、存储的值是否相同</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">contains</span><span class="params">(t_dict, count_dict)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(count_dict) &lt; len(t_dict):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> count_dict:</span><br><span class="line">                <span class="keyword">if</span> count_dict[key] &lt; t_dict[key] <span class="keyword">or</span> key <span class="keyword">not</span> <span class="keyword">in</span> t_dict:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 触发right移动</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> range(length_s):</span><br><span class="line">            <span class="keyword">if</span> s[right] <span class="keyword">in</span> t_dict:</span><br><span class="line">                count_dict[s[right]] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#  触发left移动: 当前存储的字典中与目标字典中长度、包含的值相同</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; length_s <span class="keyword">and</span> contains(t_dict, count_dict):</span><br><span class="line">                <span class="comment"># 更新结果</span></span><br><span class="line">                <span class="keyword">if</span> right - left + <span class="number">1</span> &lt; len(result):</span><br><span class="line">                    result = s[left:right + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> s[left] <span class="keyword">in</span> t_dict:</span><br><span class="line">                    count_dict[s[left]] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> result == s + s <span class="keyword">else</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution1()</span><br><span class="line">print(so.minWindow1(<span class="string">"ADOBECODEBANC"</span>, <span class="string">"ABC"</span>))</span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/22 22:32</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 77_combinations.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/combinations/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n: int, k: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> n &lt; k:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        self.__dfs(<span class="number">1</span>, k, n, [], result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dfs</span><span class="params">(self, index, k, n, pre, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(pre) == k:</span><br><span class="line">            result.append(pre[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index, n + <span class="number">1</span>):</span><br><span class="line">            pre.append(i)</span><br><span class="line">            self.__dfs(i + <span class="number">1</span>, k, n, pre, result)</span><br><span class="line">            pre.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.combine(<span class="number">4</span>, <span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="remove-duplicates-from-sorted-array-ii"><a href="#remove-duplicates-from-sorted-array-ii" class="headerlink" title="remove-duplicates-from-sorted-array-ii"></a>remove-duplicates-from-sorted-array-ii</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/26 14:00 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 80_remove-duplicates-from-sorted-array-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># j指向需要覆盖的位置</span></span><br><span class="line">        j, count = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count &lt;= <span class="number">2</span>:</span><br><span class="line">                nums[j] = nums[i]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.removeDuplicates([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-41"><a href="#interview-41" class="headerlink" title="interview_41"></a>interview_41</h2><p>窗口何时扩大，何时缩小？</p><ul><li>当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动</li><li>当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动</li><li>当窗口的和恰好等于 target 的时候，我们需要记录此时的结果。设此时的窗口为 [i, j)，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/23 18:33 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_41.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span><span class="params">(self, target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        i = <span class="number">1</span>  <span class="comment"># 左边界，做减法</span></span><br><span class="line">        j = <span class="number">1</span>  <span class="comment"># 右边界，做加法</span></span><br><span class="line">        sum_current = <span class="number">0</span>  <span class="comment"># 当前滑动窗口中的总和</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 左边界不得超过target的中值</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= target // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> sum_current &lt; target:</span><br><span class="line">                sum_current += j</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum_current &gt; target:</span><br><span class="line">                sum_current -= i</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(list(range(i, j)))</span><br><span class="line">                sum_current -= i</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findContinuousSequence(<span class="number">10</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-42"><a href="#interview-42" class="headerlink" title="interview_42"></a>interview_42</h2><p>算法流程：</p><ul><li>初始化： 双指针 i , j分别指向数组 nums 的左右两端 （俗称对撞双指针）。</li><li>循环搜索： 当双指针相遇时跳出；<ul><li>计算和 s = nums[i] + nums[j]；<br>若 s &gt; targets ，则指针 j 向左移动，即执行 j = j - 1；<br>若 s &lt; targets ，则指针 i 向右移动，即执行 i = i + 1；<br>若 s = targets ，立即返回数组 [nums[i], nums[j]] ；<br>返回空数组，代表无和为 target的数字组合。</li></ul></li></ul><p><img data-src="/images/algorithm/interview_42.png" alt="interview_42"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/23 18:33 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_42.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        <span class="keyword">while</span> i != j:</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] &gt; target:</span><br><span class="line">                <span class="comment"># j 向右移动</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] + nums[j] &lt; target:</span><br><span class="line">                <span class="comment"># i 向左移动</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [nums[i], nums[j]]</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.twoSum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">7</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-64"><a href="#interview-64" class="headerlink" title="interview_64"></a>interview_64</h2><p>如果使用暴力解法，可能会被面试官直接微笑回去等消息。即以下这种酸爽解法。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span> <span class="keyword">or</span> k == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)-k+<span class="number">1</span>):</span><br><span class="line">            ans.append(max(nums[i:i+k]))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure><p>为降低时间复杂度，此题难点是：</p><blockquote><p>如何在每次窗口滑动后，将 “获取窗口内最大值” 的时间复杂度从 O(k) 降低至 O(1) 。</p></blockquote><p>此题与interview_20（<a href="https://unknown.yuzhouwan.com/posts/55663/#interview_20">包含min函数的栈</a>）一起食用最佳。即：</p><blockquote><p>维护一个队列。保持队列是单调递减，即加入时把前面比其小的数pop掉。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:58</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_64.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        de = collections.deque()  <span class="comment"># 构建一个双向单调递减队列，队列头记录当前窗口的最大值</span></span><br><span class="line">        result, len_nums = [], len(nums)</span><br><span class="line">        <span class="keyword">for</span> left, right <span class="keyword">in</span> zip(range(<span class="number">1</span> - k, len_nums + <span class="number">1</span> - k), range(len_nums)):</span><br><span class="line">            <span class="comment"># 为队列元素同步滑动窗口：队列内仅包含窗口内的元素,每轮窗口滑动移除了元素 nums[left - 1] ，需将队列内的对应元素一起删除。</span></span><br><span class="line">            <span class="comment"># 如果不相等，则证明当前最大不等于滑动窗口刚滑过的元素</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> de[<span class="number">0</span>] == nums[left<span class="number">-1</span>]:</span><br><span class="line">                de.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 为保持队列的单调性：若队列中最小的元素小于待比较的元素，则将队尾元素弹出，新元素加入队尾</span></span><br><span class="line">            <span class="keyword">while</span> de <span class="keyword">and</span> de[<span class="number">-1</span>] &lt; nums[right]:</span><br><span class="line">                de.pop()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果本身就小于队尾元素，则直接加入队尾</span></span><br><span class="line">            de.append(nums[right])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将每次比较的结果添加到返回列表中</span></span><br><span class="line">            <span class="keyword">if</span> left &gt;= <span class="number">0</span>:</span><br><span class="line">                result.append(de[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><h2 id="wildcard-matching"><a href="#wildcard-matching" class="headerlink" title="wildcard-matching"></a>wildcard-matching</h2><p>解题思路：</p><ul><li><p>状态  dp[i][j]  : 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配 (true 的话表示匹配)</p></li><li><p>状态转移方程：</p><ul><li><p>当 s[i] == p[j]，或者 p[j] == ? 那么  dp[i][j] = dp[i - 1][j - 1] </p></li><li><p>当  p[j] == *  且  dp[i][j] = dp[i][j - 1]  ||  dp[i - 1][j]     </p></li></ul></li><li><p>初始化：</p><ul><li><p>dp[0][0]  表示什么都没有，其值为 true</p></li><li><p>第一行  dp[0][j] ，换句话说，s 为空，与 p 匹配，所以只要 p 开始为 * 才为 true</p></li><li><p>第一列 dp[i][0] ，当然全部为 false</p></li></ul></li><li><p>例如 </p><p><code>s = "abcd"</code> <code>p ="ab*"</code> ，其状态矩阵如下：</p></li></ul><div class="table-container"><table><thead><tr><th>true</th><th>false</th><th>false</th><th>false</th></tr></thead><tbody><tr><td>false</td><td>true</td><td>false</td><td>false</td></tr><tr><td>false</td><td>false</td><td>true</td><td>true</td></tr><tr><td>false</td><td>false</td><td>false</td><td>true</td></tr><tr><td>false</td><td>false</td><td>false</td><td>true</td></tr></tbody></table></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/16 09:45</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 44_wildcard-matching.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/wildcard-matching/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        s_len = len(s)</span><br><span class="line">        p_len = len(p)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * (p_len + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(s_len + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 初始化，如果s为空，且p的第一个字符为"*"，则置为True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, p_len + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[i<span class="number">-1</span>] == <span class="string">"*"</span>:</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, s_len + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, p_len + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] <span class="keyword">or</span> p[j<span class="number">-1</span>] == <span class="string">"?"</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j - <span class="number">1</span>] == <span class="string">"*"</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] <span class="keyword">or</span> dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isMatch(<span class="string">"adceb"</span>, <span class="string">"*a*b"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="maximum-subarray"><a href="#maximum-subarray" class="headerlink" title="maximum-subarray"></a>maximum-subarray</h2><ul><li>解法1:贪心算法</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/25 09:52</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 53_maximum-subarray.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/maximum-subarray/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray_GA</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        len_nums = len(nums)</span><br><span class="line">        current_sum = max_sum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len_nums):</span><br><span class="line">          <span class="comment"># 寻找局部最优解</span></span><br><span class="line">            current_sum = max(nums[i], current_sum + nums[i])</span><br><span class="line">            max_sum = max(max_sum, current_sum)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.maxSubArray([<span class="number">-2</span>, <span class="number">1</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-5</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><ul><li>解法2:动态规划</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray_DP</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    len_nums = len(nums)</span><br><span class="line">    max_sum = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len_nums):</span><br><span class="line">        <span class="keyword">if</span> nums[i<span class="number">-1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">            nums[i] += nums[i<span class="number">-1</span>]</span><br><span class="line">        max_sum = max(max_sum, nums[i])</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></tbody></table></figure><h2 id="jump-game"><a href="#jump-game" class="headerlink" title="jump-game"></a>jump-game</h2><p>解题思路：</p><p>从右向左迭代，对于每个节点我们检查是否存在一步跳跃可以到达 GOOD 的位置（currPosition + nums[currPosition] &gt;= leftmostGoodIndex）。如果可以到达，当前位置也标记为 GOOD ，同时，这个位置将成为新的最左边的 GOOD 位置，一直重复到数组的开头，如果第一个坐标标记为 GOOD 意味着可以从第一个位置跳到最后的位置。</p><div class="table-container"><table><thead><tr><th>Index</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>Nums</td><td>2</td><td>0</td><td>1</td><td>1</td><td>4</td></tr><tr><td>Good/Bad</td><td></td><td></td><td></td><td></td><td>*Good</td></tr><tr><td></td><td></td><td></td><td></td><td>*Good</td><td>Good</td></tr><tr><td></td><td></td><td></td><td>*Good</td><td>Good</td><td>Good</td></tr><tr><td></td><td></td><td>False(1+0 &lt; 2)</td><td></td><td></td><td></td></tr><tr><td></td><td>*Good(0+2 &gt;= 2)</td><td></td><td></td><td></td></tr></tbody></table></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/27 12:08 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 55_jump-game.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/jump-game/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        last_true_index = nums[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> i + nums[i] &gt;= last_true_index:</span><br><span class="line">                last_true_index = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.canJump([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="unique-paths"><a href="#unique-paths" class="headerlink" title="unique-paths"></a>unique-paths</h2><p>解题思路：</p><ul><li><p>假设<code>dp[row][col]</code>代表到格子<code>[i][j]</code>的路径个数，其中第一行<code>dp[0][j]</code>与第一列<code>dp[i][0]</code>都为1。</p></li><li><p>那么每个格子的路径个数取决于它左边格子的路径个数+它上边格子的路径个数。</p><p>即<code>dp[i][j]=dp[i][j-1]+dp[i-1][j]</code></p></li><li><p>为了节省空间，利用两个数组pre与cur来代表上一行与当前行。初始化都为1。</p></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/5 20:13</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 62_unique-paths.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/unique-paths/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        pre = [<span class="number">1</span>] * n</span><br><span class="line">        cur = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                cur[col] = cur[col<span class="number">-1</span>] + pre[col]</span><br><span class="line">            pre = cur</span><br><span class="line">        <span class="keyword">return</span> pre[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.uniquePaths(<span class="number">7</span>, <span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="unique-paths-ii"><a href="#unique-paths-ii" class="headerlink" title="unique-paths-ii"></a>unique-paths-ii</h2><p>解题思路：</p><ul><li>与上一题思路类似，让obstacleGrid存储到达各个单元的路径。</li><li>首先进行边界初始化，边界上的元素，只有自身为0（代表本身无障碍）且上一个单元值为1（已初始化，此时的1代表无障碍，有1条路可以通行）时，自身的值才被置为1（代表有路径可走）。</li><li>根据相邻单元的路径情况，进行自身路径的计算即可。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/5 21:51</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 63_unique-paths-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/unique-paths-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        row = len(obstacleGrid)</span><br><span class="line">        col = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 1.边界初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, col):</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][i] = int(obstacleGrid[<span class="number">0</span>][i<span class="number">-1</span>] == <span class="number">1</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, row):</span><br><span class="line">            obstacleGrid[j][<span class="number">0</span>] = int(obstacleGrid[j<span class="number">-1</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">and</span> obstacleGrid[j][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">        print(obstacleGrid)</span><br><span class="line"><span class="comment"># 2.计算路径</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, col):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j] + obstacleGrid[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.uniquePathsWithObstacles([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">]))</span><br></pre></td></tr></tbody></table></figure><h2 id="minimum-path-sum"><a href="#minimum-path-sum" class="headerlink" title="minimum-path-sum"></a>minimum-path-sum</h2><p>解题思路：</p><ol><li>将Grid二维数组自身进行修改，使其存储当前元素到最右下角元素的路径值</li><li>从数组右下角元素开始遍历</li><li>最后一行的元素，路径等于自身加右侧的权值</li><li>除最后一行，其他行的最后一列，路径等于同列的下一行的权值加自身值</li><li>其他元素的路径，等于自身加上右侧权值与下侧路径的较小值</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/8 00:12</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 64_minimum-path-sum.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/minimum-path-sum/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        row_len = len(grid)</span><br><span class="line">        col_len = len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(row_len<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(col_len<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="comment"># 1.最后一行的元素，路径等于自身加右侧的权值</span></span><br><span class="line">                <span class="keyword">if</span> row == row_len<span class="number">-1</span> <span class="keyword">and</span> col != col_len<span class="number">-1</span>:</span><br><span class="line">                    grid[row][col] += grid[row][col+<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 2. 除最后一行，其他行的最后一列，路径等于同列的下一行的权值加自身值</span></span><br><span class="line">                <span class="keyword">elif</span> row != row_len<span class="number">-1</span> <span class="keyword">and</span> col == col_len<span class="number">-1</span>:</span><br><span class="line">                    grid[row][col] += grid[row+<span class="number">1</span>][col]</span><br><span class="line">                <span class="comment"># 3. 其他元素的路径，等于自身加上右侧权值与下侧路径的较小值</span></span><br><span class="line">                <span class="keyword">elif</span> row != row_len<span class="number">-1</span> <span class="keyword">and</span> col != col_len<span class="number">-1</span>:</span><br><span class="line">                    grid[row][col] += min(grid[row+<span class="number">1</span>][col], grid[row][col+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.minPathSum([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></tbody></table></figure><h2 id="climbing-stairs"><a href="#climbing-stairs" class="headerlink" title="climbing-stairs"></a>climbing-stairs</h2><p><code>dp</code>用于存储到达每个台阶的方法总数。</p><p>则到达第n阶，有<code>dp[i-1]+dp[i-2]</code>种方法。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/11 12:09</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 70_climbing-stairs.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/climbing-stairs/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.climbStairs(<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="climbing-stairsII"><a href="#climbing-stairsII" class="headerlink" title="climbing-stairsII"></a>climbing-stairsII</h2><p>f(n)=f(n-1)+f(n-2)+……f(1)<br>f(n-1)=f(n-2)+……f(1)<br>得f(n)=2f(n-1)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/26 12:35 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: jumpFloorII.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number+<span class="number">1</span>):</span><br><span class="line">            n = <span class="number">2</span> * n</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></tbody></table></figure><h2 id="edit-distance"><a href="#edit-distance" class="headerlink" title="edit-distance"></a>edit-distance</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/16 12:03 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 72_edit-distance.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/edit-distance/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        n1 = len(word1)</span><br><span class="line">        n2 = len(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n2+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n1+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 第一行，进行初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 第一列，进行初始化</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            dp[j][<span class="number">0</span>] = dp[j - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.minDistance(word1=<span class="string">"horse"</span>, word2=<span class="string">"ros"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="decode-ways"><a href="#decode-ways" class="headerlink" title="decode-ways"></a>decode-ways</h2><p><a href="https://leetcode-cn.com/problems/decode-ways/solution/dong-tai-gui-hua-cong-jian-dan-de-pa-lou-ti-wen-ti/" target="_blank" rel="noopener">解题思路</a></p><p>dp[i+1]：代表s[0:i]的译码方式总数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/5 22:40</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 91_decode-ways.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/decode-ways/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">"0"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span> <span class="keyword">if</span> s[<span class="number">0</span>] != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>  <span class="comment"># dp[i] -&gt; s[i-1]</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> s[i] != <span class="string">"0"</span>:</span><br><span class="line">                dp[i+<span class="number">1</span>] += dp[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"10"</span> &lt;= s[i<span class="number">-1</span>:i+<span class="number">1</span>] &lt;= <span class="string">"26"</span>:</span><br><span class="line">                dp[i+<span class="number">1</span>] += dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.numDecodings(<span class="string">"226"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interleaving-string"><a href="#interleaving-string" class="headerlink" title="interleaving-string"></a>interleaving-string</h2><p><code>dp[i][j]</code>代表s1[:i]与s2[:j]能否构成s3[:i+j]</p><p><a href="https://leetcode-cn.com/problems/interleaving-string/solution/dong-tai-gui-hua-zhu-xing-jie-shi-python3-by-zhu-3/" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/12 21:47 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 97_interleaving-string.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/interleaving-string/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1: str, s2: str, s3: str)</span> -&gt; bool:</span></span><br><span class="line">        len_s1 = len(s1)</span><br><span class="line">        len_s2 = len(s2)</span><br><span class="line">        len_s3 = len(s3)</span><br><span class="line">        <span class="keyword">if</span> len_s1 + len_s2 != len_s3:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len_s2+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len_s1+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len_s2+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="literal">True</span> <span class="keyword">if</span> s3[j<span class="number">-1</span>] == s2[j<span class="number">-1</span>] <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len_s1+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">True</span> <span class="keyword">if</span> s3[i<span class="number">-1</span>] == s1[i<span class="number">-1</span>] <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len_s1+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len_s2+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[i<span class="number">-1</span>][j] <span class="keyword">and</span> s1[i<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j<span class="number">-1</span>] <span class="keyword">and</span> s2[j<span class="number">-1</span>] == s3[i+j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isInterleave(s1=<span class="string">"aabcc"</span>, s2=<span class="string">"dbbca"</span>, s3=<span class="string">"aadbbcbcac"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="split-array-with-equal-sum"><a href="#split-array-with-equal-sum" class="headerlink" title="split-array-with-equal-sum"></a>split-array-with-equal-sum</h2><p><a href="https://leetcode-cn.com/problems/split-array-with-equal-sum/solution/jiang-shu-zu-fen-ge-cheng-he-xiang-deng-de-zi-shu-/" target="_blank" rel="noopener">参考链接</a></p><p>这道题确定i,j,k的取值范围是关键。</p><p>通过j去约定i和k的范围，可以减少复杂度。</p><p><img data-src="/images/algorithm/split-array-with-equal-sum.png" alt="split-array-with-equal-sum"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/13 12:33 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 548_split-array-with-equal-sum.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/split-array-with-equal-sum/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        len_nums = len(nums)</span><br><span class="line">        <span class="keyword">if</span> len_nums &lt; <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        sum_list = list()</span><br><span class="line">        sum_list.append(nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len_nums):</span><br><span class="line">            sum_list.append(sum_list[i - <span class="number">1</span>] + nums[i])</span><br><span class="line">        <span class="comment"># 用中间的j去约定i与k的范围</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>, len_nums - <span class="number">3</span>):</span><br><span class="line">            sum_set = set()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, j - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> sum_list[i - <span class="number">1</span>] == sum_list[j - <span class="number">1</span>] - sum_list[i]:</span><br><span class="line">                    sum_set.add(sum_list[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(j + <span class="number">2</span>, len_nums - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> sum_list[<span class="number">-1</span>] - sum_list[k] == sum_list[k - <span class="number">1</span>] - sum_list[j] \</span><br><span class="line">                        <span class="keyword">and</span> (sum_list[k - <span class="number">1</span>] - sum_list[j]) <span class="keyword">in</span> sum_set:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.splitArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-33"><a href="#interview-33" class="headerlink" title="interview_33"></a>interview_33</h2><p><a href="https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/" target="_blank" rel="noopener">解题思路</a></p><blockquote><p>丑数的递推性质： 丑数只包含因子 2, 3, 5。因此有 “丑数 == 某较小丑数 × 某因子” （例如：10 = 5 ×2）</p></blockquote><p><img data-src="/images/algorithm/interview_33.png" alt="interview_33"></p><p>指针a,b,c分别代表<code>*2、*3、*5</code>的三个指针，它们指向的丑数一旦完成计算，则继续指向下一个丑数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/3 10:21</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_33.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/chou-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp, a, b, c = [<span class="number">1</span>] * n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 从三个倍数中选一个最小的</span></span><br><span class="line">            min_ugly = min(dp[a] * <span class="number">2</span>, dp[b] * <span class="number">3</span>, dp[c] * <span class="number">5</span>)</span><br><span class="line">            dp[i] = min_ugly</span><br><span class="line">            <span class="keyword">if</span> min_ugly == dp[a] * <span class="number">2</span>:</span><br><span class="line">                a += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_ugly == dp[b] * <span class="number">3</span>:</span><br><span class="line">                b += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> min_ugly == dp[c] * <span class="number">5</span>:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.nthUglyNumber(<span class="number">10</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-7"><a href="#interview-7" class="headerlink" title="interview_7"></a>interview_7</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 11:36 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_7.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        f_dict = {<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">1</span>}</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, N):</span><br><span class="line">            f_dict[i] = f_dict[i - <span class="number">1</span>] + f_dict[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> f_dict[N - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.fib(<span class="number">4</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-8"><a href="#interview-8" class="headerlink" title="interview_8"></a>interview_8</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 11:38</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_8.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qr</span></span><br><span class="line"><span class="comment"># u=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        dp = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.climbStairs(<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-9"><a href="#interview-9" class="headerlink" title="interview_9"></a>interview_9</h2><p>用<code>f(n)</code>表示青蛙跳上n阶台阶的跳法数，设定<code>f(0) = 1</code>;</p><p>当<code>n = 1</code> 时，只有一种跳的方式，一阶跳，<code>f(1) = 1</code></p><p>当<code>n = 2</code> 时，有两种跳的方式，一阶跳和两阶跳，<code>f(2) = f(1) + f(0) = 2</code></p><p>当<code>n = 3</code> 时，有三种跳的方式，第一次跳出一阶后，后面还有<code>f(3-1)</code>中跳法； 第一次跳出二阶后，后面还有<code>f(3-2)</code>中跳法；第一次跳出三阶后，后面还有<code>f(3-3)</code>种跳法，<code>f(3) = f(2) + f(1) + f(0) = 4</code></p><p>当n = n 时，第一次跳出一阶后，后面还有<code>f(n-1)</code>中跳法； 第一次跳出二阶后，后面还有<code>f(n-2)</code>中跳法……第一次跳出n阶后，后面还有<code>f(n-n)</code>中跳法，即</p><p><code>f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-n) = f(0) + f(1) + f(2) + ... + f(n-1)</code></p><p>又因为<code>f(n-1) = f(0) + f(2) + f(3) + ... + f(n-2)</code></p><p>两式相减得：<code>f(n) = 2 * f(n-1)  ( n &gt;= 2)</code></p><p>​              | 0，n = 0</p><p>f(n)  =    | 1, n = 1</p><p>​              | 2 * f(n-1) , n &gt;= 2</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/26 12:35</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_9.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, number + <span class="number">1</span>):</span><br><span class="line">            n = <span class="number">2</span> * n</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-67"><a href="#interview-67" class="headerlink" title="interview_67"></a>interview_67</h2><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/xiang-jie-bao-li-di-gui-ji-yi-hua-ji-zhu-dong-tai-/" target="_blank" rel="noopener">参考链接</a></p><p>方法一：暴力递归</p><ul><li>时间复杂度：$O(2^N)$。</li><li>空间复杂度：$O(2^N)$。</li></ul><p>设 <strong>F(n)</strong>为长度为 n 的绳子可以得到的最大乘积，对于每一个 F(n)，<strong>注意到我们每次将一段绳子剪成两段时，剩下的部分可以继续剪，也可以不剪</strong>。这就得到了递归函数：</p><blockquote><p>F(n) = max( i * ( n-i ) , i * F( n-1) ), i=1,2,…,n−2</p></blockquote><p><img data-src="/images/algorithm/interview_67.png" alt="递归树"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:59</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_67.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/jian-sheng-zi-lcof/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        result = <span class="number">-1</span> </span><br><span class="line">        <span class="comment"># 1 * F(n-1)、2 * F(n-2).....、i * F(n - i)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 剪或不剪</span></span><br><span class="line">            result = max(result, max(i * (n-i), i * memorize(n - i)))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><p>方法二：记忆化技术（自顶向下）</p><p><strong>暴力法超时的原因是因为重复计算了F(N）</strong>，为了避免重复计算可以使用 记忆化（memoization） 技术。</p><p>记忆化技术的代码中经常需要建立函数 <code>memoize</code> 辅助实现。我们使用数组 <code>f</code> 来保存长度为 <code>i</code>时的最大长度 <code>f[i]</code>，最后返回 <code>f[n]</code>即可。</p><p>由于利用数组保存了中间结果，所以可以将空间复杂度降低至$O(N)$</p><ul><li>时间复杂度：$O(2^N)$。</li><li>空间复杂度：$O(N)$。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:59</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_67.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/jian-sheng-zi-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">memorize</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> fn[n] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> fn[n]</span><br><span class="line"></span><br><span class="line">            result = <span class="number">-1</span></span><br><span class="line">            <span class="comment"># 1 * F(n-1)、2 * F(n-2).....、i * F(n - i)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 剪或不剪</span></span><br><span class="line">                result = max(result, max(i * (n-i), i * memorize(n - i)))</span><br><span class="line">            fn[n] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        fn = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]  <span class="comment"># 用于计算已计算过的函数变量</span></span><br><span class="line">        <span class="keyword">return</span> memorize(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.cuttingRope(<span class="number">10</span>))</span><br></pre></td></tr></tbody></table></figure><p>方法三：记忆化技术（自底向上）<strong>(推荐贪心法：简洁易懂)</strong></p><p><img data-src="/images/algorithm/interview_67_1.png" alt="自底向上"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:59</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_67.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/jian-sheng-zi-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]  <span class="comment"># 用于计算已计算过的函数变量</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 遍历dp: 即F(n)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">           <span class="comment"># 求解loop，求每个F(n)的解</span></span><br><span class="line">            <span class="comment"># j代表在i长的绳子上要怎么剪，j==0or==i都代表不需要剪</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.cuttingRope(<span class="number">10</span>))</span><br></pre></td></tr></tbody></table></figure><h1 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h1><h2 id="jump-game-ii"><a href="#jump-game-ii" class="headerlink" title="jump-game-ii"></a>jump-game-ii</h2><p>本题使用贪心算法求解，寻找<strong>局部最优解</strong>。</p><ul><li>即在可跳范围内选择能跳的最远的位置</li><li>当前位置在“2”，可跳位置为“3”，“1”，其中可跳的最远的位置为“3”，则选择“3”</li><li>当前位置在“3”，可跳位置为“1”、“1”、“4”，其中可跳的最远的位置为“4”，则选择“4”</li><li>跳跃结束，step为2</li></ul><div class="table-container"><table><thead><tr><th>步数</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Step1</td><td>2（当前位置）</td><td>*3</td><td>*1</td><td>1</td><td>4</td></tr><tr><td>Step1</td><td>2</td><td>3（当前位置）</td><td>*1</td><td>*1</td><td>*4</td></tr></tbody></table></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/17 09:45</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 45_jump-game-ii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/jump-game-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        max_position = <span class="number">0</span>  <span class="comment"># 记录局部可跳跃的最大值</span></span><br><span class="line">        end = <span class="number">0</span>  <span class="comment"># 记录每次跳跃的最大值的下标</span></span><br><span class="line">        step = <span class="number">0</span>  <span class="comment"># 记录跳跃的步数</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> step</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 寻找局部最优解</span></span><br><span class="line">            max_position = max(max_position, nums[i] + i)</span><br><span class="line">            <span class="keyword">if</span> i == end:</span><br><span class="line">                end = max_position</span><br><span class="line">                step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.jump([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="maximum-subarray-1"><a href="#maximum-subarray-1" class="headerlink" title="maximum-subarray"></a>maximum-subarray</h2><ul><li>解法1:贪心算法</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/25 09:52</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 53_maximum-subarray.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/maximum-subarray/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray_GA</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        len_nums = len(nums)</span><br><span class="line">        current_sum = max_sum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len_nums):</span><br><span class="line">          <span class="comment"># 寻找局部最优解</span></span><br><span class="line">            current_sum = max(nums[i], current_sum + nums[i])</span><br><span class="line">            max_sum = max(max_sum, current_sum)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.maxSubArray([<span class="number">-2</span>, <span class="number">1</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-5</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><ul><li>解法2:动态规划</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray_DP</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    len_nums = len(nums)</span><br><span class="line">    max_sum = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len_nums):</span><br><span class="line">        <span class="keyword">if</span> nums[i<span class="number">-1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">            nums[i] += nums[i<span class="number">-1</span>]</span><br><span class="line">        max_sum = max(max_sum, nums[i])</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-30"><a href="#interview-30" class="headerlink" title="interview_30"></a>interview_30</h2><p>此题同<a href="https://unknown.yuzhouwan.com/posts/55663/#maximum_subarray">maximum_subarray</a></p><p><img data-src="/images/algorithm/interview_30.png" alt="interview_30"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/30 14:52 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_30.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;</span></span><br><span class="line"><span class="comment"># qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_number = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            nums[i] += max(nums[i<span class="number">-1</span>], <span class="number">0</span>)</span><br><span class="line">            max_number = max(max_number, nums[i])</span><br><span class="line">        <span class="keyword">return</span> max_number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.maxSubArray([<span class="number">-2</span>, <span class="number">1</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-5</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="merge-intervals"><a href="#merge-intervals" class="headerlink" title="merge-intervals"></a>merge-intervals</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/28 11:49</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 56_merge-intervals.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/merge-intervals/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        seq = sorted(intervals)  <span class="comment"># 先按照seq[0]排序，若seq[0]一样，则按照seq[1]排序</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(seq):</span><br><span class="line">            <span class="keyword">if</span> seq[i<span class="number">-1</span>][<span class="number">0</span>] &lt;= seq[i][<span class="number">0</span>] &lt;= seq[i<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> seq[i][<span class="number">1</span>] &gt; seq[i<span class="number">-1</span>][<span class="number">1</span>]:</span><br><span class="line">                    seq[i<span class="number">-1</span>][<span class="number">1</span>] = seq[i][<span class="number">1</span>]</span><br><span class="line">                seq.remove(seq[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.merge([[<span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">6</span>], [<span class="number">1</span>, <span class="number">80</span>], [<span class="number">15</span>, <span class="number">7</span>]]))</span><br></pre></td></tr></tbody></table></figure><h2 id="insert-interval"><a href="#insert-interval" class="headerlink" title="insert-interval"></a>insert-interval</h2><p><a href="https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode/" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/29 11:45</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 57_insert-interval.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/insert-interval/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals: <span class="string">'List[Interval]'</span>, newInterval: <span class="string">'Interval'</span>)</span> -&gt; 'List[Interval]':</span></span><br><span class="line">        start, end = newInterval</span><br><span class="line">        current, n = <span class="number">0</span>, len(intervals)</span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将newInterval之前的序列直接添加到output中</span></span><br><span class="line">        <span class="keyword">while</span> current &lt; n <span class="keyword">and</span> intervals[current][<span class="number">0</span>] &lt; start:</span><br><span class="line">            output.append(intervals[current])</span><br><span class="line">            current += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加newInterval到output中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> output <span class="keyword">and</span> output[<span class="number">-1</span>][<span class="number">1</span>] &lt; start:</span><br><span class="line">            output.append(newInterval)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output[<span class="number">-1</span>][<span class="number">1</span>] = max(end, output[<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加剩余的interval</span></span><br><span class="line">        <span class="keyword">while</span> current &lt; n:</span><br><span class="line">            <span class="keyword">if</span> output[<span class="number">-1</span>][<span class="number">1</span>] &lt; intervals[current][<span class="number">0</span>]:</span><br><span class="line">                output.append(intervals[current])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output[<span class="number">-1</span>][<span class="number">1</span>] = max(intervals[current][<span class="number">1</span>], output[<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">            current += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.insert([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">10</span>], [<span class="number">12</span>, <span class="number">16</span>]], [<span class="number">4</span>, <span class="number">8</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="queue-reconstruction-by-height"><a href="#queue-reconstruction-by-height" class="headerlink" title="queue-reconstruction-by-height"></a>queue-reconstruction-by-height</h2><p>这道题的关键思想是官网所说的：<strong>“因为个子矮的人相对于个子高的人是 “看不见” 的，所以可以先安排个子高的人。”</strong></p><p>即，先按照身高对每个人进行排序，然后再根据个子矮的人所对应的索引，插入到个子高的人中，因为个子矮的人相对于个子高的人是 <strong>“看不见”</strong> 的，所以插入过程中并不会影响前面已经排好序的个子高的人。</p><p>过程如下：具体<a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/" target="_blank" rel="noopener">解题思路</a>见官网。</p><ul><li>排序：<ul><li>按高度降序排列。</li><li>在同一高度的人中，按 <code>k</code> 值的升序排列。</li></ul></li><li>逐个地把它们放在输出队列中，索引等于它们的 <code>k</code> 值。</li><li>返回输出队列</li></ul><p><img data-src="/images/algorithm/queue-reconstruction-by-height.png" alt="queue-reconstruction-by-height"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/14 19:37 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 406_queue-reconstruction-by-height.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/queue-reconstruction-by-height/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reconstructQueue</span><span class="params">(self, people: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># 按照x[0]的逆序（所以为-x[0]），x[1]的正序进行排序</span></span><br><span class="line">        people.sort(key=<span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]), reverse=<span class="literal">False</span>)</span><br><span class="line">        out_put_people = []</span><br><span class="line">        <span class="comment"># 根据索引，依次做插入操作</span></span><br><span class="line">        <span class="keyword">for</span> person <span class="keyword">in</span> people:</span><br><span class="line">            out_put_people.insert(person[<span class="number">1</span>], person)</span><br><span class="line">        <span class="keyword">return</span> out_put_people</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reconstructQueue([[<span class="number">7</span>, <span class="number">0</span>], [<span class="number">4</span>, <span class="number">4</span>], [<span class="number">7</span>, <span class="number">1</span>], [<span class="number">5</span>, <span class="number">2</span>], [<span class="number">6</span>, <span class="number">1</span>], [<span class="number">5</span>, <span class="number">0</span>]]))</span><br><span class="line"><span class="comment"># out_put : [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]</span></span><br></pre></td></tr></tbody></table></figure><h2 id="remove-duplicate-letters"><a href="#remove-duplicate-letters" class="headerlink" title="remove-duplicate-letters"></a>remove-duplicate-letters</h2><p><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/solution/zhan-by-liweiwei1419/" target="_blank" rel="noopener">参考链接</a></p><p><img data-src="/images/algorithm/remove-duplicate-letters.png" alt="remove-duplicate-letters"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/17 23:06 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 316_remove-duplicate-letters.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/remove-duplicate-letters/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">""</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        stack = []</span><br><span class="line">        value_in_stack = set()</span><br><span class="line">        last_occurance = {k:i <span class="keyword">for</span> i, k <span class="keyword">in</span> enumerate(s)}</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> value_in_stack:</span><br><span class="line">                <span class="comment"># stack[-1] &gt; c:如果栈顶元素的字典序大于当前的c</span></span><br><span class="line">                <span class="comment"># last_occurance[stack[-1]] &gt; i：且栈顶元素还会在后续s中出现</span></span><br><span class="line">                <span class="comment"># 则将栈顶元素弹出，并压入当前元素</span></span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; c <span class="keyword">and</span> last_occurance[stack[<span class="number">-1</span>]] &gt; i:</span><br><span class="line">                    value_in_stack.discard(stack.pop())</span><br><span class="line">                stack.append(c)</span><br><span class="line">                value_in_stack.add(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.removeDuplicateLetters(<span class="string">"cbacdcbc"</span>))</span><br></pre></td></tr></tbody></table></figure><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>在合并两个数组或者字符串时，如果从前往后复制每个数字（或者字符）需要重复移动数字（或字符）多次，则可以考虑从后往前复制，就能减少移动的次数。</p><h2 id="valid-number-1"><a href="#valid-number-1" class="headerlink" title="valid-number"></a>valid-number</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/8 00:41</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 65_valid-number.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/valid-number/</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># return bool(re.match(r' *[+-]?([0-9]+(\.[0-9]*)?|\.[0-9]+)(e[+-]?[0-9]+)? *$', s))</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="comment"># 去除s两边的空白符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 去除"+"、"-"</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">"+"</span>, <span class="string">"-"</span>]:</span><br><span class="line">            s = s[<span class="number">1</span>:]</span><br><span class="line">        <span class="comment"># 判断是否含有e</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"e"</span> <span class="keyword">in</span> s:</span><br><span class="line">            s_list = s.split(<span class="string">"e"</span>)</span><br><span class="line">            <span class="comment"># 说明有两个e</span></span><br><span class="line">            <span class="keyword">if</span> len(s_list) &gt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 去掉e前面的"."</span></span><br><span class="line">            s_list[<span class="number">0</span>] = s_list[<span class="number">0</span>].replace(<span class="string">"."</span>, <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 去掉e后面的"+、"-"</span></span><br><span class="line">            <span class="keyword">if</span> len(s_list[<span class="number">1</span>]) &gt; <span class="number">0</span> <span class="keyword">and</span> s_list[<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">"+"</span>, <span class="string">"-"</span>]:</span><br><span class="line">                s_list[<span class="number">1</span>] = s_list[<span class="number">1</span>].replace(s_list[<span class="number">1</span>][<span class="number">0</span>], <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 判断是否为数字</span></span><br><span class="line">            <span class="keyword">if</span> s_list[<span class="number">0</span>].isnumeric() <span class="keyword">and</span> s_list[<span class="number">1</span>].isnumeric():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s = s.replace(<span class="string">"."</span>, <span class="string">""</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> s.isnumeric():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isNumber(<span class="string">"53.5e93"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="text-justification"><a href="#text-justification" class="headerlink" title="text-justification"></a>text-justification</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/9 19:20</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 68_text-justification.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/text-justification/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span><span class="params">(self, words: List[str], maxWidth: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        current_chars_number = <span class="number">0</span>  <span class="comment"># 当前行存储的字符个数(不包括空格)</span></span><br><span class="line">        current_words_number = <span class="number">0</span>  <span class="comment"># 当前行存储的单词个数，用于统计</span></span><br><span class="line">        word_list = []  <span class="comment"># 当前行的单词列表</span></span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            current_word_length = len(value)</span><br><span class="line">            <span class="comment"># 当前字符数量大于最大限制</span></span><br><span class="line">            <span class="keyword">if</span> current_chars_number + current_word_length + current_words_number &gt; maxWidth:</span><br><span class="line">                <span class="keyword">if</span> current_words_number == <span class="number">1</span>:</span><br><span class="line">                    result.append(word_list[<span class="number">0</span>] + <span class="string">" "</span> * (maxWidth - current_chars_number))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    blank_space_number = maxWidth - current_chars_number  <span class="comment"># 当前的空格数量</span></span><br><span class="line">                    <span class="keyword">if</span> blank_space_number % (current_words_number - <span class="number">1</span>) == <span class="number">0</span>:  <span class="comment"># 空格可以平均分配</span></span><br><span class="line">                        result.append((<span class="string">" "</span>* (blank_space_number // (current_words_number - <span class="number">1</span>))).join(word_list))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 空格不能平均分配</span></span><br><span class="line">                        more_blankspace = blank_space_number % (current_words_number - <span class="number">1</span>)  <span class="comment"># 多余的空格</span></span><br><span class="line">                        stand_blankspace = blank_space_number // (current_words_number - <span class="number">1</span>)  <span class="comment"># 标准的最少空格</span></span><br><span class="line">                        res = word_list[<span class="number">0</span>]</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> range(more_blankspace):</span><br><span class="line">                            res += <span class="string">" "</span> * (stand_blankspace+<span class="number">1</span>) + word_list[i+<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> range(more_blankspace+<span class="number">1</span>, len(word_list)):</span><br><span class="line">                            res += <span class="string">" "</span> * stand_blankspace + word_list[i]</span><br><span class="line">                        result.append(res)</span><br><span class="line">                current_chars_number = current_word_length</span><br><span class="line">                current_words_number = <span class="number">1</span></span><br><span class="line">                word_list = [value]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current_chars_number += current_word_length</span><br><span class="line">                current_words_number += <span class="number">1</span></span><br><span class="line">                word_list.append(value)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.fullJustify([<span class="string">"This"</span>, <span class="string">"is"</span>, <span class="string">"an"</span>, <span class="string">"example"</span>, <span class="string">"of"</span>, <span class="string">"text"</span>, <span class="string">"justification."</span>], <span class="number">16</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="simplify-path"><a href="#simplify-path" class="headerlink" title="simplify-path"></a>simplify-path</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/12 12:01</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 71_simplify-path.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/simplify-path/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        result_list = []</span><br><span class="line">        path = path.split(<span class="string">"/"</span>)</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> path:</span><br><span class="line">            <span class="keyword">if</span> value == <span class="string">".."</span>:</span><br><span class="line">                <span class="keyword">if</span> result_list:</span><br><span class="line">                    result_list.pop()</span><br><span class="line">            <span class="keyword">elif</span> value <span class="keyword">and</span> value != <span class="string">"."</span>:</span><br><span class="line">                result_list.append(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/"</span> + <span class="string">"/"</span>.join(result_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.simplifyPath(<span class="string">"/a/./b/../../c/"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="Interview-2"><a href="#Interview-2" class="headerlink" title="Interview_2"></a>Interview_2</h2><ul><li>方法一：时间复杂度<code>O(n)</code>,空间复杂度<code>O(1)</code></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/8 22:38 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_2.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">" "</span>, <span class="string">"%20"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.replaceSpace(<span class="string">"We are happy."</span>))</span><br></pre></td></tr></tbody></table></figure><ul><li>方法二:时间复杂度<code>O(n)</code>,空间复杂度<code>O(n)</code></li></ul><p>这里用list而不是str直接处理的原因是。str是不可变数据类型，也就是说每在一个str后面加了一个字符，都是新的str。这样导致空间开销太大。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/8 22:38 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_2.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        s_list = list()</span><br><span class="line">        <span class="keyword">for</span> s_value <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> s_value == <span class="string">" "</span>:</span><br><span class="line">                s_list.append(<span class="string">"%20"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s_list.append(s_value)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(s_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.replaceSpace(<span class="string">"We are happy."</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-43"><a href="#interview-43" class="headerlink" title="interview_43"></a>interview_43</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/23 18:33 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_43.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span><span class="params">(self, s: str, n: int)</span> -&gt; str:</span></span><br><span class="line">        len_s = len(s)</span><br><span class="line">        <span class="keyword">if</span> n &gt;= len_s <span class="keyword">or</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">return</span> s[n:] + s[:n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reverseLeftWords(<span class="string">"abcdefg"</span>, <span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-44"><a href="#interview-44" class="headerlink" title="interview_44"></a>interview_44</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/24 15:15 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_44.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        s_rotate = s.split()</span><br><span class="line">        <span class="comment"># " "的情况，直接返回s</span></span><br><span class="line">        <span class="keyword">if</span> len(s_rotate) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(s_rotate[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reverseWords(<span class="string">"abc bvc nbm"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-45"><a href="#interview-45" class="headerlink" title="interview_45"></a>interview_45</h2><p>先对数组执行排序</p><ul><li>判别重复： 排序数组中的相同元素位置相邻，因此可通过遍历数组，判断 nums[i] = nums[i + 1]是否成立来判重。</li><li>获取最大 / 最小的牌： 排序后，数组末位元素 nums[4] 为最大牌；元素 nums[joker]为最小牌，其中 joker为大小王的数量。</li></ul><p><img data-src="/images/algorithm/interview_45.png" alt="interview_45"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/24 15:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_45.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isStraight</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        joker = <span class="number">0</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">                joker += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[joker] &lt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isStraight([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]))</span><br></pre></td></tr></tbody></table></figure><h1 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h1><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><div class="table-container"><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最差时间复杂度</th><th>额外空间复杂度</th><th>稳定性</th><th>备注</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$o(n^2)$</td><td>$o(n^2)$</td><td>$o(1)$</td><td>稳定</td><td>n小时效果好</td></tr><tr><td>选择排序</td><td>$o(n^2)$</td><td>$o(n^2)$</td><td>$o(1)$</td><td>不稳定</td><td>n小时效果好</td></tr><tr><td>交换排序</td><td>$o(n^2)$</td><td>$o(n^2)$</td><td>$o(1)$</td><td>不稳定</td><td>n小时效果好</td></tr><tr><td>插入排序</td><td>$o(n^2)$</td><td>$o(n^2)$</td><td>$o(1)$</td><td>稳定</td><td>n小时效果好</td></tr><tr><td>快速排序</td><td>$o(nlogn)$</td><td>$o(n^2)$</td><td>$o(nlogn)-o(n)$</td><td>不稳定</td><td>n大时效果好</td></tr><tr><td>归并排序</td><td>$o(nlogn)$</td><td>$o(nlogn)$</td><td>$o(n)$</td><td>稳定</td><td>n大时效果好</td></tr><tr><td>堆排序</td><td>$o(nlogn)$</td><td>$o(nlogn)$</td><td>$o(1)$</td><td>不稳定</td><td>n大时效果好</td></tr><tr><td>希尔排序</td><td>$o(nlogn)$</td><td>$o(n^s)$ 1&lt;s&lt;2</td><td>$o(1)$</td><td>不稳定</td><td>s是所选分组</td></tr><tr><td>基数排序</td><td>$o(log_RB)($线性复杂度)</td><td>$o(log_RB)$</td><td>$o(n)$</td><td>稳定</td><td>B是真数(0-9)，R是基数(个十百)</td></tr><tr><td>计数排序</td><td>$o(n)$</td><td>$o(nlogn)$</td><td></td><td>稳定</td><td>0</td></tr><tr><td>划分排序</td><td>$o(n)$</td><td>0</td><td>0</td><td>稳定</td><td>0</td></tr><tr><td>桶排序</td><td>$o(n)$</td><td>0</td><td>0</td><td>稳定</td><td>0</td></tr></tbody></table></div><p><a href="https://leetcode-cn.com/problems/sort-an-array/solution/python-shi-xian-de-shi-da-jing-dian-pai-xu-suan-fa/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-an-array/solution/python-shi-xian-de-shi-da-jing-dian-pai-xu-suan-fa/</a></p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p><p><strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p><strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p><p><strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergesort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="string">"""归并排序"""</span></span><br><span class="line">    <span class="keyword">if</span> len(seq) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> seq</span><br><span class="line">    mid = len(seq) / <span class="number">2</span>  <span class="comment"># 将列表分成更小的两个列表</span></span><br><span class="line">    <span class="comment"># 分别对左右两个列表进行处理，分别返回两个排序好的列表</span></span><br><span class="line">    left = mergesort(seq[:mid])</span><br><span class="line">    right = mergesort(seq[mid:])</span><br><span class="line">    <span class="comment"># 对排序好的两个列表合并，产生一个新的排序好的列表</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    <span class="string">"""合并两个已排序好的列表，产生一个新的已排序好的列表"""</span></span><br><span class="line">    result = []  <span class="comment"># 新的已排序好的列表</span></span><br><span class="line">    i = <span class="number">0</span>  <span class="comment"># 下标</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 对两个列表中的元素 两两对比。</span></span><br><span class="line">    <span class="comment"># 将最小的元素，放到result中，并对当前列表下标加1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    result += left[i:]</span><br><span class="line">    result += right[j:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">seq = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'排序前：'</span>,seq</span><br><span class="line">result = mergesort(seq)</span><br></pre></td></tr></tbody></table></figure><h2 id="largest-number"><a href="#largest-number" class="headerlink" title="largest-number"></a>largest-number</h2><p>自定义排序</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/23 21:18</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 179_largest-number.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/largest-number/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargerNumKey</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x + y &lt; y + x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        return_value = <span class="string">""</span>.join(sorted(map(str, nums), key=LargerNumKey, reverse=<span class="literal">True</span>)).lstrip(<span class="string">"0"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span> <span class="keyword">if</span> return_value[<span class="number">0</span>] == <span class="string">"0"</span> <span class="keyword">else</span> return_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.largestNumber([<span class="number">3</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">9</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-32"><a href="#interview-32" class="headerlink" title="interview_32"></a>interview_32</h2><p>同上一题：largest-number，这题不加任何技巧。<strong>类似于冒泡排序。</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/2 11:54 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_32.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            nums[i] = str(nums[i])</span><br><span class="line">        <span class="comment"># 冒泡排序：每次把最小的元素放在第一位</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j]) &gt; (nums[j] + nums[i]):</span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.minNumber([<span class="number">3</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">9</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="Top-K-Sort"><a href="#Top-K-Sort" class="headerlink" title="Top-K Sort"></a>Top-K Sort</h2><h3 id="kth-largest-element-in-an-array"><a href="#kth-largest-element-in-an-array" class="headerlink" title="kth-largest-element-in-an-array"></a>kth-largest-element-in-an-array</h3><p>堆排序</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/25 12:43</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 215_kth-largest-element-in-an-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, nums)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findKthLargest([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>], <span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure><h3 id="interview-29"><a href="#interview-29" class="headerlink" title="interview_29"></a>interview_29</h3><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/tu-jie-top-k-wen-ti-de-liang-chong-jie-fa-you-lie-/" target="_blank" rel="noopener">解题思路</a></p><ol><li>方法一：堆排序</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/29 16:40 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_29.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?</span></span><br><span class="line"><span class="comment"># tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        len_tinput = len(tinput)</span><br><span class="line">        <span class="keyword">if</span> k &gt; len_tinput:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> heapq.nsmallest(k, arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findKthLargest([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>], <span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure><ol><li>方法2：利用快速排序思想</li></ol><p><img data-src="/images/algorithm/interview_29.png" alt="interview_29"></p><p>这个 partition 操作是原地进行的，需要 O(n)的时间，接下来，快速排序会递归地排序左右两侧的数组。而快速选择（quick select）算法的不同之处在于，接下来只需要递归地选择一侧的数组。快速选择算法想当于一个“不完全”的快速排序，因为我们只需要知道最小的 k 个数是哪些，并不需要知道它们的顺序。</p><p>我们的目的是寻找最小的 k 个数。假设经过一次 partition 操作，枢纽元素位于下标 m，也就是说，左侧的数组有 m 个元素，是原数组中最小的 m 个数。那么：</p><ul><li>若 k = m，我们就找到了最小的 k 个数，就是左侧的数组；</li><li>若 k &lt; m ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li><li>若 k &gt; m，则左侧数组中的 m 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k-m 个数，对右侧数组递归地 partition 即可。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/6/29 16:40</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_29.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?</span></span><br><span class="line"><span class="comment"># tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLeastNumbers</span><span class="params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> k &gt; len(arr):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = len(arr) - <span class="number">1</span></span><br><span class="line">        pivot = self.quicksort(arr, start, end)</span><br><span class="line">        <span class="keyword">while</span> pivot != k - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> pivot &gt; k - <span class="number">1</span>:</span><br><span class="line">                end = pivot - <span class="number">1</span></span><br><span class="line">                pivot = self.quicksort(arr, start, end)</span><br><span class="line">            <span class="keyword">if</span> pivot &lt; k - <span class="number">1</span>:</span><br><span class="line">                start = pivot + <span class="number">1</span></span><br><span class="line">                pivot = self.quicksort(arr, start, end)</span><br><span class="line">        <span class="keyword">return</span> arr[:k]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(self, arr, left, right)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        简单版快速排序</span></span><br><span class="line"><span class="string">        返回一个坐标，坐标左侧都小于返回值，右侧都大于返回值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = left</span><br><span class="line">        j = right</span><br><span class="line">        temp = arr[left]</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="comment"># 从右侧搜索小元素，并进行交换</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[j] &gt;= temp:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            arr[i] = arr[j]</span><br><span class="line">            <span class="comment"># 从左侧搜索大元素，并进行交换</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> arr[i] &lt; temp:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            arr[j] = arr[i]</span><br><span class="line">        <span class="comment"># 最初left上的数字已经被覆盖了，所以需要重新赋值</span></span><br><span class="line">        arr[i] = temp</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.getLeastNumbers([<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>], <span class="number">4</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="sort-an-array"><a href="#sort-an-array" class="headerlink" title="sort-an-array"></a>sort-an-array</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/28 22:52 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 912_sort-an-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/sort-an-array/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = len(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#  快速排序</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quick</span><span class="params">(left, right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">                <span class="keyword">return</span> nums</span><br><span class="line">            <span class="comment"># 哨兵</span></span><br><span class="line">            pivot = left</span><br><span class="line">            i = left</span><br><span class="line">            j = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j:</span><br><span class="line">                <span class="comment"># 寻找右半部分</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &gt; nums[pivot]:</span><br><span class="line">                    j -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 寻找左半部分</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= nums[pivot]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            nums[pivot], nums[j] = nums[j], nums[pivot]</span><br><span class="line">            quick(left, j<span class="number">-1</span>)</span><br><span class="line">            quick(j+<span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quick(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="comment"># def insertion_sort(nums):</span></span><br><span class="line"><span class="comment">#     n = len(nums)</span></span><br><span class="line"><span class="comment">#     for i in range(1, n):</span></span><br><span class="line"><span class="comment">#         while i &gt; 0 and nums[i - 1] &gt; nums[i]:</span></span><br><span class="line"><span class="comment">#             nums[i - 1], nums[i] = nums[i], nums[i - 1]</span></span><br><span class="line"><span class="comment">#             i -= 1</span></span><br><span class="line"><span class="comment">#     return nums</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.sortArray([<span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="maximum-gap"><a href="#maximum-gap" class="headerlink" title="maximum-gap"></a>maximum-gap</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/29 12:39</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 164_maximum-gap.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/maximum-gap/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        len_nums = len(nums)</span><br><span class="line">        <span class="keyword">if</span> len_nums &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums.sort(reverse=<span class="literal">False</span>)</span><br><span class="line">        max_gap = abs(nums[<span class="number">1</span>] - nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len_nums):</span><br><span class="line">            max_gap = max(max_gap, abs(nums[i] - nums[i - <span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> max_gap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.maximumGap([<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="contains-duplicate"><a href="#contains-duplicate" class="headerlink" title="contains-duplicate"></a>contains-duplicate</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/30 17:45</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 217_contains-duplicate.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/contains-duplicate/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 先排序</span></span><br><span class="line">        nums.sort(reverse=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 再比较</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.containsDuplicate([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="contains-duplicate-ii"><a href="#contains-duplicate-ii" class="headerlink" title="contains-duplicate-ii"></a>contains-duplicate-ii</h2><p>用散列表来维护这个k大小的滑动窗口。</p><p>遍历数组，对于每个元素做以下操作：</p><ul><li><p>在散列表中搜索当前元素，如果找到了就返回 true。</p></li><li><p>在散列表中插入当前元素。</p></li><li><p>如果当前散列表的大小超过了 k， 删除散列表中最旧的元素。</p></li></ul><p>返回 false。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/30 17:46</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 219_contains-duplicate-ii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/contains-duplicate-ii/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; bool:</span></span><br><span class="line">        nums_sort = list()</span><br><span class="line">        nums_sort.append(nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> nums_sort:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> len(nums_sort) &gt;= k:</span><br><span class="line">                nums_sort.pop(<span class="number">0</span>)</span><br><span class="line">            nums_sort.append(nums[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.containsNearbyDuplicate([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="contains-duplicate-iii"><a href="#contains-duplicate-iii" class="headerlink" title="contains-duplicate-iii"></a>contains-duplicate-iii</h2><p>方法一：线性搜索，超时</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/5 21:24 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 220_contains-duplicate-iii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/contains-duplicate-iii</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(self, nums: List[int], k: int, t: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        nums_sort = list()</span><br><span class="line">        nums_sort.append(nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> len(nums_sort) &gt; k:</span><br><span class="line">                nums_sort.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 查询当前子列表中的每个元素是否满足t的要求</span></span><br><span class="line">            tmp_nums_sored = sorted(nums_sort, reverse=<span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> tmp_nums_sored:</span><br><span class="line">                <span class="keyword">if</span> abs(nums[i] - v) &lt;= t:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            nums_sort.append(nums[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.containsNearbyAlmostDuplicate(nums=[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], k=<span class="number">2</span>, t=<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><p>方法二：桶排序</p><p>由于本题对索引有要求，考虑使用桶排序。</p><ul><li>每个数字nums[i] 都被分配到一个桶中</li><li>每个桶序号代表存放t的倍数的数 nums[i] // (t + 1)<ul><li>不相邻的桶一定不满足相差小于等于t，且同一个桶内的数字最多相差t</li><li>因此如果命中同一个桶内，那么直接返回True</li><li>如果命中相邻桶，我们再判断一下是否满足相差 &lt;= t</li></ul></li><li>题目有索引相差k的要求，因此要维护一个大小为k的窗口，定期清除桶中过期的数字。bucket.pop(nums[i - k] // (t + 1)) 即清除当前i前的第k个元素所对应的桶序号。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/5 21:24 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 220_contains-duplicate-iii.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/contains-duplicate-iii</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(self, nums: List[int], k: int, t: int)</span> -&gt; bool:</span></span><br><span class="line">        bucket = dict()</span><br><span class="line">        <span class="keyword">if</span> t &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums)):</span><br><span class="line">            <span class="comment"># 每个桶序号代表存放t的倍数的数</span></span><br><span class="line">            bucket_nth = nums[i] // (t + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> bucket_nth <span class="keyword">in</span> bucket:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> bucket_nth - <span class="number">1</span> <span class="keyword">in</span> bucket <span class="keyword">and</span> abs(bucket[bucket_nth - <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> bucket_nth + <span class="number">1</span> <span class="keyword">in</span> bucket <span class="keyword">and</span> abs(bucket[bucket_nth + <span class="number">1</span>] - nums[i]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            bucket[bucket_nth] = nums[i]</span><br><span class="line">            <span class="comment"># 当桶大于k时，代表窗口已经越界，越界元素可以进行清除</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                bucket.pop(nums[i - k] // (t + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.containsNearbyAlmostDuplicate(nums=[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], k=<span class="number">2</span>, t=<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-63"><a href="#interview-63" class="headerlink" title="interview_63"></a>interview_63</h2><p><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/mian-shi-ti-41-shu-ju-liu-zhong-de-zhong-wei-shu-y/" target="_blank" rel="noopener">参考链接</a></p><p>复杂度分析：</p><ul><li>时间复杂度：<br>查找中位数 O(1) ： 获取堆顶元素使用 O(1)时间；（二分查找等则需要O(log N)）<br>添加数字 O(log N) ： 堆的插入和弹出操作使用 O(log N) 时间。（线性插入O(N)）</li><li>空间复杂度 O(N)： 其中 N 为数据流中的元素数量，小顶堆 B 和大顶堆 A最多同时保存 N 个元素。</li></ul><p>算法利用大顶堆A和小顶堆B，A存放较小的元素，B存放较大的元素。使得B的最小的元素也比A中最大的元素大，保证数据流保持有序。</p><p><strong>B保持比A多一个的状态</strong>，当数据流长度时为奇数时，则向A中插入元素；偶数时，则向B中插入元素。</p><blockquote><p>Python 中 heapq 模块是小顶堆。实现 <strong>大顶堆</strong> 方法： 小顶堆的插入和弹出操作均将元素 <strong>取反</strong> 即可。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/10/10 11:58</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @Fil</span></span><br><span class="line">e: interview_63.py</span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</span></span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.A = []  <span class="comment"># 大顶堆，存放较小的元素</span></span><br><span class="line">        self.B = []  <span class="comment"># 小顶堆，存放较大的元素，使得B的最小的元素也比A中最大的元素大，保证数据流保持有序</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># 数据流长度为奇数时，需向A中插入元素：先向B中插入num，再将B的堆顶元素插入至A，保证B比A大</span></span><br><span class="line">        <span class="keyword">if</span> len(self.A) != len(self.B):</span><br><span class="line">            heappush(self.B, num)</span><br><span class="line">            heappush(self.A, -heappop(self.B))</span><br><span class="line">        <span class="comment"># 数据流长度为偶数时，需向B中插入元素：先向A中插入num，再将A的堆顶元素插入至B，保证B比A大</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heappush(self.A, -num)</span><br><span class="line">            heappush(self.B, -heappop(self.A))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.A) != len(self.B):</span><br><span class="line">            <span class="keyword">return</span> self.B[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># A由于是存放的都是相反数，所以计算时，A中最大的数其实在A[0],也就是-A[0]是A中最大的数</span></span><br><span class="line">            <span class="keyword">return</span> (-self.A[<span class="number">0</span>] + self.B[<span class="number">0</span>]) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MedianFinder()</span></span><br><span class="line"><span class="comment"># obj.addNum(num)</span></span><br><span class="line"><span class="comment"># param_2 = obj.findMedian()</span></span><br></pre></td></tr></tbody></table></figure><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><h2 id="interview-12"><a href="#interview-12" class="headerlink" title="interview_12"></a>interview_12</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2^3</span><br><span class="line">2^3 = 2^1 * 2^1 * 2 </span><br><span class="line">2^1 = 2^0 * 2</span><br><span class="line">2^0 = 1</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2^4</span><br><span class="line">2^4 = 2^2 * 2^2</span><br><span class="line">2^2 = 2^1 * 2^1</span><br><span class="line">2^1 = 2^0 * 2</span><br><span class="line">2^0 = 1</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/16 16:24</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_12.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;q</span></span><br><span class="line"><span class="comment"># ru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / x</span><br><span class="line">        half = self.myPow(x, n // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> half * half</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> half * half * x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.myPow(<span class="number">2.00000</span>, <span class="number">-10</span>))</span><br></pre></td></tr></tbody></table></figure><h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="remove-duplicates-from-sorted-array"><a href="#remove-duplicates-from-sorted-array" class="headerlink" title="remove-duplicates-from-sorted-array"></a>remove-duplicates-from-sorted-array</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/2 11:53 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 26_remove-duplicates-from-sorted-array.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.removeDuplicates([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="remove-element"><a href="#remove-element" class="headerlink" title="remove-element"></a>remove-element</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/3 11:41 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 27_remove-element.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/remove-element/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val: int)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != val:</span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.removeElement([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>], <span class="number">2</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="implement-strstr"><a href="#implement-strstr" class="headerlink" title="implement-strstr"></a>implement-strstr</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/4 8:45 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 28_implement-strstr.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/implement-strstr/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># haystack.find(needle)</span></span><br><span class="line">        <span class="keyword">if</span> len(haystack) &lt; len(needle):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(haystack) - len(needle) + <span class="number">1</span>):</span><br><span class="line">            index = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(needle)):</span><br><span class="line">                <span class="keyword">if</span> haystack[i] != needle[j]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == len(needle) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.strStr(<span class="string">"hello"</span>, <span class="string">"ll"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="substring-with-concatenation-of-all-words"><a href="#substring-with-concatenation-of-all-words" class="headerlink" title="substring-with-concatenation-of-all-words"></a>substring-with-concatenation-of-all-words</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/14 10:25 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 30_substring-with-concatenation-of-all-words.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> words:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        words_number = len(words)</span><br><span class="line">        words_len = len(words[<span class="number">0</span>])</span><br><span class="line">        s_len = len(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将words中的单词与个数存储到字典中</span></span><br><span class="line">        word_dic = {}</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> word_dic.keys():</span><br><span class="line">                word_dic[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                word_dic[word] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        output_list = []</span><br><span class="line">        <span class="comment"># 按照word的长度设三段切词的起点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(words_len):</span><br><span class="line">            <span class="comment"># 将s按照word的长度截取words_number段</span></span><br><span class="line">            start_index = i</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 先对s进行切割</span></span><br><span class="line">            s_cut_list = []</span><br><span class="line">            cut_number = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 切词</span></span><br><span class="line">            <span class="keyword">while</span> s_len - start_index &gt;= words_len:</span><br><span class="line">                s_cut_list.append(s[start_index : start_index + words_len])</span><br><span class="line">                cut_number += <span class="number">1</span></span><br><span class="line">                start_index += words_len</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 再对切割后的s进行判断，检验长度要求，个数要求</span></span><br><span class="line">            start_cut_i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> cut_number - start_cut_i &gt; words_number:</span><br><span class="line">                <span class="comment"># count记录当前已经匹配完成的个数</span></span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                w_dic = {}</span><br><span class="line">                <span class="comment"># 在s_cut_list中截取n个单词</span></span><br><span class="line">                <span class="keyword">for</span> s_word <span class="keyword">in</span> s_cut_list[start_cut_i : start_cut_i + words_number]:</span><br><span class="line">                    <span class="keyword">if</span> s_word <span class="keyword">in</span> word_dic.keys():</span><br><span class="line">                        <span class="keyword">if</span> s_word <span class="keyword">in</span> w_dic.keys():</span><br><span class="line">                            w_dic[s_word] += <span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> w_dic[s_word] &gt; word_dic[s_word]:</span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                            count += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            w_dic[s_word] = <span class="number">1</span></span><br><span class="line">                            count += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> count == words_number:</span><br><span class="line">                    output_list.append(i + start_cut_i * words_len)</span><br><span class="line">                start_cut_i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.findSubstring(<span class="string">"barfoothefoobarman"</span>, [<span class="string">"foo"</span>, <span class="string">"bar"</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next-permutation"></a>next-permutation</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/19 12:18 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 31_next-permutation.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/next-permutation/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        left = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 从右开始，找到第一个升序的数</span></span><br><span class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] &lt; nums[i]:</span><br><span class="line">                left = i - <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 如果不存在left，则为降序数列，翻转整个数组</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则找到第一个比nums[left]大的数，至少有一个（为nums[left+1]）</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>, left, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[right] &gt; nums[left]:</span><br><span class="line">                nums[right], nums[left] = nums[left], nums[right]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 此时nums[left+1]依旧为降序数列，翻转nums[left+1]</span></span><br><span class="line">        nums_left = nums[left + <span class="number">1</span> : len(nums)]</span><br><span class="line">        nums_left = nums_left[::<span class="number">-1</span>]</span><br><span class="line">        nums[left + <span class="number">1</span> : len(nums)] = nums_left</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.nextPermutation([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="longest-valid-parentheses"><a href="#longest-valid-parentheses" class="headerlink" title="longest-valid-parentheses"></a>longest-valid-parentheses</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/21 12:58 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 32_longest-valid-parentheses.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/longest-valid-parentheses/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        maxlen = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 当前字符为"("，left+=1,")"right+=1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 正向搜索: 即")"必须与"("相同</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">"("</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                maxlen = right * <span class="number">2</span> <span class="keyword">if</span> maxlen &lt; right * <span class="number">2</span> <span class="keyword">else</span> maxlen</span><br><span class="line">            <span class="keyword">elif</span> right &gt; left:</span><br><span class="line">                left = right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反向搜索：即"("必须与")"相同</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">"("</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                maxlen = left * <span class="number">2</span> <span class="keyword">if</span> maxlen &lt; left * <span class="number">2</span> <span class="keyword">else</span> maxlen</span><br><span class="line">            <span class="keyword">elif</span> left &gt; right:</span><br><span class="line">                left = right = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.longestValidParentheses(<span class="string">"())((())"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="search-insert-position"><a href="#search-insert-position" class="headerlink" title="search-insert-position"></a>search-insert-position</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/1/5 6:22 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 35_search-insert-position.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/search-insert-position/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == target:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            <span class="keyword">elif</span> nums[i] &lt; target &lt;= nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] &gt; target:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.searchInsert([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="combination-sum-ii"><a href="#combination-sum-ii" class="headerlink" title="combination-sum-ii"></a>combination-sum-ii</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/10 2:57 下午 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 40_combination-sum-ii.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/combination-sum-ii/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> candidates <span class="keyword">or</span> <span class="keyword">not</span> target:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        output_list = []</span><br><span class="line">        path = []</span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line">        size = len(candidates)</span><br><span class="line">        self._dfs(candidates, begin, size, path, output_list, target)</span><br><span class="line">        <span class="keyword">return</span> output_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dfs</span><span class="params">(self, candidates, begin, size, path, output_list, target)</span>:</span></span><br><span class="line">        <span class="comment"># 递归终止的条件</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            output_list.append(path[:])</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(begin, size):</span><br><span class="line">            residue = target - candidates[index]</span><br><span class="line">            <span class="keyword">if</span> residue &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> index &gt; begin <span class="keyword">and</span> candidates[index - <span class="number">1</span>] == candidates[index]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(candidates[index])</span><br><span class="line">            self._dfs(candidates, index+<span class="number">1</span>, size, path, output_list, residue)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    candidates = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    target = <span class="number">5</span></span><br><span class="line">    solution = Solution()</span><br><span class="line">    result = solution.combinationSum(candidates, target)</span><br><span class="line">    print(result)</span><br></pre></td></tr></tbody></table></figure><h2 id="multiply-strings"><a href="#multiply-strings" class="headerlink" title="multiply-strings"></a>multiply-strings</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/15 11:17</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 43_multiply-strings.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/multiply-strings/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> num1 == <span class="string">'0'</span> <span class="keyword">or</span> num2 == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        return_sum = <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> val1 <span class="keyword">in</span> num2[::<span class="number">-1</span>]:</span><br><span class="line">            add = <span class="number">0</span>  <span class="comment"># 进位符</span></span><br><span class="line">            multiply_sum = <span class="number">0</span></span><br><span class="line">            count1 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> val2 <span class="keyword">in</span> num1[::<span class="number">-1</span>]:</span><br><span class="line">                multi_sum = (int(val1) * int(val2) + add) % <span class="number">10</span></span><br><span class="line">                multiply_sum += multi_sum * (<span class="number">10</span> ** count1)</span><br><span class="line">                add = (int(val1) * int(val2) + add) // <span class="number">10</span></span><br><span class="line">                count1 += <span class="number">1</span></span><br><span class="line">            return_sum += multiply_sum * (<span class="number">10</span> ** count)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str(return_sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.multiply(<span class="string">"123"</span>, <span class="string">"456"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="group-anagrams"><a href="#group-anagrams" class="headerlink" title="group-anagrams"></a>group-anagrams</h2><p>解题方法：</p><ul><li><p>collections类中的defaultdict()方法来为字典提供默认值。</p></li><li><p>按排序数组分类</p><ul><li><p>ans = {(“a”,e”,”r”):[“are”,”ear”,”era”],</p><p>​            (“a”,”b”,”t”):[“bat”,”tab”]</p><p>​            (“e”,”c”,”d”,”o”):[“code”]}</p></li></ul></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/20 00:01</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 49_group-anagrams.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/group-anagrams/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        ans = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            ans[tuple(sorted(s))].append(s)</span><br><span class="line">        <span class="keyword">return</span> ans.values()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.groupAnagrams([<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="plus-one"><a href="#plus-one" class="headerlink" title="plus-one"></a>plus-one</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/2/22 19:31</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 66_plus-one.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/plus-one/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        len_digits = len(digits)</span><br><span class="line">        add = (digits[len_digits<span class="number">-1</span>] + <span class="number">1</span>) // <span class="number">10</span></span><br><span class="line">        digits[len_digits<span class="number">-1</span>] = (digits[len_digits<span class="number">-1</span>] + <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len_digits - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            add = (digits[i] + add) // <span class="number">10</span></span><br><span class="line">            digits[i] = (digits[i] + add) % <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> add == <span class="number">1</span>:</span><br><span class="line">            digits.insert(<span class="number">0</span>, add)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.plusOne([<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="length-of-last-word"><a href="#length-of-last-word" class="headerlink" title="length-of-last-word"></a>length-of-last-word</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/1 18:01</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 58_length-of-last-word.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/length-of-last-word/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> len(s.split()[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.lengthOfLastWord(<span class="string">"Hello World"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="permutation-sequence"><a href="#permutation-sequence" class="headerlink" title="permutation-sequence"></a>permutation-sequence</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/3/2 12:07</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 60_permutation-sequence.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/permutation-sequence/</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        nums = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>)]</span><br><span class="line">        output_str = <span class="string">""</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">-1</span>:</span><br><span class="line">            number_combination = math.factorial(n)  <span class="comment"># 每组组合数总和</span></span><br><span class="line">            output_number_index = math.ceil(k / number_combination) - <span class="number">1</span>  <span class="comment"># 不用\\的原因是因为 1 1希望输出的是0，"\\"会输出1</span></span><br><span class="line">            output_str += nums[output_number_index]</span><br><span class="line">            nums.pop(output_number_index)</span><br><span class="line">            k %= number_combination</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.getPermutation(<span class="number">4</span>, <span class="number">9</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/18 11:52 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 6_convert.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="keyword">elif</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        outstr = [<span class="string">""</span>] * numRows</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, numRows):</span><br><span class="line">                <span class="keyword">if</span> i &lt; len(s):</span><br><span class="line">                    outstr[j] += s[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(numRows - <span class="number">2</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &lt; len(s):</span><br><span class="line">                    outstr[j] += s[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        outstr = <span class="string">""</span>.join(outstr)</span><br><span class="line">        <span class="keyword">return</span> outstr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">"ABCDE"</span></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.convert(s, <span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="reverse-integer"><a href="#reverse-integer" class="headerlink" title="reverse-integer"></a>reverse-integer</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/19 1:05 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 7_reverse-integer.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/reverse-integer/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        len_x = len(str(x))</span><br><span class="line">        reverse_x = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len_x):</span><br><span class="line">            middle_x = (x % pow(<span class="number">10</span>, i + <span class="number">1</span>)) // pow(<span class="number">10</span>, i)</span><br><span class="line">            reverse_x = reverse_x + str(middle_x)</span><br><span class="line">        <span class="keyword">return</span> reverse_x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="number">123456789</span></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reverse(s))</span><br></pre></td></tr></tbody></table></figure><h2 id="palindrome-number"><a href="#palindrome-number" class="headerlink" title="palindrome_number"></a>palindrome_number</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/20 11:38 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 9_palindrome_number.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/palindrome-number/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        return_num = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 只对比一半</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; return_num:</span><br><span class="line">            return_num = return_num * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x = x // <span class="number">10</span></span><br><span class="line">        <span class="comment"># x是偶数则相等 奇数要去掉最后一位</span></span><br><span class="line">        <span class="keyword">return</span> x == return_num <span class="keyword">or</span> x == return_num // <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.isPalindrome(<span class="number">1221</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="container-with-most-water"><a href="#container-with-most-water" class="headerlink" title="container-with-most-water"></a>container-with-most-water</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/23 11:33 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 11_container-with-most-water.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/container-with-most-water/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(height) - <span class="number">1</span></span><br><span class="line">        max_size = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt; height[j]:</span><br><span class="line">                tmp_size = (j - i) * height[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp_size = (j - i) * height[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            max_size = tmp_size <span class="keyword">if</span> tmp_size &gt; max_size <span class="keyword">else</span> max_size</span><br><span class="line">        <span class="keyword">return</span> max_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line"><span class="keyword">assert</span> so.maxArea([<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="integer-to-roman"><a href="#integer-to-roman" class="headerlink" title="integer-to-roman"></a>integer-to-roman</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/25 7:29 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 12_integer-to-roman.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/integer-to-roman/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        output = <span class="string">""</span></span><br><span class="line">        roman_dict = {</span><br><span class="line">            <span class="number">1000</span>: <span class="string">"M"</span>,</span><br><span class="line">            <span class="number">900</span>: <span class="string">"CM"</span>,</span><br><span class="line">            <span class="number">500</span>: <span class="string">"D"</span>,</span><br><span class="line">            <span class="number">400</span>: <span class="string">"CD"</span>,</span><br><span class="line">            <span class="number">100</span>: <span class="string">"C"</span>,</span><br><span class="line">            <span class="number">90</span>: <span class="string">"XC"</span>,</span><br><span class="line">            <span class="number">50</span>: <span class="string">"L"</span>,</span><br><span class="line">            <span class="number">40</span>: <span class="string">"XL"</span>,</span><br><span class="line">            <span class="number">10</span>: <span class="string">"X"</span>,</span><br><span class="line">            <span class="number">9</span>: <span class="string">"IX"</span>,</span><br><span class="line">            <span class="number">5</span>: <span class="string">"V"</span>,</span><br><span class="line">            <span class="number">4</span>: <span class="string">"IV"</span>,</span><br><span class="line">            <span class="number">1</span>: <span class="string">"I"</span>,</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> key, value <span class="keyword">in</span> roman_dict.items():</span><br><span class="line">                <span class="keyword">if</span> num &gt;= key:</span><br><span class="line">                    output += value</span><br><span class="line">                    num -= key</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.intToRoman(<span class="number">999</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="roman-to-integer"><a href="#roman-to-integer" class="headerlink" title="roman-to-integer"></a>roman-to-integer</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/25 7:43 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 13_roman-to-integer.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/roman-to-integer/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        output = <span class="number">0</span></span><br><span class="line">        roman_dict = {<span class="string">"I"</span>: <span class="number">1</span>, <span class="string">"V"</span>: <span class="number">5</span>, <span class="string">"X"</span>: <span class="number">10</span>, <span class="string">"L"</span>: <span class="number">50</span>, <span class="string">"C"</span>: <span class="number">100</span>, <span class="string">"D"</span>: <span class="number">500</span>, <span class="string">"M"</span>: <span class="number">1000</span>}</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(s) - <span class="number">1</span> <span class="keyword">and</span> roman_dict[s[i]] &lt; roman_dict[s[i + <span class="number">1</span>]]:</span><br><span class="line">                output -= roman_dict[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                output += roman_dict[s[i]]</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.romanToInt(<span class="string">"MCMXCIV"</span>))  <span class="comment"># 1994</span></span><br></pre></td></tr></tbody></table></figure><h2 id="longest-common-prefix"><a href="#longest-common-prefix" class="headerlink" title="longest-common-prefix"></a>longest-common-prefix</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/25 9:12 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 14_longest-common-prefix.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/longest-common-prefix/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, li)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> li:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        <span class="comment"># 按照ASCII码进行排序</span></span><br><span class="line">        min_str = min(li)</span><br><span class="line">        max_str = max(li)</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(min_str):</span><br><span class="line">            <span class="keyword">if</span> value != max_str[index]:</span><br><span class="line">                <span class="keyword">return</span> max_str[:index]</span><br><span class="line">        <span class="keyword">return</span> min_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.longestCommonPrefix([<span class="string">"flower"</span>, <span class="string">"flow"</span>, <span class="string">"flight"</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="3sum"><a href="#3sum" class="headerlink" title="3sum"></a>3sum</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/27 12:18 上午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 15_3sum.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/3sum/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        output = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> output</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[left] + nums[right] == <span class="number">0</span>:</span><br><span class="line">                    output.append((nums[i], nums[left], nums[right]))</span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.threeSum([<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="3sum-closest"><a href="#3sum-closest" class="headerlink" title="3sum-closest"></a>3sum-closest</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/28 4:32 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 16_3sum-closest.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/3sum-closest/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> len(nums) &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        result = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n - <span class="number">2</span>):</span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                min_value = nums[i] + nums[left] + nums[left + <span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 最小的都比target大，后面的元素则无需进行比较</span></span><br><span class="line">                <span class="keyword">if</span> target &lt; min_value:</span><br><span class="line">                    <span class="keyword">if</span> abs(min_value - target) &lt; abs(result - target):</span><br><span class="line">                        result = min_value</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 最大的都比target小，前面的元素则无需进行比较</span></span><br><span class="line">                max_value = nums[i] + nums[right] + nums[right - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> target &gt; max_value:</span><br><span class="line">                    <span class="keyword">if</span> abs(max_value - target) &lt; abs(result - target):</span><br><span class="line">                        result = max_value</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                sum_value = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> abs(sum_value - target) &lt; abs(result - target):</span><br><span class="line">                    result = sum_value</span><br><span class="line">                <span class="keyword">if</span> sum_value == target:</span><br><span class="line">                    <span class="keyword">return</span> sum_value</span><br><span class="line">                <span class="keyword">if</span> sum_value &gt; target:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">not</span> left == right) <span class="keyword">and</span> nums[right] == nums[right + <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">not</span> left == right) <span class="keyword">and</span> nums[left] == nums[left - <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 去重</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n - <span class="number">2</span> <span class="keyword">and</span> nums[i] == nums[i + <span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.threeSumClosest([<span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-4</span>], <span class="number">1</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="letter-combinations-of-a-phone-number"><a href="#letter-combinations-of-a-phone-number" class="headerlink" title="letter-combinations-of-a-phone-number"></a>letter-combinations-of-a-phone-number</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/29 5:55 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 17_letter-combinations-of-a-phone-number.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span>:</span></span><br><span class="line">        digit_number_dict = {</span><br><span class="line">            <span class="string">"2"</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>],</span><br><span class="line">            <span class="string">"3"</span>: [<span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>],</span><br><span class="line">            <span class="string">"4"</span>: [<span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>],</span><br><span class="line">            <span class="string">"5"</span>: [<span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>],</span><br><span class="line">            <span class="string">"6"</span>: [<span class="string">"m"</span>, <span class="string">"n"</span>, <span class="string">"o"</span>],</span><br><span class="line">            <span class="string">"7"</span>: [<span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>],</span><br><span class="line">            <span class="string">"8"</span>: [<span class="string">"t"</span>, <span class="string">"u"</span>, <span class="string">"v"</span>],</span><br><span class="line">            <span class="string">"9"</span>: [<span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>],</span><br><span class="line">        }</span><br><span class="line">        output = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(combination, next_digits)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> next_digits:</span><br><span class="line">                output.append(combination)  <span class="comment"># "ap"、"aq"、"ar"......</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> letter <span class="keyword">in</span> digit_number_dict[next_digits[<span class="number">0</span>]]:</span><br><span class="line">                    backtrack(combination + letter, next_digits[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> digits:</span><br><span class="line">            backtrack(<span class="string">""</span>, digits)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.letterCombinations(<span class="string">"27"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a>4Sum</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/30 1:15 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 18_4Sum.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/4sum/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">elif</span> sum(nums[:<span class="number">4</span>]) &gt; target:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        result_li = []</span><br><span class="line">        <span class="comment"># 固定i与left，对middle与right进行查找与去重</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> range(i + <span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">                middle = left + <span class="number">1</span></span><br><span class="line">                right = n - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> middle != right:</span><br><span class="line">                    sum_value = nums[i] + nums[left] + nums[middle] + nums[right]</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        sum_value == target</span><br><span class="line">                        <span class="keyword">and</span> [nums[i], nums[left], nums[middle], nums[right]]</span><br><span class="line">                        <span class="keyword">not</span> <span class="keyword">in</span> result_li</span><br><span class="line">                    ):</span><br><span class="line">                        result_li.append(</span><br><span class="line">                            [nums[i], nums[left], nums[middle], nums[right]]</span><br><span class="line">                        )</span><br><span class="line">                    <span class="keyword">if</span> sum_value &lt;= target:</span><br><span class="line">                        middle += <span class="number">1</span></span><br><span class="line">                        <span class="comment"># 去重</span></span><br><span class="line">                        <span class="keyword">while</span> middle != right <span class="keyword">and</span> nums[middle] == nums[middle - <span class="number">1</span>]:</span><br><span class="line">                            middle += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                        <span class="comment"># 去重</span></span><br><span class="line">                        <span class="keyword">while</span> middle != right <span class="keyword">and</span> nums[right] == nums[right + <span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result_li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.fourSum([<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">2</span>], <span class="number">0</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="remove-nth-node-from-end-of-list"><a href="#remove-nth-node-from-end-of-list" class="headerlink" title="remove-nth-node-from-end-of-list"></a>remove-nth-node-from-end-of-list</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2019/12/31 12:11 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 19_remove-nth-node-from-end-of-list.py</span></span><br><span class="line"><span class="comment"># @Desc: 通过同时向前移动两个间隔为n的指针，直到第一个指针到达最后一个节点。此时第二个指针将指向从最后一个节点数起的第n个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 哑节点用来简化某些极端情况，例如列表中只有含有一个节点，或需要删除列表的头部</span></span><br><span class="line">        head_pre = ListNode(<span class="number">-1</span>)</span><br><span class="line">        head_pre.next, start, end = head, head_pre, head_pre</span><br><span class="line">        <span class="comment"># 让end节点向前走n步</span></span><br><span class="line">        <span class="keyword">while</span> end <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            end = end.next</span><br><span class="line">        <span class="comment"># 如果end已经走到末尾，则证明比n长，直接退出</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> end:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">while</span> end.next:</span><br><span class="line">            start, end = start.next, end.next</span><br><span class="line">        <span class="comment"># 删除倒数第n个节点</span></span><br><span class="line">        start.next = start.next.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></tbody></table></figure><h2 id="length-of-longest-substring"><a href="#length-of-longest-substring" class="headerlink" title="length_of_longest_substring"></a>length_of_longest_substring</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2019/10/8 8:17 下午</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File:  3_length_of_longest_substring.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthoflongestsubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        tem_length = <span class="number">0</span></span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        s_set = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> s_set:</span><br><span class="line">                s_set.remove(s[i])</span><br><span class="line">                tem_length = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s_set.add(s[i])</span><br><span class="line">                tem_length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> tem_length &gt; max_length:</span><br><span class="line">                max_length = tem_length</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    so = Solution()</span><br><span class="line">    test_list = <span class="string">"pwdflkkkpwdsadf"</span></span><br><span class="line">    start = timeit.default_timer()</span><br><span class="line">    print(so.lengthoflongestsubstring(test_list))</span><br><span class="line">    end = timeit.default_timer()</span><br><span class="line">    print(str((end - start) * <span class="number">1000</span>), <span class="string">"s"</span>)  <span class="comment"># s0.034690000006776245 s</span></span><br></pre></td></tr></tbody></table></figure><h2 id="merge-sorted-array"><a href="#merge-sorted-array" class="headerlink" title="merge-sorted-array"></a>merge-sorted-array</h2><p>解题思路：</p><p>初阶版 — 合并后排序</p><p>时间复杂度 : <code>O((n + m)log(n + m))</code>、空间复杂度<code>O(1)</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; List:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums1[:] = sorted(nums1[:m], nums2)</span><br><span class="line">        <span class="keyword">return</span> nums1</span><br></pre></td></tr></tbody></table></figure><p>进阶版：双指针/从前往后</p><p>最直接的算法实现是将指针p1 置为 nums1的开头， p2为 nums2的开头，在每一步将最小值放入输出数组中。</p><p>由于 nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方，也就需要 O(m)O(m) 的空间复杂度。</p><p>时间复杂度 : <code>O(n + m)</code>、空间复杂度<code>O(m)</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># Make a copy of nums1.</span></span><br><span class="line">        nums1_copy = nums1[:m] </span><br><span class="line">        nums1[:] = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Two get pointers for nums1_copy and nums2.</span></span><br><span class="line">        p1 = <span class="number">0</span> </span><br><span class="line">        p2 = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Compare elements from nums1_copy and nums2</span></span><br><span class="line">        <span class="comment"># and add the smallest one into nums1.</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; m <span class="keyword">and</span> p2 &lt; n: </span><br><span class="line">            <span class="keyword">if</span> nums1_copy[p1] &lt; nums2[p2]: </span><br><span class="line">                nums1.append(nums1_copy[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1.append(nums2[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if there are still elements to add</span></span><br><span class="line">        <span class="keyword">if</span> p1 &lt; m: </span><br><span class="line">            nums1[p1 + p2:] = nums1_copy[p1:]</span><br><span class="line">        <span class="keyword">if</span> p2 &lt; n:</span><br><span class="line">            nums1[p1 + p2:] = nums2[p2:]</span><br></pre></td></tr></tbody></table></figure><p>高阶版：三指针/从后往前</p><p>p1、p2分别指向nums1、nums2当前准备移动的元素。p指向当前待放置的位置。</p><p>哪个指向的数字大，则将其放置于p所指的位置上。</p><p>时间复杂度 :  <code>O(n + m)</code>、空间复杂度<code>O(1)</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/4/1 11:24 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: 88_merge-sorted-array.py</span></span><br><span class="line"><span class="comment"># @Desc:https://leetcode-cn.com/problems/merge-sorted-array/</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; List:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums1:</span><br><span class="line">            <span class="keyword">return</span> nums2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums2:</span><br><span class="line">            <span class="keyword">return</span> nums1</span><br><span class="line">        p1 = m - <span class="number">1</span></span><br><span class="line">        p2 = n - <span class="number">1</span></span><br><span class="line">        p = m + n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 &gt;= <span class="number">0</span> <span class="keyword">and</span> p2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                nums1[p] = nums2[p2]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p] = nums1[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果nums2中有没有进行添加的元素，则进行添加</span></span><br><span class="line">        nums1[:p2 + <span class="number">1</span>] = nums2[:p2 + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> nums1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.merge(nums1=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], m=<span class="number">3</span>, nums2=[<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>], n=<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="reOrderArray"><a href="#reOrderArray" class="headerlink" title="reOrderArray"></a>reOrderArray</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/30 11:35 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: reOrderArray.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;tqId=11166&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        len_array = len(array)</span><br><span class="line">        <span class="keyword">if</span> len_array &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len_array - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 如果是偶数，就添加到末尾</span></span><br><span class="line">            <span class="keyword">if</span> array[left] &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                array.append(array.pop(left))</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reOrderArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-31"><a href="#interview-31" class="headerlink" title="interview_31"></a>interview_31</h2><p>写不动写不动，太难了。直接暴力吧。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/7/2 11:50 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_31.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        s = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            s += str(n)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s.count(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">so = Solution()</span><br><span class="line">print(so.countDigitOne(<span class="number">12</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-13"><a href="#interview-13" class="headerlink" title="interview_13"></a>interview_13</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/5/30 11:35</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_13.py</span></span><br><span class="line"><span class="comment"># @Desc: https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;tqId=11166&amp;tPage=1&amp;rp=1&amp;ru=/ta/</span></span><br><span class="line"><span class="comment"># coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        len_array = len(array)</span><br><span class="line">        <span class="keyword">if</span> len_array &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len_array - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 如果是偶数，就添加到末尾</span></span><br><span class="line">            <span class="keyword">if</span> array[left] &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                array.append(array.pop(left))</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.reOrderArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-40"><a href="#interview-40" class="headerlink" title="interview_40"></a>interview_40</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/16 20:41</span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_40.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        len_array = len(array)</span><br><span class="line">        <span class="keyword">if</span> len_array &lt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        array.sort()</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># i指向重复的首字符，j负责寻找</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len_array):</span><br><span class="line">            <span class="keyword">if</span> array[i] != array[j]:</span><br><span class="line">                <span class="comment"># 如果间隔小于1，证明重复次数小于1</span></span><br><span class="line">                <span class="keyword">if</span> j - i == <span class="number">1</span>:</span><br><span class="line">                    result.append(array[i])</span><br><span class="line">                <span class="comment"># 如果间隔大于1，证明j又找到一个新的不相等的数</span></span><br><span class="line">                i = j</span><br><span class="line">        <span class="comment"># 最后需要判断下最后一个字符</span></span><br><span class="line">        <span class="keyword">if</span> array[<span class="number">-1</span>] != array[<span class="number">-2</span>]:</span><br><span class="line">            result.append(array[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">","</span>.join(str(_) <span class="keyword">for</span> _ <span class="keyword">in</span> result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.FindNumsAppearOnce([<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>]))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-46"><a href="#interview-46" class="headerlink" title="interview_46"></a>interview_46</h2><p>暴力法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/24 15:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_46.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastRemaining</span><span class="params">(self, n: int, m: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        i, array = <span class="number">0</span>, list(range(n))</span><br><span class="line">        <span class="keyword">while</span> len(array) &gt; <span class="number">1</span>:</span><br><span class="line">            i = (i + m - <span class="number">1</span>) % len(array)</span><br><span class="line">            array.pop(i)</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.lastRemaining(<span class="number">5</span>, <span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-47"><a href="#interview-47" class="headerlink" title="interview_47"></a>interview_47</h2><p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/mian-shi-ti-64-qiu-1-2-nluo-ji-fu-duan-lu-qing-xi-/" target="_blank" rel="noopener">短路思想</a></p><p>以逻辑运算符 &amp; 为例，对于 A &amp; B 这个表达式，如果 A 表达式返回 False ，那么 A &amp; B 已经确定为 False ，此时不会去执行表达式 B。同理，对于逻辑运算符 ||， 对于 A || B 这个表达式，如果 A 表达式返回 True ，那么 A || B 已经确定为 True ，此时不会去执行表达式 B。</p><p>利用这一特性，我们可以将判断是否为递归的出口看作 A &amp; B 表达式中的 A 部分，递归的主体函数看作 B 部分。如果不是递归出口，则返回True，并继续执行表达式 B 的部分，否则递归结束。</p><p><img data-src="/images/algorithm/interview_47_1.png" alt="shortcut"></p><p>递归思路</p><p><img data-src="/images/algorithm/interview_47_2.png" alt="递归思路"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/24 15:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_47.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/qiu-12n-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNums</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 如果n大于1，则and后面的语句继续执行，即，继续递归</span></span><br><span class="line">        n &gt; <span class="number">1</span> <span class="keyword">and</span> self.sumNums(n - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果已经不大于1，则程序继续执行下面的语句，进行累加</span></span><br><span class="line">        self.res += n</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 最后返回当前累加的结果</span></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">so = Solution()</span><br><span class="line">print(so.sumNums(<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="interview-54"><a href="#interview-54" class="headerlink" title="interview_54"></a>interview_54</h2><p>Insert函数用来接收字符，构成字符流。</p><p>FirstAppearingOnce函数用来判断是否为第一个只出现一次的字符。用了字典来记录字符以及出现的次数。</p><blockquote><p>由于python的dict不是按照时间顺序来存储的，所以需要借助一个数组来记录。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/9/28 16:16 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: interview_54.py</span></span><br><span class="line"><span class="comment"># @Desc: https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.char_appearing_dict = {}</span><br><span class="line">        self.char_insert = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.char_appearing_dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#"</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.char_insert:</span><br><span class="line">            <span class="keyword">if</span> self.char_appearing_dict[c] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> c</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, char)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.char_insert.append(char)</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> self.char_appearing_dict:</span><br><span class="line">            self.char_appearing_dict[char] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.char_appearing_dict[char] = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;题目类型&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;题目&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#Hash&quot;&gt;Hash&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#twoSum&quot;&gt;twoSum&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#valid-sudoku&quot;&gt;valid-sudoku&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#first-missing-positive&quot;&gt;first-missing-positive&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#LinkNode&quot;&gt;LinkNode&lt;/a&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#add-two-numbers&quot;&gt;add-two-numbers&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#merge-two-sorted-lists&quot;&gt;merge-two-sorted-lists&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#swap-nodes-in-pairs&quot;&gt;swap-nodes-in-pairs&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#reverse-nodes-in-k-group&quot;&gt;reverse-nodes-in-k-group&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#rotate-list&quot;&gt;rotate-list&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#remove-duplicates-from-sorted-list-ii&quot;&gt;remove-duplicates-from-sorted-list-ii&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#remove-duplicates-from-sorted-list&quot;&gt;remove-duplicates-from-sorted-list&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#partition-list&quot;&gt;partition-list&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;a href=&quot;https://unknown.yuzhouwan.com/posts/55663/#reverse-linked-list-ii&quot;&gt;reverse-linked-list-ii&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://unknown.yuzhouwan.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://unknown.yuzhouwan.com/tags/Algorithm/"/>
    
      <category term="LeetCode" scheme="https://unknown.yuzhouwan.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Regex</title>
    <link href="https://unknown.yuzhouwan.com/posts/25256/"/>
    <id>https://unknown.yuzhouwan.com/posts/25256/</id>
    <published>2020-02-04T23:55:00.000Z</published>
    <updated>2020-03-01T13:14:13.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><div class="table-container"><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">匹配除换行符以外的任意字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配字母、数字、下划线、汉字</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配任意的空白符</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配数字</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配单词的开始或结束</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符串的开始</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符串的结束</td></tr></tbody></table></div><p>例：匹配有abc开头的字符串</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\babc或^abc</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h2 id="重复限定符"><a href="#重复限定符" class="headerlink" title="重复限定符"></a>重复限定符</h2><div class="table-container"><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">重复零次或更多次</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">重复一次或者更多次</td></tr><tr><td style="text-align:center">？</td><td style="text-align:center">重复零次或一次</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">重复n次</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">重复n次或更多次</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">重复n次到m次</td></tr></tbody></table></div><p>限定符作用于与它<strong>左边</strong>最近的一个字符。</p><p>例：匹配以a开头，0个或者多个以b结尾的字符串</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ab*$</span><br></pre></td></tr></tbody></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>以”()“作为分组。</p><p>例：匹配以ab开头，0个或者多个以b结尾的字符串</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(ab)*$</span><br></pre></td></tr></tbody></table></figure><p>注：如需匹配小括号，只要加转义字符串即可。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(\(ab\))*$</span><br></pre></td></tr></tbody></table></figure><h2 id="条件或"><a href="#条件或" class="headerlink" title="条件或"></a>条件或</h2><p>利用“｜”来表达条件或。</p><p>例：匹配130/131/181/177等开头的11位手机号。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(<span class="number">130</span>|<span class="number">131</span>|<span class="number">181</span>|<span class="number">177</span>)\d{<span class="number">8</span>}$</span><br></pre></td></tr></tbody></table></figure><h2 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h2><p>利用“[]”来表达区间条件。</p><blockquote><p>[0-9]：限定0到9</p><p>[A-Z]：限定A到Z</p><p>[165]：限定规定数字</p></blockquote><p>例：匹配130/131/132/156/158/159/145/177开头的11位数字</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((<span class="number">13</span>[<span class="number">0</span><span class="number">-2</span>])|(<span class="number">15</span>[<span class="number">689</span>])|<span class="number">145</span>|<span class="number">177</span>)\d{<span class="number">8</span>}$</span><br></pre></td></tr></tbody></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://juejin.im/post/5b96a8e2e51d450e6a2de115" target="_blank" rel="noopener">掘金博文</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h1&gt;&lt;h2 id=&quot;元字符&quot;&gt;&lt;a href=&quot;#元字符&quot; class=&quot;headerlink&quot; title=&quot;元字符&quot;&gt;&lt;/a&gt;元字符&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;元字符&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;.&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配除换行符以外的任意字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;\w&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配字母、数字、下划线、汉字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;\s&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配任意的空白符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;\d&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;\b&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配单词的开始或结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;^&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配字符串的开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;匹配字符串的结束&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;例：匹配有abc开头的字符串&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;\babc或^abc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://unknown.yuzhouwan.com/categories/Tools/"/>
    
    
      <category term="Regex" scheme="https://unknown.yuzhouwan.com/tags/Regex/"/>
    
  </entry>
  
  <entry>
    <title>Image-Algorithm-Summarize</title>
    <link href="https://unknown.yuzhouwan.com/posts/58748/"/>
    <id>https://unknown.yuzhouwan.com/posts/58748/</id>
    <published>2020-02-01T12:06:00.000Z</published>
    <updated>2020-11-03T07:58:07.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="YUV、RGB、HSV"><a href="#YUV、RGB、HSV" class="headerlink" title="YUV、RGB、HSV"></a>YUV、RGB、HSV</h1><p>YUV：亮度信息 即灰度值。UV：色彩信息 定义了颜色的两个方面-色调与饱和度，分别用Cr和CB来表示。其中，Cr反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。而CB反映的是RGB输入信号蓝色部分与RGB信号亮度值之同的差异。通过运算，YUV三分量可以还原出R（红），G（绿），B（蓝）。</p><p>HSV: 色调（H），饱和度（S），明度（V）</p><p>相互转换</p><h2 id="ARGB-gt-RGB"><a href="#ARGB-gt-RGB" class="headerlink" title="ARGB -> RGB"></a>ARGB -&gt; RGB</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//unsigned char *data 存的是ARGB的裸数据；</span><br><span class="line"> </span><br><span class="line">cv::Mat argbImg;</span><br><span class="line">cv::Mat rgbImg(cy, cx,CV_8UC3);</span><br><span class="line">yuvImg.create(cy, cx, CV_8UC4);</span><br><span class="line">memcpy(argbImg.data, data, len);</span><br><span class="line">cv::cvtColor(argbImg, rgbImg, CV_RGBA2RGB);</span><br><span class="line">flip(rgbImg, rgbImg, <span class="number">0</span>);    //垂直翻转</span><br></pre></td></tr></tbody></table></figure><h2 id="YUV-gt-RGB"><a href="#YUV-gt-RGB" class="headerlink" title="YUV -> RGB"></a>YUV -&gt; RGB</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//unsigned char *data 存的是YUYV的裸数据；</span><br><span class="line"> </span><br><span class="line">cv::Mat yuvImg;</span><br><span class="line">cv::Mat rgbImg(cy, cx,CV_8UC3);</span><br><span class="line">yuvImg.create(cy , cx, CV_8UC2);</span><br><span class="line">memcpy(yuvImg.data, data, len);</span><br><span class="line">cv::cvtColor(yuvImg, rgbImg, CV_YUV2BGR_YUYV);</span><br></pre></td></tr></tbody></table></figure><h2 id="I420-gt-RGB"><a href="#I420-gt-RGB" class="headerlink" title="I420 -> RGB"></a>I420 -&gt; RGB</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//unsigned char *data 存的是I420的裸数据；</span><br><span class="line"> </span><br><span class="line">cv::Mat yuvImg;</span><br><span class="line">cv::Mat rgbImg(cy, cx,CV_8UC3);</span><br><span class="line">yuvImg.create(cy * <span class="number">3</span>/<span class="number">2</span>, cx, CV_8UC1);</span><br><span class="line">memcpy(yuvImg.data, data, len);</span><br><span class="line">cv::cvtColor(yuvImg, rgbImg, CV_YUV2BGR_I420);</span><br></pre></td></tr></tbody></table></figure><p>OpenCV提供的转换函数实现YUV到RGB的转换：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool YV12ToBGR24_OpenCV(unsigned char* pYUV,unsigned char* pBGR24,int width,int height) </span><br><span class="line">{ </span><br><span class="line"><span class="keyword">if</span> (width &lt; <span class="number">1</span> || height &lt; <span class="number">1</span> || pYUV == NULL || pBGR24 == NULL) </span><br><span class="line"><span class="keyword">return</span> false; </span><br><span class="line">Mat dst(height,width,CV_8UC3,pBGR24); </span><br><span class="line">Mat src(height + height/<span class="number">2</span>,width,CV_8UC1,pYUV); </span><br><span class="line">cvtColor(src,dst,CV_YUV2BGR_YV12); </span><br><span class="line"><span class="keyword">return</span> true; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="RGB-gt-HSV"><a href="#RGB-gt-HSV" class="headerlink" title="RGB -> HSV"></a>RGB -&gt; HSV</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf<span class="number">-8</span> -*-</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">功能：读取一张图片，显示出来，并转化为HSV色彩空间</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">image = cv2.imread('images/my_wife2.jpg') # 根据路径读取一张图片</span><br><span class="line">cv2.imshow(<span class="string">"BGR"</span>, <span class="built_in">image</span>) # 显示图片</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 转化图片到HSV色彩空间</span><br><span class="line">dst = cv2.cvtColor(<span class="built_in">image</span>, cv2.COLOR_BGR2HSV)</span><br><span class="line">cv2.imshow(<span class="string">"HSV"</span>, dst) # 显示图片</span><br><span class="line">cv2.waitKey(<span class="number">0</span>) # 等待键盘触发事件，释放窗口</span><br></pre></td></tr></tbody></table></figure><h1 id="White-Balance"><a href="#White-Balance" class="headerlink" title="White Balance"></a>White Balance</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>相机的白平衡控制，是为了让实际环境中白色的物体在你拍摄的画面中也呈现出“真正”的白色。不同性质的光源会在画面中产生不同的色彩倾向，比如说，蜡烛的光线会使画面偏橘黄色，而黄昏过后的光线则会为景物披上一层蓝色的冷调。而我们的视觉系统会自动对不同的光线作出补偿，所以无论在暖调还是冷调的光线环境下，我们看一张白纸永远还是白色的。但相机则不然，它只会直接记录呈现在它面前的色彩，这就会导致画面色彩偏暖或偏冷。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>开暖光灯：YUV -&gt; RGB -&gt; SV ，全图SV值S需在0～0.1之间，V需在90～255之间。</p><a id="more"></a><h1 id="IR-Cut"><a href="#IR-Cut" class="headerlink" title="IR-Cut"></a>IR-Cut</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>自然界存在着各种波长的光线，通过折射人眼能看到不同颜色的光线，这就是光线的波长不同所导致的。其实还有许多光线是人眼看不到的，人眼识别光线的波长范围在320nm-760nm之间， 超过760nm的光线人眼就无法见到，比如红外光等。<br>随着科学的进步，人类发明了摄像机，理论上讲摄像机可以看到绝大部分波长的光线，但在摄像机的使用过程中就出现了一个问题，由于各种光线的参杂，摄像机看到的物体反映在监视器上与人眼直接看到的就变样了。如人眼看到绿色，通过摄像机则变成蓝色，产生彩色失真。过去，为解决色彩失真问题，一般在CCD前贴有一低通滤片，该滤片阻碍了红外光的进出，故白天彩色不失真，但夜间却没有了夜视功能。<br>IR CUT是一种机械装置，内有两个窗口，一为低通滤片一为透明玻璃，可依需要左右移动，从而白天彩色不失真，且夜间仍有夜视功能。简单的说，通过IR CUT，白天只允许760nm或780nm以下波长的光线进入，避免了白天的彩色失真。晚上只允许760nm或780nm以上波长的红外光线进入，避免760nm或780nm以下波长的可见光对红外光的干扰，于是在白天与夜晚都能取得最佳视觉效果。随着技术的进步，IR CUT结合低通滤片与<a href="https://www.baidu.com/s?wd=高通&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">高通</a>滤片在改进<a href="https://www.baidu.com/s?wd=夜视摄像机&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">夜视摄像机</a>的性能上发挥越来越重要的作用．低通滤片：以镀膜方式使光线中波长在760nm或780nm以下的光线通过，超过760nm或780nm波长的光线阻止通过。<a href="https://www.baidu.com/s?wd=高通&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">高通</a>滤片：以镀膜方式使光线中波长在760nm或780nm以下的光线阻止通过，只准超过760nm或780nm以上波长的光线通过。<br>根据上述分析，应用低通滤片技术，摄像机能够模拟人的眼睛，只接收同样范围波长的光线，这样就解决了摄像机的色彩失真问题。而通过<a href="https://www.baidu.com/s?wd=高通&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">高通</a>滤片技术的应用，解决了在夜间杂光干扰红外光问题。LED红外技术的出现，大大拓宽了监控领域的时空范畴，<a href="https://www.baidu.com/s?wd=红外摄像机&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">红外摄像机</a>得到了广泛的应用。但同时，我们也发现市场上流行的传统LED<a href="https://www.baidu.com/s?wd=红外摄像机&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">红外摄像机</a>存在着许多致命的缺陷：如散热问题、寿命问题、手电筒效应问题，夜晚可见光干扰的问题等。LED Array 技术解决了寿命问题，新一代的LED Array技术基本解决了“手电筒”效应，而IR CUT技术完美地解决了杂光干扰。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>关、开滤光片，打开红外灯，计算平均亮度是否符合要求（155～255之间）。</p><h1 id="Bad-Pixel"><a href="#Bad-Pixel" class="headerlink" title="Bad Pixel"></a>Bad Pixel</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>图像坏点(Bad pixel) : 图像传感器上光线采集点(像素点)所形成的阵列存在工艺上的缺陷，或光信号进行转化为电信号的过程中出现错误，从而会造成图像上像素信息错误，导致图像中的像素值不准确，这些有缺陷的像素即为图像坏点。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>根据灰度值确定坏点</p><h1 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>暗角一词属于摄影术语。对着亮度均匀景物，画面四角有变暗的现象，叫做“失光”，俗称“暗角”。</p><p>产生暗角的原因主要有：</p><p>1.边角的成像光线与<a href="https://baike.baidu.com/item/镜头光轴/10196349" target="_blank" rel="noopener">镜头光轴</a>有较大的夹角，是造成边角失光的主要原因。沿着<a href="https://baike.baidu.com/item/视场/8231871" target="_blank" rel="noopener">视场</a>边缘的光线的前进方向看<a href="https://baike.baidu.com/item/光圈/94964" target="_blank" rel="noopener">光圈</a>，由于光线与光圈所在的平面有夹角，看到的光圈是椭圆的，所以通光面积减小。镜头光心到胶片的边缘距离较大，同样的光圈直径到达底片的光线夹角较小，亮度必然减小。同理，同样的光线偏角，对于边角光线位移较大，等价于照在较大的面积上。而面积是与位移的平方成正比的，所以综合上述原因，边缘亮度与光线和光轴夹角的COS值的4次方成正比。换句话说，<a href="https://baike.baidu.com/item/广角镜头/278835" target="_blank" rel="noopener">广角镜头</a>边缘亮度随着视角变大急剧下降。</p><p>2.<a href="https://baike.baidu.com/item/长焦镜头/879928" target="_blank" rel="noopener">长焦镜头</a>尤其是<a href="https://baike.baidu.com/item/变焦/9696019" target="_blank" rel="noopener">变焦</a>长焦镜头镜片很多，偏离<a href="https://baike.baidu.com/item/光圈/94964" target="_blank" rel="noopener">光圈</a>比较远的镜片为了能让边角光线通过，这些镜片必须很大。为了降低成本，缩小了这些镜片直径，造成边角成像光线不能完全通过，降低了边角的亮度。</p><p>3.边角的<a href="https://baike.baidu.com/item/像差/448364" target="_blank" rel="noopener">像差</a>较大。为了提高像质，某些镜片的边缘或专门设置的光阑有意挡住部分影响成像质量的边缘光线，造成边角失光。</p><p><a href="https://baike.baidu.com/item/鱼眼镜头/343506" target="_blank" rel="noopener">鱼眼镜头</a>虽然视角极大，但是由于边缘<a href="https://baike.baidu.com/item/放大倍率/10294653" target="_blank" rel="noopener">放大倍率</a>很小，所以几乎没有边角失光。</p><p>高档<a href="https://baike.baidu.com/item/变焦镜头/2971419" target="_blank" rel="noopener">变焦镜头</a>已经花了大的成本，可以加大某些镜片、完美地校正像差，高档长焦镜头包括变焦镜头边缘失光很小。</p><p>还有：<a href="https://baike.baidu.com/item/广角镜头/278835" target="_blank" rel="noopener">广角镜头</a>如果使用了过多的<a href="https://baike.baidu.com/item/滤色镜/205532" target="_blank" rel="noopener">滤色镜</a>，等价于增长了镜筒，可能造成边角暗角甚至黑角！</p><p>暗角在任何一只镜头上都存在，在MTF<a href="https://baike.baidu.com/item/透光率/1192539" target="_blank" rel="noopener">透光率</a>图上可以知道，从中心到边缘会损失不少，尤其在<a href="https://baike.baidu.com/item/大光圈/8567887" target="_blank" rel="noopener">大光圈</a>。在冲扩<a href="https://baike.baidu.com/item/负片/3897269" target="_blank" rel="noopener">负片</a>是问题不大，因为放大头也存在这个问题，会抵消掉一部分影响，当然，如果镜头太滥，失光极其明显，那就能在照片上看出来了。</p><p>对于<a href="https://baike.baidu.com/item/反转片/3897682" target="_blank" rel="noopener">反转片</a>，问题就严重一些，就需要仔细研究研究了，一般的现象是：广角比长焦明显一些，反正怎么样全看你的使用情况，缩小一下<a href="https://baike.baidu.com/item/光圈/94964" target="_blank" rel="noopener">光圈</a>就是了。 </p><p>— from baike.baidu.com</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><p>开冷光灯：分为亮度暗角和色彩暗角。</p><p>亮度暗角：取四个角（10 * 10像素），四个角亮度与中间块做比值，需在0.3～1之间。</p><p>色彩暗角：图像被分成20 * 20块，算每块的R/G、B/G，分别除以中心的R/G，四个角比值都应在0.8～1.2之间。</p><h1 id="清晰度测试"><a href="#清晰度测试" class="headerlink" title="清晰度测试"></a>清晰度测试</h1><p>清晰度：影像细部影纹及边界的清晰程度，摄像机一般使用分解力来衡量它分解被摄景物细节的能力，单位有TVLine、4K分辨率、8K分辨率</p><p>衡量分解力的三个标准：</p><ol><li><p>TVLine检测（锲形线测试），用于主观测试，ISO 12233 chart读出的线对数</p></li><li><p>MTF检测（频率线测试），调制传递函数，调制度随空间频率变化的函数，镜头的MTF曲线表明镜头的能力。</p><p>MTF计算线对间最亮和最暗线对的对比度</p><p>MTF = （最大亮度 - 最小亮度） / （最大亮度 + 最小亮度）</p><p>测不用频率下的MTF值，通过将这些值和空间频率进行一一对照。</p></li><li><p>SFR检测（spatial frequency response）用于测量随着空间频率的线条增加对单一影像所造成的影响。SFR是MTF的另一种测试方法。SFR最终是希望得到MTF曲线。</p><p>SFR不需拍不同空间频率下的线对。只需一个黑白刀口（斜边），即可换算约略相等于所有空间频率下的MTF。</p><p>斜边 -&gt; 超采样 -&gt; 得到黑白变换的直线（ESF） -&gt; 求导  -&gt; 直线变换率 -&gt; FFT变换  -&gt; 各个频率下的MTF值</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;YUV、RGB、HSV&quot;&gt;&lt;a href=&quot;#YUV、RGB、HSV&quot; class=&quot;headerlink&quot; title=&quot;YUV、RGB、HSV&quot;&gt;&lt;/a&gt;YUV、RGB、HSV&lt;/h1&gt;&lt;p&gt;YUV：亮度信息 即灰度值。UV：色彩信息 定义了颜色的两个方面-色调与饱和度，分别用Cr和CB来表示。其中，Cr反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。而CB反映的是RGB输入信号蓝色部分与RGB信号亮度值之同的差异。通过运算，YUV三分量可以还原出R（红），G（绿），B（蓝）。&lt;/p&gt;
&lt;p&gt;HSV: 色调（H），饱和度（S），明度（V）&lt;/p&gt;
&lt;p&gt;相互转换&lt;/p&gt;
&lt;h2 id=&quot;ARGB-gt-RGB&quot;&gt;&lt;a href=&quot;#ARGB-gt-RGB&quot; class=&quot;headerlink&quot; title=&quot;ARGB -&gt; RGB&quot;&gt;&lt;/a&gt;ARGB -&amp;gt; RGB&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//unsigned char *data 存的是ARGB的裸数据；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::Mat argbImg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::Mat rgbImg(cy, cx,CV_8UC3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yuvImg.create(cy, cx, CV_8UC4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;memcpy(argbImg.data, data, len);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::cvtColor(argbImg, rgbImg, CV_RGBA2RGB);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;flip(rgbImg, rgbImg, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);    //垂直翻转&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;YUV-gt-RGB&quot;&gt;&lt;a href=&quot;#YUV-gt-RGB&quot; class=&quot;headerlink&quot; title=&quot;YUV -&gt; RGB&quot;&gt;&lt;/a&gt;YUV -&amp;gt; RGB&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//unsigned char *data 存的是YUYV的裸数据；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::Mat yuvImg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::Mat rgbImg(cy, cx,CV_8UC3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yuvImg.create(cy , cx, CV_8UC2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;memcpy(yuvImg.data, data, len);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::cvtColor(yuvImg, rgbImg, CV_YUV2BGR_YUYV);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;I420-gt-RGB&quot;&gt;&lt;a href=&quot;#I420-gt-RGB&quot; class=&quot;headerlink&quot; title=&quot;I420 -&gt; RGB&quot;&gt;&lt;/a&gt;I420 -&amp;gt; RGB&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//unsigned char *data 存的是I420的裸数据；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::Mat yuvImg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::Mat rgbImg(cy, cx,CV_8UC3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yuvImg.create(cy * &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, cx, CV_8UC1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;memcpy(yuvImg.data, data, len);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv::cvtColor(yuvImg, rgbImg, CV_YUV2BGR_I420);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;OpenCV提供的转换函数实现YUV到RGB的转换：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bool YV12ToBGR24_OpenCV(unsigned char* pYUV,unsigned char* pBGR24,int width,int height) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;{ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (width &amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; || height &amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; || pYUV == NULL || pBGR24 == NULL) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; false; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Mat dst(height,width,CV_8UC3,pBGR24); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Mat src(height + height/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,width,CV_8UC1,pYUV); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cvtColor(src,dst,CV_YUV2BGR_YV12); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; true; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;RGB-gt-HSV&quot;&gt;&lt;a href=&quot;#RGB-gt-HSV&quot; class=&quot;headerlink&quot; title=&quot;RGB -&gt; HSV&quot;&gt;&lt;/a&gt;RGB -&amp;gt; HSV&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# -*- coding:utf&lt;span class=&quot;number&quot;&gt;-8&lt;/span&gt; -*-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; cv2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;功能：读取一张图片，显示出来，并转化为HSV色彩空间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image = cv2.imread(&#39;images/my_wife2.jpg&#39;) # 根据路径读取一张图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv2.imshow(&lt;span class=&quot;string&quot;&gt;&quot;BGR&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;image&lt;/span&gt;) # 显示图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 转化图片到HSV色彩空间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dst = cv2.cvtColor(&lt;span class=&quot;built_in&quot;&gt;image&lt;/span&gt;, cv2.COLOR_BGR2HSV)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv2.imshow(&lt;span class=&quot;string&quot;&gt;&quot;HSV&quot;&lt;/span&gt;, dst) # 显示图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cv2.waitKey(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) # 等待键盘触发事件，释放窗口&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;White-Balance&quot;&gt;&lt;a href=&quot;#White-Balance&quot; class=&quot;headerlink&quot; title=&quot;White Balance&quot;&gt;&lt;/a&gt;White Balance&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;相机的白平衡控制，是为了让实际环境中白色的物体在你拍摄的画面中也呈现出“真正”的白色。不同性质的光源会在画面中产生不同的色彩倾向，比如说，蜡烛的光线会使画面偏橘黄色，而黄昏过后的光线则会为景物披上一层蓝色的冷调。而我们的视觉系统会自动对不同的光线作出补偿，所以无论在暖调还是冷调的光线环境下，我们看一张白纸永远还是白色的。但相机则不然，它只会直接记录呈现在它面前的色彩，这就会导致画面色彩偏暖或偏冷。&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h2&gt;&lt;p&gt;开暖光灯：YUV -&amp;gt; RGB -&amp;gt; SV ，全图SV值S需在0～0.1之间，V需在90～255之间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CV" scheme="https://unknown.yuzhouwan.com/categories/CV/"/>
    
    
      <category term="ImageAlgorithm" scheme="https://unknown.yuzhouwan.com/tags/ImageAlgorithm/"/>
    
  </entry>
  
  <entry>
    <title>AI中的数学知识</title>
    <link href="https://unknown.yuzhouwan.com/posts/59545/"/>
    <id>https://unknown.yuzhouwan.com/posts/59545/</id>
    <published>2020-02-01T11:08:26.000Z</published>
    <updated>2020-05-07T15:41:47.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性代数部分"><a href="#线性代数部分" class="headerlink" title="线性代数部分"></a>线性代数部分</h1><h2 id="矩阵及其运算合集"><a href="#矩阵及其运算合集" class="headerlink" title="矩阵及其运算合集"></a>矩阵及其运算合集</h2><a id="more"></a><h2 id="矩阵的行列式"><a href="#矩阵的行列式" class="headerlink" title="矩阵的行列式"></a>矩阵的行列式</h2><h2 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h2><h2 id="矩阵的初等变换"><a href="#矩阵的初等变换" class="headerlink" title="矩阵的初等变换"></a>矩阵的初等变换</h2><h2 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h2><h2 id="矩阵的特征值和特征向量"><a href="#矩阵的特征值和特征向量" class="headerlink" title="矩阵的特征值和特征向量"></a>矩阵的特征值和特征向量</h2><h2 id="矩阵对角化二次型"><a href="#矩阵对角化二次型" class="headerlink" title="矩阵对角化二次型"></a>矩阵对角化二次型</h2><h2 id="SVD分解的证明"><a href="#SVD分解的证明" class="headerlink" title="SVD分解的证明"></a>SVD分解的证明</h2><h2 id="SVD的应用与多元线性回归"><a href="#SVD的应用与多元线性回归" class="headerlink" title="SVD的应用与多元线性回归"></a>SVD的应用与多元线性回归</h2><h1 id="微积分部分"><a href="#微积分部分" class="headerlink" title="微积分部分"></a>微积分部分</h1><h2 id="导数中的中值定理"><a href="#导数中的中值定理" class="headerlink" title="导数中的中值定理"></a>导数中的中值定理</h2><h2 id="泰勒公式函数极值定积分"><a href="#泰勒公式函数极值定积分" class="headerlink" title="泰勒公式函数极值定积分"></a>泰勒公式函数极值定积分</h2><h2 id="多元微积分"><a href="#多元微积分" class="headerlink" title="多元微积分"></a>多元微积分</h2><h1 id="概率论部分"><a href="#概率论部分" class="headerlink" title="概率论部分"></a>概率论部分</h1><h2 id="概率基础"><a href="#概率基础" class="headerlink" title="概率基础"></a>概率基础</h2><h2 id="随机变量与多维随机变量"><a href="#随机变量与多维随机变量" class="headerlink" title="随机变量与多维随机变量"></a>随机变量与多维随机变量</h2><h2 id="期望与方差"><a href="#期望与方差" class="headerlink" title="期望与方差"></a>期望与方差</h2><h2 id="参数的估计"><a href="#参数的估计" class="headerlink" title="参数的估计"></a>参数的估计</h2><h1 id="最优化理论"><a href="#最优化理论" class="headerlink" title="最优化理论"></a>最优化理论</h1><h2 id="无约束最优化"><a href="#无约束最优化" class="headerlink" title="无约束最优化"></a>无约束最优化</h2><h2 id="带约束的最优化"><a href="#带约束的最优化" class="headerlink" title="带约束的最优化"></a>带约束的最优化</h2><h2 id="对偶理论"><a href="#对偶理论" class="headerlink" title="对偶理论"></a>对偶理论</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线性代数部分&quot;&gt;&lt;a href=&quot;#线性代数部分&quot; class=&quot;headerlink&quot; title=&quot;线性代数部分&quot;&gt;&lt;/a&gt;线性代数部分&lt;/h1&gt;&lt;h2 id=&quot;矩阵及其运算合集&quot;&gt;&lt;a href=&quot;#矩阵及其运算合集&quot; class=&quot;headerlink&quot; title=&quot;矩阵及其运算合集&quot;&gt;&lt;/a&gt;矩阵及其运算合集&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Math" scheme="https://unknown.yuzhouwan.com/categories/Math/"/>
    
    
      <category term="Machine Learning" scheme="https://unknown.yuzhouwan.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow2.0 In Action</title>
    <link href="https://unknown.yuzhouwan.com/posts/29871/"/>
    <id>https://unknown.yuzhouwan.com/posts/29871/</id>
    <published>2020-02-01T00:06:06.000Z</published>
    <updated>2020-06-02T15:42:31.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TensorFlow2-0简化的模型开发流程"><a href="#TensorFlow2-0简化的模型开发流程" class="headerlink" title="TensorFlow2.0简化的模型开发流程"></a>TensorFlow2.0简化的模型开发流程</h1><ul><li>使用tf.data加载数据</li><li>使用tf.keras构建模型，也可以使用premade estimator来验证模型（使用tesorflow hub进行迁移学习）</li><li>使用eager mode进行运行和调试</li><li>使用分发策略来进行分布式训练</li><li>导出到SavedModel</li><li>使用TesorFlow Serve、TensorFlow Lite、TensorFlow.js部署模型</li></ul><a id="more"></a><h1 id="TensorFlow-Keras"><a href="#TensorFlow-Keras" class="headerlink" title="TensorFlow-Keras"></a>TensorFlow-Keras</h1><h2 id="tf-keras和keras的区别"><a href="#tf-keras和keras的区别" class="headerlink" title="tf.keras和keras的区别"></a>tf.keras和keras的区别</h2><ul><li>tf.keras全面支持eager mode</li><li>tf.keras支持基于tf.data的模型训练</li><li>tf.keras支持TPU训练</li><li>tf.keras支持tf.distribution中的分布式策略</li><li>tf.keras可以与TensorFlow中的estimator集成</li><li>tf.keras可以保存为SavedModel</li></ul><h2 id="搭建分类模型"><a href="#搭建分类模型" class="headerlink" title="搭建分类模型"></a>搭建分类模型</h2><h3 id="数据读取与展示"><a href="#数据读取与展示" class="headerlink" title="数据读取与展示"></a>数据读取与展示</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line">fashion_mnist = keras.datasets.fashion_mnist</span><br><span class="line">(x_train_all, y_train_all), (x_test, y_test) = fashion_mnist.load_data()</span><br><span class="line">x_valid, x_train = x_train_all[:<span class="number">5000</span>], x_train_all[<span class="number">5000</span>:] <span class="comment">#将数据集的前5000张作为训练集，后面的作为验证集</span></span><br><span class="line">y_valid, y_train = y_train_all[:<span class="number">5000</span>], y_train_all[<span class="number">5000</span>:]</span><br><span class="line"></span><br><span class="line">print(x_valid.shape, y_valid.shape)</span><br><span class="line">print(x_train.shape, y_train.shape)</span><br><span class="line">print(x_test.shape, y_test.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">5000</span>, <span class="number">28</span>, <span class="number">28</span>) (<span class="number">5000</span>,)</span><br><span class="line">(<span class="number">55000</span>, <span class="number">28</span>, <span class="number">28</span>) (<span class="number">55000</span>,)</span><br><span class="line">(<span class="number">10000</span>, <span class="number">28</span>, <span class="number">28</span>) (<span class="number">10000</span>,)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 展示一张图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_single_image</span><span class="params">(img_arr)</span>:</span></span><br><span class="line">    plt.imshow(img_arr, cmap=<span class="string">"binary"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">show_single_image(x_train_all[<span class="number">0</span>]) <span class="comment"># 查看训练集中的第一张图片</span></span><br></pre></td></tr></tbody></table></figure><p><img data-src="/images/tensorflow/show_image.png" alt="show_image"><br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 展示多张图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_imgs</span><span class="params">(n_rows, n_cols, x_data, y_data, class_names)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> len(x_data) == len(y_data)</span><br><span class="line">    <span class="keyword">assert</span> n_rows * n_cols &lt; len(x_data) <span class="comment"># 查看图片的数量不能大于原本的样本数</span></span><br><span class="line">    plt.figure(figsize = (n_cols * <span class="number">1.4</span>, n_rows * <span class="number">1.6</span>))</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(n_rows):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(n_cols):</span><br><span class="line">            index = n_cols * row + col</span><br><span class="line">            plt.subplot(n_rows, n_cols, index+<span class="number">1</span>)</span><br><span class="line">            plt.imshow(x_data[index], cmap=<span class="string">"binary"</span>,</span><br><span class="line">                      interpolation = <span class="string">'nearest'</span>)</span><br><span class="line">            plt.axis(<span class="string">'off'</span>)</span><br><span class="line">            plt.title(class_names[y_data[index]])</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">class_names = [<span class="string">'T-shirt'</span>, <span class="string">'Trouser'</span>, <span class="string">'Pullover'</span>, <span class="string">'Dress'</span>,</span><br><span class="line">              <span class="string">'Coat'</span>, <span class="string">'Sandal'</span>, <span class="string">'Shirt'</span>,<span class="string">'Sneaker'</span>,</span><br><span class="line">              <span class="string">'Bag'</span>, <span class="string">'Ankle boot'</span>]</span><br><span class="line">show_imgs(<span class="number">3</span>, <span class="number">5</span>, x_train, y_train, class_names)</span><br></pre></td></tr></tbody></table></figure><p></p><p><img data-src="/images/tensorflow/show_images.png" alt="show_images"></p><h3 id="模型构建"><a href="#模型构建" class="headerlink" title="模型构建"></a>模型构建</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">model = keras.models.Sequential()</span><br><span class="line">model.add(keras.layers.Flatten(input_shape=[<span class="number">28</span>, <span class="number">28</span>]))</span><br><span class="line">model.add(keras.layers.Dense(<span class="number">300</span>, activation=<span class="string">"relu"</span>))</span><br><span class="line">model.add(keras.layers.Dense(<span class="number">100</span>, activation=<span class="string">"relu"</span>))</span><br><span class="line">model.add(keras.layers.Dense(<span class="number">10</span>, activation=<span class="string">"softmax"</span>))</span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">"sparse_categorical_crossentropy"</span>,</span><br><span class="line">             optimizer=<span class="string">"sgd"</span>,</span><br><span class="line">             metrics=[<span class="string">"accuracy"</span>])</span><br><span class="line">model.layers</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&lt;tensorflow.python.keras.layers.core.Flatten at <span class="number">0x12e0e8a58</span>&gt;,</span><br><span class="line"> &lt;tensorflow.python.keras.layers.core.Dense at <span class="number">0x12e1777b8</span>&gt;,</span><br><span class="line"> &lt;tensorflow.python.keras.layers.core.Dense at <span class="number">0x12dfdb3c8</span>&gt;,</span><br><span class="line"> &lt;tensorflow.python.keras.layers.core.Dense at <span class="number">0x12dfdbdd8</span>&gt;]</span><br></pre></td></tr></tbody></table></figure><ul><li>查看模型层次</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.summary()</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Model: <span class="string">"sequential_4"</span></span><br><span class="line">_________________________________________________________________</span><br><span class="line">Layer (type)                 Output Shape              Param <span class="comment">#   </span></span><br><span class="line">=================================================================</span><br><span class="line">flatten_4 (Flatten)          (<span class="literal">None</span>, <span class="number">784</span>)               <span class="number">0</span>         </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense_12 (Dense)             (<span class="literal">None</span>, <span class="number">300</span>)               <span class="number">235500</span>    </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense_13 (Dense)             (<span class="literal">None</span>, <span class="number">100</span>)               <span class="number">30100</span>     </span><br><span class="line">_________________________________________________________________</span><br><span class="line">dense_14 (Dense)             (<span class="literal">None</span>, <span class="number">10</span>)                <span class="number">1010</span>      </span><br><span class="line">=================================================================</span><br><span class="line">Total params: <span class="number">266</span>,<span class="number">610</span></span><br><span class="line">Trainable params: <span class="number">266</span>,<span class="number">610</span></span><br><span class="line">Non-trainable params: <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><ul><li>开始训练</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history = model.fit(x_train, y_train, epochs=<span class="number">10</span>,</span><br><span class="line">                   validation_data=(x_valid, y_valid))</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Train on <span class="number">55000</span> samples, validate on <span class="number">5000</span> samples</span><br><span class="line">Epoch <span class="number">1</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - <span class="number">4</span>s <span class="number">80</span>us/sample - loss: <span class="number">42355302163052.2422</span> - accuracy: <span class="number">0.0995</span> - val_loss: <span class="number">2.3028</span> - val_accuracy: <span class="number">0.0914</span></span><br><span class="line">Epoch <span class="number">2</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - <span class="number">4</span>s <span class="number">73</span>us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0994</span> - val_loss: <span class="number">2.3026</span> - val_accuracy: <span class="number">0.1012</span></span><br><span class="line">Epoch <span class="number">3</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - <span class="number">4</span>s <span class="number">71</span>us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0986</span> - val_loss: <span class="number">2.3027</span> - val_accuracy: <span class="number">0.1002</span></span><br><span class="line">Epoch <span class="number">4</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - <span class="number">4</span>s <span class="number">70</span>us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0977</span> - val_loss: <span class="number">2.3027</span> - val_accuracy: <span class="number">0.0986</span></span><br><span class="line">Epoch <span class="number">5</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - <span class="number">4</span>s <span class="number">72</span>us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0971</span> - val_loss: <span class="number">2.3029</span> - val_accuracy: <span class="number">0.0914</span></span><br><span class="line">Epoch <span class="number">6</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - <span class="number">4</span>s <span class="number">75</span>us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0973</span> - val_loss: <span class="number">2.3028</span> - val_accuracy: <span class="number">0.0914</span></span><br><span class="line">Epoch <span class="number">7</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - <span class="number">4</span>s <span class="number">72</span>us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0981</span> - val_loss: <span class="number">2.3027</span> - val_accuracy: <span class="number">0.0986</span></span><br><span class="line">Epoch <span class="number">8</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - <span class="number">4</span>s <span class="number">72</span>us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0968</span> - val_loss: <span class="number">2.3028</span> - val_accuracy: <span class="number">0.0914</span></span><br><span class="line">Epoch <span class="number">9</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - <span class="number">4</span>s <span class="number">73</span>us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0982</span> - val_loss: <span class="number">2.3029</span> - val_accuracy: <span class="number">0.0914</span></span><br><span class="line">Epoch <span class="number">10</span>/<span class="number">10</span></span><br><span class="line"><span class="number">55000</span>/<span class="number">55000</span> [==============================] - <span class="number">4</span>s <span class="number">73</span>us/sample - loss: <span class="number">2.3027</span> - accuracy: <span class="number">0.0969</span> - val_loss: <span class="number">2.3028</span> - val_accuracy: <span class="number">0.0914</span></span><br></pre></td></tr></tbody></table></figure><ul><li>画图</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_learning_curves</span><span class="params">(history)</span>:</span></span><br><span class="line">    pd.DataFrame(history.history).plot(figsize=(<span class="number">8</span>, <span class="number">5</span>))</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line">    plt.gca().set_ylim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">plot_learning_curves(history)</span><br></pre></td></tr></tbody></table></figure><p><img data-src="/images/tensorflow/loss_model.png" alt="loss_model"></p><h2 id="Keras回调函数"><a href="#Keras回调函数" class="headerlink" title="Keras回调函数"></a>Keras回调函数</h2><h2 id="搭建回归模型"><a href="#搭建回归模型" class="headerlink" title="搭建回归模型"></a>搭建回归模型</h2><h2 id="搭建深度神经网络"><a href="#搭建深度神经网络" class="headerlink" title="搭建深度神经网络"></a>搭建深度神经网络</h2><h2 id="实现wide-amp-deep模型"><a href="#实现wide-amp-deep模型" class="headerlink" title="实现wide&amp;deep模型"></a>实现wide&amp;deep模型</h2><h2 id="Keras与scikit-learn实现超参数搜索"><a href="#Keras与scikit-learn实现超参数搜索" class="headerlink" title="Keras与scikit-learn实现超参数搜索"></a>Keras与scikit-learn实现超参数搜索</h2><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TensorFlow2-0简化的模型开发流程&quot;&gt;&lt;a href=&quot;#TensorFlow2-0简化的模型开发流程&quot; class=&quot;headerlink&quot; title=&quot;TensorFlow2.0简化的模型开发流程&quot;&gt;&lt;/a&gt;TensorFlow2.0简化的模型开发流程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用tf.data加载数据&lt;/li&gt;
&lt;li&gt;使用tf.keras构建模型，也可以使用premade estimator来验证模型（使用tesorflow hub进行迁移学习）&lt;/li&gt;
&lt;li&gt;使用eager mode进行运行和调试&lt;/li&gt;
&lt;li&gt;使用分发策略来进行分布式训练&lt;/li&gt;
&lt;li&gt;导出到SavedModel&lt;/li&gt;
&lt;li&gt;使用TesorFlow Serve、TensorFlow Lite、TensorFlow.js部署模型&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="https://unknown.yuzhouwan.com/categories/Machine-Learning/"/>
    
    
      <category term="Neural Network" scheme="https://unknown.yuzhouwan.com/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://unknown.yuzhouwan.com/posts/2246/"/>
    <id>https://unknown.yuzhouwan.com/posts/2246/</id>
    <published>2020-01-31T23:55:00.000Z</published>
    <updated>2020-11-20T06:30:24.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同步，异步，阻塞，非阻塞？"><a href="#同步，异步，阻塞，非阻塞？" class="headerlink" title="同步，异步，阻塞，非阻塞？"></a>同步，异步，阻塞，非阻塞？</h1><p>同步： 多个任务之间有先后顺序执行，一个执行完下个才能执行。</p><p>异步： 多个任务之间没有先后顺序，可以同时执行，有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！</p><p>阻塞： 如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。</p><p>非阻塞： 如果不会卡住，可以继续执行，就是说非阻塞的。</p><p>同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。</p><a id="more"></a><h2 id="同步阻塞、同步非阻塞、多路I-O复用、异步I-O"><a href="#同步阻塞、同步非阻塞、多路I-O复用、异步I-O" class="headerlink" title="同步阻塞、同步非阻塞、多路I/O复用、异步I/O"></a>同步阻塞、同步非阻塞、多路I/O复用、异步I/O</h2><ul><li><p><strong>同步阻塞I/O:</strong> </p><p>当进程调用某些涉及I/O操作的系统调用或库函数是，比如send()、accept()等，进程便暂停下来，等I/O操作完成后再继续运行。</p></li><li><p><strong>同步非阻塞I/O: (轮询)</strong></p><ol><li><p>不会等待数据就绪，而是结合反复轮询来尝试数据是否就绪</p></li><li><p>与同步阻塞相比，同步非阻塞好处是在一个进程中可以同时处理多个I/O操作，而不是阻塞在一个I/O操作上</p></li></ol></li><li><p><strong>多路I/O复用</strong></p><ol><li>允许进程通过一种方法来同时监听所有文件描述符，并可以快速获得所有就绪的文件描述符，然后只针对这些文件描述符进行数据访问。select、poll、epoll等函数使用了I/O 复用模型</li></ol></li><li><p><strong>异步I/O</strong></p><ol><li>启动某个操作，并让内核在整个操作（包括等待数据和将数据从内核复制到用户空间）完成后通知应用进程。<strong>应用进程在整个操作期间都不会被阻塞。</strong></li></ol></li></ul><h2 id="Python异步使用场景有哪些"><a href="#Python异步使用场景有哪些" class="headerlink" title="Python异步使用场景有哪些"></a>Python异步使用场景有哪些</h2><p>异步的使用场景:</p><p>1、 不涉及共享资源，获对共享资源只读，即<strong>非互斥</strong>操作</p><p>2、 <strong>没有时序上的严格关系</strong></p><p>3、 不需要原子操作，或可以通过其他方式控制原子性</p><p>4、 <strong>常用于IO操作等耗时操作</strong>，因为比较影响客户体验和使用性能</p><p>5、 <strong>不影响主线程逻辑</strong></p><h2 id="select-poll和epoll"><a href="#select-poll和epoll" class="headerlink" title="select,poll和epoll"></a>select,poll和epoll</h2><p><strong>进程监视多个描述符</strong></p><p><strong>进程监视多个描述符</strong></p><p><strong>进程监视多个描述符</strong></p><p>Select、poll、epoll都是I/O多路复用的机制。<strong>I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（通常是读写操作），能够通知程序进行相应的读写操作。</strong></p><p><strong>都是I/O轮询的方法（同步I/O）</strong>，它们都需要在读写事件就绪后自己负责读写。</p><p><a href="https://www.wemeng.top/2019/08/22/%E8%81%8A%E8%81%8AIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8Bselect%E3%80%81poll%E3%80%81epoll%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">聊聊I/O多路复用之select、poll、epoll</a></p><p>关于epoll的: <a href="http://www.cnblogs.com/my_life/articles/3968782.html" target="_blank" rel="noopener">http://www.cnblogs.com/my_life/articles/3968782.html</a></p><p>基本上select有3个缺点:</p><ol><li><strong>连接数受限</strong>：单个进程所打开的fd是有一定限制的</li><li><strong>查找配对速度慢</strong>：对socket进行轮询扫描时是<strong>线性扫描</strong>，效率较低。</li><li><strong>数据由内核拷贝到用户态</strong>：维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</li></ol><p>poll改善了第一个缺点：原因是它是基于<strong>链表来存储的</strong></p><p>epoll改了三个缺点：<strong>epoll通过内核和用户空间共享一块内存来实现</strong>。通知机制需要很多函数回调。</p><h2 id="边沿触发和水平触发"><a href="#边沿触发和水平触发" class="headerlink" title="边沿触发和水平触发"></a>边沿触发和水平触发</h2><p>水平触发是<strong>只要满足条件</strong>就发生一个 io 事件，边缘触发是指每当<strong>状态变化</strong>时发生一个 io 事件。</p><p>如：epoll也是实现I/O多路复用的一种方法。</p><p>epoll有<strong>水平触发</strong>（level trigger，LT，LT为epoll的默认工作模式）与<strong>边缘触发</strong>（edge trigger，ET）两种工作模式。</p><ul><li>水平触发</li></ul><ol><li>对于读操作</li></ol><p>只要<strong>缓冲内容</strong>不为空，LT模式返回读就绪。</p><ol><li>对于写操作</li></ol><p>只要缓冲区还不满，LT模式会返回写就绪。</p><ul><li>边缘触发</li></ul><ol><li>对于读操作</li></ol><p>（1）当缓冲区<strong>由不可读变为可读</strong>的时候，即缓冲区<strong>由空变为不空</strong>的时候。</p><p>（2）当有<strong>新数据到达</strong>时，即缓冲区中的待读数据变多的时候。</p><p>（3）当缓冲区有数据可读，且应用进程对相应的描述符进行<code>EPOLL_CTL_MOD</code> 修改<code>EPOLLIN</code>事件时。</p><ol><li>对于写操作</li></ol><p>（1）当缓冲区由不可写变为可写时。</p><p>（2）当有旧数据被发送走，即缓冲区中的内容变少的时候。</p><p>（3）当缓冲区有空间可写，且应用进程对相应的描述符进行<code>EPOLL_CTL_MOD</code> 修改<code>EPOLLOUT</code>事件时。</p><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程总结"><a href="#进程总结" class="headerlink" title="进程总结"></a>进程总结</h2><p><strong>进程：程序运行在操作系统上的一个实例，就称之为进程。进程需要相应的系统资源：内存、时间片、pid。</strong><br>创建进程：<br>首先要导入multiprocessing中的Process：<br>创建一个Process对象;<br>创建Process对象时，可以传递参数;</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = Process(target=XXX,args=(tuple,),kwargs={key:value})</span><br><span class="line">target = XXX 指定的任务函数，不用加(),</span><br><span class="line">args=(tuple,)kwargs={key:value}给任务函数传递的参数</span><br></pre></td></tr></tbody></table></figure><p>使用start()启动进程<br>结束进程<br>给子进程指定函数传递参数Demo</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> mulitprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pro_func</span><span class="params">(name,age,**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">"子进程正在运行中，name=%s,age=%d,pid=%d"</span>%(name,age,os.getpid()))</span><br><span class="line">        print(kwargs)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#创建Process对象</span></span><br><span class="line">    p = Process(target=pro_func,args=(<span class="string">'小明'</span>,<span class="number">18</span>),kwargs={<span class="string">'m'</span>:<span class="number">20</span>})</span><br><span class="line">    <span class="comment">#启动进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#1秒钟之后，立刻结束子进程</span></span><br><span class="line">    p.terminate()</span><br><span class="line">    p.join()</span><br></pre></td></tr></tbody></table></figure><p>注意：进程间不共享全局变量</p><p>进程之间的通信-Queue</p><p>在初始化Queue()对象时（例如q=Queue(),若在括号中没有指定最大可接受的消息数量，获数量为负值时，那么就代表可接受的消息数量没有上限一直到内存尽头）</p><p>Queue.qsize():返回当前队列包含的消息数量</p><p>Queue.empty():如果队列为空，返回True，反之False</p><p>Queue.full():如果队列满了，返回True,反之False</p><p>Queue.get([block[,timeout]]):获取队列中的一条消息，然后将其从队列中移除，</p><p>block默认值为True。</p><p>如果block使用默认值，且没有设置timeout（单位秒),消息队列如果为空，此时程序将被阻塞（停在读中状态），直到消息队列读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出“Queue.Empty”异常：</p><p>Queue.get_nowait()相当于Queue.get(False)</p><p>Queue.put(item,[block[,timeout]]):将item消息写入队列，block默认值为True;<br>如果block使用默认值，且没有设置timeout（单位秒），消息队列如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息队列腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出”Queue.Full”异常<br>如果block值为False，消息队列如果没有空间可写入，则会立刻抛出”Queue.Full”异常;<br>Queue.put_nowait(item):相当Queue.put(item,False)</p><p>进程间通信Demo:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process.Queue</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"><span class="comment">#写数据进程执行的代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>]:</span><br><span class="line">        print(<span class="string">"Put %s to queue..."</span>,%value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"><span class="comment">#读数据进程执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            value = q.get(<span class="literal">True</span>)</span><br><span class="line">            print(<span class="string">"Get %s from queue."</span>,%value)</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#父进程创建Queue，并传给各个子进程</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write,args=(q,))</span><br><span class="line">    pr = Process(target=read,args=(q,))</span><br><span class="line">    <span class="comment">#启动子进程pw ，写入：</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment">#等待pw结束</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment">#启动子进程pr，读取：</span></span><br><span class="line">    pr.start()</span><br><span class="line">    pr.join()</span><br><span class="line">    <span class="comment">#pr 进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    print(<span class="string">''</span>)</span><br><span class="line">    print(<span class="string">'所有数据都写入并且读完'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>进程池Pool</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(msg)</span>:</span></span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(<span class="string">"%s 开始执行，进程号为%d"</span>%(msg,os.getpid()))</span><br><span class="line">    <span class="comment"># random.random()随机生成0-1之间的浮点数</span></span><br><span class="line">    time.sleep(random.random()*<span class="number">2</span>)</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(msg,<span class="string">"执行完毕，耗时%0.2f”%（t_stop-t_start))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">po = Pool(3)#定义一个进程池，最大进程数3</span></span><br><span class="line"><span class="string">for i in range(0,10):</span></span><br><span class="line"><span class="string">    po.apply_async(worker,(i,))</span></span><br><span class="line"><span class="string">print("</span>---start----<span class="string">")</span></span><br><span class="line"><span class="string">po.close()</span></span><br><span class="line"><span class="string">po.join()</span></span><br><span class="line"><span class="string">print("</span>----end----<span class="string">")</span></span><br></pre></td></tr></tbody></table></figure><p>进程池中使用Queue</p><p>如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue(),而不是multiprocessing.Queue(),否则会得到如下的错误信息：</p><p>RuntimeError： Queue objects should only be shared between processs through inheritance</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager,Pool</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">"reader 启动(%s),父进程为（%s)"</span>%(os.getpid(),os.getpid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(q.qsize()):</span><br><span class="line">        print(<span class="string">"reader 从Queue获取到消息:%s"</span>%q.get(<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">"writer 启动（%s),父进程为(%s)"</span>%(os.getpid(),os.getpid()))</span><br><span class="line">    <span class="keyword">for</span> i ini <span class="string">"itcast"</span>:</span><br><span class="line">        q.put(i)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"(%s)start"</span>%os.getpid())</span><br><span class="line">    q = Manager().Queue()<span class="comment">#使用Manager中的Queue</span></span><br><span class="line">    po = Pool()</span><br><span class="line">    po.apply_async(wrtier,(q,))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    po.apply_async(reader,(q,))</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    print(<span class="string">"(%s)End"</span>%os.getpid())</span><br></pre></td></tr></tbody></table></figure><h2 id="多进程，多线程，以及协程的理解"><a href="#多进程，多线程，以及协程的理解" class="headerlink" title="多进程，多线程，以及协程的理解"></a>多进程，多线程，以及协程的理解</h2><p>这个问题被问的概念相当之大。<br>进程：<strong>一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间</strong>，所有进程间数据不共享，开销大。</p><p>线程: <strong>cpu调度执行的最小单位，依赖进程存在</strong>，一个进程至少有一个线程，叫主线程，而<strong>多个线程共享内存</strong>（数据共享，共享全局变量), 从而极大地提高了程序的运行效率。</p><p>协程: 是一种用户态的轻量级线程，<strong>协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。</strong>协程调度时，将<strong>寄存器上下文和栈</strong>保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><p>协程是进程和线程的升级版, <strong>进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.</strong>（实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU））</p><p><strong>Python里最常见的yield就是协程的思想</strong>!</p><p>协程：<a href="https://www.cnblogs.com/zingp/p/8678109.html" target="_blank" rel="noopener">https://www.cnblogs.com/zingp/p/8678109.html</a></p><h2 id="协程库：python-asyncio的原理"><a href="#协程库：python-asyncio的原理" class="headerlink" title="协程库：python asyncio的原理"></a>协程库：python asyncio的原理</h2><p>asyncio这个库就是实现协程，<strong>底层都是基于生成器（yield）来实现的。</strong></p><p>在生成器的基础上实现了：</p><ol><li><p>现在的生成器虽然可以在暂停执行时吐出一个值，<strong>但是恢复生成器时，我们不能传入参数。</strong> （言下之意是恢复协程时，应该需要支持传入参数）</p></li><li><p>现在的生成器不支持在 try block 中暂停（言下之意是<strong>协程应该要支持在 try block 中暂停</strong>）</p></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> asyncio</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'hello world'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">job1</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'job1 started...'</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'job1 paused'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">await</span> hello_world()</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'job1 resumed'</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'job1 finished'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loop = asyncio.get_event_loop()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>loop.run_until_complete(job1())</span><br></pre></td></tr></tbody></table></figure><p><a href="http://cosven.me/blogs/88" target="_blank" rel="noopener">http://cosven.me/blogs/88</a></p><h2 id="僵尸进程和孤儿进程？怎么避免僵尸进程"><a href="#僵尸进程和孤儿进程？怎么避免僵尸进程" class="headerlink" title="僵尸进程和孤儿进程？怎么避免僵尸进程"></a>僵尸进程和孤儿进程？怎么避免僵尸进程</h2><ul><li><p>孤儿进程： <strong>父进程退出，子进程还在运行的这些子进程都是孤儿进程</strong>，孤儿进程将被init 进程（进程号为1）所收养，并<strong>由init 进程对他们完成状态收集工作</strong>。</p></li><li><p>僵尸进程： <strong>进程使用fork 创建子进程，如果子进程退出</strong>，而父进程并没有<strong>调用wait （join方法）获waitpid 获取子进程的退出状态信息</strong>，那么<strong>子进程的进程描述符仍然保存在系统中</strong>的这些进程是僵尸进程。</p></li></ul><p>避免僵尸进程的方法：</p><ol><li><p><strong>暴力法</strong>：结束父进程（主进程），父进程退出时子进程也会退出。</p></li><li><p><strong>用wait使父进程阻塞</strong>：如join()方法来wait</p></li><li><p><strong>使用信号量</strong>：在<strong>父进程中处理</strong>signal handler信号，在<strong>处理程序中调用waitpid</strong>, 这样父进程不用阻塞</p></li></ol><h2 id="进程与线程的使用场景"><a href="#进程与线程的使用场景" class="headerlink" title="进程与线程的使用场景"></a>进程与线程的使用场景</h2><p>多线程适合在IO密性型操作（读写数据操作比多的的，比如爬虫）</p><p>多进程适合在CPU密集操作（cpu操作指令比较多，如位多的的浮点运算）。</p><h2 id="IO密集型和CPU密集型区别"><a href="#IO密集型和CPU密集型区别" class="headerlink" title="IO密集型和CPU密集型区别"></a>IO密集型和CPU密集型区别</h2><p>IO密集型： 系统运行，大部分的状况是CPU在等 I/O（硬盘/内存）的读/写</p><p>CPU密集型： 大部分时间用来做计算，逻辑判断等CPU动作的程序称之CPU密集型。</p><h2 id="线程，进程是并发还是并行"><a href="#线程，进程是并发还是并行" class="headerlink" title="线程，进程是并发还是并行"></a>线程，进程是并发还是并行</h2><ul><li><p>线程是并发，</p></li><li><p>进程是并行;</p></li></ul><p>进程之间互相独立，是系统分配资源的最小单位，同一个线程中的所有线程共享资源。</p><h2 id="什么是多线程竞争"><a href="#什么是多线程竞争" class="headerlink" title="什么是多线程竞争"></a>什么是多线程竞争</h2><ul><li><p>线程是非独立的，<strong>同一个进程里线程是数据共享的，当各个线程访问数据资源时会出现竞争状态即：数据几乎同步会被多个线程占用，造成数据混乱</strong>，即所谓的线程不安全</p></li><li><p>怎么解决多线程竞争问题？—- <strong>锁</strong></p></li></ul><p>锁的好处： 确保了某段关键代码（共享数据资源）只能由一个线程从头到尾完整地执行能解决多线程资源竞争下的原子操作问题。</p><p>锁的坏处： <strong>阻止了多线程并发执行</strong>，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</p><p><strong>锁的致命问题: 死锁</strong></p><h2 id="Python的线程同步"><a href="#Python的线程同步" class="headerlink" title="Python的线程同步"></a>Python的线程同步</h2><p> 一、 setDaemon(False)<br>当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行的最小单位，当设置多线程时，<strong>主线程会创建多个子线程</strong>，在Python中，默认情况下就是setDaemon(False), <strong>主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。</strong></p><p>例子</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'---子线程结束---'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    t1 = threading.Thread(target=thread)</span><br><span class="line">    t1.start()</span><br><span class="line">    print(<span class="string">'---主线程--结束'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment">#执行结果</span></span><br><span class="line">---主线程--结束</span><br><span class="line">---子线程结束---</span><br></pre></td></tr></tbody></table></figure><p>二、 setDaemon（True)<br>当我们使用setDaemon(True)时，<strong>这是子线程为守护线程，主线程一旦执行结束，则全部子线程被强制终止</strong></p><p>例子</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(’---子线程结束---<span class="string">')</span></span><br><span class="line"><span class="string">def main():</span></span><br><span class="line"><span class="string">    t1 = threading.Thread(target=thread)</span></span><br><span class="line"><span class="string">    t1.setDaemon(True)#设置子线程守护主线程</span></span><br><span class="line"><span class="string">    t1.start()</span></span><br><span class="line"><span class="string">    print('</span>---主线程结束---<span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if __name__ =='</span>__main__<span class="string">':</span></span><br><span class="line"><span class="string">    main()</span></span><br><span class="line"><span class="string">#执行结果</span></span><br><span class="line"><span class="string">---主线程结束--- #只有主线程结束，子线程来不及执行就被强制结束</span></span><br></pre></td></tr></tbody></table></figure><p>三、 join（线程同步)<br><strong>join 所完成的工作就是线程同步</strong>，即主线程任务结束以后，进入堵塞状态，一直<strong>等待所有的子线程结束以后，主线程再终止</strong>。</p><p>当设置守护线程时，含义是<strong>主线程对于子线程等待timeout的时间将会杀死该子线程</strong>，最后退出程序，所以说，如果有10个子线程，全部的等待时间就是每个timeout的累加和，简单的来说，就是给每个子线程一个timeou的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。</p><p>没有设置守护线程时，主线程将会等待timeout的累加和这样的一段时间，时间一到，主线程结束，但是并没有杀死子线程，子线程依然可以继续执行，直到子线程全部结束，程序退出。</p><p>例子</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'---子线程结束---'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    t1 = threading.Thread(target=thread)</span><br><span class="line">    t1.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t1.join(timeout=<span class="number">1</span>)<span class="comment">#1 线程同步，主线程堵塞1s 然后主线程结束，子线程继续执行</span></span><br><span class="line">                        <span class="comment">#2 如果不设置timeout参数就等子线程结束主线程再结束</span></span><br><span class="line">                        <span class="comment">#3 如果设置了setDaemon=True和timeout=1主线程等待1s后会强制杀死子线程，然后主线程结束</span></span><br><span class="line">    print(<span class="string">'---主线程结束---'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main___'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h2 id="多线程交互访问数据，如果访问到了就不访问了"><a href="#多线程交互访问数据，如果访问到了就不访问了" class="headerlink" title="多线程交互访问数据，如果访问到了就不访问了"></a>多线程交互访问数据，如果访问到了就不访问了</h2><p>怎么避免重读？</p><p><strong>创建一个已访问数据列表，用于存储已经访问过的数据，并加上互斥锁</strong>，在多线程访问数据的时候先查看数据是否在已访问的列表中，若已存在就直接跳过。</p><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><ul><li><p>并发（concurrency)：不会在同一时刻同时运行，存在交替执行的情况。（threading）</p></li><li><p>并行（parallel）： 同一时刻多个任务同时在运行（multiprocessing）</p></li></ul><p>程序需要执行较多的读写、请求和回复任务的需要大量的IO操作，IO密集型操作使用并发更好<strong>（I/O密集型 - 线程 - 并发）</strong></p><p>CPU运算量大的程序，使用并行会更好<strong>（CPU密集型 - 进程 - 并行）</strong></p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><p>锁(Lock)是python提供的对线程控制的对象。<strong>有互斥锁，可重入锁，死锁</strong>。</p><ul><li>死锁：死锁是一个资源被多次调用，而多次调用方都未能释放该资源就会造成死锁</li><li>互斥锁：threading.Lock</li><li>可重入锁：threading.RLock，为了支持在<strong>同一线程中多次请求同一资源</strong>，python提供了“可重入锁”：threading.RLock。<strong>RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次acquire。</strong>直到一个线程所有的acquire都被release，其他的线程才能获得资源。</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>若干子线程在<strong>系统资源竞争</strong>时，都在<strong>等待对方对某部分资源解除占用状态</strong>，结果是<strong>谁也不愿先解锁</strong>，互相干等着，程序无法执行下去，这就是死锁。</p><p>必要条件:</p><ol><li>互斥条件</li><li>请求和保持条件</li><li>不剥夺条件</li><li>环路等待条件</li></ol><p>处理死锁基本方法:</p><ol><li>预防死锁(摒弃除1以外的条件)</li><li><strong>避免死锁(银行家算法)</strong>：当一个进程申请使用资源的时候，银行家算法通过先 <strong>试探</strong> 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。</li><li>检测死锁(<strong>资源分配图</strong>)</li><li>解除死锁<ol><li><strong>剥夺资源</strong></li><li><strong>撤销进程</strong></li></ol></li></ol><p>死锁概念处理策略详细介绍:<a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html</a></p><p>一个死锁的例子：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_numbers</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"1"</span>)</span><br><span class="line">    s2.acquire()</span><br><span class="line">    print(<span class="string">"2"</span>)</span><br><span class="line">    s1.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_char</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"3"</span>)</span><br><span class="line">    s1.acquire()</span><br><span class="line">    print(<span class="string">"4"</span>)</span><br><span class="line">    s2.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 创建锁</span></span><br><span class="line">    s1 = Lock()</span><br><span class="line">    s2 = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建两个线程</span></span><br><span class="line">    t1 = Thread(name=<span class="string">"打印字符"</span>, target=print_numbers)</span><br><span class="line">    t2 = Thread(name=<span class="string">"打印字母"</span>, target=print_char)</span><br><span class="line">    s1.acquire()</span><br><span class="line">    s2.acquire()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></tbody></table></figure><h2 id="互斥锁、线程安全"><a href="#互斥锁、线程安全" class="headerlink" title="互斥锁、线程安全"></a>互斥锁、线程安全</h2><p><strong>每个对象</strong>都对应于一个可称为’互斥锁‘的标记，这个<strong>标记用来保证在任一时刻，只能有一个线程访问该对象。</strong></p><p>同一进程中的多线程之间是共享系统资源的，多个线程同时对一个对象进行操作，一个线程操作尚未结束，另一线程已经对其进行操作，导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。</p><h2 id="GIL锁-全局解释器锁"><a href="#GIL锁-全局解释器锁" class="headerlink" title="GIL锁 全局解释器锁"></a>GIL锁 全局解释器锁</h2><p>作用： 限制多线程同时执行，保证同一时间只有一个线程执行，所以cython里的多线程其实是伪多线程！</p><p>所以python里常常使用协程技术来代替多线程，协程是一种更轻量级的线程。</p><p>进程和线程的切换时由系统决定，而协程由我们程序员自己决定，而模块gevent下切换是遇到了耗时操作时才会切换</p><p>三者的关系：进程里有线程，线程里有协程。</p><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><ul><li><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反<strong>数据完整性</strong>的操作</p><p><strong>互斥锁、可重入锁都属于悲观锁。</strong>当你读取或者写入数据时，你都悲观地认为有别人正在改动数据，所以你希望在你 操作数据的时候上锁，防止别人改动。当然，当已经有别人上锁，你必须等待别人操作完毕。</p></li></ul><p>  悲观锁的业务流程:</p><blockquote><p>事务开始<br>查询、修改数据表之前 加锁<br>对数据库 操作<br>事务提交（检测、返回冲突）</p></blockquote><ul><li><p>乐观锁：假设不会发生并发冲突，只在<strong>提交操作时检查</strong>是否违反数据完整性。</p><p><strong>Redis的并发竞争解决方案</strong>，使用乐观锁，成本低，非阻塞，性能高。</p><p>每次去取数据的时候总认为不会有其他线程对数据进行修改，因此<strong>不会上锁</strong>，但是在更新时会判断其他线程在这之前有没有对数据进行修改。</p></li></ul><p>乐观锁与悲观锁的具体区别:</p><p> <a href="http://www.cnblogs.com/Bob-FD/p/3352216.html" target="_blank" rel="noopener">http://www.cnblogs.com/Bob-FD/p/3352216.html</a></p><p><a href="http://blog.csdn.net/chosen0ne/article/details/18093187" target="_blank" rel="noopener">http://blog.csdn.net/chosen0ne/article/details/18093187</a>)</p><h2 id="多线程共同操作同一个数据互斥锁同步？"><a href="#多线程共同操作同一个数据互斥锁同步？" class="headerlink" title="多线程共同操作同一个数据互斥锁同步？"></a>多线程共同操作同一个数据互斥锁同步？</h2><p>两个线程循环打印数字和字母</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time: 2020/11/9 11:00 </span></span><br><span class="line"><span class="comment"># @Author: GraceKoo</span></span><br><span class="line"><span class="comment"># @File: test.py</span></span><br><span class="line"><span class="comment"># @Desc:</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_numbers</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">27</span>):</span><br><span class="line">        <span class="keyword">if</span> s1.acquire(): <span class="comment"># 判断是否得到锁</span></span><br><span class="line">            print(str(i))</span><br><span class="line">            s1.release() <span class="comment"># 释放锁</span></span><br><span class="line">            time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_char</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">65</span>, <span class="number">91</span>):</span><br><span class="line">        <span class="keyword">if</span> s1.acquire():</span><br><span class="line">            print(chr(i))</span><br><span class="line">            s1.release()</span><br><span class="line">            time.sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 创建锁</span></span><br><span class="line">    s1 = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建两个线程</span></span><br><span class="line">    t1 = Thread(name=<span class="string">"打印字符"</span>, target=print_numbers)</span><br><span class="line">    t2 = Thread(name=<span class="string">"打印字母"</span>, target=print_char)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></tbody></table></figure><h1 id="作业调度算法"><a href="#作业调度算法" class="headerlink" title="作业调度算法"></a>作业调度算法</h1><ol><li><p>先来先服务(FCFS, First Come First Serve)</p></li><li><p><strong>短作业优先</strong>(SJF, Shortest Job First)</p></li><li><p><strong>最高优先权调度</strong>(Priority Scheduling)</p></li><li><p><strong>时间片轮转</strong>(RR, Round Robin)：把CPU的时间分给各个任务用</p></li><li><p><strong>多级反馈队列调度</strong>(multilevel feedback queue scheduling)：能使优先级高的作业得到响应又能使短作业（进程）迅速完成。</p><p>对于优先级高的作业，首先执行；</p><p>对于优先级低的队列，采用时间片轮询的方法。</p></li></ol><p>常见的调度算法总结:<a href="http://www.jianshu.com/p/6edf8174c1eb" target="_blank" rel="noopener">http://www.jianshu.com/p/6edf8174c1eb</a></p><p>实时调度算法:</p><ol><li>最早截至时间优先 EDF</li><li>最低松弛度优先 LLF</li></ol><h1 id="程序编译与链接"><a href="#程序编译与链接" class="headerlink" title="程序编译与链接"></a>程序编译与链接</h1><p>推荐: <a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/11/compiler.html</a></p><p>Bulid过程可以分解为4个步骤:<strong>预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking)</strong></p><p>以c语言为例:</p><h2 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1 预处理"></a>1 预处理</h2><p><strong>预编译过程主要处理那些源文件中的以“#”开始的预编译指令</strong>，主要处理规则有：</p><ol><li>将所有的“<strong>#define</strong>”删除，并展开所用的宏定义</li><li>处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif”</li><li>处理“<strong>#include</strong>”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是<strong>递归</strong>进行的</li><li><strong>删除所有注释</strong></li><li><strong>添加行号和文件名标识</strong>，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号</li><li>保留所有的#pragma编译器指令。</li></ol><h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2 编译"></a>2 编译</h2><p>编译过程就是把预处理完的文件进行一系列的<strong>词法分析、语法分析、语义分析及优化</strong>后<strong>生成相应的汇编代码文件</strong>。这个过程是整个程序构建的核心部分。</p><h2 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3 汇编"></a>3 汇编</h2><p>汇编器是将<strong>汇编代码转化成机器可以执行的指令</strong>，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件<strong>成为目标文件</strong>(Object File)</p><h2 id="4-链接"><a href="#4-链接" class="headerlink" title="4 链接"></a>4 链接</h2><p>链接的主要内容就是把<strong>各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。</strong><br>链接的主要过程包块地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。</p><h1 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h1><ul><li><p>静态链接方法：<strong>静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来</strong><br>静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库</p></li><li><p>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是<strong>直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址</strong>，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式<strong>使程序初始化时间较短，但运行期间的性能比不上静态链接的程序</strong></p></li></ul><h1 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h1><p>虚拟存储器是指具有<strong>请求调入</strong>功能和<strong>置换功能</strong>,能<strong>从逻辑上对内存容量加以扩充的一种存储系统.</strong></p><h1 id="分页和分段"><a href="#分页和分段" class="headerlink" title="分页和分段"></a>分页和分段</h1><p>分页: <strong>用户程序的地址空间被划分成若干固定大小的区域，称为“页”</strong>，相应地，<strong>内存空间分成若干个物理块，页和块的大小相等</strong>。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p><p>分段: 将用户程序地址空间分成<strong>若干个大小不等的段</strong>，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，<strong>段与段在内存中可以不相邻接，也实现了离散分配。</strong></p><h1 id="分页与分段的主要区别"><a href="#分页与分段的主要区别" class="headerlink" title="分页与分段的主要区别"></a>分页与分段的主要区别</h1><ol><li><p><strong>页是信息的物理单位</strong>,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于<strong>系统管理的需要</strong>.</p><p><strong>段是信息的逻辑单位</strong>,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,<strong>满足用户的需要</strong>.</p></li><li><p>页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是<strong>由机器硬件实现的</strong>.</p><p>而段的长度却不固定,决定于用户所编写的程序,通常由<strong>编译程序</strong>在对源程序进行编译时根据信息的性质来划分.</p></li><li><p>分页的作业地址空间是一维的.</p><p>分段的地址空间是二维的.</p></li></ol><h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><ol><li><strong>最佳置换算法OPT</strong>:不可能实现，选择的被淘汰的页面将是以后永不使用的，或是在最长（未来）时间内不再被访问的页面。采用最佳置换算法通常可保证<strong>最低的缺页率</strong>。</li><li><strong>先进先出FIFO</strong></li><li><strong>最近最久未使用算法LRU</strong>: 最近一段时间里最久没有使用过的页面予以置换.</li><li><strong>clock算法</strong></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;同步，异步，阻塞，非阻塞？&quot;&gt;&lt;a href=&quot;#同步，异步，阻塞，非阻塞？&quot; class=&quot;headerlink&quot; title=&quot;同步，异步，阻塞，非阻塞？&quot;&gt;&lt;/a&gt;同步，异步，阻塞，非阻塞？&lt;/h1&gt;&lt;p&gt;同步： 多个任务之间有先后顺序执行，一个执行完下个才能执行。&lt;/p&gt;
&lt;p&gt;异步： 多个任务之间没有先后顺序，可以同时执行，有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！&lt;/p&gt;
&lt;p&gt;阻塞： 如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。&lt;/p&gt;
&lt;p&gt;非阻塞： 如果不会卡住，可以继续执行，就是说非阻塞的。&lt;/p&gt;
&lt;p&gt;同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Basic" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/"/>
    
      <category term="Interview" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/Interview/"/>
    
    
      <category term="Operating System" scheme="https://unknown.yuzhouwan.com/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶</title>
    <link href="https://unknown.yuzhouwan.com/posts/23063/"/>
    <id>https://unknown.yuzhouwan.com/posts/23063/</id>
    <published>2020-01-31T23:00:01.000Z</published>
    <updated>2020-10-19T12:39:03.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="args-和-Kwargs"><a href="#args-和-Kwargs" class="headerlink" title="*args 和 **Kwargs"></a><strong>*args</strong> 和 **Kwargs</h1><ul><li>*args 是用来发送一个非键值对的可变数量的参数列表给一个函数</li><li>kwargs 允许你将不定长度的键值对, 作为参数传递给一个函数。 如果你想要在一个函 数里处理带名字的参数, 你应该使用kwargs。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_args_kwargs</span><span class="params">(arg1, arg2, arg3)</span>:</span></span><br><span class="line">    print(<span class="string">"arg1:"</span>, arg1)</span><br><span class="line">    print(<span class="string">"arg2:"</span>, arg2)</span><br><span class="line">    print(<span class="string">"arg3:"</span>, arg3)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Test *args</span></span><br><span class="line">args = (<span class="string">"two"</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">test_args_kwargs(*args)</span><br><span class="line"></span><br><span class="line">arg1: two</span><br><span class="line">arg2: <span class="number">3</span></span><br><span class="line">arg3: <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Test **kwargs</span></span><br><span class="line">kwargs = {<span class="string">"arg3"</span>: <span class="number">3</span>, <span class="string">"arg2"</span>: <span class="string">"two"</span>, <span class="string">"arg1"</span>: <span class="number">5</span>}</span><br><span class="line">test_args_kwargs(**kwargs)</span><br><span class="line">arg1: <span class="number">5</span></span><br><span class="line">arg2: two</span><br><span class="line">arg3: <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h1 id="Debugging模式"><a href="#Debugging模式" class="headerlink" title="Debugging模式"></a>Debugging模式</h1><p>python提供的pdb功能可以在命令行模式下或者函数内部设置断点进行调试。</p><p>常见命令列表如下：</p><ul><li>c: 继续执行</li><li>w: 显示当前正在执行的代码行的上下文信息</li><li>a: 打印当前函数的参数列表</li><li>s: 执行当前代码行，并停在第一个能停的地方(相当于单步进入)</li><li>n: 继续执行到当前函数的下一行，或者当前行直接返回(单步跳过)</li></ul><ul><li>命令行模式</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m pdb my_script.py</span><br></pre></td></tr></tbody></table></figure><ul><li>函数内部执行</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_bread</span><span class="params">()</span>:</span> pdb.set_trace()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is pdb mode"</span></span><br></pre></td></tr></tbody></table></figure><h1 id="生成器：Generator"><a href="#生成器：Generator" class="headerlink" title="生成器：Generator"></a>生成器：Generator</h1><p>生成器也是一种迭代器，但<strong>只使用一次迭代</strong>。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。你通过遍历来使用它们，要么用一个“for”循环，要么将它们传递给任意可以进行迭代的函数和结构。大多数时候生成器是以函数来实现的。然而， 它们并不返回一个值，而是<strong>yield</strong>(暂且译作“生出”)一个值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> generator_function():</span><br><span class="line">print(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: 0 </span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="comment">#3</span></span><br></pre></td></tr></tbody></table></figure><p>应用场景：不同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环。用这种方式，不必担心会大量使用资源。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 斐波那契数列的迭代器：会大量使用内存资源（在在计算很大的输入参数时）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibon</span><span class="params">(n)</span>:</span> a=b=<span class="number">1</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">result.append(a)</span><br><span class="line">a, b = b, a + b </span><br><span class="line">  <span class="keyword">return</span> result</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 斐波那契数列的生成器：不会大量使用内存资源</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibon</span><span class="params">(n)</span>:</span></span><br><span class="line">a=b=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line"><span class="keyword">yield</span> a</span><br><span class="line">a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> fibon(<span class="number">1000000</span>):</span><br><span class="line">    print(x)</span><br></pre></td></tr></tbody></table></figure><h2 id="内置函数：next"><a href="#内置函数：next" class="headerlink" title="内置函数：next()"></a>内置函数：next()</h2><p>Python内置函数:next()。允许我们获取一个序列的下一个元素。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"><span class="keyword">yield</span> i</span><br><span class="line">gen = generator_function() </span><br><span class="line">print(next(gen))</span><br><span class="line"><span class="comment"># Output: 0 </span></span><br><span class="line">print(next(gen))</span><br><span class="line"><span class="comment"># Output: 1</span></span><br><span class="line">print(next(gen))</span><br><span class="line"><span class="comment"># Output: 2</span></span><br><span class="line">print(next(gen))</span><br><span class="line"><span class="comment"># Output: Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#            File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#         StopIteration</span></span><br></pre></td></tr></tbody></table></figure><h2 id="内置函数：iter"><a href="#内置函数：iter" class="headerlink" title="内置函数：iter()"></a>内置函数：iter()</h2><p>一个可迭代对象并不是一个迭代器，如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_string = <span class="string">"Yasoob"</span></span><br><span class="line">next(my_string)</span><br><span class="line"><span class="comment"># Output: Traceback (most recent call last): </span></span><br><span class="line"><span class="comment"># File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># TypeError: str object is not an iterator</span></span><br></pre></td></tr></tbody></table></figure><p>iter。它将根据一个可迭代对象返回一个迭代器对象。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_string = <span class="string">"Yasoob"</span> </span><br><span class="line">my_iter = iter(my_string) </span><br><span class="line">next(my_iter)</span><br><span class="line"><span class="comment"># Output: 'Y'</span></span><br></pre></td></tr></tbody></table></figure><h1 id="装饰器：Decorator"><a href="#装饰器：Decorator" class="headerlink" title="装饰器：Decorator"></a>装饰器：Decorator</h1><ul><li><p>作用：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic。装饰器让你在一个函数的前后去执行代码。</p></li><li><p>“@decorator_name” is meaning of</p><blockquote><p>f = decorator_name(f)</p></blockquote></li><li><p>@wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表 等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。</p></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_name</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">  @wraps(f)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">decorated</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> can_run:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Function will not run"</span></span><br><span class="line">  <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">  <span class="keyword">return</span> decorated</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="string">"Function is running"</span>)</span><br><span class="line"></span><br><span class="line">can_run = <span class="literal">True</span></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># Output: Function is running</span></span><br><span class="line"></span><br><span class="line">can_run = <span class="literal">False</span></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># Output: Function will not run</span></span><br></pre></td></tr></tbody></table></figure><h1 id="容器-Collections"><a href="#容器-Collections" class="headerlink" title="容器 Collections"></a>容器 Collections</h1><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>与dict类型不同，defaultdict不需要检查key是否存在</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">tree = <span class="keyword">lambda</span>: collections.defaultdict(tree) </span><br><span class="line">some_dict = tree() </span><br><span class="line">some_dict[<span class="string">'colours'</span>][<span class="string">'favourite'</span>] = <span class="string">"yellow"</span></span><br><span class="line"></span><br><span class="line">print(json.dumps(some_dict))</span><br><span class="line"><span class="comment">## 输出: {"colours": {"favourite": "yellow"}}</span></span><br></pre></td></tr></tbody></table></figure><h2 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h2><p>Counter是一个计数器，它可以帮助我们针对某项数据进行计数。比如它可以用来计算每个人喜欢多少种颜色:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">colours = (</span><br><span class="line">  (<span class="string">'Yasoob'</span>, <span class="string">'Yellow'</span>), </span><br><span class="line">  (<span class="string">'Ali'</span>, <span class="string">'Blue'</span>), </span><br><span class="line">  (<span class="string">'Arham'</span>, <span class="string">'Green'</span>), </span><br><span class="line">  (<span class="string">'Ali'</span>, <span class="string">'Black'</span>), </span><br><span class="line">  (<span class="string">'Yasoob'</span>, <span class="string">'Red'</span>), </span><br><span class="line">  (<span class="string">'Ahmed'</span>, <span class="string">'Silver'</span>),</span><br><span class="line">)</span><br><span class="line">favs = Counter(name <span class="keyword">for</span> name, colour <span class="keyword">in</span> colours) </span><br><span class="line">print(favs)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出:</span></span><br><span class="line"><span class="comment">## Counter({</span></span><br><span class="line"><span class="comment">##    'Yasoob': 2,</span></span><br><span class="line"><span class="comment">## 'Ali': 2,</span></span><br><span class="line"><span class="comment">##    'Arham': 1,</span></span><br><span class="line"><span class="comment">##    'Ahmed': 1</span></span><br><span class="line"><span class="comment">##  })</span></span><br></pre></td></tr></tbody></table></figure><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque提供了一个双端队列，你可以从头/尾两端添加或删除元素。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">d = deque()</span><br><span class="line">d.append(<span class="string">'1'</span>) </span><br><span class="line">d.append(<span class="string">'2'</span>) </span><br><span class="line">d.append(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">print(d[<span class="number">0</span>])</span><br><span class="line"><span class="comment">## 输出: '1'</span></span><br><span class="line">print(d[<span class="number">-1</span>])</span><br><span class="line"><span class="comment">## 输出: '3'</span></span><br><span class="line"></span><br><span class="line">d.popleft() <span class="comment">## 输出: 1</span></span><br><span class="line">d.pop() <span class="comment">## 输出: 3</span></span><br></pre></td></tr></tbody></table></figure><p>也可以限制这个列表的大小，当超出设定的限制时，数据会从对队列另一端被挤出 去(pop)。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = deque(maxlen=<span class="number">30</span>)</span><br></pre></td></tr></tbody></table></figure><p>还可以从任一端扩展这个队列中的数据</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) </span><br><span class="line">d.extendleft([<span class="number">0</span>]) </span><br><span class="line">d.extend([<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]) </span><br><span class="line">print(d)</span><br><span class="line"><span class="comment">## 输出: deque([0, 1, 2, 3, 4, 5, 6, 7, 8])</span></span><br></pre></td></tr></tbody></table></figure><h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h2><p>命名元组把元组变成一个针对简单任务的容器。你不必使用整数索引来访问一个namedtuples的数据。你可以像字典(dict)一样访问namedtuples， 但namedtuples是不可变的。</p><ul><li>命名元组(namedtuple)有两个必需的参数。它们是元组名称和字段名称。</li></ul><p>下面例子中，我们的元组名称是Animal，字段名称是’name’，’age’和’type’。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">perry = Animal(name=<span class="string">"perry"</span>, age=<span class="number">31</span>, type=<span class="string">"cat"</span>) </span><br><span class="line">print(perry)</span><br><span class="line"><span class="comment">## 输出: Animal(name='perry', age=31, type='cat')</span></span><br><span class="line"></span><br><span class="line">print(perry.name)</span><br><span class="line"><span class="comment">## 输出: 'perry'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>namedtuple的每个实例没有对象字典，所以它们很轻量，与普通的元组比，并不 需要更多的内存。这使得它们比字典更快。</li><li>命名元组向后兼容于普通的元组，这意味着可以既使用整数索引，也可以使用名称来访问namedtuple:</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>) </span><br><span class="line">perry = Animal(name=<span class="string">"perry"</span>, age=<span class="number">31</span>, type=<span class="string">"cat"</span>) </span><br><span class="line">print(perry[<span class="number">0</span>])</span><br><span class="line"><span class="comment">## 输出: perry</span></span><br></pre></td></tr></tbody></table></figure><ul><li>可以将一个命名元组转换为字典</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>) </span><br><span class="line">perry = Animal(name=<span class="string">"Perry"</span>, age=<span class="number">31</span>, type=<span class="string">"cat"</span>) </span><br><span class="line">print(perry._asdict())</span><br><span class="line"><span class="comment">## 输出: OrderedDict([('name', 'Perry'), ('age', 31), ...</span></span><br></pre></td></tr></tbody></table></figure><h2 id="enum-Enum"><a href="#enum-Enum" class="headerlink" title="enum.Enum"></a>enum.Enum</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Species</span><span class="params">(Enum)</span>:</span> </span><br><span class="line">  cat = <span class="number">1</span></span><br><span class="line">dog = <span class="number">2</span> </span><br><span class="line"></span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">tom = Animal(name=<span class="string">"Tom"</span>, age=<span class="number">75</span>, type=Species.cat)</span><br></pre></td></tr></tbody></table></figure><h1 id="枚举-enumerate"><a href="#枚举-enumerate" class="headerlink" title="枚举 enumerate"></a>枚举 enumerate</h1><p>enumerate()是在python2.3中引入的。它具有一定的惰性，只在需要的时候才会产生一个(index,value)。</p><blockquote><p>enumerate(sequence, start = 0)</p></blockquote><p>接受一个可迭代的对象作为输入，如list或者set，函数返回一个迭代器。可以使用next()方法获取下一个元素。枚举(enumerate)是Python内置函数，它允许我们遍历数据并自动计数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grapes'</span>, <span class="string">'pear'</span>] </span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> zip(len(my_list),mylist)</span><br><span class="line">print(index,value)</span><br></pre></td></tr></tbody></table></figure><p>等价于</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grapes'</span>, <span class="string">'pear'</span>] </span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(my_list, <span class="number">1</span>):</span><br><span class="line">    print(index, value)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">'apple'</span>) </span><br><span class="line">(<span class="number">2</span>, <span class="string">'banana'</span>) </span><br><span class="line">(<span class="number">3</span>, <span class="string">'grapes'</span>) </span><br><span class="line">(<span class="number">4</span>, <span class="string">'pear'</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grapes'</span>, <span class="string">'pear'</span>] </span><br><span class="line">e = enumerate(my_list)</span><br><span class="line">e.next()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">(<span class="number">0</span>, <span class="string">'apple'</span>)</span><br></pre></td></tr></tbody></table></figure><p>enumerate()的函数实现非常简单，实际相当于以下代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enumerate</span><span class="params">(sequence, start=<span class="number">0</span>)</span>:</span></span><br><span class="line">   n = start</span><br><span class="line">   <span class="keyword">for</span> elem <span class="keyword">in</span> sequence:</span><br><span class="line">    <span class="keyword">yield</span> n,elem</span><br><span class="line">    n += <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h1 id="对象自省"><a href="#对象自省" class="headerlink" title="对象自省"></a>对象自省</h1><p>自省(introspection)，是指在运行时来判断一个对象的类型的能力。 它是Python的强项之一。</p><h2 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h2><p>dir返回一个列表，列出了一个对象所拥有的属性和方法。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">dir(my_list)</span><br><span class="line"><span class="comment"># Output: ['__add__', '__class__', '__contains__', '__delattr__', '__delit # '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattri # '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul # '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne_ # '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '_ # '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', # '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop # 'remove', 'reverse', 'sort']</span></span><br></pre></td></tr></tbody></table></figure><h2 id="type和id"><a href="#type和id" class="headerlink" title="type和id"></a>type和id</h2><ul><li>type函数返回一个对象的类型。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(type(<span class="string">''</span>))</span><br><span class="line"><span class="comment"># Output: &lt;type 'str'&gt;</span></span><br><span class="line">print(type([]))</span><br><span class="line"><span class="comment"># Output: &lt;type 'list'&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>id()函数返回任意不同种类对象的唯一ID。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"Yasoob"</span> </span><br><span class="line">print(id(name))</span><br><span class="line"><span class="comment"># Output: 139972439030304</span></span><br></pre></td></tr></tbody></table></figure><h2 id="inspect模块"><a href="#inspect模块" class="headerlink" title="inspect模块"></a>inspect模块</h2><p>inspect模块也提供了许多有用的函数，来获取活跃对象的信息。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line">print(inspect.getmembers(str))</span><br><span class="line"><span class="comment"># Output: [('__add__', &lt;slot wrapper '__add__' of ... ...</span></span><br></pre></td></tr></tbody></table></figure><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a><strong>lambda</strong>表达式</h1><p>它们在其他语言中也被称为匿名函数。如果你不想在程序中对一个函数使用两次，你也许会想用lambda表达式。</p><blockquote><p>lambda 参数:操作(参数)</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x, y: x + y </span><br><span class="line">print(add(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># Output: 8</span></span><br></pre></td></tr></tbody></table></figure><h1 id="Map、Filter、Reduce"><a href="#Map、Filter、Reduce" class="headerlink" title="Map、Filter、Reduce"></a>Map、Filter、Reduce</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map()会将一个函数映射到一个输入列表的所有元素上。</p><blockquote><p>map(function_to_apply, list_of_inputs)​</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = list(map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, items))</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (x*x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (x+x)</span><br><span class="line">funcs = [multiply, add] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">value = map(<span class="keyword">lambda</span> x: x(i), funcs)</span><br><span class="line">print(list(value))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># [0, 0]</span></span><br><span class="line"><span class="comment"># [1, 2]</span></span><br><span class="line"><span class="comment"># [4, 4]</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>filter()过滤列表中的元素，并且返回一个由所有符合要求的元素所构成的列表，符合要求即函数映射到该元素时返回值为True。filter()是一个内置函数，类似于for循环，但是执行会更快。</p><blockquote><p>filter(function_to_apply, list_of_inputs)</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">number_list = range(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">less_than_zero = filter(<span class="keyword">lambda</span> x: x &lt; <span class="number">0</span>, number_list)</span><br><span class="line">print(list(less_than_zero))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: [-5, -4, -3, -2, -1]</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><p>Reduce()用于对一个列表进行一些计算并返回结果。</p><blockquote><p>reduce(function_to_apply, list_of_inputs)</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">product = reduce((<span class="keyword">lambda</span> x, y: x * y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 24</span></span><br></pre></td></tr></tbody></table></figure><h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><p>如果条件为真，返回真 否则返回假</p><blockquote><p>condition_is_true if condition else condition_is_false</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_fat = <span class="literal">True</span></span><br><span class="line">state = <span class="string">"fat"</span> <span class="keyword">if</span> is_fat <span class="keyword">else</span> <span class="string">"not fat"</span></span><br></pre></td></tr></tbody></table></figure><p>另一个晦涩一点的用法比较少见，它使用了元组:</p><blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(if_test_is_false, if_test_is_true)[test]</span><br></pre></td></tr></tbody></table></figure></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fat = <span class="literal">True</span></span><br><span class="line">fitness = (<span class="string">"skinny"</span>, <span class="string">"fat"</span>)[fat] print(<span class="string">"Ali is "</span>, fitness)</span><br><span class="line"><span class="comment">#输出: Ali is fat</span></span><br></pre></td></tr></tbody></table></figure><h1 id="对象的可变-mutable-与不可变-immutable"><a href="#对象的可变-mutable-与不可变-immutable" class="headerlink" title="对象的可变( mutable)与不可变(immutable)"></a>对象的可变( mutable)与不可变(immutable)</h1><p>每当你将一个变量赋值为另一个可变类型的变量时，对这个数据的任意改动会同时反映到这两个变量上去。新变量只不过是 老变量的一个别名而已。这个情况只是针对可变数据类型。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo = [<span class="string">'hi'</span>] print(foo)</span><br><span class="line"><span class="comment"># Output: ['hi']</span></span><br><span class="line"></span><br><span class="line">bar = foo</span><br><span class="line">bar += [<span class="string">'bye'</span>] print(foo)</span><br><span class="line"><span class="comment"># Output: ['hi', 'bye']</span></span><br></pre></td></tr></tbody></table></figure><br>在Python中当函数被定义时，默认参数只会运算一次，而不是每次被调用时都会重新运算。<br><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to</span><span class="params">(num, target=[])</span>:</span> target.append(num) <span class="keyword">return</span> target</span><br><span class="line">add_to(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># Output: [1]</span></span><br><span class="line"></span><br><span class="line">add_to(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Output: [1, 2]</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>现在每当你在调用这个函数不传入target参数的时候，一个新的列表会被创建。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to</span><span class="params">(element, target=None)</span>:</span> </span><br><span class="line">  <span class="keyword">if</span> target <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    target = [] </span><br><span class="line">  target.append(element) </span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line"></span><br><span class="line">add_to(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># Output: [42]</span></span><br><span class="line"></span><br><span class="line">add_to(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># Output: [42]</span></span><br></pre></td></tr></tbody></table></figure><h1 id="slot"><a href="#slot" class="headerlink" title="__slot__"></a>__slot__</h1><p>在Python中，每个类都有实例属性。默认情况下Python用一个字典来保存一个对象的实例属性 。然而，对于有着已知属性的小类来说，它可能是个瓶颈。这个字典浪费了很多内存。 Python不能在对象创建时直接分配一个固定量的内存来保存所有的属性。</p><p>不过还是有一个方法来规避这个问题。这个方法需要使用__slots__来告诉Python不要使用字典，而且只给一个<strong>固定集合的属性分配空间</strong>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, identifier)</span>:</span></span><br><span class="line">self.name = name </span><br><span class="line">   self.identifier = identifier </span><br><span class="line">   self.set_up()</span><br></pre></td></tr></tbody></table></figure><p>第二段代码会为你的内存减轻负担。通过这个技巧，可以看到内存占用率几乎 40%~50%的减少。<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">__slots__ = [<span class="string">'name'</span>, <span class="string">'identifier'</span>] </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, identifier)</span>:</span></span><br><span class="line">self.name = name </span><br><span class="line">        self.identifier = identifier </span><br><span class="line">        self.set_up()</span><br></pre></td></tr></tbody></table></figure><p></p><h1 id="Comprehension推导式"><a href="#Comprehension推导式" class="headerlink" title="Comprehension推导式"></a>Comprehension推导式</h1><p>推导式(又称解析式)是Python的一种独有特性。推导式是可以从一个数据序列构建另一个新的数据序列的结构体。 共有三种推导：</p><ul><li>列表(list)推导式</li><li>字典(dict)推导式</li><li>集合(set)推导式</li></ul><h2 id="列表-list-推导式"><a href="#列表-list-推导式" class="headerlink" title="列表(list)推导式"></a>列表(list)推导式</h2><p>列表推导式(又称列表解析式)提供了一种简明扼要的方法来创建列表。它的结构是在一个中括号里包含一个表达式，然后是一个for语句，然后是0个或多个for 或者if语句。</p><blockquote><p>variable = [out_exp for out_exp in input_list if out_exp == 2]</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multiples = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> <span class="keyword">is</span> <span class="number">0</span>] </span><br><span class="line">print(multiples)</span><br><span class="line"><span class="comment"># Output: [0, 3, 6, 9, 12, 15, 18, 21, 24, 27]</span></span><br></pre></td></tr></tbody></table></figure><h2 id="字典-dict-推导式"><a href="#字典-dict-推导式" class="headerlink" title="字典(dict)推导式"></a>字典(dict)推导式</h2><p>字典推导和列表推导的使用方法是类似的。如快速对换一个字典的键和值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> some_dict.items()}</span><br></pre></td></tr></tbody></table></figure><h2 id="集合-set-推导式"><a href="#集合-set-推导式" class="headerlink" title="集合(set)推导式"></a>集合(set)推导式</h2><p>它跟列表推导式也是类似的。 唯一的区别在于它使用大括号{}。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">squared = {x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]}</span><br><span class="line">print(squared)</span><br><span class="line"><span class="comment"># Output: {1, 4}</span></span><br></pre></td></tr></tbody></table></figure><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><ul><li>处理一个异常</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  file = open(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">  print(<span class="string">"An EOF error occurred."</span>) <span class="keyword">raise</span> e</span><br></pre></td></tr></tbody></table></figure><ul><li>处理多个异常：在你不知道你要捕捉什么异常时，非常有用</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  file = open(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line"><span class="comment"># 打印一些异常日志，如果你想要的话 </span></span><br><span class="line"><span class="keyword">raise</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h2><p>包裹到finally从 句中的代码不管异常是否触发都将会被执行。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">file = open(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">print(<span class="string">'An IOError occurred. {}'</span>.format(e.args[<span class="number">-1</span>]))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">"This would be printed whether or not an exception occurred!"</span></span><br><span class="line"><span class="comment"># Output: An IOError occurred. No such file or directory</span></span><br><span class="line"><span class="comment"># This would be printed whether or not an exception occurred!</span></span><br></pre></td></tr></tbody></table></figure><h2 id="try-else"><a href="#try-else" class="headerlink" title="try/else"></a>try/else</h2><p>else从句只会在没有异常的情况下执行，而且它会在finally语句之前执行。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'I am sure no exception is going to occur!'</span>)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    print(<span class="string">'exception'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 这里的代码只会在try语句里没有触发异常时运行,</span></span><br><span class="line"><span class="comment"># 但是这里的异常将 *不会* 被捕获</span></span><br><span class="line">print(<span class="string">'This would only run if no exception occurs. And an error here '</span></span><br><span class="line"><span class="string">'would NOT be caught.'</span>)</span><br><span class="line">print(<span class="string">'This would be printed in every case.'</span>)</span><br><span class="line"><span class="comment"># Output: I am sure no exception is going to occur! # This would only run if no exception occurs.</span></span><br><span class="line"><span class="comment"># This would be printed in every case.</span></span><br></pre></td></tr></tbody></table></figure><h1 id="一行式"><a href="#一行式" class="headerlink" title="一行式"></a>一行式</h1><h2 id="简易Web-Server"><a href="#简易Web-Server" class="headerlink" title="简易Web Server"></a>简易Web Server</h2><p>通过网络快速共享文件，进入到共享文件的目录下并在命令行中运行下面的代码:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server</span><br></pre></td></tr></tbody></table></figure><h2 id="漂亮的打印"><a href="#漂亮的打印" class="headerlink" title="漂亮的打印"></a>漂亮的打印</h2><p>Python REPL可漂亮的打印出<strong>列表和字典</strong>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">my_dict = {<span class="string">'name'</span>: <span class="string">'Yasoob'</span>, <span class="string">'age'</span>: <span class="string">'undefined'</span>}</span><br><span class="line">pprint(my_dict)</span><br></pre></td></tr></tbody></table></figure><h2 id="脚本性能分析"><a href="#脚本性能分析" class="headerlink" title="脚本性能分析"></a>脚本性能分析</h2><p>cProfile是一个比profile更快的实现，因为它是用c写的。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m cProfile my_script.py</span><br></pre></td></tr></tbody></table></figure><h2 id="CSV转换为json"><a href="#CSV转换为json" class="headerlink" title="CSV转换为json"></a><strong>CSV</strong>转换为json</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">"import csv,json;print json.dumps(list(csv.reader(open('csv.csv'))))</span></span><br></pre></td></tr></tbody></table></figure><h2 id="列表辗平"><a href="#列表辗平" class="headerlink" title="列表辗平"></a>列表辗平</h2><p>通过使用itertools包中的itertools.chain.from_iterable轻松快速的辗平一个列表。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a_list = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">print(list(itertools.chain.from_iterable(a_list)))</span><br><span class="line"><span class="comment"># Output: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">print(list(itertools.chain(*a_list)))</span><br><span class="line"><span class="comment"># Output: [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></tbody></table></figure><h2 id="一行式的构造器"><a href="#一行式的构造器" class="headerlink" title="一行式的构造器"></a>一行式的构造器</h2><p>避免类初始化时大量重复的赋值语句</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b, c, d, e, f)</span>:</span></span><br><span class="line">    self.__dict__.update({k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> locals().items()})</span><br></pre></td></tr></tbody></table></figure><h1 id="For-Else"><a href="#For-Else" class="headerlink" title="For-Else"></a>For-Else</h1><p>for循环还有一个else从句，我们大多数人并不熟悉。这个else从句会在循环正常结束时执行。这意味着，循环没有遇到任何break。</p><p>有个常见的构造是跑一个循环，并查找一个元素。如果这个元素被找到了，我们使 用break来中断这个循环。有两个场景会让循环停下来。</p><ul><li>第一个是当一个元素被找到，break被触发。 </li><li>第二个场景是循环结束。</li></ul><p>现在我们也许想知道其中哪一个，才是导致循环完成的原因。一个方法是先设置一个标记，然后在循环结束时打上标记。另一个是使用else从句。</p><p><strong>简而言之：当循环自然终结（未调用break），else从句会被执行一次。</strong></p><p>以下例子会找出2到10之间的数字的因子。附加的else语句块，用来抓住质数： </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">      <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">        print( n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n/x) <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># loop fell through without finding a factor</span></span><br><span class="line">        print(n, <span class="string">'is a prime number'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># output        </span></span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2.0</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3.0</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4.0</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3.0</span></span><br></pre></td></tr></tbody></table></figure><h1 id="使用C扩展"><a href="#使用C扩展" class="headerlink" title="使用C扩展"></a>使用<strong>C</strong>扩展</h1><p>CPython使得Python可以轻松调用C代码。</p><h2 id="ctypes"><a href="#ctypes" class="headerlink" title="ctypes"></a>ctypes</h2><p>ctypes模块提供了和C语言 兼容的数据类型和函数来加载dll文件，因此在调用时不需对源文件做任何的修改。</p><ol><li>实现两数求和的C代码，保存为add.c</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_float</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_float</span><span class="params">(<span class="keyword">float</span> num1, <span class="keyword">float</span> num2)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>接下来将C文件编译为.so文件(windows下为DLL)</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">For Linux</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -Wl,-soname,adder -o adder.so -fPIC add.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">For Mac</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -Wl,-install_name,adder.so -o adder.so -fPIC add.c</span></span><br></pre></td></tr></tbody></table></figure><ol><li>现在在Python代码中来调用它</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#load the shared object file</span></span><br><span class="line">adder = CDLL(<span class="string">'./adder.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find sum of integers</span></span><br><span class="line">res_int = adder.add_int(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Sum of 4 and 5 = "</span> + str(res_int)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find sum of floats</span></span><br><span class="line">a = c_float(<span class="number">5.5</span>)</span><br><span class="line">b = c_float(<span class="number">4.1</span>)</span><br><span class="line">add_float = adder.add_float</span><br><span class="line">add_float.restype = c_float</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Sum of 5.5 and 4.1 = "</span>, str(add_float(a, b))</span><br><span class="line"></span><br><span class="line">Sum of <span class="number">4</span> <span class="keyword">and</span> <span class="number">5</span> = <span class="number">9</span></span><br><span class="line">Sum of <span class="number">5.5</span> <span class="keyword">and</span> <span class="number">4.1</span> = <span class="number">9.60000038147</span></span><br></pre></td></tr></tbody></table></figure><p>这种方法虽然简单，清晰，但是却很受限。例如，并不能在C中对对象进行操作。</p><h2 id="SWIG"><a href="#SWIG" class="headerlink" title="SWIG"></a>SWIG</h2><p>SWIG是Simplified Wrapper and Interface Generator的缩写。是Python中调用C代码的另一种 方法。在这个方法中，开发人员必须编写一个额外的接又文件来作为SWIG(终端工具)的入口。Python开发者一般不会采用这种方法，因为大多数情况它会带来不必要的复杂。而当你有一个C/C++代码库需要被多种语言调用时，这将是个非常不错的选择。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">​```C</span><br><span class="line"><span class="comment">#include</span></span><br><span class="line">double My_variable = <span class="number">3.0</span>;</span><br><span class="line">int fact(int n) {</span><br><span class="line">  ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译它</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unix % swig -python example.i</span><br><span class="line">unix % gcc -c example.c example_wrap.c \</span><br><span class="line"> -I/usr/local/include/python2.1</span><br><span class="line">unix % ld -shared example.o example_wrap.o -o _example.so</span><br></pre></td></tr></tbody></table></figure><p>Python的调用</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> example</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.fact(<span class="number">5</span>) </span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.my_mod(<span class="number">7</span>,<span class="number">3</span>) </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.get_time()</span><br><span class="line"><span class="string">'Sun Feb 11 23:01:07 1996'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Python-C-API"><a href="#Python-C-API" class="headerlink" title="Python/C API"></a>Python/C API</h2><p>Python/C API可能是被最广泛使用的方法。它不仅简单，而且可以在C代码中操作你的Python对象。这种方法需要以特定的方式来编写C代码以供Python去调用它。所有的Python对象都被表 示为一种叫做PyObject的结构体，并且Python.h头文件中提供了各种操作它的函数。</p><ol><li>编写一个C扩展，添加所有元素到一个Python列表(所有元素都是数字)</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Python.h has all the required function definitions to manipulate the Pyt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"><span class="comment">//This is the function that is called from your python code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">addList_add</span><span class="params">(PyObject* self, PyObject* args)</span></span>{</span><br><span class="line">    PyObject * listObj;</span><br><span class="line">    <span class="keyword">if</span> (! PyArg_ParseTuple( args, <span class="string">"O"</span>, &amp;listObj ))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">long</span> length = PyList_Size(listObj); <span class="comment">//iterate over all the elements</span></span><br><span class="line"><span class="keyword">int</span> i, sum =<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">sum += elem;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> addList_docs[] =</span><br><span class="line"><span class="string">"add( ): add all elements of the list\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyMethodDef addList_funcs[] = {</span><br><span class="line">{<span class="string">"add"</span>, (PyCFunction)addList_add, METH_VARARGS, addList_docs}, {<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">initaddList</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line">    Py_InitModule3(<span class="string">"addList"</span>, addList_funcs,</span><br><span class="line">            <span class="string">"Add all ze lists"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Python.h头文件中包含了所有需要的类型(Python对象类型的表示)和函数定义(对 Python对象的操作)<br> 接下来我们编写将要在Python调用的函数, 函数传统的命名方式由{模块名}_{函数 名}组成，所以我们将其命名为addList_add 然后填写想在模块内实现函数的相关信息表，每行一个函数，以空行作为结束 最后的模块初始化块签名为PyMODINIT_FUNC init{模块名}。</p><ol><li>现在我们已经编写完C模块了。将下列代码保存为setup.py</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​</span><br></pre></td></tr></tbody></table></figure><h1 id="build-the-modules"><a href="#build-the-modules" class="headerlink" title="build the modules"></a>build the modules</h1><p>​```</p><p>from distutils.core import setup, Extension</p><p>setup(name=’addList’, version=’1.0’, \ ext_modules=[Extension(‘addList’, [‘adder.c’])])<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行，现在应该已经将我们的C文件编译安装到我们的Python模块中了。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">python setup.py install</span><br></pre></td></tr></tbody></table></figure><p></p><ol><li>验证</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#module that talks to the C code</span></span><br><span class="line"><span class="keyword">import</span> addList l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Sum of List - "</span> + str(l) + <span class="string">" = "</span> + str(addList.add(l))</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">Sum of List - [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] = <span class="number">15</span></span><br></pre></td></tr></tbody></table></figure><h2 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h2><h1 id="Open"><a href="#Open" class="headerlink" title="Open()"></a>Open()</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'photo.jpg'</span>, <span class="string">'r+'</span>) <span class="keyword">as</span> f: </span><br><span class="line">  jpgdata = f.read()</span><br></pre></td></tr></tbody></table></figure><p>open的第一个参数是文件名。第二个(mode 打开模式)决定了这个文件如何被打开。</p><ul><li>如果你想读取文件，传入r </li><li>如果你想读取并写入文件，传入r+ </li><li>如果你想覆盖写入文件，传入w </li><li>如果你想在文件末尾附加内容，传入a</li></ul><p>如果不传入任意编码，一个系统 - 以及Python -指定的默认选项将被选中。你也许会·去依赖这个默认选项，但这个默认选项经常是错误的，或者默认编码实际上不能表达文件里的所有字符(这将经常发生在Python 2.x和/或Windows)。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'photo.jpg'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> inf:</span><br><span class="line">jpgdata = inf.read()</span><br><span class="line"><span class="keyword">if</span> jpgdata.startswith(<span class="string">b'\xff\xd8'</span>):</span><br><span class="line">text = <span class="string">u'This is a JPEG file (%d bytes long)\n'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">text = <span class="string">u'This is a random file (%d bytes long)\n'</span></span><br><span class="line"><span class="keyword">with</span> io.open(<span class="string">'summary.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> outf: </span><br><span class="line">  outf.write(text % len(jpgdata))</span><br></pre></td></tr></tbody></table></figure><h1 id="Python-2-3"><a href="#Python-2-3" class="headerlink" title="Python 2+3"></a>Python 2+3</h1><h2 id="Future模块导入"><a href="#Future模块导入" class="headerlink" title="Future模块导入"></a>Future模块导入</h2><p>Future模块可以帮你在Python2中导入 Python3的功能。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function </span><br><span class="line">print(<span class="keyword">print</span>)</span><br><span class="line"><span class="comment"># Output: &lt;built-in function print&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="模块重命名"><a href="#模块重命名" class="headerlink" title="模块重命名"></a>模块重命名</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib_request <span class="comment"># for Python 3</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">  <span class="keyword">import</span> urllib2 <span class="keyword">as</span> urllib_request <span class="comment"># for Python 2</span></span><br></pre></td></tr></tbody></table></figure><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>Python中的协程和生成器很相似但又稍有不同。主要区别在于: </p><ul><li><p>生成器是数据的生产者</p></li><li><p>协程则是数据的消费者</p></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern)</span>:</span></span><br><span class="line">  print(<span class="string">"Searching for"</span>, pattern)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">line = (<span class="keyword">yield</span>)</span><br><span class="line"><span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">print(line)</span><br></pre></td></tr></tbody></table></figure><p>我们可以通过send()方法向它传值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">search = grep(<span class="string">'coroutine'</span>)</span><br><span class="line">next(search)</span><br><span class="line"><span class="comment">#output: Searching for coroutine </span></span><br><span class="line">search.send(<span class="string">"I love you"</span>) </span><br><span class="line">search.send(<span class="string">"Don't you love me?"</span>) </span><br><span class="line">search.send(<span class="string">"I love coroutine instead!"</span>) </span><br><span class="line"><span class="comment">#output: I love coroutine instead!</span></span><br></pre></td></tr></tbody></table></figure><p>发送的值会被yield接收。</p><p>next()方法启动一个协程。就像协程中包含的生成器并不是立刻执行，而是通过next()方法来响应send()方法。因此，你必须通过next()方法来执行yield表达式。</p><p>可以通过调用close()方法来关闭一个协程。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search = grep(<span class="string">'coroutine'</span>)</span><br><span class="line">search.close()</span><br></pre></td></tr></tbody></table></figure><h1 id="函数缓存"><a href="#函数缓存" class="headerlink" title="函数缓存"></a>函数缓存</h1><p>在Python 3.2以后版本，lru_cache的装饰器，允许我们将一个函数的返回值快速地缓存或取消缓存。</p><p>实现一个斐波那契计算器，并使用lru_cache。</p><ul><li>maxsize参数是告诉lru_cache，最多缓存最近多少个返回值。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="meta">@lru_cache(maxsize=32)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line"><span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([fib(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line"><span class="comment"># Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></tbody></table></figure><ul><li>也可以轻松地对返回值清空缓存</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib.cache_clear()</span><br></pre></td></tr></tbody></table></figure><h1 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h1><p>上下文管理器允许你在有需要的时候，精确地分配和释放资源。with确保我们的文件会被关闭，而不用关注嵌套代码如何退出。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'some_file'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> opened_file: </span><br><span class="line">  opened_file.write(<span class="string">'Hola!'</span>)</span><br></pre></td></tr></tbody></table></figure><p>等价于：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file = open(<span class="string">'some_file'</span>, <span class="string">'w'</span>) </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  file.write(<span class="string">'Hola!'</span>) </span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">file.close()</span><br></pre></td></tr></tbody></table></figure><h2 id="自行实现上下文管理器-—-基于类的实现"><a href="#自行实现上下文管理器-—-基于类的实现" class="headerlink" title="自行实现上下文管理器 — 基于类的实现"></a>自行实现上下文管理器 — 基于类的实现</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, file_name, method)</span>:</span></span><br><span class="line">      self.file_obj = open(file_name, method)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span> </span><br><span class="line">  <span class="keyword">return</span> self.file_obj</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, type, value, traceback)</span>:</span> </span><br><span class="line">  print(<span class="string">"Exception has been handled"</span>) </span><br><span class="line">  self.file_obj.close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure><p>通过定义enter和exit方法，我们可以在with语句里使用它。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> File(<span class="string">'demo.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">  opened_file.write(<span class="string">'Hola!'</span>)</span><br></pre></td></tr></tbody></table></figure><p>exit函数接受三个参数。这些参数对于每个上下文管理器类中的exit方法都是必须的。</p><ol><li>with语句先暂存了File类的exit方法 </li><li>然后它调用File类的enter方法</li><li>enter__方法打开文件并返回给with语句 </li><li>打开的文件句柄被传递给opened_file参数 </li><li><p>我们使用.write()来写文件</p></li><li><p>with语句调用之前暂存的exit方法 </p></li><li><p>exit方法关闭了文件</p><p>在4与6之前，如果发生了异常，Python会将异常的type,value和traceback传递给exit方法。它让exit方法来决定如何关闭文件以及是否需要其他步骤。</p></li><li><p>如果exit返回的是True，那么这个异常就被优雅地处理了。</p></li><li>如果exit返回的是True以外的任何东西，那么这个异常将被with语句抛出。</li></ol><h2 id="自行实现上下文管理器-—-基于生成器的实现"><a href="#自行实现上下文管理器-—-基于生成器的实现" class="headerlink" title="自行实现上下文管理器 — 基于生成器的实现"></a>自行实现上下文管理器 — 基于生成器的实现</h2><p>还可以使用一个生成器函数来实现一 个上下文管理器，而不是使用一个类。</p><ol><li>Python解释器遇到了yield关键字。因为这个缘故它创建了一个生成器而不是一个普通的函数。</li><li>因为这个装饰器，contextmanager会被调用并传入函数名(open_file)作为 参数。</li><li>contextmanager函数返回一个以GeneratorContextManager对象封装过的 生成器。</li><li>这个GeneratorContextManager被赋值给open_file函数，我们实际上是在 调用GeneratorContextManager对象。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_file</span><span class="params">(name)</span>:</span></span><br><span class="line">f = open(name, <span class="string">'w'</span>) </span><br><span class="line">  <span class="keyword">yield</span> f</span><br><span class="line">f.close()</span><br></pre></td></tr></tbody></table></figure><p>等价于：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open_file(<span class="string">'some_file'</span>) <span class="keyword">as</span> f: </span><br><span class="line">  f.write(<span class="string">'hola!'</span>)</span><br></pre></td></tr></tbody></table></figure><h1 id="Pythonic的代码"><a href="#Pythonic的代码" class="headerlink" title="Pythonic的代码"></a>Pythonic的代码</h1><h2 id="print-字符串格式化"><a href="#print-字符串格式化" class="headerlink" title="print 字符串格式化"></a>print 字符串格式化</h2><p>非常Pythonic的代码应该是这样：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Hello %(name)s!'</span>%{<span class="string">'name'</span>:<span class="string">'Tom'</span>})</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'{greet} from {language}.'</span>.format(greet = <span class="string">'Hello world'</span>,language = <span class="string">'Python'</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="风格检查工具"><a href="#风格检查工具" class="headerlink" title="风格检查工具"></a>风格检查工具</h2><p>风格检查工具提出了保持代码一致性细节的要求。包括代码布局、注释、命名规范等方面的要求。这种工具有PEP8、Pychecker、Pylint等。如PEP8的安装与使用如下：</p><ul><li>安装：使用conda或者pip进行安装</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda install -c anaconda pycodestyle</span><br></pre></td></tr></tbody></table></figure><p>or</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install -U pycodestyle</span><br></pre></td></tr></tbody></table></figure><ul><li>简单的检测代码</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pycodestyle --first test.py</span><br></pre></td></tr></tbody></table></figure><ul><li>还可以使用—show-source参数让PEP8显示每一个错误和警告对应的代码</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pycodestyle --show-source --show-pep8 test.py</span><br></pre></td></tr></tbody></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol><li>函数注释：给外部可访问的函数与方法添加文档注释。注释要清楚的描述方法的功能，并对参数、返回值以及可能发生的异常进行说明。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FuncName</span><span class="params">(parameter1,parameter2)</span>:</span></span><br><span class="line">  <span class="string">"""Describe what this Function does:</span></span><br><span class="line"><span class="string">     # such as "Find wheter the special string is in the queue or not"</span></span><br><span class="line"><span class="string">     Args:</span></span><br><span class="line"><span class="string">     parameter1:parameter type,what is the parameter used for.</span></span><br><span class="line"><span class="string">     parameter2:parameter type,what is the parameter used for.</span></span><br><span class="line"><span class="string">      return type, return value.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  function body</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br></pre></td></tr></tbody></table></figure><ol><li>推荐在文件头中包含copyright申明、模块描述等，如有必要可以加入作者信息及变更记录。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Licensed Materials - Property of CorpA</span></span><br><span class="line"><span class="string">(C) Copyright A Corp.1999,2011 All Right Reserved</span></span><br><span class="line"><span class="string">CopyRight statement and purpose...</span></span><br><span class="line"><span class="string">-------------------------------------------------------------</span></span><br><span class="line"><span class="string"># @Time: 2020/2/27 12:08 </span></span><br><span class="line"><span class="string"># @Author: GraceKoo</span></span><br><span class="line"><span class="string"># @File: 55_jump-game.py</span></span><br><span class="line"><span class="string"># @Desc:https://leetcode-cn.com/problems/jump-game/</span></span><br><span class="line"><span class="string">-------------------------------------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></tbody></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>Python的内建命名空间是支持一小部分常量的，如True、Flase、None等。只是Python没有提供常量的直接方式而已。</p><ul><li>常量名所有字母应大写，用下划线连接各个单词，如：MAX_OVERFLOW</li><li>将常量集中到一个文件</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_const</span>:</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ConstError</span><span class="params">(TypeError)</span>:</span><span class="keyword">pass</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ConstCaseError</span><span class="params">(constError)</span>:</span><span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_setattr_</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.__dict__.has_key(name):</span><br><span class="line">      <span class="keyword">raise</span> self.ConstError, <span class="string">"can not change const"</span> %name</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> name.isupper():</span><br><span class="line">      <span class="keyword">raise</span> self.ConstCaseError,\</span><br><span class="line">        <span class="string">'const name "%s" is not all uppercase'</span> %name</span><br><span class="line">    self.__dict__[name] = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.modules[__name__]=_const()</span><br></pre></td></tr></tbody></table></figure><p>设置常量<br></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> const</span><br><span class="line">const.COMPANY = <span class="string">"IBM"</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>使用常量</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> constant <span class="keyword">import</span> const</span><br><span class="line">print(const.COMPANY)</span><br></pre></td></tr></tbody></table></figure><h1 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h1><p>内建函数type() 用于返回当前对象的类型，但type()有时并不能准确返回结果。建议使用isinstance()来检测。</p><blockquote><p>isinstance(object, classinfo)</p></blockquote><p>classinfo为直接或者间接的类名，基本类型名称或者由它们组成的元组。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isinstance(<span class="number">2</span>, float)</span><br><span class="line">isinstance(<span class="string">"a"</span>, (str.unicode))</span><br><span class="line">isinstance((<span class="number">2</span>,<span class="number">3</span>), (str, list, tuple))</span><br></pre></td></tr></tbody></table></figure><h1 id="浮点计算"><a href="#浮点计算" class="headerlink" title="浮点计算"></a>浮点计算</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">1.1</span> + <span class="number">1.1</span> + <span class="number">1.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0.30000000000003</span></span><br></pre></td></tr></tbody></table></figure><p>如果对精度要求比较高，可以用Decimal来进行处理。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Decimal <span class="keyword">import</span> *</span><br><span class="line">getcontext().prec = <span class="number">6</span></span><br><span class="line">Decimal(<span class="number">1</span>) / Decimal(<span class="number">7</span>) <span class="comment"># Decimal('0.142857') 保留6个有效数字</span></span><br><span class="line"></span><br><span class="line">Decimal(<span class="string">'50.5679'</span>).quantize(Decimal(<span class="string">'0.00'</span>)) <span class="comment"># Decimal('50.57') 四舍五入保留两位小数</span></span><br></pre></td></tr></tbody></table></figure><h1 id="官方资源地址"><a href="#官方资源地址" class="headerlink" title="官方资源地址"></a>官方资源地址</h1><p><a href="https://docs.python.org/2/library/pdb.html" target="_blank" rel="noopener">https://docs.python.org/2/library/pdb.html</a> </p><p><a href="https://docs.python.org/3/library/pdb.html" target="_blank" rel="noopener">https://docs.python.org/3/library/pdb.html</a></p><h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><ul><li>《Intermediate Python》</li><li>《编写高质量代码 改善Python程序的91个建议》</li><li>《Python核心编程 第三版》</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;args-和-Kwargs&quot;&gt;&lt;a href=&quot;#args-和-Kwargs&quot; class=&quot;headerlink&quot; title=&quot;*args 和 **Kwargs&quot;&gt;&lt;/a&gt;&lt;strong&gt;*args&lt;/strong&gt; 和 **Kwargs&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;*args 是用来发送一个非键值对的可变数量的参数列表给一个函数&lt;/li&gt;
&lt;li&gt;kwargs 允许你将不定长度的键值对, 作为参数传递给一个函数。 如果你想要在一个函 数里处理带名字的参数, 你应该使用kwargs。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_args_kwargs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg1, arg2, arg3)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;arg1:&quot;&lt;/span&gt;, arg1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;arg2:&quot;&lt;/span&gt;, arg2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;arg3:&quot;&lt;/span&gt;, arg3)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Test *args&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;args = (&lt;span class=&quot;string&quot;&gt;&quot;two&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test_args_kwargs(*args)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arg1: two&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arg2: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arg3: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Test **kwargs&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kwargs = {&lt;span class=&quot;string&quot;&gt;&quot;arg3&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;arg2&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;two&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;arg1&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test_args_kwargs(**kwargs)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arg1: &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arg2: two&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arg3: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Language" scheme="https://unknown.yuzhouwan.com/categories/Language/"/>
    
    
      <category term="Python" scheme="https://unknown.yuzhouwan.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://unknown.yuzhouwan.com/posts/6678/"/>
    <id>https://unknown.yuzhouwan.com/posts/6678/</id>
    <published>2020-01-30T23:55:00.000Z</published>
    <updated>2020-11-23T03:16:17.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><ol><li>客户端通过向服务器端<strong>发送一个请求报文SYN</strong>来创建一个主动打开。</li><li>Server端接受连接后<strong>回复ACK报文</strong>，并为这次连接分配资源。</li><li>Client端接收到<strong>ACK报文</strong>后也向Server段发送报文，并分配资源，这样TCP连接就建立了。</li></ol><a id="more"></a><p><img data-src="/images/data/Screen Shot 2020-11-08 at 00.57.08.png" alt="Screen Shot 2020-11-08 at 00.57.08"></p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p><em>注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.</em></p><ol><li>客户端发送一个<strong>FIN报文</strong>. 客户端进入 <strong>FIN-WAIT 状态</strong>. 该状态下客户端只接收数据, 不再发送数据.</li><li>服务器接收到带有 FIN = 1 的数据分段, 发送带有 <strong>ACK = 1 的剩余数据分段</strong>, 确认收到客户端发来的 FIN 信息.</li><li>服务器<strong>等到所有数据传输结束,</strong> 向客户端发送一个带有 <strong>FIN = 1 的数据分段</strong>, 并进入 <strong>CLOSE-WAIT 状态</strong>, 等待客户端发来带有 ACK = 1 的确认报文.</li><li>客户端收到服务器发来带有 FIN = 1 的报文, 返回 <strong>ACK = 1 的报文</strong>确认, <strong>为了防止服务器端未收到需要重发</strong>, 进入 <strong>TIME-WAIT</strong> 状态. 服务器接收到报文后关闭连接. 客户端等待 <strong>2MSL 后未收到回复, 则认为服务器成功关闭</strong>, 客户端关闭连接。</li></ol><blockquote><p> 注：MSL是报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。RFC规定为两分钟，实际应用中常用的是30秒，1分钟和2分钟。</p></blockquote><p><img data-src="/images/data/Screen Shot 2020-11-08 at 00.57.38.png" alt="Screen Shot 2020-11-08 at 00.57.38"></p><p>图解: <a href="http://blog.csdn.net/whuslei/article/details/6667471" target="_blank" rel="noopener">http://blog.csdn.net/whuslei/article/details/6667471</a></p><h1 id="七层网络模型"><a href="#七层网络模型" class="headerlink" title="七层网络模型"></a>七层网络模型</h1><p>网络通信的分层模型讲起：七层模型，也称OSI (Open System Interconnection)模型。</p><p><img data-src="/images/data/Screen Shot 2020-11-08 at 11.56.48.png" alt="Screen Shot 2020-11-08 at 11.56.48"></p><h1 id="TCP和UDP对比"><a href="#TCP和UDP对比" class="headerlink" title="TCP和UDP对比"></a>TCP和UDP对比</h1><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th>TCP</th><th style="text-align:left">UDP</th></tr></thead><tbody><tr><td style="text-align:left">是否连接</td><td>面向连接</td><td style="text-align:left">无连接，想发就发</td></tr><tr><td style="text-align:left">是否可靠</td><td>可靠传输，使用流量控制和拥塞控制</td><td style="text-align:left">不可靠传输，不使用流量控制和拥塞控制</td></tr><tr><td style="text-align:left">连接对象个数</td><td>只能是一对一通信</td><td style="text-align:left">支持一对一，一对多，多对一和多对多交互通信</td></tr><tr><td style="text-align:left">传输方式</td><td>面向字节流</td><td style="text-align:left">面向报文</td></tr><tr><td style="text-align:left">首部开销</td><td>首部最小20字节，最大60字节</td><td style="text-align:left">首部开销小，仅8字节</td></tr><tr><td style="text-align:left">适用场景</td><td>适用于要求可靠传输的应用，例如文件传输</td><td style="text-align:left">适用于实时应用（IP电话、视频会议、直播等）</td></tr></tbody></table></div><p>总结</p><ul><li>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。</li><li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li><li>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</li></ul><h1 id="Socket-Ip-address-TCP-UDP-port"><a href="#Socket-Ip-address-TCP-UDP-port" class="headerlink" title="Socket(Ip address+ TCP/UDP + port)"></a>Socket(Ip address+ TCP/UDP + port)</h1><p><strong>套接字用于描述IP地址和端口，是一个通信链的句柄。</strong>应用程序通过套接字向网络发出请求或应答网络请求。注意的是套接字既不是程序也不是协议，只是<strong>操作系统提供给通信层的一组抽象API接口。</strong></p><p>Socket=Ip address+ TCP/UDP + port</p><p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.31.08.png" alt="Screen Shot 2020-11-08 at 15.31.08"></p><p>推荐: <a href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></p><p>使用Socket套接字需要传入哪些参数？</p><ul><li><p><strong>地址族(Address Family)</strong></p><p>地址族通常作为 socket() 函数的第一个参数。</p><p>socket.AF_INET 　IPv4地址族，(host, port) 形式的二元组，host是一个表示网络主机的字符串，port为套接字的端口号。AF_INET对应的数值是：2。</p><p>socket.AF_INET6 　(host, port, flowinfo, scopeid) 形式的四元组。AF_INET6对应的数值是：23。</p></li><li><p><strong>套接字类型（Type）</strong></p><p>套接字类型用于 socket() 函数的第二个参数。</p><p>但是只有 SOCK_STREAM （TCP）和 SOCK_DGRAM （UDP）是比较常见的。</p></li></ul><h1 id="怎么强行关闭客户端和服务器的连接"><a href="#怎么强行关闭客户端和服务器的连接" class="headerlink" title="怎么强行关闭客户端和服务器的连接"></a>怎么强行关闭客户端和服务器的连接</h1><ul><li><p>关闭TCP连接是指TCP协议层的东西，就是两个TCP端之间交换了一些协议包（FIN，RST等），具体的交换过程可以看TCP协议。</p></li><li><p>而关闭socket是指<strong>关闭用户应用程序中的socket句柄，释放相关资源</strong>。但是当用户<strong>关闭socket句柄时会隐含的触发TCP连接的关闭过程</strong>。</p></li></ul><p>TCP连接的关闭过程有两种，一种是<strong>优雅关闭</strong>（graceful close），一种是<strong>强制关闭</strong>（hard close或abortive close）</p><ul><li>优雅关闭是指，如果<strong>发送缓存</strong>中还有数据未发出则其发出去，<strong>并且收到所有数据的ACK之后，发送FIN包，开始关闭过程</strong>。</li><li>强制关闭是指如果<strong>缓存中</strong>还有数据，则这些数据都将被丢弃，然后发送<strong>RST</strong>包，直接重置TCP连接。</li></ul><p>shutdown函数，用于关闭TCP连接，但并不关闭socket句柄。</p><ul><li>SD_RECEIVE表明<strong>关闭接收通道</strong>，在该socket上不能再接收数据，如果当前接收缓存中仍有未取出数据或者<strong>以后再有数据到达，则TCP会向发送端发送RST包</strong>，将连接重置。</li><li>SD_SEND表明<strong>关闭发送通道</strong>，TCP会将发送缓存中的数据都发送完毕并<strong>收到所有数据的ACK后向对端发送FIN包</strong>，表明本端没有更多数据发送。这个是一个优雅关闭过程。</li><li>SD_BOTH则表示<strong>同时关闭接收通道和发送通道</strong>。</li></ul><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><div class="table-container"><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">定义</th></tr></thead><tbody><tr><td style="text-align:left">1xx 报告</td><td style="text-align:left">接收到请求，继续进程</td></tr><tr><td style="text-align:left">2xx 成功</td><td style="text-align:left">步骤成功接收，被理解，并被接受</td></tr><tr><td style="text-align:left">3xx 重定向</td><td style="text-align:left">为了完成请求,必须采取进一步措施</td></tr><tr><td style="text-align:left">4xx 客户端出错</td><td style="text-align:left">请求包括错的顺序或不能完成</td></tr><tr><td style="text-align:left">5xx 服务器出错</td><td style="text-align:left">服务器无法完成显然有效的请求</td></tr></tbody></table></div><p>403: Forbidden<br>404: Not Found</p><h2 id="HTTP1-0和HTTP1-1"><a href="#HTTP1-0和HTTP1-1" class="headerlink" title="HTTP1.0和HTTP1.1"></a>HTTP1.0和HTTP1.1</h2><p>推荐: <a href="http://blog.csdn.net/elifefly/article/details/3964766" target="_blank" rel="noopener">http://blog.csdn.net/elifefly/article/details/3964766</a></p><p><strong>HTTP 1.0*规定浏览器与服务器只保持短暂的连接</strong>，浏览器的每次请求都需要与服务器建立一个<em>TCP</em>连接，服务器完成请求处理后立即断开<em>TCP</em>连接，服务器不跟踪每个客户也不记录过去的请求。</p><p><strong>HTTP1.1改进点</strong></p><ol><li><strong>支持了长链接</strong>：在一个<em>TCP</em>连接上可以传送多个<em>HTTP</em>请求和响应，减少了建立和关闭连接的消耗和延迟。</li><li><strong>HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求</strong>。但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</li><li><strong>增加请求头Host字段</strong>：一个服务器多个虚拟Web站点。</li><li><strong>身份认证,状态管理,Cache缓存等机制</strong>相关的请求头和响应头。</li></ol><h2 id="HTTP常见请求头与响应头"><a href="#HTTP常见请求头与响应头" class="headerlink" title="HTTP常见请求头与响应头"></a>HTTP常见请求头与响应头</h2><p>常见请求头：Request</p><div class="table-container"><table><thead><tr><th>Accept</th><th>可接受的响应内容类型（<code>Content-Types</code>）。</th><th><code>Accept: text/plain</code></th><th>固定</th></tr></thead><tbody><tr><td>Accept-Charset</td><td>浏览器可接受的字符集</td><td><code>Accept-Charset: utf-8</code></td><td>固定</td></tr><tr><td>Accept-Encoding</td><td>可接受的响应内容的数据压缩格式</td><td><code>Accept-Encoding: gzip, deflate</code></td><td>固定</td></tr><tr><td>Accept-Language</td><td>可接受的响应内容语言列表。</td><td><code>Accept-Language: en-US</code></td><td>固定</td></tr><tr><td>Accept-Datetime</td><td>可接受的按照时间来表示的响应内容版本</td><td>Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT</td><td>临时</td></tr><tr><td>Cache-Control</td><td>用来指定当前的请求/回复中的，是否使用缓存机制。</td><td></td></tr></tbody></table></div><p>常见响应头：Response</p><div class="table-container"><table><thead><tr><th style="text-align:left">响应头</th><th style="text-align:left">说明</th><th style="text-align:left">示例</th><th style="text-align:left">状态</th></tr></thead><tbody><tr><td style="text-align:left">Age</td><td style="text-align:left">响应对象在代理缓存中存在的时间，以秒为单位</td><td style="text-align:left"><code>Age: 12</code></td><td style="text-align:left">固定</td></tr><tr><td style="text-align:left">Cache-Control</td><td style="text-align:left">通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒</td><td style="text-align:left"><code>Cache-Control: max-age=3600</code></td><td style="text-align:left">固定</td></tr></tbody></table></div><p><a href="https://itbilu.com/other/relate/EJ3fKUwUx.html" target="_blank" rel="noopener">https://itbilu.com/other/relate/EJ3fKUwUx.html</a></p><p><a href="https://juejin.im/post/6844903745004765198" target="_blank" rel="noopener">https://juejin.im/post/6844903745004765198</a></p><h2 id="HTTP协议以及协议头部中表示数据类型的字段"><a href="#HTTP协议以及协议头部中表示数据类型的字段" class="headerlink" title="HTTP协议以及协议头部中表示数据类型的字段"></a>HTTP协议以及协议头部中表示数据类型的字段</h2><div class="table-container"><table><thead><tr><th>Accept</th><th>可接受的响应内容类型（<code>Content-Types</code>）。</th><th><code>Accept: text/plain</code></th><th>固定</th></tr></thead><tbody><tr><td>Accept-Charset</td><td>浏览器可接受的字符集</td><td><code>Accept-Charset: utf-8</code></td><td>固定</td></tr><tr><td>Accept-Encoding</td><td>可接受的响应内容的数据压缩格式</td><td><code>Accept-Encoding: gzip, deflate</code></td><td>固定</td></tr><tr><td>Accept-Language</td><td>可接受的响应内容语言列表。</td><td><code>Accept-Language: en-US</code></td><td>固定</td></tr></tbody></table></div><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>HTTP请求8种方法介绍<br>HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。</p><ol><li>GET</li></ol><p><strong>GET请求会显示请求指定的资源</strong>。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的幂等的操作中。</p><p>GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。</p><ol><li>HEAD</li></ol><p><strong>HEAD方法与GET方法一样，都是向服务器发出指定资源的请求</strong>。但是，服务器在响应HEAD请求时<strong>不会回传资源的内容部分，即：响应主体</strong>。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。</p><ol><li>POST</li></ol><p><strong>POST请求会向指定资源提交数据，请求服务器进行处理</strong>，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。<strong>POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。</strong></p><ol><li>PUT</li></ol><p><strong>PUT请求会身向指定资源位置上传其最新内容</strong>，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</p><ol><li>DELETE</li></ol><p><strong>DELETE请求用于请求服务器删除所请求URI</strong>（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。</p><ol><li>CONNECT</li></ol><p><strong>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器</strong>。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p><ol><li>OPTIONS</li></ol><p><strong>OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能</strong>。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许</p><ol><li>TRACE</li></ol><p><strong>TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。</strong></p><p>HTTP/1.1之后增加的方法</p><p>在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：</p><ol><li>PATCH</li></ol><p>PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：</p><p><strong>但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。</strong><br>当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。</p><h2 id="Post和Get"><a href="#Post和Get" class="headerlink" title="Post和Get"></a>Post和Get</h2><p><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html" target="_blank" rel="noopener">GET和POST有什么区别？及为什么网上的多数答案都是错的</a><br><a href="https://www.zhihu.com/question/31640769?rf=37401322" target="_blank" rel="noopener">知乎回答</a></p><p>get: <a href="http://tools.ietf.org/html/rfc2616#section-9.3" target="_blank" rel="noopener">RFC 2616 - Hypertext Transfer Protocol — HTTP/1.1</a><br>post: <a href="http://tools.ietf.org/html/rfc2616#section-9.5" target="_blank" rel="noopener">RFC 2616 - Hypertext Transfer Protocol — HTTP/1.1</a></p><p>HTTP协议用法的约定，使用上的区别：</p><ol><li><strong>GET使用URL或Cookie传参，而POST将数据放在BODY中。</strong></li><li><strong>GET方式提交的数据长度有限，而POST的数据则可以非常大。</strong>（这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。也不是GET和POST本身的区别。）</li><li><strong>POST比GET安全，因为数据在地址栏上不可见。</strong></li></ol><p>终极区别：</p><ol><li><strong>GET请求是满足幂等性的，POST请求不是。</strong>所以不应该且不能用get请求做数据的<strong>增删改</strong>这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用。</li></ol><blockquote><p>什么是幂等性？简单来说意味着对同一URL的多个请求应该返回同样的结果。</p></blockquote><h2 id="幂等-Idempotence"><a href="#幂等-Idempotence" class="headerlink" title="幂等 Idempotence"></a>幂等 Idempotence</h2><p><strong>HTTP方法的幂等性是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用</strong>。(注意是副作用)</p><p>1.、HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>2、GET：<strong>向特定的资源发出请求数据。（要数据）</strong><br>3、POST：<strong>向指定资源提交数据进行处理请求（给数据）</strong>（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。<br>4、PUT：向指定资源位置上传其最新内容。<br>5、DELETE：请求服务器删除Request-URI所标识的资源。 </p><p>如：</p><p><code>GET http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，<strong>这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。</strong><code>GET http://www.news.com/latest-news</code>这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，<strong>因而是满足幂等性的。</strong></p><p>DELETE方法用于删除资源，有副作用，但它<strong>应该满足幂等性</strong>。比如：<code>DELETE http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p><p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：<code>POST http://www.forum.com/articles</code>的语义是在<code>http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，<strong>POST方法不具备幂等性</strong>。</p><p>PUT所对应的URI是要创建或更新的资源本身。比如：<code>PUT http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，<strong>PUT方法具有幂等性</strong>。</p><h2 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h2><p>HTTPS协议是由<strong>SSL+HTTP协议构建的可进行加密传输</strong>、身份认证的网络协议，要比http协议安全。(SSL: Secure Sockets Layer)</p><p>HTTPS和HTTP的区别主要如下：</p><ol><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li><p>http的连接很简单，<strong>是无状态的</strong>；HTTPS协议是由SSL+HTTP协议构建的<strong>可进行加密传输、身份认证的网络协议</strong>，比http协议安全。</p></li><li><p>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p></li></ol><h1 id="URL的形式"><a href="#URL的形式" class="headerlink" title="URL的形式"></a>URL的形式</h1><ul><li>定义</li></ul><p>URL(Uniform Resource Locator,统一资源定位符)，定义资源在网上唯一的地址。</p><ul><li>组成部分</li></ul><p>URL由三部分组成：资源类型、存放资源的主机域名、资源文件名</p><blockquote><p>protocol :// hostname[:port] / path / [;parameters][?query]#fragment</p></blockquote><ul><li>protocol(协议):</li></ul><p>file 资源是本地计算机上的文件。格式file:///，注意后边应是三个斜杠。</p><p>ftp 通过 FTP访问资源。格式 FTP://</p><p>http 通过 HTTP 访问该资源。 格式 </p><p>HTTP:// https 通过安全的 HTTPS 访问该资源。 格式 HTTPS://</p><p>mailto 资源为电子邮件地址，通过 SMTP 访问。 格式 mailto:</p><ul><li>hostname(主机名)</li></ul><p>是指存放资源的服务器的域名系统(DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式: username:password@hostname）。</p><ul><li>Path(路径)</li></ul><p>由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。parameters（参数）</p><ul><li>query（查询）</li></ul><p>可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//变量url即具有了url模块所提供的方法</span><br><span class="line">var url = require(<span class="string">'url'</span>);</span><br><span class="line">var queryUrl = <span class="string">"http://localhost:8888/bb?name=bigbear&amp;memo-helloworld"</span>;</span><br><span class="line">console.log(typeof url.parse(queryUrl));</span><br><span class="line">console.log(url.parse(queryUrl));</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">object</span><br><span class="line">Url {</span><br><span class="line">  protocol: <span class="string">'http:'</span>,</span><br><span class="line">  slashes: true,</span><br><span class="line">  auth: null,</span><br><span class="line">  host: <span class="string">'localhost:8888'</span>,</span><br><span class="line">  port: <span class="string">'8888'</span>,</span><br><span class="line">  hostname: <span class="string">'localhost'</span>,</span><br><span class="line">  hash: null,</span><br><span class="line">  search: <span class="string">'?name=bigbear&amp;memo-helloworld'</span>,</span><br><span class="line">  query: <span class="string">'name=bigbear&amp;memo-helloworld'</span>,</span><br><span class="line">  pathname: <span class="string">'/bb'</span>,</span><br><span class="line">  path: <span class="string">'/bb?name=bigbear&amp;memo-helloworld'</span>,</span><br><span class="line">  href: <span class="string">'http://localhost:8888/bb?name=bigbear&amp;memo-helloworld'</span> }</span><br></pre></td></tr></tbody></table></figure><h1 id="urllib和urllib2的区别"><a href="#urllib和urllib2的区别" class="headerlink" title="urllib和urllib2的区别"></a>urllib和urllib2的区别</h1><p>这个面试官确实问过,当时答的<strong>urllib2可以Post而urllib不可以</strong>.</p><ol><li>urllib提供<strong>urlencode</strong>方法用来<strong>GET查询字符串的产生</strong>，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li><li>urllib2可以接受一个<strong>Request类的实例来设置URL请求的headers，urllib仅可以接受URL</strong>。<strong>这意味着，你不可以伪装你的用户代理字符串等</strong>。</li></ol><h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><p><strong>地址解析协议(Address Resolution Protocol)</strong>，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，<strong>以保证通信的顺利进行</strong>。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被<strong>邻居发现协议（NDP）所替代</strong>（Neighbor Discovery Protocol）。</p><h1 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">Cookie</th><th style="text-align:left">Session</th></tr></thead><tbody><tr><td style="text-align:left">储存位置</td><td style="text-align:left">客户端</td><td style="text-align:left">服务器端</td></tr><tr><td style="text-align:left">目的</td><td style="text-align:left">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td><td style="text-align:left">跟踪会话</td></tr><tr><td style="text-align:left">安全性</td><td style="text-align:left">不安全</td><td style="text-align:left">安全</td></tr></tbody></table></div><p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p><h1 id="apache和nginx的区别（Web服务器）"><a href="#apache和nginx的区别（Web服务器）" class="headerlink" title="apache和nginx的区别（Web服务器）"></a>apache和nginx的区别（Web服务器）</h1><p>nginx 相对 apache 的优点：</p><ul><li><strong>轻量级</strong>，同样起web 服务，比apache 占用更少的内存及资源</li><li><strong>抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接</strong>，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能</li><li><strong>配置简洁</strong></li><li>高度模块化的设计，编写模块相对简单</li><li>社区活跃</li></ul><p>apache 相对nginx 的优点：</p><ul><li><p><strong>rewrite ，比nginx 的rewrite 强大</strong></p></li><li><p><strong>模块超多</strong>，基本想到的都可以找到</p></li><li><p><strong>少bug</strong> ，nginx 的bug 相对较多</p></li><li><p><strong>超稳定</strong></p></li></ul><h1 id="网站用户密码保存"><a href="#网站用户密码保存" class="headerlink" title="网站用户密码保存"></a>网站用户密码保存</h1><ol><li><strong>明文保存</strong>在数据库中</li><li><strong>明文hash后保存,如MD5</strong></li><li><strong>MD5+Salt方式,这个Salt可以随机</strong></li><li>知乎使用了Bcrypy(好像)加密</li></ol><h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><p>推荐: <a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p><p>304 Not Modified</p><p>浏览器缓存机制，其实<strong>主要就是HTTP协议定义的缓存机制</strong>（如：Expires；Cache-control等）</p><p>但是也有非HTTP协议定义的缓存机制。</p><p><strong>一、非HTTP协议定义的缓存机制</strong></p> <figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">"Pragma"</span> <span class="attr">CONTENT</span>=<span class="string">"no-cache"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有<strong>缓存代理服务器都不支持，因为代理不解析HTML内容本身。</strong></p><p><strong>二、HTTP协议定义的缓存机制</strong></p><ol><li><p>Expires策略:  是Web服务器响应消息头字段，在响应http请求时告诉<strong>浏览器在过期时间前</strong>浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.41.48.png" alt="Screen Shot 2020-11-08 at 15.41.48"></p></li><li><p>Cache-control策略:Cache-Control与Expires的作用一致，都是指明当前资源的<strong>有效期</strong>，控制浏览器<strong>是否直接从浏览器缓存取数据还是重新发请求到服务器取数据</strong>。只不过Cache-Control的<strong>选择更多，设置更细致</strong>，如果同时设置的话，其<strong>优先级高于</strong>Expires。</p><p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.42.01.png" alt="Screen Shot 2020-11-08 at 15.42.01"></p><p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.42.14.png" alt="Screen Shot 2020-11-08 at 15.42.14"></p></li></ol><h1 id="CSRF和XSS"><a href="#CSRF和XSS" class="headerlink" title="CSRF和XSS"></a>CSRF和XSS</h1><ul><li><strong>CSRF(Cross-site request forgery)跨站请求伪造</strong>：<strong>网站过分信任用户</strong>，放任来自所谓通过访问控制机制的代表合法用户的请求执行网站的某个特定功能。</li><li><strong>XSS(Cross Site Scripting)跨站脚本攻击：用户过分信任网站</strong>，放任来自来自浏览器地址代表的那个网站代码在自己本地任意执行。如果没有浏览器的安全机制限制，XSS代码可以在用户浏览器为所欲为。</li></ul><p>CSRF重点在<strong>请求</strong>,XSS重点在<strong>脚本</strong></p><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p><strong>RPC（Remote Procedure Call Protocol）——远程过程调用协议</strong>。</p><p>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。<strong>RPC是一个分布式计算的CS模式，总是由Client向Server发出一个执行若干过程请求，Server接受请求，使用客户端提供的参数，计算完成之后将结果返回给客户端。</strong></p><p><strong>RPC是面向过程，Restful是面向资源</strong>，并且使用了Http动词。从这个维度上看，Restful风格的url在表述的精简性、可读性上都要更好。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RPC风格</span></span><br><span class="line">/queryOrder?orderId=123</span><br><span class="line"></span><br><span class="line"><span class="comment"># Restful风格</span></span><br><span class="line">Get  </span><br><span class="line">/order/<span class="number">123</span></span><br></pre></td></tr></tbody></table></figure><p>RPC原理：</p><p>比如 A (client) 调用 B (server) 提供的<code>remoteAdd</code>方法：</p><ol><li>首先A与B之间建立一个TCP连接；</li><li>然后A把需要调用的方法名（这里是remoteAdd）以及方法参数（10， 20）<strong>序列化成字节流发送出去；</strong></li><li>B接受A发送过来的字节流，然后<strong>反序列化得到目标方法名，方法参数</strong>，接着执行相应的方法调用（可能是localAdd）并把结果30返回；</li><li>A接受远程调用结果,输出30。</li></ol><p><strong>进化的顺序: RPC -&gt; SOAP -&gt; RESTful</strong></p><h1 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h1><ol><li>SOAP（原为<strong>Simple Object Access Protocol</strong>的首字母缩写，即<strong>简单对象访问协议</strong>）是交换数据的一种协议规范，<strong>使用在计算机网络Web服务（web service）中</strong>，交换带结构信息。</li><li>SOAP为了简化<strong>网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间</strong>。不同应用程序之间按照<strong>HTTP通信协议，遵从XML格式执行资料互换</strong>，使其抽象于语言实现、平台和硬件。</li></ol><h1 id="RESTful架构-SOAP-RPC"><a href="#RESTful架构-SOAP-RPC" class="headerlink" title="RESTful架构(SOAP,RPC)"></a>RESTful架构(SOAP,RPC)</h1><p>推荐: <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p><p>Representational State Transfer：表现层状态转移</p><p>RESTful架构，<strong>就是目前最流行的一种互联网软件架构</strong>。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p><p>总结一下什么是RESTful架构：</p><p>（1）<strong>每一个URI代表一种资源；</strong></p><p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p><p>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”<strong>表现层状态转化</strong>“。</p><h1 id="CGI和WSGI"><a href="#CGI和WSGI" class="headerlink" title="CGI和WSGI"></a>CGI和WSGI</h1><ul><li><p>CGI(Common Gateway Interface)是<strong>通用网关接口</strong>，是连接web服务器和应用程序的接口，用户通过CGI来获取<strong>动态数据或文件</strong>等。<br>CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。</p></li><li><p>WSGI(Web Server Gateway Interface)<strong>Web服务器网关接口</strong>，是<strong>Python应用程序或框架和Web服务器</strong>之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p><p>它不是服务器,也不是python模块,<strong>它是一种规范,描述Web服务器和应用之间的交互</strong>.通俗来讲, 它就是一条纽带,连接着Web服务器和应用。</p></li></ul><p>官方说明：<a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">PEP-3333</a></p><h1 id="简述浏览器通过WSGI请求动态资源的过程"><a href="#简述浏览器通过WSGI请求动态资源的过程" class="headerlink" title="简述浏览器通过WSGI请求动态资源的过程"></a>简述浏览器通过WSGI请求动态资源的过程</h1><ul><li>静态服务器加载的是一个静态html页面，或是存在服务器中的静态数据。</li><li><p>动态服务器是，当客户端发送一个请求，<strong>服务器拿到这个请求找到相关的程序代码执行，将执行结果返回给客户端的一个过程</strong></p></li><li><p>WSGI</p><p>怎么在你刚刚建立的web服务器上运行一个Django应用和一个Flask应用呢。如何做不做任何改变而适应不同的web架构呢：WSGI</p></li></ul><ol><li>浏览器发送http请求动态资源给web服务器（flask）</li><li>web服务器收到请求后<strong>通过WSGI调用一个属性给应用程序框架</strong></li><li>应用程序框架通过引用WSGI调用Web服务器，<strong>设置返回的状态和头信息</strong></li><li>调用后返回，此时Web服务器保存了刚刚设置的信息</li><li><strong>应用程序查询数据库，生成动态页面的body信息</strong></li><li><strong>把生成的body信息返回给Web服务器</strong></li><li>Web服务器把数据返回给浏览器</li></ol><p><img data-src="/images/data/截屏2020-11-17 16.52.08.png" alt="截屏2020-11-17 16.52.08"></p><h1 id="WSGI与Flask之间的关系"><a href="#WSGI与Flask之间的关系" class="headerlink" title="WSGI与Flask之间的关系"></a>WSGI与Flask之间的关系</h1><ol><li>使用<code>app.run()</code>方法来启动flask应用（<code>app.run()</code>代码隐藏着创建一个服务器），<strong>app应用本身会作为参数传递到WSGI服务器中</strong>。</li><li>在客户端（这里就是浏览器）输入网址（发送一个请求），服务器使用WSGI 中间件来处理这个请求。</li><li>WSGI 处理请求对应着<code>wsgi_app(self, environ, start_response)</code>方法，<code>self</code>参数对应着<code>app</code>，即flask程序；<code>environ</code>和 <code>start_response</code>由服务器提供。</li><li><code>wsgi_app()</code>作用就是调用各种请求处理函数来处理请求，然后返回处理结果。即用户输入网址后，看到了网页响应。</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)  </span><br><span class="line"><span class="comment">#生成app实例，传递 __name__参数，__name__ 就是当前模块名字。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"2017-08-21"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><p><a href="https://blog.csdn.net/sinat_36651044/article/details/77462831" target="_blank" rel="noopener">https://blog.csdn.net/sinat_36651044/article/details/77462831</a></p><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p>在<strong>GFW(Great Firewall: 中国国家防火墙)</strong>里屡见不鲜的,呵呵.</p><p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指<strong>攻击者与通讯的两端分别创建独立的联系</strong>，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p><h1 id="c10k问题"><a href="#c10k问题" class="headerlink" title="c10k问题"></a>c10k问题</h1><p>所谓<strong>c10k</strong>问题，指的是<strong>服务器同时支持成千上万个客户端</strong>的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。</p><p>解决方法：</p><ol><li><strong>每个连接分配一个独立的线程/进程</strong>：该思路最为直接，但是申请进程/线程是需要系统资源的，且系统需要管理这些进程/线程，所以<strong>会使资源占用过多，可扩展性差</strong></li><li><strong>同一个线程/进程同时处理多个连接（I/O多路复用）</strong>：select方式、poll方式、epoll方式、异步I/O以及Windows</li></ol><p><a href="https://my.oschina.net/xianggao/blog/664275" target="_blank" rel="noopener">https://my.oschina.net/xianggao/blog/664275</a></p><p><a href="https://www.jianshu.com/p/ba7fa25d3590" target="_blank" rel="noopener">C10K问题及其解决方法</a></p><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>AJAX(Asynchronous JavaScript and XML)（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与<strong>服务器交换数据并更新部分网页的技术</strong>。</p><h1 id="描述用浏览器访问www-baidu-com的过程"><a href="#描述用浏览器访问www-baidu-com的过程" class="headerlink" title="描述用浏览器访问www.baidu.com的过程"></a>描述用浏览器访问www.baidu.com的过程</h1><ol><li>浏览器获取用户输入的域名：www.baidu.com</li><li><p>浏览器<strong>向域名解析器DNS获取www.baidu.com的IP地址</strong></p></li><li><p>DNS解析出IP地址</p></li><li>浏览器与服务器<strong>建立TCP连接</strong>（默认端口号80）</li><li><p><strong>浏览器发出HTTP请求</strong>，请求百度页面</p></li><li><p><strong>服务器通过HTTP响应</strong>把首页内容发送给浏览器</p></li><li><p>TCP连接释放</p></li><li><strong>浏览器解析首页文件</strong>，并将WEB页面显示给用户</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;三次握手&quot;&gt;&lt;a href=&quot;#三次握手&quot; class=&quot;headerlink&quot; title=&quot;三次握手&quot;&gt;&lt;/a&gt;三次握手&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;客户端通过向服务器端&lt;strong&gt;发送一个请求报文SYN&lt;/strong&gt;来创建一个主动打开。&lt;/li&gt;
&lt;li&gt;Server端接受连接后&lt;strong&gt;回复ACK报文&lt;/strong&gt;，并为这次连接分配资源。&lt;/li&gt;
&lt;li&gt;Client端接收到&lt;strong&gt;ACK报文&lt;/strong&gt;后也向Server段发送报文，并分配资源，这样TCP连接就建立了。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Computer Basic" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/"/>
    
      <category term="Interview" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/Interview/"/>
    
    
      <category term="Computer Network" scheme="https://unknown.yuzhouwan.com/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础</title>
    <link href="https://unknown.yuzhouwan.com/posts/22488/"/>
    <id>https://unknown.yuzhouwan.com/posts/22488/</id>
    <published>2020-01-29T23:55:00.000Z</published>
    <updated>2020-11-20T06:34:57.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>数据库事务(Database Transaction) ，是指为访问并可能操作各个数据项的<strong>一个数据库操作序列，这些操作要么全部执行，要么全部不执行</strong>，是一个不可分割的工作单位。事务由事务开始与结束之间执行的全部数据库操作组成。</p><p>如：我们去银行转账，操作可能分为以下两个环节：</p><p>（1）从第一个账户划出款项</p><p>（2）将款项存入第二个账户</p><p>这两个环节是关联的，如果第二个环节没有完成，那么所有的环节都应该取消。</p><p>性质：</p><p>A：原子性（Atomicity）事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全部不执行。</p><p>C：一致性（Consistency）几个并行执行的事务，其执行结果必须与按某一顺序 串行执行的结果相一致。</p><p>I：隔离性（Isolation）事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。</p><p>D：持久性（Durability）对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。</p><p>彻底理解数据库事务: <a href="http://www.hollischuang.com/archives/898" target="_blank" rel="noopener">http://www.hollischuang.com/archives/898</a></p><a id="more"></a><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="主键-超键-候选键-外键"><a href="#主键-超键-候选键-外键" class="headerlink" title="主键 超键 候选键 外键"></a>主键 超键 候选键 外键</h2><ul><li><p><strong>主键</strong>：指的是<strong>一个列或多列的组合，其值能唯一地标识表中的每一行</strong>，通过它可强制表的实体完整性。主键主要是用与其他表的外键关联，以及本记录的修改与删除。</p><p>身份证号也是一种业务场景，如果身份证号升位了，或者需要变更，作为主键，不得不修改的时候，就会对业务产生严重影响。 所以，选取主键的一个基本原则是：<strong>不使用任何业务相关的字段作为主键</strong>。 因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。</p></li><li><p><strong>外键</strong>：关系模式R1中的某属性集不是R1的主键，而是另一个<strong>关系R2的主键</strong>则该属性集是关系模式<strong>R1的外键</strong>。</p></li><li><p><strong>超键</strong>：<strong>在关系中能唯一标识元组的属性集称为关系模式的超键</strong>。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。<strong>超键包含候选键和主键。</strong></p></li><li><p><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</p></li></ul><p>例子：</p><blockquote><p>假设有如下两个表：</p><p>学生（学号，姓名，性别，身份证号，教师编号）</p><p>教师（教师编号，姓名，工资）</p></blockquote><p><strong>超键：</strong></p><p>由超键的定义可知，学生表中含有学号或者身份证号的任意组合都为此表的超键。如：（学号）、（学号，姓名）、（身份证号，性别）等。</p><p><strong>候选键：</strong></p><p>候选键属于超键，它是最小的超键，就是说如果再去掉候选键中的任何一个属性它就不再是超键了。学生表中的候选键为：（学号）、（身份证号）。</p><p><strong>主键：</strong></p><p>主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，教师表中让“教师编号”做主键。</p><p><strong>外键：</strong></p><p>外键比较简单，学生表中的外键就是“教师编号”。外键主要是用来描述两个表的关系。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li>索引是关系数据库中对<strong>某一列或多个列的值进行预排序的数据结构</strong>。通过使用索引，可以让数据库系统不必扫描整个表，而是<strong>直接定位到符合条件的记录，这样就大大加快了查询速度。</strong></li></ul><p>索引的效率<strong>取决于索引列的值是否散列</strong>，即该<strong>列的值如果越不相同，那么索引效率越高</strong>。反过来，如果记录的列存在大量相同的值。例如gender列，那对该列创建索引就没有意义。</p><p>例如：创建名称为idx_score，使用列score的索引。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_score (score)</span><br></pre></td></tr></tbody></table></figure><p>推荐:<a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1218728442198976" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1177760294764384/1218728442198976</a></p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><p>聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理</p><ul><li>数据库索引，<strong>是数据库管理系统中一个排序的数据结构，以协助快速查询</strong>，更新数据库表中数据。索引的实现通常使用<strong>B树($O(Log_2N)$)以其变种B+树</strong>。</li></ul><p>在数据之外，数据库系统还维护着<strong>满足特定查找算法的数据结构</strong>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。<strong>这种数据结构，就是索引</strong>。</p><p>为表设置索引要付出代价的：<strong>一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间（因为索引也要随之变动）</strong></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul><li><strong>视图是虚拟的表，主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</strong>隐藏具体的细节，保护数据; 视图创建后，可以使用与表相同的方式利用它们。</li></ul><p>视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by则对视图再次order by将被覆盖。</p><blockquote><p>创建视图： create view xxx as xxxxxx</p></blockquote><p>优点：</p><ol><li>使用视图，可以定制用户数据，聚焦特定的数据。</li><li>使用视图，可以简化数据操作。</li><li>使用视图，基表中的数据就有了一定的安全性</li></ol><p><a href="https://www.jianshu.com/p/6a2c7407be4c" target="_blank" rel="noopener">https://www.jianshu.com/p/6a2c7407be4c</a></p><h2 id="drop-truncate-delete的区别"><a href="#drop-truncate-delete的区别" class="headerlink" title="drop, truncate, delete的区别"></a>drop, truncate, delete的区别</h2><ul><li><p>drop直接删掉表</p></li><li><p>truncate删除表中数据，<strong>再插入时自增长id又从1开始</strong></p><p>truncate table则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，<strong>删除行是不能恢复的</strong>。并且在删除的过程中不会激活与表有关的删除触发器，执行速度快；</p></li><li><p>delete删除表中数据，<strong>可以加where字句</strong></p><p>delete 语句执行删除的过程是<strong>每次从表中删除一行</strong>，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作。</p></li></ul><ol><li><p>表和索引所占空间：drop语句将表所占用的空间全释放掉；当表被truncate后，这个表和索引所占用的空间会恢复到初始大小，而delete操作不会减少表或索引所占用的空间。</p></li><li><p>一般而言，drop&gt;truncate&gt;delete</p></li><li><p>应用范围。truncate只能对table，delete可以是table和view</p></li><li><p>truncate和delete只删除数据，而drop则删除整个表<strong>（结构和数据)</strong></p></li><li><p>truncate与不带where的delete:只删除数据，<strong>而不删除表的结构（定义）</strong>drop语句将删除表的结构被依赖的<strong>约束(constrain),触发器（trigger)索引(index)</strong>;依赖于该表的存储过程/函数将被保留，但其状态会变为:invalid.</p></li></ol><h2 id="连接的种类：内连接、外连接、交叉连接"><a href="#连接的种类：内连接、外连接、交叉连接" class="headerlink" title="连接的种类：内连接、外连接、交叉连接"></a>连接的种类：内连接、外连接、交叉连接</h2><p>join_type 指出连接类型。join_condition指连接条件。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM  join_table join_type join_table[ON (join_condition)]</span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>内连接（inner join）</strong>：使用比较运算符（包括=、&gt;、&lt;、&lt;&gt;、&gt;=、&lt;=、!&gt;和!&lt;）进行表间的比较操作，查询与连接条件相匹配的数据</p><ul><li>等值连接（=）</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_student s, T_class c <span class="keyword">where</span> s.classID = c.classID</span><br><span class="line">等于</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_student s <span class="keyword">inner</span> <span class="keyword">join</span> T_class <span class="keyword">on</span> s.classID = c.classID</span><br></pre></td></tr></tbody></table></figure><ul><li>自然连接：与等值相同，<strong>但是会删除表中的重复列</strong></li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.*,c.className <span class="keyword">from</span> T_student s <span class="keyword">inner</span> <span class="keyword">join</span> T_class c <span class="keyword">on</span> s.classId = c.classId</span><br></pre></td></tr></tbody></table></figure><ul><li>不等连接（&lt;, &gt;, &lt;&gt;, &gt;=, &lt;=, !&gt;, !&lt;）</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_student s <span class="keyword">inner</span> <span class="keyword">join</span> T_class c <span class="keyword">on</span> s.classId &lt;&gt; c.classId</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>外连接</strong>（left join、right join、full join）</p><ul><li><p><strong>左连接</strong>（LEFT JOIN）：返回左表中的所有行，如果左表中行在右表中没有匹配行，则结果中右表中的列返回空值。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span>  T_student s <span class="keyword">left</span> <span class="keyword">join</span> T_class c <span class="keyword">on</span> s.classId = c.classId</span><br></pre></td></tr></tbody></table></figure></li><li><p>左外连接（LEFT OUTER JOIN）:</p></li><li><p><strong>右连接</strong>（RIGHT JOIN）: 与左连接相反</p></li><li><p>右外连接（RIGHT OUTER JOIN）</p></li><li><p><strong>全连接</strong>（FULL JOIN）: 返回左表和右表中的所有行。当某行在另一表中没有匹配行，则另一表中的列返回空值</p></li><li><p>全外连接（FULL OUTER JOIN）</p></li></ul></li><li><p><strong>交叉连接</strong>：笛卡尔积（cross join）</p><p>不带WHERE条件子句，<strong>它将会返回被连接的两个表的笛卡尔积</strong>，返回结果的行数等于两个表行数的乘积（例如：T_student和T_class，返回4*4=16条记录）；如果带where，返回或显示的是匹配的行数。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T_student s <span class="keyword">cross</span> <span class="keyword">join</span> T_class c <span class="keyword">where</span> s.classId = c.classId</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="存储过程与触发器的区别"><a href="#存储过程与触发器的区别" class="headerlink" title="存储过程与触发器的区别"></a>存储过程与触发器的区别</h2><ul><li>存储过程：用户调用的时候才会执行</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 创建的存储过程名字(<span class="keyword">OUT</span>|<span class="keyword">IN</span>|INOUT 参数名 数据类型,...,...) 特征 过程体</span><br></pre></td></tr></tbody></table></figure><ul><li>触发器：对表进行诸如UPDATE、INSERT、DELETE等时，<strong>SqlServer自动执行触发器定义的SQL语句</strong>，通过事件触发</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 创建的触发器名字 BEFFOR|<span class="keyword">AFTER</span>  <span class="keyword">INSERT</span>|<span class="keyword">UPDATE</span>|<span class="keyword">DELETE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> 表名字 <span class="keyword">FOR</span>  触发器的执行间隔   触发器的<span class="keyword">SQL</span>语句</span><br></pre></td></tr></tbody></table></figure><h2 id="数据库优化的思路"><a href="#数据库优化的思路" class="headerlink" title="数据库优化的思路"></a>数据库优化的思路</h2><ol><li><p>SQL语句优化</p><ul><li>应尽量避免在 where 子句中对字段进行 <strong>null 值</strong>判断，否则将导致<strong>引擎放弃使用索引而进行全表扫描</strong></li><li>应尽量避免在 where 子句中使用<strong>!=或&lt;&gt;操作符</strong>，否则将<strong>引擎放弃使用索引而进行全表扫描</strong></li></ul></li><li><p>索引优化</p><ul><li>创建索引：<strong>对经常需要搜索的列上</strong>，可以加快搜索的速度；<strong>在经常需要排序的列上创建索引</strong>，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>不应该创建索引：对于那些在查询中很少使用或者参考的列不应该创建索引；当修改性能远远大于检索性能时，不应该创建索引</li></ul></li><li><p>数据库结构优化</p><ul><li>范式优化：消除冗余（节省空间）</li><li>反范式优化：适当增加冗余（减少join）</li></ul></li><li><p>服务器硬件优化</p><p>花钱</p></li></ol><p><a href="https://www.jishuchi.com/read/mysql-interview/2810" target="_blank" rel="noopener">https://www.jishuchi.com/read/mysql-interview/2810</a></p><h2 id="MySQL引擎：InnoDB、MyIASM和MEMORY"><a href="#MySQL引擎：InnoDB、MyIASM和MEMORY" class="headerlink" title="MySQL引擎：InnoDB、MyIASM和MEMORY"></a>MySQL引擎：InnoDB、MyIASM和MEMORY</h2><p>MySQL支持三个引擎：InnoDB、MyIASM和MEMORY</p><p><strong>InnoDB 和 MyISAM之间的区别：</strong></p><ul><li><p>两者索引<strong>都使用B+树</strong>，InnoDB是MySQL默认的存储引擎</p></li><li><p>InnoDB<strong>支持事务</strong>，而MyISAM不支持事务</p></li><li>InnoDB<strong>支持外键</strong>，而MyISAM不支持</li><li>InnoDB<strong>支持MVCC,</strong> 而MyISAM不支持</li><li>InnoDB<strong>不支持全文索引</strong>，而MyISAM支持</li></ul><p><strong>InnoDB</strong> ：如果要提供提交、回滚、崩溃恢复的事务安全能力，用InnoDB</p><p><strong>MyISAM</strong>：如果数据表主要用来<strong>插入和查询</strong>记录，MyISAM能提供较高的处理速度</p><p><strong>MEMORY：</strong>如果只是临时存放数据，数据量不大，不需要较高的安全性，可以选择将数据保存在内存中的MEMORY引擎</p><p>mysql 数据库引擎: <a href="http://www.cnblogs.com/0201zcr/p/5296843.html" target="_blank" rel="noopener">http://www.cnblogs.com/0201zcr/p/5296843.html</a><br>MySQL存储引擎－－MyISAM与InnoDB区别: <a href="https://segmentfault.com/a/1190000008227211" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008227211</a></p><h2 id="？-MySQL的innodb引擎是如何实现MVCC的"><a href="#？-MySQL的innodb引擎是如何实现MVCC的" class="headerlink" title="？ MySQL的innodb引擎是如何实现MVCC的"></a>？ <a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">MySQL</a>的innodb引擎是如何实现MVCC的</h2><blockquote><p>​    全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，<strong>每个读操作会看到一个一致性的snapshot</strong>，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。</p></blockquote><p>innodb会为每一行添加两个字段，分别表示该行<strong>创建的版本</strong>和<strong>删除的版本</strong>，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（<a href="http://blog.csdn.net/chosen0ne/article/details/10036775" target="_blank" rel="noopener">事务的隔离级别请看这篇文章</a>）下，具体各种数据库操作的实现：</p><ul><li>select：满足以下两个条件innodb会返回该行数据：<ul><li>该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。</li><li>该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。</li></ul></li><li>insert：将新插入的行的创建版本号设置为当前系统的版本号。</li><li>delete：将要删除的行的删除版本号设置为当前系统的版本号。</li><li>update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。</li></ul><p>其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。</p><p>​    由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。</p><p>通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。</p><h2 id="MySQL怎么限制IP访问？"><a href="#MySQL怎么限制IP访问？" class="headerlink" title="MySQL怎么限制IP访问？"></a>MySQL怎么限制IP访问？</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> priviledge <span class="keyword">on</span> <span class="string">"*"</span> <span class="keyword">to</span> <span class="string">"用户名@ip地址"</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">"数据库密码"</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'admin@192.168.0.1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改密码</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> <span class="keyword">for</span> <span class="string">'admin@192.168.0.1'</span> = <span class="keyword">password</span>(<span class="string">"admin"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权：只有来自192.168.0.1的用户才能通过admin访问服务器</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> priviledges <span class="keyword">on</span> <span class="string">"*"</span> <span class="keyword">to</span> <span class="string">"admin@192.168.0.1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line"><span class="keyword">flush</span> priviledges</span><br></pre></td></tr></tbody></table></figure><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h2><ol><li>是一个完全开源免费的<strong>key-value内存数据库</strong> </li><li>通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets</li></ol><h2 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h2><blockquote><p>​    通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用<strong>来处理高并发的数据库操作</strong></p></blockquote><ul><li>速度快：使用标准C写，<strong>所有数据都在内存中完成</strong>，读写速度分别达到10万/20万 </li><li>持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof) </li><li>自动操作：对不同数据类型的操作都是自动的，很安全 </li><li><strong>快速的主—从复制</strong>，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。 </li><li>Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。</li></ul><h2 id="Redis缺点"><a href="#Redis缺点" class="headerlink" title="Redis缺点"></a>Redis缺点</h2><ul><li><strong>是数据库容量受到物理内存的限制,</strong> 不能用作海量数据的高性能读写, 因此Redis适合的场景主要<strong>局限在较小数据量的高性能操作和运算上。</strong></li><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul><h2 id="Redis宕机怎么解决"><a href="#Redis宕机怎么解决" class="headerlink" title="Redis宕机怎么解决"></a>Redis宕机怎么解决</h2><p>宕机:服务器停止服务</p><p><strong>如果只有一台redis，肯定会造成数据丢失，无法挽救</strong></p><p>多台redis或者是redis集群，宕机则需要分为在主从模式下区分来看：</p><ul><li><p>slave从redis宕机：配置主从复制的时候才配置从的redis，从的会从主的redis中读取主的redis的操作日志，在redis中从库重新启动后会自动加入到主从架构中，自动完成同步数据;</p></li><li><p>主redis宕机：如果从数据库实现了持久化，此时千万不要立马重启服务，否则可能会造成数据丢失，正确的操作如下：<strong>在slave</strong>数据上执行SLAVEOF ON ONE, <strong>来断开主从关系并把slave升级为主库</strong>，此时重新启动主数据库，执行SLAVEOF，<strong>把主库设置为从库</strong>，连接到主的redis上面做主从复制，自动备份数据。</p></li></ul><p>以上过程很容易配置错误，可以使用redis提供的哨兵机制来简化上面的操作。简单的方法: <strong>redis的哨兵(sentinel)</strong>的功能</p><h2 id="Redis和mecached的区别，以及使用场景"><a href="#Redis和mecached的区别，以及使用场景" class="headerlink" title="Redis和mecached的区别，以及使用场景"></a>Redis和mecached的区别，以及使用场景</h2><p>总结</p><p>都是内存数据库</p><p>redis挂掉后会备份，并实现了持久化，除了k/v，还支持多种类型的数据存储。</p><p>memcache挂掉后，数据不可恢复，仅支持k/v。</p><p>使用场景</p><ol><li><p>如果有<strong>持久方面的需求</strong>或对<strong>数据类型和处理有要求</strong>的应该选择redis</p></li><li><p>如果<strong>简单的key/value存储应该选择memcached</strong>.</p></li></ol><p>区别</p><p>1、redis和Memcache都是<strong>将数据存放在内存中，都是内存数据库</strong>。不过memcache还可以用于缓存其他东西，例如图片，视频等等</p><p>2、Redis不仅仅支持简单的<strong>k/v类型的数据</strong>，同时还提供<strong>list,set,hash等数据结构的存储</strong></p><p>3、虚拟内存-redis当物流内存用完时，可以将一些很久没用的value交换到磁盘</p><p>4、过期策略-memcache在set时就指定，例如set key1 0 0 8，即永不过期。Redis可以通过例如expire设定，例如expire name 10</p><p>5、分布式-设定memcache集群，利用magent做一主多从，redis可以做一主多从。都可以一主一从</p><p>6、存储数据安全-<strong>memcache挂掉后，数据没了</strong>。<strong>redis可以定期保存到磁盘(持久化)</strong></p><p>7、灾难恢复-<strong>memcache挂掉后，数据不可恢复</strong>。redis数据丢失后可以通过aof恢复</p><p>8、Redis支持数据的备份，即master-slave模式的数据备份</p><p>9、应用场景不一样，redis除了作为NoSQL数据库使用外，还能用做消息队列，数据堆栈和数据缓存等; Memcache适合于缓存SQL语句，数据集，用户临时性数据，延迟查询数据和session等</p><h2 id="Redis集群方案该怎么做-都有哪些方案"><a href="#Redis集群方案该怎么做-都有哪些方案" class="headerlink" title="Redis集群方案该怎么做?都有哪些方案?"></a>Redis集群方案该怎么做?都有哪些方案?</h2><ol><li><p>codis</p><p>目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在节点数量改变情况下，旧节点数据客恢复到新hash节点</p></li><li><p>redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方介绍</p></li><li><p>在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key进行hash计算，然后去对应的redis实例操作数据。这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的字典脚本恢复，实例的监控，等等</p></li></ol><h2 id="Redis回收进程是如何工作的"><a href="#Redis回收进程是如何工作的" class="headerlink" title="Redis回收进程是如何工作的"></a>Redis回收进程是如何工作的</h2><p>一个客户端运行了新的命令，添加了新的数据。</p><p>redis检查内存使用情况，如果大于maxmemory的限制，则根据<strong>设定好的策略</strong>进行回收。</p><p>一个新的命令被执行等等，所以我们不断地穿越内存限制的边界，通过<strong>不断达到边界然后不断回收回到边界以下</strong>。</p><p>如果一个命令的结果导致大量内存被使用(例如很大的集合的交集保存到一个新的键)，不用多久内存限制就会被这个内存使用量超越。</p><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="211-MongoDB中对多条记录做更新操作命令是什么？"><a href="#211-MongoDB中对多条记录做更新操作命令是什么？" class="headerlink" title="211.MongoDB中对多条记录做更新操作命令是什么？"></a>211.MongoDB中对多条记录做更新操作命令是什么？</h2><h2 id="212-MongoDB如何才会拓展到多个shard里？"><a href="#212-MongoDB如何才会拓展到多个shard里？" class="headerlink" title="212.MongoDB如何才会拓展到多个shard里？"></a>212.MongoDB如何才会拓展到多个shard里？</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;p&gt;数据库事务(Database Transaction) ，是指为访问并可能操作各个数据项的&lt;strong&gt;一个数据库操作序列，这些操作要么全部执行，要么全部不执行&lt;/strong&gt;，是一个不可分割的工作单位。事务由事务开始与结束之间执行的全部数据库操作组成。&lt;/p&gt;
&lt;p&gt;如：我们去银行转账，操作可能分为以下两个环节：&lt;/p&gt;
&lt;p&gt;（1）从第一个账户划出款项&lt;/p&gt;
&lt;p&gt;（2）将款项存入第二个账户&lt;/p&gt;
&lt;p&gt;这两个环节是关联的，如果第二个环节没有完成，那么所有的环节都应该取消。&lt;/p&gt;
&lt;p&gt;性质：&lt;/p&gt;
&lt;p&gt;A：原子性（Atomicity）事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全部不执行。&lt;/p&gt;
&lt;p&gt;C：一致性（Consistency）几个并行执行的事务，其执行结果必须与按某一顺序 串行执行的结果相一致。&lt;/p&gt;
&lt;p&gt;I：隔离性（Isolation）事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。&lt;/p&gt;
&lt;p&gt;D：持久性（Durability）对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。&lt;/p&gt;
&lt;p&gt;彻底理解数据库事务: &lt;a href=&quot;http://www.hollischuang.com/archives/898&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.hollischuang.com/archives/898&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Basic" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/"/>
    
      <category term="Interview" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/Interview/"/>
    
    
      <category term="DataBase Basic" scheme="https://unknown.yuzhouwan.com/tags/DataBase-Basic/"/>
    
  </entry>
  
  <entry>
    <title>软件测试基础</title>
    <link href="https://unknown.yuzhouwan.com/posts/22398/"/>
    <id>https://unknown.yuzhouwan.com/posts/22398/</id>
    <published>2020-01-28T23:55:00.000Z</published>
    <updated>2020-11-23T03:17:04.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件测试理论"><a href="#软件测试理论" class="headerlink" title="软件测试理论"></a>软件测试理论</h1><h2 id="软件测试的生命周期"><a href="#软件测试的生命周期" class="headerlink" title="软件测试的生命周期"></a>软件测试的生命周期</h2><p>软件测试生命周期是指从项目计划建立到BUG提交的整个测试过程，包括：</p><ol><li>软件项目测试计划</li><li>测试需求分析</li><li>测试用例设计</li><li>测试用例执行</li><li>BUG提交</li></ol><a id="more"></a><h2 id="软件的三个要素是什么"><a href="#软件的三个要素是什么" class="headerlink" title="软件的三个要素是什么"></a>软件的三个要素是什么</h2><p>程序+数据+文档</p><h2 id="软件的产品质量"><a href="#软件的产品质量" class="headerlink" title="软件的产品质量"></a>软件的产品质量</h2><p>参考质量模型部分</p><h2 id="软件测试的目的"><a href="#软件测试的目的" class="headerlink" title="软件测试的目的"></a>软件测试的目的</h2><ol><li>验证软件是否满足软件开发合同或者项目<strong>开发计划，软件需求规格说明书，软件产品说明</strong>等规定的软件质量要求</li><li>通过测试，发现软件中迄今为止尚未发现的缺陷</li><li>为软件产品的质量测量和评价提供依据</li></ol><h2 id="软件测试过程中的四个基本活动"><a href="#软件测试过程中的四个基本活动" class="headerlink" title="软件测试过程中的四个基本活动"></a>软件测试过程中的四个基本活动</h2><ol><li><strong>测试策划</strong>：进行测试的需求分析和测试计划的编写</li><li><strong>测试设计</strong>：依据测试需求，分析并选用已有的测试用例或者设计新的测试用例，进行用例评审</li><li><strong>测试执行</strong>：执行测试用例，获取测试结果，分析并判定测试结果</li><li><strong>测试总结</strong>：整理和分析测试数据，描述测试状态，最后完成软件测试报告并通过测试评审</li></ol><h2 id="测试用例设计的基本原则"><a href="#测试用例设计的基本原则" class="headerlink" title="测试用例设计的基本原则"></a>测试用例设计的基本原则</h2><p>case的设计应该符合以下几点：</p><ol><li>一个case一个功能点：每个case都要有个测点，找准一个测点即可，不能同时覆盖很多功能点</li><li>case的执行粒度：粒度越小越好</li><li>步骤清晰：一个case多个步骤，指明怎么去操作</li><li>总体设计：先正常，后异常，这样可以确保正常情况下功能能够走通</li></ol><h1 id="测试的分类"><a href="#测试的分类" class="headerlink" title="测试的分类"></a>测试的分类</h1><ul><li>按开发阶段划分<ul><li>单元测试：基于软件设计文档</li><li>集成测试：基于软件结构设计文档</li><li>系统测试：基于用户需求</li><li>验收测试：基于软件研制合同</li></ul></li><li>按是否查看代码分类<ul><li>黑盒测试：功能测试</li><li>白盒测试：基于程序的测试</li><li>灰盒测试：黑盒 + 白盒</li></ul></li><li>按是否运行划分<ul><li>静态测试：不执行被测软件，也可以用静态分析测试工具来进行（代码扫描）。</li><li>动态测试：执行被测试程序。通过执行结果，分析软件可能出现的错误。执行测试用例等。</li></ul></li><li>按测试对象划分<ul><li>性能测试</li><li>安全测试</li><li>兼容性测试</li><li>文档测试</li><li>用户体验测试</li><li>业务测试</li><li>界面测试</li><li>安装测试</li><li>内存泄漏测试</li></ul></li><li>按测试实施的组织<ul><li>$\alpha$测试：初期测试，软件完成后，由<strong>程序员</strong>来测试执行查看软件功能性是否正常</li><li>$\beta$测试：验收测试，交给<strong>最终的用户</strong>来测试其功能性</li><li>第三方测试：介于开发者和用户之间，由第三方组织来进行</li></ul></li><li>按是否手工执行划分<ul><li>手工测试</li><li>自动化测试</li></ul></li><li>其他分类<ul><li>冒烟测试：针对不同的版本，每次需求变更之后，<strong>在正式测试之前</strong>，对产品或者系统进行一次<strong>简单的验证测试 — 自测</strong></li><li>回归测试：修改代码之后，需要测试下是否引起了其他的一些问题</li></ul></li></ul><h1 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h1><p><strong>黑盒测试：功能测试</strong>，数据驱动测试或者基于规格说明书的测试。这种测试<strong>不必了解程序的内部逻辑结构</strong>，而是<strong>根据需求说明书中的功能来设计测试用例。</strong>具体方法分为：等价类划分法、边界值分析法、判定表法、因果图法、错误推测法</p><h2 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h2><ol><li>定义：等价类划分是在分析需求规格说明的基础上，把<strong>程序的输入域划分成若干个部分，然后在每部分选取代表性的数据形成测试用例</strong></li><li>等价类划分法的步骤如下：<ol><li><strong>划分有效等价类</strong>：对规格说明是有意义的、合理的输入数据所构成的集合。利用有效等价类可以检验程序是否满足规格说明所规定的<strong>功能和性能</strong>。</li><li><strong>划分无效等价类</strong>：不合理的输入数据所构成的集合。使用无效等价类可以<strong>测试程序/系统的容错性</strong>—对异常输入情况的处理。</li></ol></li></ol><h2 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h2><ol><li>定义：边界值分析法是针对边界值进行测试的，使用等于、大于或者小于边界值的数据对程序进行测试的方法</li><li>边界值分析法的步骤：<ol><li>通过分析规格说明书找出所有可能的边界条件</li><li>对每个边界条件给出满足和不满足的输入数据</li><li>设计相应的测试用例</li></ol></li></ol><h2 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h2><h1 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h1><p><strong>白盒测试：又称为结构测试</strong>、逻辑驱动测试或者基于程序的测试。这种测试应该了解软件程序的内部构造，并且根据程序的内部结构来设计测试用例。<strong>白盒测试是基于覆盖的测试，尽可能覆盖程序的结构特征和逻辑路径。</strong>其具体方法有逻辑覆盖、循环覆盖、基本路径覆盖。逻辑覆盖又可分为语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖。</p><h2 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h2><h2 id="循环覆盖"><a href="#循环覆盖" class="headerlink" title="循环覆盖"></a>循环覆盖</h2><h2 id="基本路径覆盖"><a href="#基本路径覆盖" class="headerlink" title="基本路径覆盖"></a>基本路径覆盖</h2><h1 id="静态测试、动态测试"><a href="#静态测试、动态测试" class="headerlink" title="静态测试、动态测试"></a>静态测试、动态测试</h1><ol><li>静态测试：又称为静态分析结束，其基本特征是不执行被测软件，根据检查列表，<strong>对需求分析说明书、软件设计说明书以及源程序做结构检查、流程图分析等找出软件错误</strong>。静态测试一般采用人工分析（针对文档），也可以用静态分析测试工具来进行（代码扫描）。</li><li>动态测试：其基本特征是执行被测试程序。通过执行结果，分析软件可能出现的错误 ，一般由人工设计程序测试用例，也可以由测试工具做检查和分析。</li></ol><h1 id="软件质量模型"><a href="#软件质量模型" class="headerlink" title="软件质量模型"></a>软件质量模型</h1><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><p>ANSI/IEEE 定义软件质量为：“与软件产品满足规定的和隐含的需求的能力有关的特征或特性的全体”。</p><h2 id="ISO-IEC-9126质量模型"><a href="#ISO-IEC-9126质量模型" class="headerlink" title="ISO/IEC 9126质量模型"></a>ISO/IEC 9126质量模型</h2><p>测试是对软件质量的度量，那么如何度量，从哪些角度度量。</p><p>我们需要一套标准，或者说模型来作参考，赋予不同指标不同的权重，通过计算软件质量的得分，便可以评判出质量的好坏。</p><p>ISO/IEC 9126在1991年12月发布，将软件质量归为6大特性和27个子特性。</p><p><img data-src="/images/data/Screen Shot 2020-11-10 at 11.44.26.png" alt="Screen Shot 2020-11-10 at 11.44.26"></p><p>功能性：软件产品提供满足明确和隐含需求功能的能力</p><ul><li>适合性：为规定任务提供一组合适功能的功能，即做了该做的事</li><li>准确性：得到正确或相符的预期结果的能力</li><li>互操作性：与其他系统软件交互的能力</li><li>保密安全性：防止对程序及数据的非授权的故意或意外访问的能力</li></ul><p>可靠性：软件产品维护规定的性能级别的能力</p><ul><li>成熟性：避免软件内部的错误扩散而导致系统失效的能力</li><li>容错性：防止外部接口错误扩散而导致系统失效的能力</li><li>易恢复性：系统失效后，重新恢复原有的功能和性能的能力</li></ul><p>易用性：软件产品被理解、学习、使用及吸引用户的能力</p><ul><li>易理解性：交互性要清晰、准确和易懂</li><li>易学性：用户学习软件所花努力的属性</li><li>易操作性：用户操作和控制软件的能力</li><li>吸引性：吸引用户的能力</li></ul><p><strong>性能效率</strong>：相对于所用资源的数量，软件产品可提供适当性能的能力</p><ul><li><strong>时间特性</strong>：软件执行功能时的响应、处理时间和吞吐率</li><li><strong>资源特性</strong>：软件执行功能时所使用的资源数量和类型</li></ul><p>维护性：软件产品可以被修改的能力，修改可能包括修改、改进或者适应环境、需求和功能规约的变化</p><ul><li>易分析性：诊断缺陷或失效原因所需努力的属性</li><li>易改变性：进行修改、排除错误或适应环境变化的能力</li><li>稳定性：避免软件修改而造成意外结果的能力</li><li>易测试性：提供辅助性手段帮助测试人员实现其测试意图</li></ul><p>可移植性：软件产品从一个环境迁移到另一个环境的能力</p><ul><li>适应性：无需相应变动就能适应不同环境的能力</li><li>易安装性：尽可能少的提供选择，方便用户直接安装</li><li>共存性：与其他公共软件共存</li><li>易替换性：同等环境下，替换其他同类产品的能力</li></ul><h2 id="GB-T-25000质量模型"><a href="#GB-T-25000质量模型" class="headerlink" title="GB/T 25000质量模型"></a>GB/T 25000质量模型</h2><p>于2016年发布，(新增兼容性和信息安全)，大方向没有改变，新增的2大特性（信息安全性、兼容性）也是从原有的功能性和可移植性中分裂出来。</p><p><img data-src="/images/data/Screen Shot 2020-11-10 at 11.54.54.png" alt="Screen Shot 2020-11-10 at 11.54.54"></p><p>信息安全性，产品或系统保护信息和数据的程序，以使用户、其他产品或系统具有与其授权和授权级别一致的数据访问度</p><ul><li>保密性，产品或系统确保数据只有在被授权时才能被访问的程度</li><li>完整性，系统、产品或组件防止未授权访问、篡改计算机程序或数据的程度</li><li>抗抵赖性，活动或事件发生后可以被证实且不可被否认的程度</li><li>可核查性，实体的活动可以被唯一地追溯到该实体的程度</li><li>真实性，对象或资源的身份标识能够被证实符合其声明的程度</li></ul><p><a href="https://juejin.im/post/6844903878354272269" target="_blank" rel="noopener">从纺锤模型到金字塔模型</a></p><h1 id="软件开发中之敏捷开发：DevOps"><a href="#软件开发中之敏捷开发：DevOps" class="headerlink" title="软件开发中之敏捷开发：DevOps"></a>软件开发中之敏捷开发：DevOps</h1><p>DevOps是一套实践方法论和文化，提倡打破原有组织和限制，职能团队开始拥抱和接受<strong>DevOps所倡导的高度协同，研发、测试、运维及交付一体化的思维</strong>。随着DevOps和敏捷热度的不断提升，无论是互联网企业还是传统软件企业都开始拥抱<strong>敏捷</strong>，实践DevOps。<strong>持续集成CI（Continuous integration）、持续交付CD（Continuous delivery ）</strong>作为DevOps的最佳实践，越来越受到重视。</p><h1 id="软件开发中之微服务架构"><a href="#软件开发中之微服务架构" class="headerlink" title="软件开发中之微服务架构"></a>软件开发中之微服务架构</h1><p>微服务架构源起于DevOps意识形态和实践中，是一种软件架构风格。微服务架构带来了一系列好处，例如<strong>可部署性、可靠性、可用性</strong>等等。虽然原则上可以使用任何架构来实践DevOps，但微服务架构<strong>正在成为构建持续部署 (CD)</strong>系统的标准<strong>架构风格</strong>。由于<strong>每项服务的规模都很小</strong>，它允许通过<strong>连续重构来实现单个服务</strong>的体系结构，因此<strong>减少了对大型项目前期设计的需求，允许尽早发布软件并且持续交付</strong>。微服务和DevOps是天然的共同体，结合起来共同实现软件开发行业的变革。</p><h1 id="分层理论：金字塔模型"><a href="#分层理论：金字塔模型" class="headerlink" title="分层理论：金字塔模型"></a>分层理论：金字塔模型</h1><p>随着敏捷和微服务架构的引入，<strong>CI/CD成为构建和部署的标准</strong>。传统的手工测试方式在人员和效率上都存在严重不足，因此自动化测试已经成为现代软件研发过程中一个关键组成部分。<strong>自动化测试是打通持续集成和持续交付的核心</strong>，没有有效的自动化测试保证，持续集成和持续交付就仅仅是一个没有灵魂的躯壳。</p><p>Martin Fowler描述<strong>测试金字塔</strong>分为单元、服务和UI三个层级。</p><p><strong>1)单元测试</strong></p><p>单元测试是针对<strong>代码单元（通常是类/方法）</strong>的测试，单元测试的价值在于能提供最快的反馈，在开发过程中就可以对逻辑单元进行验证。好的单元测试可以帮助改善既有设计，在团队掌握 TDD的前提下，单元测试能辅助重构，帮助提升代码整洁度。</p><p><strong>2)接口（服务/API）测试</strong></p><p><strong>接口测试是针对业务接口进行的测试</strong>，主要测试内部接口功能实现是否完整。比如内部逻辑是否正常、异常处理是否正确。接口测试的主要价值在于接口定义相对稳定，不像界面或底层代码会经常发生变化，所以接口测试比较容易编写，用例的维护成本也相对较低。在接口层面准备测试的性价比相对较高。</p><p><strong>3)集成（UI）测试</strong></p><p><strong>集成测试从用户的角度验证产品功能的正确性，测的是端到端的流程</strong>，并且加入用户场景和数据，验证整个过程是否健康流畅。集成测试的业务价值最高，它验证的是一个完整的流程，但因为需要验证完整流程，在环境部署、准备用例及实施等方面成本较高，实施起来并不容易。</p><h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><h2 id="自动化测试分层及占比"><a href="#自动化测试分层及占比" class="headerlink" title="自动化测试分层及占比"></a>自动化测试分层及占比</h2><p>先来看一般的功能测试如何进行：设计并编写用例文档，描述测试步骤和预期结果；测试人员根据测试用例描述按步骤操作，然后判断实际结果与预期是否一致。如果一致，测试通过；如果不符，测试失败。</p><p><strong>自动化测试要做的事情与功能测试是一致的。分层理论和自动化测试方法结合，出现了三个层面的自动化：单元测试自动化、接口测试自动化和UI测试自动化。</strong>当然，不同层面的自动化关注点是不一样的。所以，从测试的行为本质上来看，功能测试与单元自动化测试、接口自动化测试和UI自动化测试并没有区别。唯一的区别是，一个由人来执行，一个由代码或工具执行。</p><ul><li>单元自动化测试</li></ul><p>单元测试关注的是代码的实现与逻辑。单元测试是最基本的测试，也是测试中的最小单元，它的对象是函数对象，也可以包含输入输出，针对的是函数功能或者函数内部的代码逻辑，并不包含业务逻辑。</p><p>该类测试一般由研发人员完成，需要借助单元测试框架，如java的Junit、TestNG，python的<strong>unittest</strong>等。</p><ul><li>接口自动化测试</li></ul><p>接口自动化测试，主要验证<strong>模块间的调用返回以及不同系统、服务间的数据交换</strong>。</p><p>根据接口文档是RESTful还是RPC，最终断言返回的结果是否等于预期结果。如果相等，测试通过；如果不相等，测试失败。</p><p>常见的接口测试工具有<strong>postman、jmeter、loadrunner</strong>等。</p><ul><li>集成自动化测试</li></ul><p>UI层是用户使用产品的入口，所有功能通过这一层提供给用户。</p><p>当UI自动化登录成功后，就去获取这个数据进行断言，断言如果相等，测试通过；如果不相等，测试失败。</p><p>所以，UI自动化的关注点用户操作形为，以及UI上各种组件是否可用。常见的测试工具有<strong>UFT、Robot Framework、Selenium、Appium</strong>等。</p><p>按照测试金字塔模型以及投入/产出比，我们得知越向下回报率越高，<strong>所以应该使用大量的单元测试和全面的接口测试来覆盖产品提供的基本逻辑和功能，使用少量的集成（UI）测试来进行前端界面的功能验证。</strong></p><p>都说业内最佳实践看Google，Google的自动化分层投入占比是：<strong>单元测试（Unit）：占比70%；接口测试（Service）：占比20%；集成测试（UI）：占比10%.</strong></p><h2 id="自动化最佳实践：纺锤模型"><a href="#自动化最佳实践：纺锤模型" class="headerlink" title="自动化最佳实践：纺锤模型"></a>自动化最佳实践：纺锤模型</h2><p><strong>对现阶段公司大部分团队来说，更符合实际测试模式是纺锤模型</strong>。新项目中，可能由于时限原因或者开发人员习惯问题，一开始并没有把单元测试准备得很完善；而某些遗留老项目，可能原本就没有多少单元测试。</p><p>在上述情况下，一般的做法是先将重心放在中间层的测试上，原因有以下两点：</p><ul><li>第一，中间层<strong>投入产出比较高</strong>，可以实现较高的自动化率；</li><li>第二，可以帮助加强<strong>开发跟测试人员之间的协作</strong>，提高测试质量。这一层需要开发跟测试人员共同定义，因为开发知道内部实现的细节，测试掌握业务场景。</li></ul><p>当项目进行一段时间以后，各层测试占比有必要向理想型的金字塔型过渡，这时需要关注以下三个方面：</p><ul><li>开发与测试互相传递能力；</li><li>全员关注产品设计跟代码的质量；</li><li>让用例逐步下沉，最后逐步过渡到理想型。</li></ul><p><img data-src="/images/data/Screen Shot 2020-11-10 at 13.09.44.png" alt="Screen Shot 2020-11-10 at 13.09.44"></p><h1 id="测试质量评估"><a href="#测试质量评估" class="headerlink" title="测试质量评估"></a>测试质量评估</h1><p>关于度量，不要用单一的指标去评估测试和产品质量，比如用例通过率、代码覆盖率等都无法独立地评估产品质量。</p><p>评估测试质量时要关心以下几个方面：</p><ul><li>第一是<strong>用例比例</strong>，即每一层的用例比例是多少。</li><li>第二是<strong>测试覆盖率</strong>。</li><li>第三是<strong>测试总运行时间</strong>，因为经过优化以后，总运行时间一定是越来越少。</li><li>第四是<strong>代码质量指标，反映代码的质量和整洁度</strong>。</li></ul><h1 id="Python自动化测试框架"><a href="#Python自动化测试框架" class="headerlink" title="Python自动化测试框架"></a>Python自动化测试框架</h1><ol><li><p>python+selenium+unittest+htmltestrunner</p></li><li><p>python+selenium+pytest+allure</p></li><li><p>robotframework+Selenium2Library</p></li></ol><h2 id="pytest"><a href="#pytest" class="headerlink" title="pytest"></a>pytest</h2><p>pytest是一个非常成熟的Python测试框架</p><ol><li>能够支持简单的单元测试和复杂的功能测试，还可以用来做selenium/appnium等自动化测试，接口自动化测试（pytest+request）</li><li>pytest具有很多第三方插件，并且可以自定义扩展，常用的插件有：<ol><li>pytest-selenium（集成selenium）</li><li>pytest-html（完美html测试报告生成）</li><li>pytest-rerunfailures（失败case重复执行）</li><li>pytest-xdist（多CPU分发）</li></ol></li></ol><p><a href="https://www.cnblogs.com/mytianying/p/12466302.html" target="_blank" rel="noopener">https://www.cnblogs.com/mytianying/p/12466302.html</a></p><h1 id="算法测试"><a href="#算法测试" class="headerlink" title="算法测试"></a>算法测试</h1><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><h2 id="算法鲁棒性"><a href="#算法鲁棒性" class="headerlink" title="算法鲁棒性"></a>算法鲁棒性</h2><h2 id="模型安全"><a href="#模型安全" class="headerlink" title="模型安全"></a>模型安全</h2><h2 id="响应速度"><a href="#响应速度" class="headerlink" title="响应速度"></a>响应速度</h2><h1 id="测试问题汇总"><a href="#测试问题汇总" class="headerlink" title="测试问题汇总"></a>测试问题汇总</h1><h2 id="编写测试计划的目的是"><a href="#编写测试计划的目的是" class="headerlink" title="编写测试计划的目的是"></a>编写测试计划的目的是</h2><h2 id="对关键词触发模块进行测试"><a href="#对关键词触发模块进行测试" class="headerlink" title="对关键词触发模块进行测试"></a>对关键词触发模块进行测试</h2><h2 id="其他常用笔试题目网址汇总"><a href="#其他常用笔试题目网址汇总" class="headerlink" title="其他常用笔试题目网址汇总"></a>其他常用笔试题目网址汇总</h2><h2 id="测试人员在软件开发过程中的任务是什么"><a href="#测试人员在软件开发过程中的任务是什么" class="headerlink" title="测试人员在软件开发过程中的任务是什么"></a>测试人员在软件开发过程中的任务是什么</h2><h2 id="一条软件Bug记录都包含了哪些内容？"><a href="#一条软件Bug记录都包含了哪些内容？" class="headerlink" title="一条软件Bug记录都包含了哪些内容？"></a>一条软件Bug记录都包含了哪些内容？</h2><h2 id="简述黑盒测试和白盒测试的优缺点"><a href="#简述黑盒测试和白盒测试的优缺点" class="headerlink" title="简述黑盒测试和白盒测试的优缺点"></a>简述黑盒测试和白盒测试的优缺点</h2><h2 id="请列出你所知道的软件测试种类，至少5项"><a href="#请列出你所知道的软件测试种类，至少5项" class="headerlink" title="请列出你所知道的软件测试种类，至少5项"></a>请列出你所知道的软件测试种类，至少5项</h2><h2 id="Alpha测试与Beta测试的区别是什么？"><a href="#Alpha测试与Beta测试的区别是什么？" class="headerlink" title="Alpha测试与Beta测试的区别是什么？"></a>Alpha测试与Beta测试的区别是什么？</h2><h2 id="举例说明什么是Bug？一个bug-report应包含什么关键字？"><a href="#举例说明什么是Bug？一个bug-report应包含什么关键字？" class="headerlink" title="举例说明什么是Bug？一个bug report应包含什么关键字？"></a>举例说明什么是Bug？一个bug report应包含什么关键字？</h2><h2 id="在selenium自动化测试中，你一般完成什么类型的测试？自动化覆盖率？"><a href="#在selenium自动化测试中，你一般完成什么类型的测试？自动化覆盖率？" class="headerlink" title="在selenium自动化测试中，你一般完成什么类型的测试？自动化覆盖率？"></a><strong>在selenium自动化测试中，你一般完成什么类型的测试？自动化覆盖率？</strong></h2><p>主要是冒烟测试和回归测试。回归测试主要写一些功能稳定的场景，通过自动化手段去实现，节约测试时间。因为自动化测试用例也是在不断的更新和迭代，没有刻意去统计，大概在30%-40%左右！</p><h2 id="什么是PO模式，为什么要使用它"><a href="#什么是PO模式，为什么要使用它" class="headerlink" title="什么是PO模式，为什么要使用它"></a><strong>什么是PO模式，为什么要使用它</strong></h2><p>PO是Page Object 模式的简称，它是一种设计思想，意思是，把一个页面，当做一个对象，页面的元素和元素之间操作方法就是页面对象的属性和行为，PO模式一般使用三层架构，分别为：基础封装层BasePage，PO页面对象层，TestCase测试用例层。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;软件测试理论&quot;&gt;&lt;a href=&quot;#软件测试理论&quot; class=&quot;headerlink&quot; title=&quot;软件测试理论&quot;&gt;&lt;/a&gt;软件测试理论&lt;/h1&gt;&lt;h2 id=&quot;软件测试的生命周期&quot;&gt;&lt;a href=&quot;#软件测试的生命周期&quot; class=&quot;headerlink&quot; title=&quot;软件测试的生命周期&quot;&gt;&lt;/a&gt;软件测试的生命周期&lt;/h2&gt;&lt;p&gt;软件测试生命周期是指从项目计划建立到BUG提交的整个测试过程，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;软件项目测试计划&lt;/li&gt;
&lt;li&gt;测试需求分析&lt;/li&gt;
&lt;li&gt;测试用例设计&lt;/li&gt;
&lt;li&gt;测试用例执行&lt;/li&gt;
&lt;li&gt;BUG提交&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Computer Basic" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/"/>
    
      <category term="Interview" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/Interview/"/>
    
    
      <category term="Software Test Basic" scheme="https://unknown.yuzhouwan.com/tags/Software-Test-Basic/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://unknown.yuzhouwan.com/posts/2248809/"/>
    <id>https://unknown.yuzhouwan.com/posts/2248809/</id>
    <published>2020-01-27T23:55:00.000Z</published>
    <updated>2020-11-20T06:33:38.527Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/27700617" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27700617</a></p><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>（1）非叶子节点最多拥有两个子节点；</p><p>（2）非叶子节值大于左边子节点、小于右边子节点；</p><p>（3）树的左右两边的层级数相差不会大于1;</p><p>（4）没有值相等重复的节点;</p><a id="more"></a><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树与AVL的比较：</p><ul><li><p>AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，<strong>旋转的次数比红黑树要多；</strong></p></li><li><p>红黑是用非严格的平衡来<strong>换取增删节点时候旋转次数的降低</strong>；</p></li></ul><p>所以简单说，如果你的应用中，<strong>搜索的次数远远大于插入和删除，那么选择AVL</strong>。</p><p>如果<strong>搜索，插入删除次数几乎差不多，应该选择RB</strong>。</p><p>红黑树详解: <a href="https://xieguanglei.github.io/blog/post/red-black-tree.html" target="_blank" rel="noopener">https://xieguanglei.github.io/blog/post/red-black-tree.html</a></p><p>教你透彻了解红黑树: <a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md" target="_blank" rel="noopener">https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md</a></p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>B树和平衡二叉树稍有不同的是B树属于多叉树又名<strong>平衡多路查找树</strong>（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构。</p><p>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</p><p>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉）；</p><p>（3）关键字数：枝节点的关键字数量大于等于ceil(m/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p><p>（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</p><p><img data-src="/images/data/B-tree.png" alt="B-tree"></p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>（1）B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，<strong>只进行数据索引</strong>，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</p><p>（2）B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p><p>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</p><p>（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;</p><h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h1><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><p>（1）首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b<em>树的初始化个数为（cei(2/3</em>m)）</p><p>（2）B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27700617&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/27700617&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;平衡二叉树&quot;&gt;&lt;a href=&quot;#平衡二叉树&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树&quot;&gt;&lt;/a&gt;平衡二叉树&lt;/h1&gt;&lt;h2 id=&quot;平衡二叉树-1&quot;&gt;&lt;a href=&quot;#平衡二叉树-1&quot; class=&quot;headerlink&quot; title=&quot;平衡二叉树&quot;&gt;&lt;/a&gt;平衡二叉树&lt;/h2&gt;&lt;p&gt;（1）非叶子节点最多拥有两个子节点；&lt;/p&gt;
&lt;p&gt;（2）非叶子节值大于左边子节点、小于右边子节点；&lt;/p&gt;
&lt;p&gt;（3）树的左右两边的层级数相差不会大于1;&lt;/p&gt;
&lt;p&gt;（4）没有值相等重复的节点;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Basic" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/"/>
    
      <category term="Interview" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/Interview/"/>
    
    
      <category term="DataStructure" scheme="https://unknown.yuzhouwan.com/tags/DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>Python自动化测试框架</title>
    <link href="https://unknown.yuzhouwan.com/posts/22398665/"/>
    <id>https://unknown.yuzhouwan.com/posts/22398665/</id>
    <published>2020-01-26T23:55:00.000Z</published>
    <updated>2020-11-23T03:18:19.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pytest"><a href="#pytest" class="headerlink" title="pytest"></a>pytest</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>pytest是一个非常成熟的Python测试框架</p><ol><li>能够支持简单的单元测试和复杂的功能测试，还可以用来做selenium/appnium等自动化测试，接口自动化测试（pytest+request）</li><li>pytest具有很多第三方插件，并且可以自定义扩展，常用的插件有：<ol><li>pytest-selenium（集成selenium）</li><li>pytest-html（完美html测试报告生成）</li><li><strong>pytest-rerunfailures（失败case重复执行）</strong></li><li>pytest-xdist（多CPU分发）</li></ol></li><li>支持参数化，可以细粒度地控制要测试的测试用例</li><li>可以很好的和CI工具结合，例如Jenkins</li></ol><p><a href="https://docs.pytest.org/en/stable/" target="_blank" rel="noopener">https://docs.pytest.org/en/stable/</a></p><p><a href="https://www.cnblogs.com/mytianying/p/12466302.html" target="_blank" rel="noopener">https://www.cnblogs.com/mytianying/p/12466302.html</a></p><a id="more"></a><h3 id="编写规则"><a href="#编写规则" class="headerlink" title="编写规则"></a>编写规则</h3><ul><li>测试文件以test开头（以test结尾也可以）</li><li>测试类以Test开头，并且不能带有init方法</li><li>测试函数以test开头</li><li>断言使用基本的assert即可</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_whitebalance.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLoginCase</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="comment"># def __init__(self):</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test01</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"test01"</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  pytest.main([<span class="string">"-vs"</span>, <span class="string">"test_whitebalance.py"</span>])</span><br></pre></td></tr></tbody></table></figure><p>Console参数介绍</p><ul><li>-v 用于显示每个测试函数的执行结果</li><li>-q 只显示整体测试结果</li><li>-s 用于显示测试函数中print ()函数输出</li><li>-x，—exitfirst，在第一个错误或测试失败时立刻退出</li><li>-h 帮助</li></ul><h3 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h3><ul><li>配置PyCharm执行<ul><li>Tools -&gt; Python Integrated tools -&gt; Default test runner</li></ul></li><li>main方法<ul><li>pytest.main([“-s”, “-v”, “test_whitebalance.py”])</li></ul></li><li>命令行<ul><li>pytest -s -v test_whitebalance.py</li></ul></li></ul><h2 id="pytest标记"><a href="#pytest标记" class="headerlink" title="pytest标记"></a>pytest标记</h2><h3 id="pytest查找测试策略"><a href="#pytest查找测试策略" class="headerlink" title="pytest查找测试策略"></a>pytest查找测试策略</h3><ul><li>默认情况下，pytest会递归查找当前目录下所有以test开始或者结尾的Python脚本</li><li>并执行文件内的所有以test开始或结束的函数和方法</li></ul><h3 id="标记测试函数"><a href="#标记测试函数" class="headerlink" title="标记测试函数"></a>标记测试函数</h3><ul><li><p>由于某种原因（<strong>如test_func2的功能尚未开发完成</strong>），我们只想执行指定的测试函数。</p></li><li><p>第一种，显式指定函数名，通过“ :: ”标记</p><ul><li>test_whitebalance.py::test_func1</li></ul></li><li><p>第二种，使用模糊匹配，使用-k选项标识</p><ul><li>pytest -k func1 test_whitebalance.py</li></ul></li><li><p>第三种，使用pytest.mark在函数上进行标记</p><blockquote><ol><li><p>在项目中添加pytest.ini配置文件</p><p>[pytest]</p><p>markers=</p><p>​        do: do</p><p>​        undo: undo</p></li></ol></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_whitebalance.py</span></span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.do</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test01</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"test01"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="meta">@pytest.mark.undo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test02</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"test02"</span>)</span><br></pre></td></tr></tbody></table></figure><ul><li>pytest -m do test_whitebalance.py</li></ul></li></ul><h2 id="pytest参数化处理-pytest-mark-parametrize-：数据驱动DDT"><a href="#pytest参数化处理-pytest-mark-parametrize-：数据驱动DDT" class="headerlink" title="pytest参数化处理@pytest.mark.parametrize()：数据驱动DDT"></a>pytest参数化处理@pytest.mark.parametrize()：数据驱动DDT</h2><p>pytest参数化处理：使用参数化装饰器、解析列表、元组、字典等数据</p><ul><li>在pytest中，也可以使用参数化测试，即<strong>每组参数都独立执行一次测试</strong></li><li>使用的工具就是<strong>pytest.mark.parametrize(arguments, argvalues)</strong></li></ul><p>例子：</p><p>如需要测试用户登陆功能，假设需要4个用例</p><ol><li>用户名正确，密码错误：<code>admin ***</code></li><li>用户名错误，密码正确：<code>*** 123</code></li><li>用户名正确，密码正确：<code>admin 123</code></li><li>用户名错误，密码错误： <code>*** ***</code></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">data1 = [<span class="string">'123'</span>, <span class="string">'456'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize('pwd', data1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(pwd)</span>:</span></span><br><span class="line">  print(pwd)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元组</span></span><br><span class="line">data2 = [</span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), </span><br><span class="line">  (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize('a, b, c', data2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(pwd)</span>:</span></span><br><span class="line">  print(a, b, c)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典</span></span><br><span class="line">data3 = (</span><br><span class="line">{</span><br><span class="line">    <span class="string">'usr'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'pwd'</span>: <span class="number">2</span></span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'email'</span>: <span class="string">'tom@qq.com'</span></span><br><span class="line">  }</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize('dic', data3)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">(dic)</span>:</span></span><br><span class="line">  print(dic) <span class="comment"># 再去按照字典类型遍历即可</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># id值可以自定义，只要方便理解每个用例是干什么的即可, 主要为了增强可读性</span></span><br><span class="line">data4 = [</span><br><span class="line">  pytest.param(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, id=<span class="string">"(a+b):pass"</span>),</span><br><span class="line">  pytest.param(<span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, id=<span class="string">"(a+b):fail"</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize("a, b, expect", data4)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_parameterize</span><span class="params">(a, b, expect)</span>:</span></span><br><span class="line">  <span class="keyword">assert</span> add(a, b) == expect</span><br></pre></td></tr></tbody></table></figure><h2 id="pytest-fixture"><a href="#pytest-fixture" class="headerlink" title="@pytest.fixture()"></a>@pytest.fixture()</h2><p>@pytest.fixture() 用于定义一个标记，定义好了之后在其他的测试用例里面，作为第一个参数，来直接引用就可以了。</p><ul><li>定义fixture跟定义普通函数差不多，唯一区别就是在函数上加一个装饰器@pytest.fixture()</li><li>fixture命名不要以test开头，跟用例区分开。fixture是有返回值的，没有返回值默认为None</li><li>用例调用fixture的返回值，直接就是把fixture的函数名称当作变量名称</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"init..."</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(init)</span>:</span></span><br><span class="line">  print(<span class="string">"test1"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(init)</span>:</span></span><br><span class="line">  print(<span class="string">"test2"</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="pytest-setup和teardown"><a href="#pytest-setup和teardown" class="headerlink" title="pytest setup和teardown"></a>pytest setup和teardown</h2><ul><li>作用：<strong>每次用例开始前和结束后都会去执行一次</strong></li><li>还有更高级的setupClass和teardownClass，需配合@classmethod装饰器一起使用</li><li>在做selenium自动化的时候，它的效率尤为突出，可以只启动一次浏览器执行多个用例</li></ul><p>简介</p><ul><li><p>模块级<strong>（setup_module/teardown_module）</strong>开始于模块始末，全局的</p><p>即一个模块只执行一次</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_module</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"setup_module"</span>)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"test1"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teardown_module</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"teardown_module"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  pytest.main([<span class="string">'test.py'</span>, <span class="string">'-sv'</span>])</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>函数级<strong>(setup_function/teardown_function)</strong>只对函数用例生效（不在类中）</p><p>即每次执行测试用例（函数）时，会去执行</p></li></ul><ul><li><p>类级<strong>(setup_class/teardown_class)</strong>只在类中前后运行一次（在类中）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCase01</span><span class="params">(object)</span>:</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup_class</span><span class="params">(cls)</span>:</span></span><br><span class="line">    print(<span class="string">"setup_class"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">teardown_class</span><span class="params">(cls)</span>:</span></span><br><span class="line">    print(<span class="string">"teardown_class"</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"test1 setup"</span>)</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li>方法级<strong>(setup_method/teardown_method)</strong>开始于方法始末（在类中）</li></ul><ul><li>类里面的<strong>(setup/teardown)</strong>运行在调用方法的前后（在类中）</li></ul><h2 id="pytest-allure生成测试报告"><a href="#pytest-allure生成测试报告" class="headerlink" title="pytest allure生成测试报告"></a>pytest allure生成测试报告</h2><ul><li>安装<ul><li>pip install allure-pytest</li></ul></li><li>官方文档<ul><li><a href="https://docs.qameta.io" target="_blank" rel="noopener">https://docs.qameta.io</a></li></ul></li><li>下载allure<ul><li><a href="https://dl.bintray.com/qameta/generic/io/qameta/allure/allure/2.7.0/" target="_blank" rel="noopener">https://dl.bintray.com/qameta/generic/io/qameta/allure/allure/2.7.0/</a></li></ul></li></ul><p>用例描述</p><div class="table-container"><table><thead><tr><th>使用方法</th><th>参数值</th><th>参数说明</th></tr></thead><tbody><tr><td>@allure.epic()</td><td>epic描述</td><td>敏捷里面的概念，定义史诗，往下是feature</td></tr><tr><td>@allure.feature()</td><td>模块名称</td><td>功能点的描述，往下是story</td></tr><tr><td>@allure.story()</td><td>用户故事</td><td>用户故事，往下是title</td></tr><tr><td>@allure.title(用例的标题)</td><td>用例的标题</td><td>重命名html报告名称</td></tr><tr><td>@allure.testcase()</td><td>测试用例的链接地址</td><td>对应功能测试用例系统里面的case</td></tr><tr><td>@allure.issue()</td><td>缺陷</td><td>对应缺陷管理系统里面的链接</td></tr><tr><td>@allure.description()</td><td>用例描述</td><td>测试用例的描述</td></tr><tr><td>@allure.step()</td><td>操作步骤</td><td>测试用例的步骤</td></tr><tr><td>@allure.severity()</td><td>用例等级</td><td>blocker、critical、normal、minor、trivial</td></tr><tr><td>@allure.link()</td><td>链接</td><td>定义一个链接，在测试报告展现</td></tr><tr><td>@allure.attachment()</td><td>附件</td><td>报告添加附件</td></tr></tbody></table></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> allure</span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(scope="session")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"用例先登陆"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="meta">@allure.step("步骤1：点***")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"111"</span>)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@allure.step("步骤2：点***")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_2</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">"222"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="meta">@allure.feature("编辑页面")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestEditPage</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="string">"""编辑页面"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">  @allure.story("这是一个***的用例")</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_01</span><span class="params">(self, login)</span>:</span></span><br><span class="line">  <span class="string">"""用例描述：先登陆，再去执行xxx"""</span></span><br><span class="line">    step_1()</span><br><span class="line">    step_2()</span><br><span class="line">    print(<span class="string">"xxx"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @allure.story("打开a页面")</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_02</span><span class="params">(self, login)</span>:</span></span><br><span class="line">  <span class="string">"""用例描述：先登陆，再去执行yyy"""</span></span><br><span class="line">    step_1()</span><br><span class="line">    step_2()</span><br><span class="line">    print(<span class="string">"yyy"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  <span class="comment"># 注意生成测试报告，必须在命令行里执行</span></span><br><span class="line">  <span class="comment"># pytest --alluredir ./report test08.py</span></span><br><span class="line">  <span class="comment"># allure serve ./report 启动allure 查看报告</span></span><br><span class="line">  pytest.main([<span class="string">'--alluredir'</span>, <span class="string">'./reports'</span>, <span class="string">'test08.py'</span>])</span><br><span class="line">  pytest.main([<span class="string">'--alluredir'</span>, <span class="string">'./reports'</span>, <span class="string">'test08.py'</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="使用pytest重构项目"><a href="#使用pytest重构项目" class="headerlink" title="使用pytest重构项目"></a>使用pytest重构项目</h2><ul><li>继承unittest.TestCase修改为继承object</li><li>unittest setup方法修改为pytest setup</li><li>unittest 的断言修改为python断言assert</li><li>使用pytest依赖插件</li><li>pip3 install pytest-dependency</li></ul><p>pytest里面的用例的依赖关系，使用@pytest.mark.dependency()</p><p>假如test_category.py需要依赖test_admin_login.py模块的执行成功，需要下面这样写。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_category.py</span></span><br><span class="line"><span class="keyword">from</span> testcases.pytest.test_admin_login <span class="keyword">import</span> TestAdminLogin</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.dependency(depends=["admin_login"], scope="module")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_add_category_error</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>日志级别</p><div class="table-container"><table><thead><tr><th>级别</th><th>信息</th></tr></thead><tbody><tr><td>DEBUG</td><td>最详细日志信息，典型应用场景是问题诊断</td></tr><tr><td>INFO</td><td>信息详细程度仅次于DEBUG，通常只记录关键点信息，用于确认一切都是按照我们预期的那样进行工作</td></tr><tr><td>WARNING</td><td>当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的</td></tr><tr><td>ERROR</td><td>由于一个更严重的问题导致某些功能不能正常运行时的记录的信息</td></tr><tr><td>CRITICAL</td><td>当放生严重错误时，导致应用程序不能继续运行时记录的信息</td></tr></tbody></table></div><h2 id="logging模块的四大组件"><a href="#logging模块的四大组件" class="headerlink" title="logging模块的四大组件"></a>logging模块的四大组件</h2><ul><li>loggers提供应用程序代码直接使用的接口</li><li>handlers用于将日志记录发送到指定的目的位置</li><li>filters 提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其他的日志记录将会被忽略）</li><li>formatters用于控制日志信息的最终输出格式</li></ul><h1 id="POM设计模式重构项目"><a href="#POM设计模式重构项目" class="headerlink" title="POM设计模式重构项目"></a>POM设计模式重构项目</h1><ul><li>POM页面对象模型是一种设计模式，用来管理维护一组web元素集的对象库</li><li>在POM模式下，应用程序的<strong>每一个页面都有一个对应的page class</strong></li><li>每一个page class维护着该web页的元素集和操作这些元素的方法</li><li>page class中的方法命名最好根据其对应的业务场景进行</li></ul><p><img data-src="/images/data/POM.png" alt="POM"></p><p>一个非POM的Web测试脚本如下：(测试和代码耦合在一起)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBaidu</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setUpClass</span><span class="params">(cls)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    cls.driver = webdriver.Chrome()</span><br><span class="line">    cls.driver.maxmize.window()</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_baidu</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.driver.get(<span class="string">"www.baidu.com"</span>)</span><br><span class="line">    self.driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(<span class="string">"selenium"</span>)</span><br><span class="line">    self.driver.find_element_by_id(<span class="string">"su"</span>).click()</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tearDownClass</span><span class="params">(cls)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    cls.driver.quit()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  uinttest.main()</span><br></pre></td></tr></tbody></table></figure><p>一个POM的Web测试脚本如下：（测试和代码解耦）</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 页面类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaiduPage</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.driver = webdriver.Chrome()</span><br><span class="line">    self.driver.maxmize_window()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定位器</span></span><br><span class="line">    self.input_element = (By.ID, <span class="string">"kw"</span>)</span><br><span class="line">    self.btn_element = (By.ID, <span class="string">"su"</span>)</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">goto_baidu</span><span class="params">(self, url)</span>:</span></span><br><span class="line">    self.driver.get(url)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_search</span><span class="params">(self, url, kw)</span>:</span></span><br><span class="line">    self.goto_baidu(url)</span><br><span class="line">    self.driver.find_element(*self.input_element).send_keys(kw)</span><br><span class="line">    self.driver.find_element(*self.btn_element).send_keys.click()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBaidu</span><span class="params">(uinttest.TestCase)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    self.baiduPage = BaiduPage()</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_search</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.baduPage.test_search(<span class="string">"www.baidu.com"</span>, <span class="string">"selenium"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  uinttest.main()</span><br></pre></td></tr></tbody></table></figure><h1 id="持续集成和交付"><a href="#持续集成和交付" class="headerlink" title="持续集成和交付"></a>持续集成和交付</h1><h2 id="Jenkins环境搭建"><a href="#Jenkins环境搭建" class="headerlink" title="Jenkins环境搭建"></a>Jenkins环境搭建</h2><ul><li>下载安装JDK</li><li>下载安装Jenkins</li></ul><h2 id="邮件通知"><a href="#邮件通知" class="headerlink" title="邮件通知"></a>邮件通知</h2><h2 id="定时运行项目：实现自动化测试"><a href="#定时运行项目：实现自动化测试" class="headerlink" title="定时运行项目：实现自动化测试"></a>定时运行项目：实现自动化测试</h2><p><a href="https://time.geekbang.org/course/detail/100055601-280769" target="_blank" rel="noopener">https://time.geekbang.org/course/detail/100055601-280769</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;pytest&quot;&gt;&lt;a href=&quot;#pytest&quot; class=&quot;headerlink&quot; title=&quot;pytest&quot;&gt;&lt;/a&gt;pytest&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;pytest是一个非常成熟的Python测试框架&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;能够支持简单的单元测试和复杂的功能测试，还可以用来做selenium/appnium等自动化测试，接口自动化测试（pytest+request）&lt;/li&gt;
&lt;li&gt;pytest具有很多第三方插件，并且可以自定义扩展，常用的插件有：&lt;ol&gt;
&lt;li&gt;pytest-selenium（集成selenium）&lt;/li&gt;
&lt;li&gt;pytest-html（完美html测试报告生成）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pytest-rerunfailures（失败case重复执行）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;pytest-xdist（多CPU分发）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;支持参数化，可以细粒度地控制要测试的测试用例&lt;/li&gt;
&lt;li&gt;可以很好的和CI工具结合，例如Jenkins&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.pytest.org/en/stable/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.pytest.org/en/stable/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mytianying/p/12466302.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/mytianying/p/12466302.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Computer Basic" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/"/>
    
      <category term="python" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/python/"/>
    
    
      <category term="Software Test Basic" scheme="https://unknown.yuzhouwan.com/tags/Software-Test-Basic/"/>
    
  </entry>
  
  <entry>
    <title>Web框架</title>
    <link href="https://unknown.yuzhouwan.com/posts/224800/"/>
    <id>https://unknown.yuzhouwan.com/posts/224800/</id>
    <published>2020-01-26T23:55:00.000Z</published>
    <updated>2020-11-19T08:36:50.638Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h2><h3 id="140-对Flask蓝图-Blueprint-的理解？"><a href="#140-对Flask蓝图-Blueprint-的理解？" class="headerlink" title="140.对Flask蓝图(Blueprint)的理解？"></a>140.对Flask蓝图(Blueprint)的理解？</h3><p>蓝图的定义</p><p>蓝图 /Blueprint 是Flask应用程序组件化的方法，可以在一个应用内或跨越多个项目共用蓝图。使用蓝图可以极大简化大型应用的开发难度，也为Flask扩展提供了一种在应用中注册服务的集中式机制。</p><p>蓝图的应用场景：</p><p>把一个应用分解为一个蓝图的集合。这对大型应用是理想的。一个项目可以实例化一个应用对象，初始化几个扩展，并注册一集合的蓝图。</p><p>以URL前缀和/或子域名，在应用上注册一个蓝图。URL前缀/子域名中的参数即成为这个蓝图下的所有视图函数的共同的视图参数（默认情况下）<br>在一个应用中用不同的URL规则多次注册一个蓝图。</p><p>通过蓝图提供模板过滤器、静态文件、模板和其他功能。一个蓝图不一定要实现应用或视图函数。</p><p>初始化一个Flask扩展时，在这些情况中注册一个蓝图。</p><p>蓝图的缺点：</p><p>不能在应用创建后撤销注册一个蓝图而不销毁整个应用对象。</p><p>使用蓝图的三个步骤</p><p>1.创建一个蓝图对象</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blue = Blueprint(<span class="string">"blue"</span>,__name__)</span><br></pre></td></tr></tbody></table></figure><p>2.在这个蓝图对象上进行操作，例如注册路由、指定静态文件夹、注册模板过滤器…</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@blue.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blue_index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Welcome to my blueprint"</span></span><br></pre></td></tr></tbody></table></figure><p>3.在应用对象上注册这个蓝图对象</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.register_blueprint(blue,url_prefix=<span class="string">"/blue"</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="141-Flask-和-Django-路由映射的区别？"><a href="#141-Flask-和-Django-路由映射的区别？" class="headerlink" title="141.Flask 和 Django 路由映射的区别？"></a>141.Flask 和 Django 路由映射的区别？</h3><p>  在django中，路由是浏览器访问服务器时，先访问的项目中的url，再由项目中的url找到应用中url，这些url是放在一个列表里，遵从从前往后匹配的规则。在flask中，路由是通过装饰器给每个视图函数提供的，而且根据请求方式的不同可以一个url用于不同的作用。</p><h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><h3 id="142-什么是wsgi-uwsgi-uWSGI"><a href="#142-什么是wsgi-uwsgi-uWSGI" class="headerlink" title="142.什么是wsgi,uwsgi,uWSGI?"></a>142.什么是wsgi,uwsgi,uWSGI?</h3><p>WSGI:</p><p>web服务器网关接口，是一套协议。用于接收用户请求并将请求进行初次封装，然后将请求交给web框架。</p><p>实现wsgi协议的模块：wsgiref,本质上就是编写一socket服务端，用于接收用户请求（django)</p><p>werkzeug,本质上就是编写一个socket服务端，用于接收用户请求(flask)</p><p>uwsgi:</p><p>与WSGI一样是一种通信协议，它是uWSGI服务器的独占协议，用于定义传输信息的类型。<br>uWSGI:</p><p>是一个web服务器，实现了WSGI的协议，uWSGI协议，http协议</p><h3 id="143-Django、Flask、Tornado的对比？"><a href="#143-Django、Flask、Tornado的对比？" class="headerlink" title="143.Django、Flask、Tornado的对比？"></a>143.Django、Flask、Tornado的对比？</h3><p>1、 Django走的大而全的方向，开发效率高。它的MTV框架，自带的ORM,admin后台管理,自带的sqlite数据库和开发测试用的服务器，给开发者提高了超高的开发效率。<br>重量级web框架，功能齐全，提供一站式解决的思路，能让开发者不用在选择上花费大量时间。</p><p>自带ORM和模板引擎，支持jinja等非官方模板引擎。</p><p>自带ORM使Django和关系型数据库耦合度高，如果要使用非关系型数据库，需要使用第三方库</p><p>自带数据库管理app</p><p>成熟，稳定，开发效率高，相对于Flask，Django的整体封闭性比较好，适合做企业级网站的开发。python web框架的先驱，第三方库丰富</p><p>2、 Flask 是轻量级的框架，自由，灵活，可扩展性强，核心基于Werkzeug WSGI工具 和jinja2 模板引擎</p><p>适用于做小网站以及web服务的API,开发大型网站无压力，但架构需要自己设计</p><p>与关系型数据库的结合不弱于Django，而与非关系型数据库的结合远远优于Django</p><p>3、 Tornado走的是少而精的方向，性能优越，它最出名的异步非阻塞的设计方式</p><p>Tornado的两大核心模块：</p><p>iostraem:对非阻塞的socket进行简单的封装</p><p>ioloop: 对I/O 多路复用的封装,它实现一个单例</p><h3 id="144-CORS-和-CSRF的区别？"><a href="#144-CORS-和-CSRF的区别？" class="headerlink" title="144.CORS 和 CSRF的区别？"></a>144.CORS 和 CSRF的区别？</h3><p>什么是CORS？</p><p>CORS是一个W3C标准,全称是“跨域资源共享”(Cross-origin resoure sharing).<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而客服了AJAX只能同源使用的限制。</p><p>什么是CSRF？</p><p>CSRF主流防御方式是在后端生成表单的时候生成一串随机token,内置到表单里成为一个字段，同时，将此串token置入session中。每次表单提交到后端时都会检查这两个值是否一致，以此来判断此次表单提交是否是可信的，提交过一次之后，如果这个页面没有生成CSRF token,那么token将会被清空,如果有新的需求，那么token会被更新。<br>攻击者可以伪造POST表单提交，但是他没有后端生成的内置于表单的token，session中没有token都无济于事。</p><h3 id="145-Session-Cookie-JWT的理解"><a href="#145-Session-Cookie-JWT的理解" class="headerlink" title="145.Session,Cookie,JWT的理解"></a>145.Session,Cookie,JWT的理解</h3><p>为什么要使用会话管理</p><p>众所周知，HTTP协议是一个无状态的协议，也就是说每个请求都是一个独立的请求，请求与请求之间并无关系。但在实际的应用场景，这种方式并不能满足我们的需求。举个大家都喜欢用的例子，把商品加入购物车，单独考虑这个请求，服务端并不知道这个商品是谁的，应该加入谁的购物车？因此这个请求的上下文环境实际上应该包含用户的相关信息，在每次用户发出请求时把这一小部分额外信息，也做为请求的一部分，这样服务端就可以根据上下文中的信息，针对具体的用户进行操作。所以这几种技术的出现都是对HTTP协议的一个补充，使得我们可以用HTTP协议+状态管理构建一个的面向用户的WEB应用。</p><p>Session 和Cookie的区别</p><p>  这里我想先谈谈session与cookies,因为这两个技术是做为开发最为常见的。那么session与cookies的区别是什么？个人认为session与cookies最核心区别在于额外信息由谁来维护。利用cookies来实现会话管理时，用户的相关信息或者其他我们想要保持在每个请求中的信息，都是放在cookies中,而cookies是由客户端来保存，每当客户端发出新请求时，就会稍带上cookies,服务端会根据其中的信息进行操作。<br>  当利用session来进行会话管理时，客户端实际上只存了一个由服务端发送的session_id,而由这个session_id,可以在服务端还原出所需要的所有状态信息，从这里可以看出这部分信息是由服务端来维护的。</p><p>除此以外，session与cookies都有一些自己的缺点：</p><p>cookies的安全性不好，攻击者可以通过获取本地cookies进行欺骗或者利用cookies进行CSRF攻击。使用cookies时,在多个域名下，会存在跨域问题。<br>session 在一定的时间里，需要存放在服务端，因此当拥有大量用户时，也会大幅度降低服务端的性能，当有多台机器时，如何共享session也会是一个问题.(redis集群)也就是说，用户第一个访问的时候是服务器A，而第二个请求被转发给了服务器B，那服务器B如何得知其状态。实际上，session与cookies是有联系的，比如我们可以把session_id存放在cookies中的。</p><p>JWT是如何工作的</p><p>首先用户发出登录请求，服务端根据用户的登录请求进行匹配，如果匹配成功，将相关的信息放入payload中，利用算法，加上服务端的密钥生成token，这里需要注意的是secret_key很重要，如果这个泄露的话，客户端就可以随机篡改发送的额外信息，它是信息完整性的保证。生成token后服务端将其返回给客户端，客户端可以在下次请求时，将token一起交给服务端，一般是说我们可以将其放在Authorization首部中，这样也就可以避免跨域问题。</p><h3 id="146-简述Django请求生命周期"><a href="#146-简述Django请求生命周期" class="headerlink" title="146.简述Django请求生命周期"></a>146.简述Django请求生命周期</h3><p>一般是用户通过浏览器向我们的服务器发起一个请求(request),这个请求会去访问视图函数，如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户）<br>视图函数调用模型毛模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。</p><p>1.wsgi ,请求封装后交给web框架（Flask，Django)</p><p>2.中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf,request.session</p><p>3.路由匹配 根据浏览器发送的不同url去匹配不同的视图函数</p><p>4.视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm，templates </p><p>5.中间件，对响应的数据进行处理</p><p>6.wsgi，将响应的内容发送给浏览器</p><h3 id="147-用的restframework完成api发送时间时区"><a href="#147-用的restframework完成api发送时间时区" class="headerlink" title="147.用的restframework完成api发送时间时区"></a>147.用的restframework完成api发送时间时区</h3><p>当前的问题是用django的rest framework模块做一个get请求的发送时间以及时区信息的api</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">getCurrenttime</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        local_time = time.localtime()</span><br><span class="line">        time_zone =settings.TIME_ZONE</span><br><span class="line">        temp = {<span class="string">'localtime'</span>:local_time,<span class="string">'timezone'</span>:time_zone}</span><br><span class="line">        <span class="keyword">return</span> Response(temp)</span><br></pre></td></tr></tbody></table></figure><h3 id="148-nginx-tomcat-apach到都是什么？"><a href="#148-nginx-tomcat-apach到都是什么？" class="headerlink" title="148.nginx,tomcat,apach到都是什么？"></a>148.nginx,tomcat,apach到都是什么？</h3><p>Nginx（engine x)是一个高性能的HTTP和反向代理服务器，也是 一个IMAP/POP3/SMTP服务器，工作在OSI七层，负载的实现方式：轮询，IP_HASH,fair,session_sticky.<br>Apache HTTP Server是一个模块化的服务器，源于NCSAhttpd服务器<br>Tomcat 服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，是开发和调试JSP程序的首选。</p><h3 id="149-请给出你熟悉关系数据库范式有哪些，有什么作用？"><a href="#149-请给出你熟悉关系数据库范式有哪些，有什么作用？" class="headerlink" title="149.请给出你熟悉关系数据库范式有哪些，有什么作用？"></a>149.请给出你熟悉关系数据库范式有哪些，有什么作用？</h3><p>在进行数据库的设计时，所遵循的一些规范，只要按照设计规范进行设计，就能设计出没有数据冗余和数据维护异常的数据库结构。</p><p>数据库的设计的规范有很多，通常来说我们在设是数据库时只要达到其中一些规范就可以了，这些规范又称之为数据库的三范式，一共有三条，也存在着其他范式，我们只要做到满足前三个范式的要求，就能设陈出符合我们的数据库了，我们也不能全部来按照范式的要求来做，还要考虑实际的业务使用情况，所以有时候也需要做一些违反范式的要求。<br>1.数据库设计的第一范式(最基本)，基本上所有数据库的范式都是符合第一范式的，符合第一范式的表具有以下几个特点：</p><p>数据库表中的所有字段都只具有单一属性，单一属性的列是由基本的数据类型（整型，浮点型，字符型等）所构成的设计出来的表都是简单的二比表</p><p>2.数据库设计的第二范式(是在第一范式的基础上设计的)，要求一个表中只具有一个业务主键，也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系</p><p>3.数据库设计的第三范式，指每一个非主属性既不部分依赖与也不传递依赖于业务主键，也就是第二范式的基础上消除了非主属性对主键的传递依赖</p><h3 id="150-简述QQ登陆过程"><a href="#150-简述QQ登陆过程" class="headerlink" title="150.简述QQ登陆过程"></a>150.简述QQ登陆过程</h3><p>qq登录，在我们的项目中分为了三个接口，</p><p>第一个接口是请求qq服务器返回一个qq登录的界面;</p><p>第二个接口是通过扫码或账号登陆进行验证，qq服务器返回给浏览器一个code和state,利用这个code通过本地服务器去向qq服务器获取access_token覆返回给本地服务器，凭借access_token再向qq服务器获取用户的openid(openid用户的唯一标识)</p><p>第三个接口是判断用户是否是第一次qq登录，如果不是的话直接登录返回的jwt-token给用户，对没有绑定过本网站的用户，对openid进行加密生成token进行绑定</p><h3 id="151-post-和-get的区别"><a href="#151-post-和-get的区别" class="headerlink" title="151.post 和 get的区别?"></a>151.post 和 get的区别?</h3><p>1.GET是从服务器上获取数据，POST是向服务器传送数据</p><p>2.在客户端，GET方式在通过URL提交数据，数据在URL中可以看到，POST方式，数据放置在HTML——HEADER内提交</p><p>3.对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据</p><h3 id="152-项目中日志的作用"><a href="#152-项目中日志的作用" class="headerlink" title="152.项目中日志的作用"></a>152.项目中日志的作用</h3><p>一、日志相关概念</p><p>1.日志是一种可以追踪某些软件运行时所发生事件的方法</p><p>2.软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情</p><p>3.一个事件可以用一个包含可选变量数据的消息来描述</p><p>4.此外，事件也有重要性的概念，这个重要性也可以被成为严重性级别(level)</p><p>二、日志的作用</p><p>1.通过log的分析，可以方便用户了解系统或软件、应用的运行情况;</p><p>2.如果你的应用log足够丰富，可以分析以往用户的操作行为、类型喜好，地域分布或其他更多信息;</p><p>3.如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。</p><p>4.简单来讲就是我们通过记录和分析日志可以了解一个系统或软件程序运行情况是否正常，也可以在应用程序出现故障时快速定位问题。不仅在开发中，在运维中日志也很重要，日志的作用也可以简单。总结为以下几点：</p><p>1.程序调试</p><p>2.了解软件程序运行情况，是否正常</p><p>3,软件程序运行故障分析与问题定位</p><p>4,如果应用的日志信息足够详细和丰富，还可以用来做用户行为分析</p><h3 id="153-django中间件的使用？"><a href="#153-django中间件的使用？" class="headerlink" title="153.django中间件的使用？"></a>153.django中间件的使用？</h3><p>Django在中间件中预置了六个方法，这六个方法的区别在于不同的阶段执行，对输入或输出进行干预，方法如下：</p><p>1.初始化：无需任何参数，服务器响应第一个请求的时候调用一次，用于确定是否启用当前中间件</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure><p>2.处理请求前：在每个请求上调用，返回None或HttpResponse对象。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure><p>3.处理视图前:在每个请求上调用，返回None或HttpResponse对象。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(request,view_func,view_args,view_kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure><p>4.处理模板响应前：在每个请求上调用，返回实现了render方法的响应对象。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_template_response</span><span class="params">(request,response)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure><p>5.处理响应后：所有响应返回浏览器之前被调用，在每个请求上调用，返回HttpResponse对象。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(request,response)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure><p>6.异常处理：当视图抛出异常时调用，在每个请求上调用，返回一个HttpResponse对象。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(request,exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure><h3 id="154-谈一下你对uWSGI和nginx的理解？"><a href="#154-谈一下你对uWSGI和nginx的理解？" class="headerlink" title="154.谈一下你对uWSGI和nginx的理解？"></a>154.谈一下你对uWSGI和nginx的理解？</h3><p>1.uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。WSGI是一种Web服务器网关接口。它是一个Web服务器（如nginx，uWSGI等服务器）与web应用（如用Flask框架写的程序）通信的一种规范。</p><p>要注意WSGI/uwsgi/uWSGI这三个概念的区分。</p><p>WSGI是一种通信协议。</p><p>uwsgi是一种线路协议而不是通信协议，在此常用于在uWSGI服务器与其他网络服务器的数据通信。</p><p>uWSGI是实现了uwsgi和WSGI两种协议的Web服务器。</p><p>nginx 是一个开源的高性能的HTTP服务器和反向代理：</p><p>1.作为web服务器，它处理静态文件和索引文件效果非常高</p><p>2.它的设计非常注重效率，最大支持5万个并发连接，但只占用很少的内存空间</p><p>3.稳定性高，配置简洁。</p><p>4.强大的反向代理和负载均衡功能，平衡集群中各个服务器的负载压力应用</p><h3 id="155-Python中三大框架各自的应用场景？"><a href="#155-Python中三大框架各自的应用场景？" class="headerlink" title="155.Python中三大框架各自的应用场景？"></a>155.Python中三大框架各自的应用场景？</h3><p>django:主要是用来搞快速开发的，他的亮点就是快速开发，节约成本，,如果要实现高并发的话，就要对django进行二次开发，比如把整个笨重的框架给拆掉自己写socket实现http的通信,底层用纯c,c++写提升效率，ORM框架给干掉，自己编写封装与数据库交互的框架,ORM虽然面向对象来操作数据库，但是它的效率很低，使用外键来联系表与表之间的查询;<br>flask: 轻量级，主要是用来写接口的一个框架，实现前后端分离，提考开发效率，Flask本身相当于一个内核，其他几乎所有的功能都要用到扩展(邮件扩展Flask-Mail，用户认证Flask-Login),都需要用第三方的扩展来实现。比如可以用Flask-extension加入ORM、文件上传、身份验证等。Flask没有默认使用的数据库，你可以选择MySQL，也可以用NoSQL。</p><p>其WSGI工具箱用Werkzeug(路由模块)，模板引擎则使用Jinja2,这两个也是Flask框架的核心。</p><p>Tornado： Tornado是一种Web服务器软件的开源版本。Tornado和现在的主流Web服务器框架（包括大多数Python的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。得利于其非阻塞的方式和对epoll的运用，Tornado每秒可以处理数以千计的连接因此Tornado是实时Web服务的一个理想框架</p><h3 id="156-Django中哪里用到了线程？哪里用到了协程？哪里用到了进程？"><a href="#156-Django中哪里用到了线程？哪里用到了协程？哪里用到了进程？" class="headerlink" title="156.Django中哪里用到了线程？哪里用到了协程？哪里用到了进程？"></a>156.Django中哪里用到了线程？哪里用到了协程？哪里用到了进程？</h3><p>1.Django中耗时的任务用一个进程或者线程来执行，比如发邮件，使用celery.</p><p>2.部署django项目是时候，配置文件中设置了进程和协程的相关配置。</p><h3 id="157-有用过Django-REST-framework吗？"><a href="#157-有用过Django-REST-framework吗？" class="headerlink" title="157.有用过Django REST framework吗？"></a>157.有用过Django REST framework吗？</h3><p>Django REST framework是一个强大而灵活的Web API工具。使用RESTframework的理由有：</p><p>Web browsable API对开发者有极大的好处</p><p>包括OAuth1a和OAuth2的认证策略</p><p>支持ORM和非ORM数据资源的序列化</p><p>全程自定义开发—如果不想使用更加强大的功能，可仅仅使用常规的function-based views额外的文档和强大的社区支持</p><h3 id="158-对cookies与session的了解？他们能单独用吗？"><a href="#158-对cookies与session的了解？他们能单独用吗？" class="headerlink" title="158.对cookies与session的了解？他们能单独用吗？"></a>158.对cookies与session的了解？他们能单独用吗？</h3><p>Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但是禁用Cookie就不能得到Session。因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于SessionID,也就得不到Session。</p><h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><h3 id="159-试列出至少三种目前流行的大型数据库"><a href="#159-试列出至少三种目前流行的大型数据库" class="headerlink" title="159.试列出至少三种目前流行的大型数据库"></a>159.试列出至少三种目前流行的大型数据库</h3><h3 id="160-列举您使用过的Python网络爬虫所用到的网络数据包"><a href="#160-列举您使用过的Python网络爬虫所用到的网络数据包" class="headerlink" title="160.列举您使用过的Python网络爬虫所用到的网络数据包?"></a>160.列举您使用过的Python网络爬虫所用到的网络数据包?</h3><p>requests, urllib,urllib2, httplib2</p><h3 id="161-爬取数据后使用哪个数据库存储数据的，为什么？"><a href="#161-爬取数据后使用哪个数据库存储数据的，为什么？" class="headerlink" title="161.爬取数据后使用哪个数据库存储数据的，为什么？"></a>161.爬取数据后使用哪个数据库存储数据的，为什么？</h3><h3 id="162-你用过的爬虫框架或者模块有哪些？优缺点？"><a href="#162-你用过的爬虫框架或者模块有哪些？优缺点？" class="headerlink" title="162.你用过的爬虫框架或者模块有哪些？优缺点？"></a>162.你用过的爬虫框架或者模块有哪些？优缺点？</h3><p>Python自带：urllib,urllib2</p><p>第三方：requests</p><p>框架： Scrapy</p><p>urllib 和urllib2模块都做与请求URL相关的操作，但他们提供不同的功能。</p><p>urllib2: urllib2.urlopen可以接受一个Request对象或者url,(在接受Request对象时，并以此可以来设置一个URL的headers),urllib.urlopen只接收一个url。</p><p>urllib 有urlencode,urllib2没有，因此总是urllib, urllib2常会一起使用的原因</p><p>scrapy是封装起来的框架，他包含了下载器，解析器，日志及异常处理，基于多线程，twisted的方式处理，对于固定单个网站的爬取开发，有优势，但是对于多网站爬取100个网站，并发及分布式处理不够灵活，不便调整与扩展</p><p>requests是一个HTTP库，它只是用来请求，它是一个强大的库，下载，解析全部自己处理，灵活性高</p><p>Scrapy优点：异步，xpath，强大的统计和log系统，支持不同url。shell方便独立调试。写middleware方便过滤。通过管道存入数据库</p><h3 id="163-写爬虫是用多进程好？还是多线程好？"><a href="#163-写爬虫是用多进程好？还是多线程好？" class="headerlink" title="163.写爬虫是用多进程好？还是多线程好？"></a>163.写爬虫是用多进程好？还是多线程好？</h3><h3 id="164-常见的反爬虫和应对方法？"><a href="#164-常见的反爬虫和应对方法？" class="headerlink" title="164.常见的反爬虫和应对方法？"></a>164.常见的反爬虫和应对方法？</h3><h3 id="165-解析网页的解析器使用最多的是哪几个"><a href="#165-解析网页的解析器使用最多的是哪几个" class="headerlink" title="165.解析网页的解析器使用最多的是哪几个?"></a>165.解析网页的解析器使用最多的是哪几个?</h3><h3 id="166-需要登录的网页，如何解决同时限制ip，cookie-session"><a href="#166-需要登录的网页，如何解决同时限制ip，cookie-session" class="headerlink" title="166.需要登录的网页，如何解决同时限制ip，cookie,session"></a>166.需要登录的网页，如何解决同时限制ip，cookie,session</h3><h3 id="167-验证码的解决"><a href="#167-验证码的解决" class="headerlink" title="167.验证码的解决?"></a>167.验证码的解决?</h3><h3 id="168-使用最多的数据库，对他们的理解？"><a href="#168-使用最多的数据库，对他们的理解？" class="headerlink" title="168.使用最多的数据库，对他们的理解？"></a>168.使用最多的数据库，对他们的理解？</h3><h3 id="169-编写过哪些爬虫中间件？"><a href="#169-编写过哪些爬虫中间件？" class="headerlink" title="169.编写过哪些爬虫中间件？"></a>169.编写过哪些爬虫中间件？</h3><h3 id="170-“极验”滑动验证码如何破解？"><a href="#170-“极验”滑动验证码如何破解？" class="headerlink" title="170.“极验”滑动验证码如何破解？"></a>170.“极验”滑动验证码如何破解？</h3><h3 id="171-爬虫多久爬一次，爬下来的数据是怎么存储？"><a href="#171-爬虫多久爬一次，爬下来的数据是怎么存储？" class="headerlink" title="171.爬虫多久爬一次，爬下来的数据是怎么存储？"></a>171.爬虫多久爬一次，爬下来的数据是怎么存储？</h3><h3 id="172-cookie过期的处理问题？"><a href="#172-cookie过期的处理问题？" class="headerlink" title="172.cookie过期的处理问题？"></a>172.cookie过期的处理问题？</h3><h3 id="173-动态加载又对及时性要求很高怎么处理？"><a href="#173-动态加载又对及时性要求很高怎么处理？" class="headerlink" title="173.动态加载又对及时性要求很高怎么处理？"></a>173.动态加载又对及时性要求很高怎么处理？</h3><h3 id="174-HTTPS有什么优点和缺点？"><a href="#174-HTTPS有什么优点和缺点？" class="headerlink" title="174.HTTPS有什么优点和缺点？"></a>174.HTTPS有什么优点和缺点？</h3><h3 id="175-HTTPS是如何实现安全传输数据的？"><a href="#175-HTTPS是如何实现安全传输数据的？" class="headerlink" title="175.HTTPS是如何实现安全传输数据的？"></a>175.HTTPS是如何实现安全传输数据的？</h3><h3 id="176-TTL，MSL，RTT各是什么？"><a href="#176-TTL，MSL，RTT各是什么？" class="headerlink" title="176.TTL，MSL，RTT各是什么？"></a>176.TTL，MSL，RTT各是什么？</h3><h3 id="177-谈一谈你对Selenium和PhantomJS了解"><a href="#177-谈一谈你对Selenium和PhantomJS了解" class="headerlink" title="177.谈一谈你对Selenium和PhantomJS了解"></a>177.谈一谈你对Selenium和PhantomJS了解</h3><h3 id="178-平常怎么使用代理的-？"><a href="#178-平常怎么使用代理的-？" class="headerlink" title="178.平常怎么使用代理的 ？"></a>178.平常怎么使用代理的 ？</h3><h3 id="179-存放在数据库-redis、mysql等-。"><a href="#179-存放在数据库-redis、mysql等-。" class="headerlink" title="179.存放在数据库(redis、mysql等)。"></a>179.存放在数据库(redis、mysql等)。</h3><h3 id="180-怎么监控爬虫的状态"><a href="#180-怎么监控爬虫的状态" class="headerlink" title="180.怎么监控爬虫的状态?"></a>180.怎么监控爬虫的状态?</h3><h3 id="181-描述下scrapy框架运行的机制？"><a href="#181-描述下scrapy框架运行的机制？" class="headerlink" title="181.描述下scrapy框架运行的机制？"></a>181.描述下scrapy框架运行的机制？</h3><h3 id="182-谈谈你对Scrapy的理解？"><a href="#182-谈谈你对Scrapy的理解？" class="headerlink" title="182.谈谈你对Scrapy的理解？"></a>182.谈谈你对Scrapy的理解？</h3><h3 id="183-怎么样让-scrapy-框架发送一个-post-请求（具体写出来）"><a href="#183-怎么样让-scrapy-框架发送一个-post-请求（具体写出来）" class="headerlink" title="183.怎么样让 scrapy 框架发送一个 post 请求（具体写出来）"></a>183.怎么样让 scrapy 框架发送一个 post 请求（具体写出来）</h3><h3 id="184-怎么监控爬虫的状态-？"><a href="#184-怎么监控爬虫的状态-？" class="headerlink" title="184.怎么监控爬虫的状态 ？"></a>184.怎么监控爬虫的状态 ？</h3><h3 id="185-怎么判断网站是否更新？"><a href="#185-怎么判断网站是否更新？" class="headerlink" title="185.怎么判断网站是否更新？"></a>185.怎么判断网站是否更新？</h3><h3 id="186-图片、视频爬取怎么绕过防盗连接"><a href="#186-图片、视频爬取怎么绕过防盗连接" class="headerlink" title="186.图片、视频爬取怎么绕过防盗连接"></a>186.图片、视频爬取怎么绕过防盗连接</h3><h3 id="187-你爬出来的数据量大概有多大？大概多长时间爬一次？"><a href="#187-你爬出来的数据量大概有多大？大概多长时间爬一次？" class="headerlink" title="187.你爬出来的数据量大概有多大？大概多长时间爬一次？"></a>187.你爬出来的数据量大概有多大？大概多长时间爬一次？</h3><h3 id="188-用什么数据库存爬下来的数据？部署是你做的吗？怎么部署？"><a href="#188-用什么数据库存爬下来的数据？部署是你做的吗？怎么部署？" class="headerlink" title="188.用什么数据库存爬下来的数据？部署是你做的吗？怎么部署？"></a>188.用什么数据库存爬下来的数据？部署是你做的吗？怎么部署？</h3><h3 id="189-增量爬取"><a href="#189-增量爬取" class="headerlink" title="189.增量爬取"></a>189.增量爬取</h3><h3 id="190-爬取下来的数据如何去重，说一下scrapy的具体的算法依据。"><a href="#190-爬取下来的数据如何去重，说一下scrapy的具体的算法依据。" class="headerlink" title="190.爬取下来的数据如何去重，说一下scrapy的具体的算法依据。"></a>190.爬取下来的数据如何去重，说一下scrapy的具体的算法依据。</h3><h3 id="191-Scrapy的优缺点"><a href="#191-Scrapy的优缺点" class="headerlink" title="191.Scrapy的优缺点?"></a>191.Scrapy的优缺点?</h3><h3 id="192-怎么设置爬取深度？"><a href="#192-怎么设置爬取深度？" class="headerlink" title="192.怎么设置爬取深度？"></a>192.怎么设置爬取深度？</h3><h3 id="193-scrapy和scrapy-redis有什么区别？为什么选择redis数据库？"><a href="#193-scrapy和scrapy-redis有什么区别？为什么选择redis数据库？" class="headerlink" title="193.scrapy和scrapy-redis有什么区别？为什么选择redis数据库？"></a>193.scrapy和scrapy-redis有什么区别？为什么选择redis数据库？</h3><h3 id="194-分布式爬虫主要解决什么问题？"><a href="#194-分布式爬虫主要解决什么问题？" class="headerlink" title="194.分布式爬虫主要解决什么问题？"></a>194.分布式爬虫主要解决什么问题？</h3><h3 id="195-什么是分布式存储？"><a href="#195-什么是分布式存储？" class="headerlink" title="195.什么是分布式存储？"></a>195.什么是分布式存储？</h3><h3 id="196-你所知道的分布式爬虫方案有哪些？"><a href="#196-你所知道的分布式爬虫方案有哪些？" class="headerlink" title="196.你所知道的分布式爬虫方案有哪些？"></a>196.你所知道的分布式爬虫方案有哪些？</h3><h3 id="197-scrapy-redis，有做过其他的分布式爬虫吗？"><a href="#197-scrapy-redis，有做过其他的分布式爬虫吗？" class="headerlink" title="197.scrapy-redis，有做过其他的分布式爬虫吗？"></a>197.scrapy-redis，有做过其他的分布式爬虫吗？</h3><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Web&quot;&gt;&lt;a href=&quot;#Web&quot; class=&quot;headerlink&quot; title=&quot;Web&quot;&gt;&lt;/a&gt;Web&lt;/h1&gt;&lt;h2 id=&quot;Flask&quot;&gt;&lt;a href=&quot;#Flask&quot; class=&quot;headerlink&quot; title=&quot;Flask&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Computer Basic" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/"/>
    
      <category term="Interview" scheme="https://unknown.yuzhouwan.com/categories/Computer-Basic/Interview/"/>
    
    
      <category term="Web" scheme="https://unknown.yuzhouwan.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>DataStructure &amp; Algorithm</title>
    <link href="https://unknown.yuzhouwan.com/posts/57792/"/>
    <id>https://unknown.yuzhouwan.com/posts/57792/</id>
    <published>2020-01-12T23:05:00.000Z</published>
    <updated>2020-02-08T15:08:59.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p><img data-src="/images/algorithm/栈.png" alt="栈"></p><h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><p><img data-src="/images/algorithm/括号匹配.png" alt="括号匹配"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LEFT = {<span class="string">'('</span>,<span class="string">'['</span>,<span class="string">'{'</span>}</span><br><span class="line">RIGHT = {<span class="string">')'</span>,<span class="string">']'</span>,<span class="string">'}'</span>}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(expr)</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> expr:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> LEFT:</span><br><span class="line">            stack.append(c)</span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> RIGHT:</span><br><span class="line">            <span class="comment">#为空</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">1</span> &lt;= ord(c) - ord(stack[<span class="number">-1</span>]) &lt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.pop()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br><span class="line"></span><br><span class="line">print(match(<span class="string">'{{[]}}'</span>))</span><br><span class="line"></span><br><span class="line">TRUE</span><br></pre></td></tr></tbody></table></figure><h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><p><img data-src="/images/algorithm/迷宫问题.png" alt="宫问"></p><p>最后栈为空说明已经无路可走，如果栈不为空说明找到了一条路径。</p><a id="more"></a><p>为了让表达统一，我们初始化迷宫的时候，将迷宫四周边缘都设成1，这样我们就不用考虑一个点是边界还是非边界点，<strong>即所有点都判断上下左右点是否唯一即可。</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化迷宫</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initMaze</span><span class="params">()</span>:</span></span><br><span class="line">    maze = [[<span class="number">0</span>] * <span class="number">7</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span> + <span class="number">2</span>)]</span><br><span class="line">    walls = [(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">3</span>),(<span class="number">5</span>,<span class="number">4</span>),]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>+<span class="number">2</span>):</span><br><span class="line">        maze[i][<span class="number">0</span>] = maze[i][<span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">        maze[<span class="number">0</span>][i] = maze[<span class="number">-1</span>][i] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i,j <span class="keyword">in</span> walls:</span><br><span class="line">        maze[i][j] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> maze</span><br><span class="line"></span><br><span class="line"><span class="comment">#路径选择</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">path</span><span class="params">(maze,start,end)</span>:</span></span><br><span class="line">    </span><br><span class="line">    print(maze)</span><br><span class="line">    </span><br><span class="line">    i,j = start</span><br><span class="line">    e_i,e_j = end</span><br><span class="line">    s = [(i,j)]           <span class="comment">#用栈(列表)保存路径节点</span></span><br><span class="line">    maze[i][j] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> s:         <span class="comment">#如果栈不为空,证明还有路可走</span></span><br><span class="line">        i,j = s[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> (i,j) == (e_i,e_j):  <span class="comment">#如果到达终点</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> di,dj <span class="keyword">in</span> [(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>)]:    <span class="comment">#上下左右四个方向 </span></span><br><span class="line">            <span class="keyword">if</span> maze[i+di][j+dj] == <span class="number">0</span>:       <span class="comment">#如果存在为0的可走路径</span></span><br><span class="line">                maze[i+di][j+di] = <span class="number">1</span></span><br><span class="line">                s.append((i+di,j+dj))       <span class="comment">#将新的路径加入</span></span><br><span class="line">                <span class="keyword">break</span>                       <span class="comment">#跳出此循环，执行i,j = s[-1]</span></span><br><span class="line">        <span class="keyword">else</span>:                           <span class="comment">#如果不存在为0的可走路径</span></span><br><span class="line">            s.pop()                     <span class="comment">#如果发现四周都为1，即无路可走了,执行i,j = s[-1]</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">maze = initMaze()</span><br><span class="line">print(path(maze,(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">5</span>,<span class="number">5</span>)))</span><br></pre></td></tr></tbody></table></figure><h2 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h2><p><img data-src="/images/algorithm/后缀表达式求值.png" alt="后缀表达式求值"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">后缀表达式求值问题</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">operators = {</span><br><span class="line">    <span class="string">"+"</span>:<span class="keyword">lambda</span> op1,op2:op1 + op2,</span><br><span class="line">    <span class="string">"-"</span>:<span class="keyword">lambda</span> op1,op2:op1 - op2,</span><br><span class="line">    <span class="string">"*"</span>:<span class="keyword">lambda</span> op1,op2:op1 * op2,</span><br><span class="line">    <span class="string">"/"</span>:<span class="keyword">lambda</span> op1,op2:op1 / op2,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">#后缀表达式求值，e是表达式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalPostfix</span><span class="params">(e)</span>:</span></span><br><span class="line">    tokens = e.split()</span><br><span class="line">    s = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="keyword">if</span> token.isdigit():</span><br><span class="line">            s.append(int(token))</span><br><span class="line">        <span class="keyword">elif</span> token <span class="keyword">in</span> operators:</span><br><span class="line">            f = operators[token]</span><br><span class="line">            op2 = s.pop()</span><br><span class="line">            op1 = s.pop()</span><br><span class="line">            s.append(f(op1,op2))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.pop()</span><br><span class="line"></span><br><span class="line">print(evalPostfix(<span class="string">"2 3 4 * +"</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img data-src="/images/algorithm/背包问题.png" alt="背包问题"></p><p><img data-src="/images/algorithm/背包问题2.png" alt="背包问题2"></p><p>”回溯法“就是一步一步创建解的过程。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">背包问题</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#t是求解的总重量，w是一个列表，为每个物体的重量，返回值是解</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack</span><span class="params">(t,w)</span>:</span></span><br><span class="line">    n = len(w)                 <span class="comment">#物体的个数</span></span><br><span class="line">    s = []                     <span class="comment">#存放对应物体的下标</span></span><br><span class="line">    k = <span class="number">0</span>                      <span class="comment">#物体的指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">or</span> k &lt; n:   <span class="comment"># 当栈里有元素(证明可能还有解)，或者初始指针小于n -- 这两种情况下，解可能存在</span></span><br><span class="line">        <span class="keyword">while</span> t &gt; <span class="number">0</span> <span class="keyword">and</span> k &lt; n: </span><br><span class="line">            <span class="keyword">if</span> t &gt;= w[k]:      <span class="comment">#求解的重量大于某个物体的重量</span></span><br><span class="line">                s.append(k)    <span class="comment">#装入对应物体的指针</span></span><br><span class="line">                t -= w[k]      <span class="comment">#总重减小</span></span><br><span class="line">            k += <span class="number">1</span>             <span class="comment">#指向下一个物体</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> t == <span class="number">0</span>:             <span class="comment">#对应上层while不成立的条件：当t已经为0(也就是已经找到解)</span></span><br><span class="line">            print(s)</span><br><span class="line">        </span><br><span class="line">        k = s.pop()    <span class="comment">#或者指针k已经超出n时，即无解情况，回溯，k指针设为栈顶的元素指针的下一个元素指针</span></span><br><span class="line">        t += w[k]</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">knapsack(<span class="number">10</span>,[<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></tbody></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><img data-src="/images/algorithm/队列.png" alt="队列"></p><p>Python中队列的接口为：<img data-src="/images/algorithm/队列接口.png" alt="队列接口"></p><h2 id="Python标准库中的队列deque"><a href="#Python标准库中的队列deque" class="headerlink" title="Python标准库中的队列deque"></a>Python标准库中的队列deque</h2><p>队列的方法如下：</p><p><img data-src="/images/algorithm/队列标准库.png" alt="队列标准库"></p><p><img data-src="/images/algorithm/1.png" alt="屏幕快照 2018-04-06 下午12.34.52"></p><p><img data-src="/images/algorithm/2.png" alt="屏幕快照 2018-04-06 下午12.35.04"></p><h2 id="二项式系数"><a href="#二项式系数" class="headerlink" title="二项式系数"></a>二项式系数</h2><p><img data-src="/images/algorithm/多项式系数.png" alt="多项式系数"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">杨辉三角形，求解多项式系数问题</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="comment">#求解杨辉三角第k层的系数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yanghui</span><span class="params">(k)</span>:</span> </span><br><span class="line">    <span class="comment">#从第0层，一步一步推算出第k层的系数</span></span><br><span class="line">    </span><br><span class="line">    q = deque([<span class="number">1</span>]) <span class="comment">#第0层系数是1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k): <span class="comment"># k次推导，i表示当前所在的层</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(i): <span class="comment"># 第i层需要经过i次出栈操作，才能计算出来结果</span></span><br><span class="line">            </span><br><span class="line">            q.append(q.popleft() + q[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        q.append(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> list(q)</span><br><span class="line"></span><br><span class="line">print(yanghui(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure><h2 id="划分无冲突子集"><a href="#划分无冲突子集" class="headerlink" title="划分无冲突子集"></a>划分无冲突子集</h2><p><img data-src="/images/algorithm/划分无冲突子集.png" alt="划分无冲突子集"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">划分无冲突子集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">division</span><span class="params">(M,n)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    q = deque(range(n))</span><br><span class="line">    pre = n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        cur = q.popleft()</span><br><span class="line">        <span class="keyword">if</span> pre &gt;= cur:</span><br><span class="line">            res.append([])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> res[<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">if</span> M[cur][a]:</span><br><span class="line">                q.append(cur)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[<span class="number">-1</span>].append(cur)</span><br><span class="line">        pre = cur</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = <span class="number">9</span></span><br><span class="line">R = {</span><br><span class="line">    (<span class="number">1</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">8</span>),(<span class="number">1</span>,<span class="number">8</span>),(<span class="number">1</span>,<span class="number">7</span>),</span><br><span class="line">    (<span class="number">8</span>,<span class="number">3</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">5</span>),(<span class="number">1</span>,<span class="number">5</span>),</span><br><span class="line">    (<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>),(<span class="number">5</span>,<span class="number">2</span>),(<span class="number">6</span>,<span class="number">2</span>),(<span class="number">6</span>,<span class="number">4</span>)</span><br><span class="line">}</span><br><span class="line">M = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> R:</span><br><span class="line">    M[i][j] = M[j][i] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">print(division(M,N))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>], [<span class="number">1</span>, <span class="number">6</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">8</span>]]</span><br></pre></td></tr></tbody></table></figure><h2 id="数字变换-用队列实现广度优先搜索"><a href="#数字变换-用队列实现广度优先搜索" class="headerlink" title="数字变换(用队列实现广度优先搜索)"></a>数字变换(用队列实现广度优先搜索)</h2><p><img data-src="/images/algorithm/数字变换.png" alt="数字变换"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数字变换</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将a变成b需要经过几个步骤，使用队列存储转换时的状态</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atob</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    state_queue = deque([(a,<span class="number">0</span>)]) <span class="comment"># 使用元组作为一个元素，第一个值是计算到的数字，第二个值记录现在经过的状态，使用队列记录正在被计算的数字</span></span><br><span class="line">    checked = {a} <span class="comment"># 使用集合记录已经被检查过的数字，要是队列中又出现相同的数字，则不予计算</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        num,state = state_queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> num == b:</span><br><span class="line">            <span class="keyword">break</span>   <span class="comment"># 跳出循环的条件</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; b: <span class="comment"># 比b小的数只能通过“+”，“*”操作才有可能得到b，所以忽略“-”操作</span></span><br><span class="line">            <span class="keyword">if</span> num * <span class="number">2</span> <span class="keyword">not</span> <span class="keyword">in</span> checked:</span><br><span class="line">                state_queue.append((num * <span class="number">2</span>,state + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> num + <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> checked:</span><br><span class="line">                state_queue.append((num + <span class="number">1</span>,state + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> num &gt; b:</span><br><span class="line">            <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> checked:</span><br><span class="line">                state_queue.append((num - <span class="number">1</span>,state + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> state</span><br><span class="line"></span><br><span class="line">print(<span class="string">"需要通过"</span> + str(atob(<span class="number">3</span>,<span class="number">8</span>)) + <span class="string">"步"</span>)  </span><br><span class="line"></span><br><span class="line">需要通过<span class="number">2</span>步</span><br></pre></td></tr></tbody></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><img data-src="/images/algorithm/二叉树.png" alt="二叉树"></p><h2 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data,left=None,right=None)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self)</span><br><span class="line"></span><br><span class="line">A,B,C,D,E,F,G,H,I = [TreeNode(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">"ABCDEFGHI"</span>]</span><br><span class="line">A.left = B</span><br><span class="line">A.right = C</span><br><span class="line">B.right = D</span><br><span class="line">C.left = E</span><br><span class="line">C.right = F</span><br><span class="line">E.left = G</span><br><span class="line">F.left = H</span><br><span class="line">F.right = I</span><br><span class="line"></span><br><span class="line">print(C.right.data)</span><br></pre></td></tr></tbody></table></figure><h2 id="遍历二叉树（前、中、后序）（递归、回溯-栈）"><a href="#遍历二叉树（前、中、后序）（递归、回溯-栈）" class="headerlink" title="遍历二叉树（前、中、后序）（递归、回溯-栈）"></a>遍历二叉树（前、中、后序）（递归、回溯-栈）</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data,left=None,right=None)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">()</span>:</span></span><br><span class="line">    A,B,C,D,E,F,G,H,I = [TreeNode(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">"ABCDEFGHI"</span>]</span><br><span class="line">    A.left = B</span><br><span class="line">    A.right = C</span><br><span class="line">    B.right = D</span><br><span class="line">    C.left = E</span><br><span class="line">    C.right = F</span><br><span class="line">    E.left = G</span><br><span class="line">    F.left = H</span><br><span class="line">    F.right = I</span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preOrder</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    print(node.data)</span><br><span class="line">    preOrder(node.left)</span><br><span class="line">    preOrder(node.right)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inOrder</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    inOrder(node.left)</span><br><span class="line">    print(node.data)</span><br><span class="line">    inOrder(node.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postOrder</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    postOrder(node.left)</span><br><span class="line">    postOrder(node.right)</span><br><span class="line">    print(node.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">"__main__"</span>:</span><br><span class="line">    root = createTree()</span><br><span class="line">    preOrder(root)</span><br><span class="line">    inOrder(root)</span><br><span class="line">    postOrder(root)</span><br></pre></td></tr></tbody></table></figure><p>使用递归的开销比较大，下面实现一个迭代版的先序遍历。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回溯的前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preOrderIter</span><span class="params">(root)</span>:</span></span><br><span class="line">    node = root</span><br><span class="line">    s = [] <span class="comment"># 使用一个栈存未遍历的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 在节点左子树不为空的情况下，将其左子树一直压栈</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            print(node.data)</span><br><span class="line">            s.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果栈为空，则说明已经遍历完成</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 出栈操作，遍历其右子树</span></span><br><span class="line">        node = s.pop().right</span><br></pre></td></tr></tbody></table></figure><h2 id="遍历二叉树（层次遍历-队列）"><a href="#遍历二叉树（层次遍历-队列）" class="headerlink" title="遍历二叉树（层次遍历 - 队列）"></a>遍历二叉树（层次遍历 - 队列）</h2><p>一个节点出队后，才入队它的子节点。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(root)</span>:</span></span><br><span class="line">    q = deque([root])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果队列不为空</span></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        node = q.popleft()</span><br><span class="line">        print(node.data)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            q.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            q.append(node.right)</span><br></pre></td></tr></tbody></table></figure><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p>采用<strong>分而治之</strong>的思路，把求一个树的深度转化为<strong>它左子树的深度</strong>加上<strong>右子树的深度</strong>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求二叉树的深度 -- 递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dl = depth(node.left)</span><br><span class="line">    dr = depth(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max(dl,dr) + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求二叉树的深度 -- 非递归方式，层次遍历，只需记录一下当前节点的深度即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">depth2</span><span class="params">(root)</span>:</span></span><br><span class="line">    q = deque([(root,<span class="number">1</span>)])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        node,d = q.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            q.append((node.left,d+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            q.append((node.right,d+<span class="number">1</span>))</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> d</span><br></pre></td></tr></tbody></table></figure><h2 id="拷贝二叉树"><a href="#拷贝二叉树" class="headerlink" title="拷贝二叉树"></a>拷贝二叉树</h2><p>依旧采用分治的思想，先拷贝左子树，再拷贝右子树，接着拷贝节点。</p> <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyTree</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    lt = copyTree(node.left)</span><br><span class="line">    rt = copyTree(node.right)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TreeNode(node.data,lt,rt)</span><br><span class="line"></span><br><span class="line">newTree = copyTree(root)</span><br><span class="line">levelOrder(newTree)</span><br></pre></td></tr></tbody></table></figure><h2 id="N个节点不同二叉树个数"><a href="#N个节点不同二叉树个数" class="headerlink" title="N个节点不同二叉树个数"></a>N个节点不同二叉树个数</h2><p>计算由N个节点，所构成的二叉树的个数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># root : 1</span></span><br><span class="line">    <span class="comment"># left : K [0,n - 1]</span></span><br><span class="line">    <span class="comment"># right : n - 1 - k</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> :  <span class="comment"># 递归的出口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">        s += count(k) * count(n - <span class="number">1</span> - k)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">     </span><br><span class="line">print(count(<span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树又作二叉排序树，它可以支持快速的查找。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于二叉搜索树的操作</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,k)</span>:</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">and</span> node.data != k:</span><br><span class="line">            <span class="keyword">if</span> k &lt; node.data:</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">if</span> k &gt; node.data:</span><br><span class="line">                node = node.right</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#同样的实现搜索操作，不过还要返回父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_</span><span class="params">(self,k)</span>:</span></span><br><span class="line">        parent = <span class="literal">None</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">and</span> node.data != k:</span><br><span class="line">            parent = node</span><br><span class="line">            <span class="keyword">if</span> k &lt; node.data:</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">if</span> k &gt; node.data:</span><br><span class="line">                node = node.right</span><br><span class="line">        <span class="keyword">return</span> node,parent</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,k)</span>:</span></span><br><span class="line">        node,parent = self.search_(k)</span><br><span class="line">        <span class="comment"># 如果返回到了node的值，说明这个node在节点上存在，则不用执行插入操作</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果是不存在的，首先构造一个新节点</span></span><br><span class="line">        node = TreeNode(k)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 将node插入到parent上</span></span><br><span class="line">        <span class="comment"># 树为空，将整个节点插入到树上，赋为根节点</span></span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = node</span><br><span class="line">        <span class="keyword">elif</span> k &lt; parent.data:</span><br><span class="line">            parent.left = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parent.right = node</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self,k)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">bst = BinarySearchTree()  </span><br><span class="line">bst.insert(<span class="number">10</span>)</span><br><span class="line">bst.insert(<span class="number">5</span>)</span><br><span class="line">bst.insert(<span class="number">15</span>)</span><br><span class="line">levelOrder(bst.root)</span><br></pre></td></tr></tbody></table></figure><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p><img data-src="/images/algorithm/图.png" alt="图"></p><h2 id="在Python中使用图"><a href="#在Python中使用图" class="headerlink" title="在Python中使用图"></a>在Python中使用图</h2><p><strong>邻接矩阵表示法（有向图、无向图）：</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用二维数组表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个点确定一条边</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Vertical</span><span class="params">(G,n1,n2)</span>:</span></span><br><span class="line">    Graph[n1][n2] = Graph[n2][n1] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">N = <span class="number">5</span>   <span class="comment"># 一共5个点</span></span><br><span class="line">a,b,c,d,e = range(<span class="number">5</span>)</span><br><span class="line">Graph = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)] <span class="comment"># 建立一个二维数组保存图</span></span><br><span class="line">Vertical(Graph,a,b)</span><br><span class="line">print(Graph)</span><br><span class="line"></span><br><span class="line">[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], </span><br><span class="line"> [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], </span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], </span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], </span><br><span class="line"> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]</span><br></pre></td></tr></tbody></table></figure><p>邻接矩阵的缺点：</p><p>1.如果图中节点个数很多，边的条数很少，则会浪费资源。</p><p>2.访问一个节点的邻接节点，需要遍历一个列表才可以。</p><p><strong>邻接集合表示法（有向图和无向图）：</strong></p><p>用一个列表存储集合的形式保存节点和边的关系，第一个集合保存节点1，第一个集合保存节点2，以此类推。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">邻接集合表示有向图和无向图</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一个集合表示对应点相邻的点</span></span><br><span class="line">G2 = [{b,e},{c,d,e},{b,d},{b,c,e},{a,b,d}]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于b点来说</span></span><br><span class="line">G2[b]</span><br><span class="line"></span><br><span class="line">{<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>}</span><br></pre></td></tr></tbody></table></figure><p>邻接列表就是把集合换成列表。</p><p><strong>对于带权的边，可以使用邻接字典。</strong></p><p>不再使用集合存储，而使用字典存储，其中字典的值表示边的长度。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G3 = [{b:<span class="number">4</span>,e:<span class="number">2</span>},{c:<span class="number">5</span>,d:<span class="number">6</span>,e:<span class="number">3</span>}]</span><br><span class="line">G3</span><br><span class="line"></span><br><span class="line">[{<span class="number">1</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">2</span>}, {<span class="number">2</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">6</span>, <span class="number">4</span>: <span class="number">3</span>}]</span><br></pre></td></tr></tbody></table></figure><h2 id="图的深度优先遍历算法DFS"><a href="#图的深度优先遍历算法DFS" class="headerlink" title="图的深度优先遍历算法DFS"></a>图的深度优先遍历算法DFS</h2><p><img data-src="/images/algorithm/图1.png" alt="图1"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">G = [</span><br><span class="line">    {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}, <span class="comment"># 0的邻接节点</span></span><br><span class="line">    {<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>}, <span class="comment"># 1</span></span><br><span class="line">    {<span class="number">0</span>,<span class="number">3</span>},   <span class="comment"># 2</span></span><br><span class="line">    {<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>}, <span class="comment"># 3</span></span><br><span class="line">    {<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>},<span class="comment"># 4 </span></span><br><span class="line">    {<span class="number">4</span>,<span class="number">7</span>},   <span class="comment"># 5</span></span><br><span class="line">    {<span class="number">1</span>,<span class="number">4</span>},   <span class="comment"># 6</span></span><br><span class="line">    {<span class="number">5</span>},      <span class="comment"># 7</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(G,v,visited=set<span class="params">()</span>)</span>:</span></span><br><span class="line">    print(v)</span><br><span class="line">    visited.add(v)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> G[v]:</span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            dfs(G,u,visited)</span><br><span class="line">            </span><br><span class="line">dfs(G,<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归 --  循环实现深度优先遍历    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfsIter</span><span class="params">(G,v)</span>:</span></span><br><span class="line">    visited = set()</span><br><span class="line">    <span class="comment"># 使用栈</span></span><br><span class="line">    s = [v]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> s:</span><br><span class="line">        u = s.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.add(u)</span><br><span class="line">            print(u)</span><br><span class="line">            s.extend(G[u])</span><br><span class="line"></span><br><span class="line">dfsIter(G,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><h2 id="图的广度优先遍历算法BFS"><a href="#图的广度优先遍历算法BFS" class="headerlink" title="图的广度优先遍历算法BFS"></a>图的广度优先遍历算法BFS</h2><p><img data-src="/images/algorithm/图1.png" alt="图1"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">G = [</span><br><span class="line">    {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}, <span class="comment"># 0的邻接节点</span></span><br><span class="line">    {<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>}, <span class="comment"># 1</span></span><br><span class="line">    {<span class="number">0</span>,<span class="number">3</span>},   <span class="comment"># 2</span></span><br><span class="line">    {<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>}, <span class="comment"># 3</span></span><br><span class="line">    {<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>},<span class="comment"># 4 </span></span><br><span class="line">    {<span class="number">4</span>,<span class="number">7</span>},   <span class="comment"># 5</span></span><br><span class="line">    {<span class="number">1</span>,<span class="number">4</span>},   <span class="comment"># 6</span></span><br><span class="line">    {<span class="number">5</span>},      <span class="comment"># 7</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(G,v)</span>:</span></span><br><span class="line">    <span class="comment"># 队列里放未被访问过的元素</span></span><br><span class="line">    q = deque([v])</span><br><span class="line">    visited = {v}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        u = q.popleft()</span><br><span class="line">        print(u)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> G[u]:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append(w)</span><br><span class="line">                visited.add(w)</span><br><span class="line"></span><br><span class="line">bfs(G,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></tbody></table></figure><h2 id="最小生成树算法（Prim算法）"><a href="#最小生成树算法（Prim算法）" class="headerlink" title="最小生成树算法（Prim算法）"></a>最小生成树算法（Prim算法）</h2><p>图的生成树：<strong>包含所有顶点不能有回环的图。</strong></p><p>最小生成树：代价（边的权值）最小的生成树。</p><p><img data-src="/images/algorithm/最小生成树.png" alt="最小生成树"></p><p><img data-src="/images/algorithm/Prim.png" alt="Prim"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">G = [</span><br><span class="line">    {<span class="number">1</span>:<span class="number">28</span>,<span class="number">5</span>:<span class="number">10</span>},     <span class="comment"># 0</span></span><br><span class="line">    {<span class="number">0</span>:<span class="number">28</span>,<span class="number">2</span>:<span class="number">16</span>,<span class="number">6</span>:<span class="number">14</span>},<span class="comment"># 1</span></span><br><span class="line">    {<span class="number">1</span>:<span class="number">16</span>,<span class="number">3</span>:<span class="number">12</span>},     <span class="comment"># 2</span></span><br><span class="line">    {<span class="number">2</span>:<span class="number">12</span>,<span class="number">4</span>:<span class="number">22</span>,<span class="number">6</span>:<span class="number">18</span>},<span class="comment"># 3</span></span><br><span class="line">    {<span class="number">3</span>:<span class="number">22</span>,<span class="number">5</span>:<span class="number">25</span>,<span class="number">6</span>:<span class="number">24</span>},<span class="comment"># 4</span></span><br><span class="line">    {<span class="number">0</span>:<span class="number">10</span>,<span class="number">4</span>:<span class="number">25</span>},     <span class="comment"># 5</span></span><br><span class="line">    {<span class="number">1</span>:<span class="number">14</span>,<span class="number">3</span>:<span class="number">18</span>,<span class="number">4</span>:<span class="number">24</span>},<span class="comment"># 6</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prim</span><span class="params">(G)</span>:</span></span><br><span class="line">    n = len(G)</span><br><span class="line">    v = <span class="number">0</span>  <span class="comment"># 初始顶点设为0</span></span><br><span class="line">    s = {v}</span><br><span class="line">    </span><br><span class="line">    edges = []</span><br><span class="line">    res = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> u,w <span class="keyword">in</span> G[v].items():</span><br><span class="line">            heapq.heappush(edges,(w,v,u))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> edges:</span><br><span class="line">            w,p,q = heapq.heappop(edges)</span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">                s.add(q)</span><br><span class="line">                res.append(((p,q),w))</span><br><span class="line">                v = q</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"not connected gram!"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">prim(G)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[((<span class="number">0</span>, <span class="number">5</span>), <span class="number">10</span>),</span><br><span class="line"> ((<span class="number">5</span>, <span class="number">4</span>), <span class="number">25</span>),</span><br><span class="line"> ((<span class="number">4</span>, <span class="number">3</span>), <span class="number">22</span>),</span><br><span class="line"> ((<span class="number">3</span>, <span class="number">2</span>), <span class="number">12</span>),</span><br><span class="line"> ((<span class="number">2</span>, <span class="number">1</span>), <span class="number">16</span>),</span><br><span class="line"> ((<span class="number">1</span>, <span class="number">6</span>), <span class="number">14</span>)]</span><br></pre></td></tr></tbody></table></figure><h2 id="最短路径算法（Dijkstra算法）"><a href="#最短路径算法（Dijkstra算法）" class="headerlink" title="最短路径算法（Dijkstra算法）"></a>最短路径算法（Dijkstra算法）</h2><p><img data-src="/images/algorithm/3.png" alt="屏幕快照 2018-04-23 下午9.04.07"></p><p><img data-src="/images/algorithm/Dijkstra算法.png" alt="Dijkstra算法"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">a,b,c,d,e,f = range(<span class="number">6</span>)</span><br><span class="line">G = {</span><br><span class="line">    a:{b:<span class="number">2</span>,c:<span class="number">1</span>,d:<span class="number">4</span>,f:<span class="number">10</span>},</span><br><span class="line">    b:{a:<span class="number">2</span>,c:<span class="number">4</span>,e:<span class="number">3</span>},</span><br><span class="line">    c:{a:<span class="number">1</span>,b:<span class="number">4</span>,d:<span class="number">2</span>,f:<span class="number">8</span>},</span><br><span class="line">    d:{a:<span class="number">4</span>,c:<span class="number">2</span>,e:<span class="number">1</span>},</span><br><span class="line">    e:{b:<span class="number">3</span>,d:<span class="number">1</span>,f:<span class="number">7</span>},</span><br><span class="line">    f:{a:<span class="number">10</span>,c:<span class="number">8</span>,e:<span class="number">7</span>},</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span><span class="params">(G,s)</span>:</span></span><br><span class="line">    <span class="comment"># D = {},D[c],D[e]</span></span><br><span class="line">    <span class="comment"># 将顶点到其他点的距离初始化为正无穷大</span></span><br><span class="line">    inf = float(<span class="string">'inf'</span>)</span><br><span class="line">    D = {v: inf <span class="keyword">for</span> v <span class="keyword">in</span> G} <span class="comment"># 每个点的距离设成无穷大</span></span><br><span class="line">    D[s] = <span class="number">0</span>    <span class="comment"># 除了到自己本身，到其余各点距离都是无穷</span></span><br><span class="line">    P = {}      <span class="comment"># 建立父节点的路径</span></span><br><span class="line">    S = {s}     <span class="comment"># 已访问节点</span></span><br><span class="line">    q = []      <span class="comment"># 优先队列</span></span><br><span class="line">    v = s       <span class="comment"># 当前点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 循环次数</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(G)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> u,w <span class="keyword">in</span> G[v].items():</span><br><span class="line">            d = D[v] + G[u][v]</span><br><span class="line">            <span class="keyword">if</span> D[u] &gt; d:</span><br><span class="line">                D[u] = d</span><br><span class="line">                P[u] = v</span><br><span class="line">                heapq.heappush(q,(d,u))</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            _,v = heapq.heappop(q)</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> S:</span><br><span class="line">                S.add(v)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> D,P</span><br><span class="line"></span><br><span class="line">D,P = dijkstra(G,a)</span><br><span class="line">print(D,P)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">{<span class="number">0</span>: <span class="number">0</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">3</span>, <span class="number">4</span>: <span class="number">4</span>, <span class="number">5</span>: <span class="number">9</span>} {<span class="number">1</span>: <span class="number">0</span>, <span class="number">2</span>: <span class="number">0</span>, <span class="number">3</span>: <span class="number">2</span>, <span class="number">4</span>: <span class="number">3</span>, <span class="number">5</span>: <span class="number">2</span>}</span><br></pre></td></tr></tbody></table></figure><h2 id="拓扑排序算法"><a href="#拓扑排序算法" class="headerlink" title="拓扑排序算法"></a>拓扑排序算法</h2><p><img data-src="/images/algorithm/拓扑排序算法.png" alt="拓扑排序算法"></p><p>首先寻找入度为0的点。添加到队列中，删除其出度的边，再次寻找入度为0的点，添加到队列中。依此类推。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">G = {</span><br><span class="line">    <span class="string">'C1'</span>:[<span class="string">'C3'</span>,<span class="string">'C8'</span>],</span><br><span class="line">    <span class="string">'C2'</span>:[<span class="string">'C3'</span>,<span class="string">'C4'</span>,<span class="string">'C5'</span>],</span><br><span class="line">    <span class="string">'C3'</span>:[<span class="string">'C4'</span>],</span><br><span class="line">    <span class="string">'C4'</span>:[<span class="string">'C6'</span>,<span class="string">'C7'</span>],</span><br><span class="line">    <span class="string">'C5'</span>:[<span class="string">'C6'</span>],</span><br><span class="line">    <span class="string">'C6'</span>:[],</span><br><span class="line">    <span class="string">'C7'</span>:[],</span><br><span class="line">    <span class="string">'C8'</span>:[<span class="string">'C9'</span>],</span><br><span class="line">    <span class="string">'C9'</span>:[<span class="string">'C7'</span>],</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topsort</span><span class="params">(G)</span>:</span></span><br><span class="line">    indegrees = {v:<span class="number">0</span> <span class="keyword">for</span> v <span class="keyword">in</span> G}</span><br><span class="line">    <span class="keyword">for</span> al <span class="keyword">in</span> G.values():</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> al:</span><br><span class="line">            indegrees[v] += <span class="number">1</span></span><br><span class="line">    q = [v <span class="keyword">for</span> v <span class="keyword">in</span> G <span class="keyword">if</span> indegrees[v] == <span class="number">0</span>] <span class="comment"># 选出所有入度为0的点</span></span><br><span class="line">    i = <span class="number">0</span> <span class="comment"># 队头</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(q):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> G[q[i]]:</span><br><span class="line">            indegrees[v] -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 判断是否已经入度为0了，若是，则添加到队列中</span></span><br><span class="line">            <span class="keyword">if</span> indegrees[v] ==  <span class="number">0</span>:</span><br><span class="line">                q.append(v)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> q <span class="keyword">if</span> i == len(G) <span class="keyword">else</span> <span class="literal">None</span> <span class="comment"># 如果有相互依赖的情况，则返回None</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">topsort(G)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C8'</span>, <span class="string">'C3'</span>, <span class="string">'C5'</span>, <span class="string">'C9'</span>, <span class="string">'C4'</span>, <span class="string">'C6'</span>, <span class="string">'C7'</span>]</span><br></pre></td></tr></tbody></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="枚举简介"><a href="#枚举简介" class="headerlink" title="枚举简介"></a>枚举简介</h2><p>将可能的解逐一列出。</p><h2 id="熄灯问题"><a href="#熄灯问题" class="headerlink" title="熄灯问题"></a>熄灯问题</h2><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ul><li>问题求解时，总是做出在当前来看最好的选择。即，不保证全局最优，仅是在某种意义上的<strong>局部最优解</strong>。</li><li>自顶向下的计算，将原问题归结为<strong>子问题</strong>。</li></ul><p>f(m,n) = f(m-1,n) + f(m,n-1)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/algorithm/栈.png&quot; alt=&quot;栈&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;括号匹配问题&quot;&gt;&lt;a href=&quot;#括号匹配问题&quot; class=&quot;headerlink&quot; title=&quot;括号匹配问题&quot;&gt;&lt;/a&gt;括号匹配问题&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/algorithm/括号匹配.png&quot; alt=&quot;括号匹配&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;LEFT = {&lt;span class=&quot;string&quot;&gt;&#39;(&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;[&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;{&#39;&lt;/span&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RIGHT = {&lt;span class=&quot;string&quot;&gt;&#39;)&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;]&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;}&#39;&lt;/span&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(expr)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stack = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; c &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; expr:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; c &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; LEFT:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stack.append(c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; c &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; RIGHT:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;#为空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; stack:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;= ord(c) - ord(stack[&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]) &amp;lt;= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stack.pop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; stack&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(match(&lt;span class=&quot;string&quot;&gt;&#39;{{[]}}&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TRUE&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;迷宫问题&quot;&gt;&lt;a href=&quot;#迷宫问题&quot; class=&quot;headerlink&quot; title=&quot;迷宫问题&quot;&gt;&lt;/a&gt;迷宫问题&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/algorithm/迷宫问题.png&quot; alt=&quot;宫问&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后栈为空说明已经无路可走，如果栈不为空说明找到了一条路径。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://unknown.yuzhouwan.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://unknown.yuzhouwan.com/tags/Algorithm/"/>
    
      <category term="Python" scheme="https://unknown.yuzhouwan.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Mardown</title>
    <link href="https://unknown.yuzhouwan.com/posts/20260/"/>
    <id>https://unknown.yuzhouwan.com/posts/20260/</id>
    <published>2020-01-07T00:02:00.000Z</published>
    <updated>2020-03-03T15:51:12.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><p>要启用这个功能，首先到<code>Preference</code>-&gt;<code>Editor</code>中启用。然后使用<script type="math/tex">`符号包裹Tex命令，例如：`$lim_{x \to \infty} \ exp(-x)=0</script>将产生如下的数学表达式：</p><p>$\lim_{x \to \infty} \exp(-x)=0$</p><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p>下标使用<code>~</code>包裹，例如：<code>H~2~O</code>将产生H~2~O, 即水的分子式。</p><h2 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h2><p>上标使用<code>^</code>包裹，例如：<code>y^2^=4</code>将产生表达式y^2^ = 4</p><h2 id="插入表情-happy"><a href="#插入表情-happy" class="headerlink" title="插入表情:happy:"></a>插入表情:happy:</h2><p>使用<code>:happy:</code>输入表情:happy:,使用<code>:sad:</code>输入表情:sad:,使用<code>:cry:</code>输入表情:cry:等。以此类推！</p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>用HTML的语法<code>&lt;u&gt;Underline&lt;/u&gt;</code>将产生下划线<u>Underline</u>.</p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用<code>~~</code>包裹的文本将会具有删除的样式，例如<code>~删除文本~</code>将产生<del>删除文本</del>的样式。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li>使用`包裹的内容将会以代码样式显示，例如</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用`printf()`</span><br></pre></td></tr></tbody></table></figure><p>则会产生<code>printf()</code>样式。</p><a id="more"></a><ul><li>输入<code>``或者</code>然后回车，可以输入代码块，并且可以选择代码的语言。例如：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class HelloWorld{</span><br><span class="line">System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将会产生</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class HelloWorld{</span><br><span class="line">System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>使用两个<code>*</code>号或者两个<code>_</code>包裹的内容将会被强调。例如</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**使用两个*号强调内容**</span><br><span class="line">__使用两个下划线强调内容__</span><br></pre></td></tr></tbody></table></figure><p>将会输出</p><p><strong>使用两个*号强调内容</strong><br><strong>使用两个下划线强调内容</strong><br>Typroa 推荐使用两个*号。</p><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><p>  在标准的Markdown语法中，*和_包裹的内容会是斜体显示，但是GFM下划线一般用来分隔人名和代码变量名，因此我们推荐是用星号来包裹斜体内容。如果要显示星号，则使用转义：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\*</span><br></pre></td></tr></tbody></table></figure><h2 id="插入URL连接"><a href="#插入URL连接" class="headerlink" title="插入URL连接"></a>插入URL连接</h2><p>使用尖括号包裹的url将产生一个连接，例如：<code>&lt;www.baidu.com&gt;</code>将产生连接:<www.baidu.com>.</www.baidu.com></p><p>如果是标准的url，则会自动产生连接，例如:www.google.com</p><h2 id="目录列表Table-of-Contents（TOC）"><a href="#目录列表Table-of-Contents（TOC）" class="headerlink" title="目录列表Table of Contents（TOC）"></a>目录列表Table of Contents（TOC）</h2><p>输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。</p><h2 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h2><p>使用<code>***</code>或者<code>---</code>，然后回车，来产生水平分割线。</p><hr><h2 id="标注"><a href="#标注" class="headerlink" title="标注"></a>标注</h2><p>我们可以对某一个词语进行标注。例如</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">某些人用过了才知道[^注释]</span><br><span class="line">[^注释]:Somebody that I used to know.</span><br></pre></td></tr></tbody></table></figure><p>将产生：</p><p>某些人用过了才知道<sup><a href="#fn_注释" id="reffn_注释">注释</a></sup><br><sup><a href="#fn_注释" id="reffn_注释">注释</a></sup>: Somebody that I used to know.</p><p>把鼠标放在<code>注释</code>上，将会有提示内容。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|姓名|性别|毕业学校|工资|</span><br><span class="line">|:---|:---:|:---:|---:|</span><br><span class="line">|杨洋|男|重庆交通大学|3200|</span><br><span class="line">|峰哥|男|贵州大学|5000|</span><br><span class="line">|小阳|女|北京大学|2000|</span><br></pre></td></tr></tbody></table></figure><p>将产生:</p><div class="table-container"><table><thead><tr><th style="text-align:left">姓名</th><th style="text-align:center">性别</th><th style="text-align:center">毕业学校</th><th style="text-align:right">工资</th></tr></thead><tbody><tr><td style="text-align:left">杨洋</td><td style="text-align:center">男</td><td style="text-align:center">重庆交通大学</td><td style="text-align:right">3200</td></tr><tr><td style="text-align:left">峰哥</td><td style="text-align:center">男</td><td style="text-align:center">贵州大学</td><td style="text-align:right">5000</td></tr><tr><td style="text-align:left">小阳</td><td style="text-align:center">女</td><td style="text-align:center">北京大学</td><td style="text-align:right">2000</td></tr></tbody></table></div><p>其中代码的第二行指定对齐的方式，第一个是左对齐，第二个和第三个是居中，最后一个是右对齐。</p><h2 id="数学表达式块"><a href="#数学表达式块" class="headerlink" title="数学表达式块"></a>数学表达式块</h2><p>输入两个美元符号，然后回车，就可以输入数学表达式块了。例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\\end{vmatrix}$$</span><br></pre></td></tr></tbody></table></figure><p>将会产生:</p><script type="math/tex; mode=display">\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} \mathbf{i} & \mathbf{j} & \mathbf{k} \\\frac{\partial X}{\partial u} &  \frac{\partial Y}{\partial u} & 0 \\\frac{\partial X}{\partial v} &  \frac{\partial Y}{\partial v} & 0 \\\end{vmatrix}</script><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>使用如下的代码创建任务列表，在[]中输入x表示完成，也可以通过点击选择完成或者没完成。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [ ] 吃饭</span><br><span class="line">- [ ] 逛街</span><br><span class="line">- [ ] 看电影</span><br></pre></td></tr></tbody></table></figure><ul><li><p>[x] 吃饭</p></li><li><p>[x] 逛街</p></li><li><p>[x] 看电影</p></li><li><p>[x] </p></li></ul><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>输入+, -, *,创建无序的列表，使用任意数字开头，创建有序列表，例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**无序的列表**</span><br><span class="line">* tfboys</span><br><span class="line">* 杨洋</span><br><span class="line">* Mr.Smith</span><br></pre></td></tr></tbody></table></figure><p><strong>无序的列表</strong></p><ul><li>tfboys</li><li>杨洋</li><li>Mr.Smith</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**有序的列表**</span><br><span class="line">1. 苹果</span><br><span class="line">6. 香蕉</span><br><span class="line">10. 我都不喜欢</span><br></pre></td></tr></tbody></table></figure><p><strong>有序的列表</strong></p><ol><li>苹果</li><li>香蕉</li><li>我都不喜欢</li></ol><h2 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h2><p>使用&gt;来插入块引用。例如：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是一个块引用！</span><br></pre></td></tr></tbody></table></figure><p>将产生：</p><blockquote><p>这是一个块引用！</p></blockquote><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用#表示一级标题，##表示二级标题，以此类推，有6个标题。</p><h1 id="Markdown插件"><a href="#Markdown插件" class="headerlink" title="Markdown插件"></a>Markdown插件</h1><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><h3 id="Sequence-Diagrams"><a href="#Sequence-Diagrams" class="headerlink" title="Sequence Diagrams"></a>Sequence Diagrams</h3><ul><li><a href="https://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">官网链接</a></li></ul><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Andrew-&gt;China: Says Hello</span><br><span class="line">Note right of China: China thinks\nabout it</span><br><span class="line">China--&gt;Andrew: How are you?</span><br><span class="line">Andrew-&gt;&gt;China: I am good thanks!</span><br></pre></td></tr></tbody></table></figure><h3 id="Flowcharts"><a href="#Flowcharts" class="headerlink" title="Flowcharts"></a>Flowcharts</h3><ul><li><a href="http://flowchart.js.org/" target="_blank" rel="noopener">官网链接</a></li></ul><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></tbody></table></figure><div id="flowchart-0" class="flow-chart"></div><h3 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h3><ul><li><a href="https://knsv.github.io/mermaid/#/" target="_blank" rel="noopener">官网链接</a>：支持时序图、流程图、甘特图、 类图、 状态图、派图</li></ul><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">%% Example with selection of syntaxes</span><br><span class="line">gantt</span><br><span class="line">dateFormat  YYYY-MM-DD</span><br><span class="line">title Adding GANTT diagram functionality to mermaid</span><br><span class="line"></span><br><span class="line">section A section</span><br><span class="line">Completed task            :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">Active task               :active,  des2, 2014-01-09, 3d</span><br><span class="line">Future task               :         des3, after des2, 5d</span><br><span class="line">Future task2               :         des4, after des3, 5d</span><br><span class="line"></span><br><span class="line">section Critical tasks</span><br><span class="line">Completed task in the critical line :crit, done, 2014-01-06,24h</span><br><span class="line">Implement parser and jison          :crit, done, after des1, 2d</span><br><span class="line">Create tests for parser             :crit, active, 3d</span><br><span class="line">Future task in critical line        :crit, 5d</span><br><span class="line">Create tests for renderer           :2d</span><br><span class="line">Add to mermaid                      :1d</span><br><span class="line"></span><br><span class="line">section Documentation</span><br><span class="line">Describe gantt syntax               :active, a1, after des1, 3d</span><br><span class="line">Add gantt diagram to demo page      :after a1  , 20h</span><br><span class="line">Add another diagram to demo page    :doc1, after a1  , 48h</span><br><span class="line"></span><br><span class="line">section Last section</span><br><span class="line">Describe gantt syntax               :after doc1, 3d</span><br><span class="line">Add gantt diagram to demo page      : 20h</span><br><span class="line">Add another diagram to demo page    : 48h</span><br></pre></td></tr></tbody></table></figure><pre class="mermaid">%% Example with selection of syntaxesganttdateFormat  YYYY-MM-DDtitle Adding GANTT diagram functionality to mermaidsection A sectionCompleted task            :done,    des1, 2014-01-06,2014-01-08Active task               :active,  des2, 2014-01-09, 3dFuture task               :         des3, after des2, 5dFuture task2               :         des4, after des3, 5dsection Critical tasksCompleted task in the critical line :crit, done, 2014-01-06,24hImplement parser and jison          :crit, done, after des1, 2dCreate tests for parser             :crit, active, 3dFuture task in critical line        :crit, 5dCreate tests for renderer           :2dAdd to mermaid                      :1dsection DocumentationDescribe gantt syntax               :active, a1, after des1, 3dAdd gantt diagram to demo page      :after a1  , 20hAdd another diagram to demo page    :doc1, after a1  , 48hsection Last sectionDescribe gantt syntax               :after doc1, 3dAdd gantt diagram to demo page      : 20hAdd another diagram to demo page    : 48h</pre><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Animal <span class="xml"><span class="tag">&lt;<span class="name">|--</span> <span class="attr">Duck</span></span></span></span><br><span class="line"><span class="xml">Animal <span class="tag">&lt;<span class="name">|--</span> <span class="attr">Fish</span></span></span></span><br><span class="line"><span class="xml">Animal <span class="tag">&lt;<span class="name">|--</span> <span class="attr">Zebra</span></span></span></span><br><span class="line"><span class="xml">Animal : +int age</span></span><br><span class="line"><span class="xml">Animal : +String gender</span></span><br><span class="line"><span class="xml">Animal: +isMammal()</span></span><br><span class="line"><span class="xml">Animal: +mate()</span></span><br><span class="line"><span class="xml">class Duck{</span></span><br><span class="line"><span class="xml">+String beakColor</span></span><br><span class="line"><span class="xml">+swim()</span></span><br><span class="line"><span class="xml">+quack()</span></span><br><span class="line"><span class="xml">}</span></span><br><span class="line"><span class="xml">class Fish{</span></span><br><span class="line"><span class="xml">-int sizeInFeet</span></span><br><span class="line"><span class="xml">-canEat()</span></span><br><span class="line"><span class="xml">}</span></span><br><span class="line"><span class="xml">class Zebra{</span></span><br><span class="line"><span class="xml">+bool is_wild</span></span><br><span class="line"><span class="xml">+run()</span></span><br><span class="line"><span class="xml">}</span></span><br></pre></td></tr></tbody></table></figure><pre class="mermaid">classDiagram      Animal &lt;|-- Duck      Animal &lt;|-- Fish      Animal &lt;|-- Zebra      Animal : +int age      Animal : +String gender      Animal: +isMammal()      Animal: +mate()      class Duck{          +String beakColor          +swim()          +quack()      }      class Fish{          -int sizeInFeet          -canEat()      }      class Zebra{          +bool is_wild          +run()      }</pre><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line"><span class="code">    title Pie Chart</span></span><br><span class="line"><span class="code">    "Dogs" : 386</span></span><br><span class="line"><span class="code">    "Cats" : 85</span></span><br><span class="line"><span class="code">    "Rats" : 150</span></span><br></pre></td></tr></tbody></table></figure><pre class="mermaid">pie    title Pie Chart    "Dogs" : 386    "Cats" : 85    "Rats" : 150</pre><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Markdown语法&quot;&gt;&lt;a href=&quot;#Markdown语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法&quot;&gt;&lt;/a&gt;Markdown语法&lt;/h1&gt;&lt;h2 id=&quot;数学表达式&quot;&gt;&lt;a href=&quot;#数学表达式&quot; class=&quot;headerlink&quot; title=&quot;数学表达式&quot;&gt;&lt;/a&gt;数学表达式&lt;/h2&gt;&lt;p&gt;要启用这个功能，首先到&lt;code&gt;Preference&lt;/code&gt;-&amp;gt;&lt;code&gt;Editor&lt;/code&gt;中启用。然后使用&lt;script type=&quot;math/tex&quot;&gt;`符号包裹Tex命令，例如：`$lim_{x \to \infty} \ exp(-x)=0&lt;/script&gt;将产生如下的数学表达式：&lt;/p&gt;
&lt;p&gt;$\lim_{x \to \infty} \exp(-x)=0$&lt;/p&gt;
&lt;h2 id=&quot;下标&quot;&gt;&lt;a href=&quot;#下标&quot; class=&quot;headerlink&quot; title=&quot;下标&quot;&gt;&lt;/a&gt;下标&lt;/h2&gt;&lt;p&gt;下标使用&lt;code&gt;~&lt;/code&gt;包裹，例如：&lt;code&gt;H~2~O&lt;/code&gt;将产生H~2~O, 即水的分子式。&lt;/p&gt;
&lt;h2 id=&quot;上标&quot;&gt;&lt;a href=&quot;#上标&quot; class=&quot;headerlink&quot; title=&quot;上标&quot;&gt;&lt;/a&gt;上标&lt;/h2&gt;&lt;p&gt;上标使用&lt;code&gt;^&lt;/code&gt;包裹，例如：&lt;code&gt;y^2^=4&lt;/code&gt;将产生表达式y^2^ = 4&lt;/p&gt;
&lt;h2 id=&quot;插入表情-happy&quot;&gt;&lt;a href=&quot;#插入表情-happy&quot; class=&quot;headerlink&quot; title=&quot;插入表情:happy:&quot;&gt;&lt;/a&gt;插入表情:happy:&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;:happy:&lt;/code&gt;输入表情:happy:,使用&lt;code&gt;:sad:&lt;/code&gt;输入表情:sad:,使用&lt;code&gt;:cry:&lt;/code&gt;输入表情&lt;span class=&quot;github-emoji&quot; style=&quot;color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8) center/contain&quot; data-src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8&quot;&gt;😢&lt;/span&gt;等。以此类推！&lt;/p&gt;
&lt;h2 id=&quot;下划线&quot;&gt;&lt;a href=&quot;#下划线&quot; class=&quot;headerlink&quot; title=&quot;下划线&quot;&gt;&lt;/a&gt;下划线&lt;/h2&gt;&lt;p&gt;用HTML的语法&lt;code&gt;&amp;lt;u&amp;gt;Underline&amp;lt;/u&amp;gt;&lt;/code&gt;将产生下划线&lt;u&gt;Underline&lt;/u&gt;.&lt;/p&gt;
&lt;h2 id=&quot;删除线&quot;&gt;&lt;a href=&quot;#删除线&quot; class=&quot;headerlink&quot; title=&quot;删除线&quot;&gt;&lt;/a&gt;删除线&lt;/h2&gt;&lt;p&gt;GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用&lt;code&gt;~~&lt;/code&gt;包裹的文本将会具有删除的样式，例如&lt;code&gt;~删除文本~&lt;/code&gt;将产生&lt;del&gt;删除文本&lt;/del&gt;的样式。&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用`包裹的内容将会以代码样式显示，例如&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;使用`printf()`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;则会产生&lt;code&gt;printf()&lt;/code&gt;样式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://unknown.yuzhouwan.com/categories/Tools/"/>
    
    
      <category term="markdown" scheme="https://unknown.yuzhouwan.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://unknown.yuzhouwan.com/posts/25246/"/>
    <id>https://unknown.yuzhouwan.com/posts/25246/</id>
    <published>2020-01-06T23:55:00.000Z</published>
    <updated>2020-03-01T13:10:07.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><h2 id="config文件"><a href="#config文件" class="headerlink" title="config文件"></a>config文件</h2><ul><li><p>/etc/gitconfig文件：系统中对所有的用户都普遍适用的配置。若使用git config —system选项，读写就是这个文件</p></li><li><p>～/.gitconfig文件：用户目录下的配置文件，只适用于该用户。若使用config —global选项，读写就是这个文件</p></li><li><p>当前Git仓库的git文件（.git/config），这里配置只对当前项目有效，每个配置级别都会覆盖上层的配置，所以.git/config会覆盖/etc/gitconfig里的文件</p><p>在Windows系统上，Git会找主目录下的.gitconfig文件，主目录即$HOME变量指定的目录，一般在C:\Documents and Settings$USER中</p><p>此外，Git还会尝试找寻/etc/gitconfig文件，只不过看当初Git装在什么目录，就以此作为根目录来定位</p></li></ul><h2 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --<span class="keyword">global</span> user.name <span class="string">"loen"</span></span><br><span class="line">$ git config --<span class="keyword">global</span> user.email loen@qq.com</span><br></pre></td></tr></tbody></table></figure><p>利用gloabal选项，更改用户主目录下的config文件，以后所有项目都会默认使用这里配置的用户信息</p><p>如果要在某个特定项目里使用其他名字或者邮件，只要去掉—global选项重新配置即可，新的设定保存在当前目录的.git/config 文件里</p><h2 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h2> <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></tbody></table></figure><p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件( 比如/etc/gitconfig和~./gitconfig)，不过Git实际采用的是最后一个</p><p>也可以在/etc/gitconfig和~./gitconfig里看到</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.gitconfig</span><br></pre></td></tr></tbody></table></figure><h2 id="忽略特殊文件-gitignore"><a href="#忽略特殊文件-gitignore" class="headerlink" title="忽略特殊文件.gitignore"></a>忽略特殊文件.gitignore</h2><p>有时必须把某些文件放入Git工作目录中，但是又不能将其提交，如存储了数据库密码的配置文件。</p><p>只需在Git工作区的根目录下创建一个名为.gitignore的文件，写入过滤规则就可以了</p><p>.gitignore不需要从头写，所有配置文件可以直接在线浏览<a href="https://github.com/github/.gitignore" target="_blank" rel="noopener">https://github.com/github/.gitignore</a></p><p>忽略文件的原则是：</p><p>1.忽略系统自动生成的文件</p><p>2.忽略编译生成的中间文件</p><p>3.忽略用户带有敏感信息的配置文件</p><h1 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h1><p>Git（Global Information Tracker）是一个开源的分布式版本控制系统，是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源代码的软件。</p><p>Git一般的工作流程如下：</p><a id="more"></a><ul><li><p>克隆Git资源作为本地的工作目录</p></li><li><p>在工作目录上添加或者修改文件</p></li><li><p>提交修改</p></li><li><p>可以撤回提交并再次修改</p><p><img data-src="/images/git/git_1.png" alt="屏幕快照 2019-08-18 下午9.21.01"></p></li></ul><h1 id="快速入门Git"><a href="#快速入门Git" class="headerlink" title="快速入门Git"></a>快速入门Git</h1><h2 id="创建版本库：git-init"><a href="#创建版本库：git-init" class="headerlink" title="创建版本库：git init"></a>创建版本库：git init</h2><p>在本地目录中执行git init，创建一个新的Git仓库FirstGit。.git用于跟踪管理版本库。</p><p><img data-src="/images/git/git_0.png" alt="屏幕快照 2019-08-18 下午9.34.53"></p><h2 id="添加到暂存区：git-add"><a href="#添加到暂存区：git-add" class="headerlink" title="添加到暂存区：git add"></a>添加到暂存区：git add</h2><p>在FirstGit目录下添加文件README.md</p><p><img data-src="/images/git/git_2.png" alt="屏幕快照 2019-08-18 下午9.43.56"></p><ul><li>git status用于查看项目的当前状态，-s表示查看简要信息</li><li>git add命令将其添加到暂存区，也可以使用git add . 用于添加当前目录下的所有文件</li></ul><p>改动README.md，再次执行git status</p><p><img data-src="/images/git/git_3.png" alt="屏幕快照 2019-08-18 下午9.50.02"></p><ul><li>“AM”状态表示这个文件在被添加到暂存区后进行了修改</li><li>再次执行git add命令将其添加到暂存区（缓存）</li></ul><p>再次改动README.md</p><p><img data-src="/images/git/git_4.png" alt="屏幕快照 2019-08-18 下午10.04.07"></p><p><img data-src="/images/git/git_5.png" alt="屏幕快照 2019-08-18 下午10.04.47"></p><ul><li>git diff：查看写入缓存与已修改但尚未写入缓存的区别</li><li>git diff —cached：查看已缓存的改动</li><li>git diff HEAD：查看已缓存的与未缓存的所有改动</li><li>git diff —stat：显示摘要而非整个diff</li></ul><h2 id="向仓库提交代码：git-commit"><a href="#向仓库提交代码：git-commit" class="headerlink" title="向仓库提交代码：git commit"></a>向仓库提交代码：git commit</h2><p>git add将快照内容写入缓存区，git commit则是将缓存区的内容添加到远程仓库中</p><p><img data-src="/images/git/git_6.png" alt="屏幕快照 2019-08-18 下午10.18.43"></p><p><img data-src="/images/git/git_7.png" alt="屏幕快照 2019-08-18 下午10.22.09"></p><ul><li>-m 选项表示提交的注释</li><li>再次执行git status，输出表示在上次提交之后，没有作出任何更改</li><li>也可以利用git commit -am “lala”来替代git add  . 与 git commit -m “lala”</li></ul><h2 id="取消已缓存的内容：git-reset-HEAD"><a href="#取消已缓存的内容：git-reset-HEAD" class="headerlink" title="取消已缓存的内容：git reset HEAD"></a>取消已缓存的内容：git reset HEAD</h2><p><img data-src="/images/git/git_8.png" alt="屏幕快照 2019-08-18 下午10.47.03"></p><p>可以看到git add后将README文件添加到了缓存区，利用git reset命令取消了README的缓存，HEAD表示指向的版本为当前版本</p><h2 id="删除文件：git-rm"><a href="#删除文件：git-rm" class="headerlink" title="删除文件：git rm"></a>删除文件：git rm</h2><ul><li>git rm <file>：从版本库中删除文件</file></li><li>git rm -f <file>：从暂存区中删除文件（必须进行强制删除）</file></li><li>git rm —cached <file>：从暂存区中删除文件，保留工作区中的文件</file></li><li>git rm -r test：递归删除test目录下的所有目录与文件</li></ul><h2 id="恢复文件：git-checkout"><a href="#恢复文件：git-checkout" class="headerlink" title="恢复文件：git checkout"></a>恢复文件：git checkout</h2><p>git checkout —file：工作区的文件替换为版本库的文件</p><h2 id="移动-重命名：git-mv"><a href="#移动-重命名：git-mv" class="headerlink" title="移动/重命名：git mv"></a>移动/重命名：git mv</h2><p>git mv ：用于移动或者重命名一个文件、目录</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br><span class="line">$ git mv README README.md </span><br><span class="line">$ ls</span><br><span class="line">README.md</span><br></pre></td></tr></tbody></table></figure><h1 id="远程仓库GitHub"><a href="#远程仓库GitHub" class="headerlink" title="远程仓库GitHub"></a>远程仓库GitHub</h1><p>GitHub是一个面向开源及私有软件项目的托管平台，仅支持git作为唯一的版本库格式进行托管。</p><h2 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h2><p>本地创建新的仓库并与GitHub进行关联</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git remote add origin https://github.com/gracekoo/gitlearn.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></tbody></table></figure><p>或者将本地已有仓库与之关联</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/gracekoo/gitlearn.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></tbody></table></figure><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><p>git clone：拷贝一个git仓库到本地，还可以在命令末尾加上自己想要的名字</p> <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/gracekoo/gitlearn.git mygit</span><br></pre></td></tr></tbody></table></figure><h2 id="更新数据：git-fetch"><a href="#更新数据：git-fetch" class="headerlink" title="更新数据：git fetch"></a>更新数据：git fetch</h2><p>git fetch：从远程获取最新版本到本地，不会自动merge</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout issue12 </span><br><span class="line">$ git fetch origin issue12 </span><br><span class="line">$ git log -p issue12..origin/issue12</span><br><span class="line">$ git merge origin/issue12</span><br></pre></td></tr></tbody></table></figure><p>(1) 换到issue12分支</p><p>(2)从远程的origin的issue12分支下载最新版本到issue12分支上</p><p>(3)比较本地issue12分支和origin/issue12分支的差别</p><p>(4)将origin/issue12分支合并到issue12</p><h2 id="更新数据：git-pull"><a href="#更新数据：git-pull" class="headerlink" title="更新数据：git pull"></a>更新数据：git pull</h2><p>git pull：从远程获取最新版本并merge到本地</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout issue12</span><br><span class="line">$ git pull origin issue12 // git fetch + git merge</span><br></pre></td></tr></tbody></table></figure><h1 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h1><h2 id="分支原理"><a href="#分支原理" class="headerlink" title="分支原理"></a>分支原理</h2><ul><li><p>执行git init时，缺省情况下Git会创建“master”分支</p></li><li><p>master指向提交，HEAD指向当前分支</p></li><li><p>每次提交，master分支都会向前移动一步。当创建新的分支，如dev时，Git新建一个指针dev，指向与master相同的<strong>提交</strong>，再把HEAD指向dev，表示现在分支在dev上</p><p><img data-src="/images/git/git_9.jpeg" alt="WechatIMG265"></p></li><li><p>从现在开始，对工作区的修改和提交就是针对dev分支了，比如一次新提交后，dev指针向前移动一步，而master指针不变</p><p><img data-src="/images/git/git_10.jpeg" alt="WechatIMG263"></p></li><li><p>在dev上完成相应的开发后，将其合并到master分支上</p><p><img data-src="/images/git/git_11.jpeg" alt="WechatIMG264"></p></li></ul><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>使用分支意味着从开发主线上分离开，然后在不影响主线的同时继续工作</p><ul><li>创建新分支new_branch</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch new_branch</span><br></pre></td></tr></tbody></table></figure><ul><li>切换到新分支new_branch：当切换到新分支时，Git会用该分支的最后提交的快照替换工作目录的内容</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout new_branch //切换到new_branch</span><br><span class="line">$ git checkout -b new_branch //创建并切换到new_branch</span><br></pre></td></tr></tbody></table></figure><ul><li>合并分支</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge</span><br></pre></td></tr></tbody></table></figure><p>通常Git在合并分支时会用Fast Forward模式，这样删除分支后，会丢失分支信息。</p><p>因此在合并分支时可以使用—no-ff，强制禁用Fast Forward模式，这样Git在合并时会生成一个新的commit，然后就可以在历史分支上看到分支信息。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev2</span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></tbody></table></figure><ul><li>删除分支</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d new_branch</span><br></pre></td></tr></tbody></table></figure><ul><li>查看分支</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch </span><br><span class="line">$ git branch -r //查看远程分支</span><br><span class="line">$ git branch -a //查看远程和本地的所有分支</span><br></pre></td></tr></tbody></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>在两个分支中修改了同一个文件的同一行代码，在合并时就会发生冲突，使用git status可以显示存在冲突的文件和文件名</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></tbody></table></figure><p>当发生冲突时，必须手动解决冲突，并再次提交</p><p>利用带参数的git log也可以看到合并后的情况</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></tbody></table></figure><p>实际开发中，应该按照以下基本原则来进行分支管理</p><ul><li>master分支应该是非常稳定的，也就是仅用来发布新版本，平时不用于开发</li><li>团队成员在dev上开发，时不时的往dev上进行合并，等到发布新版本时，再将dev往master上合并</li></ul><h2 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h2><p>当从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git remote //查看远程库信息，远程仓库默认名字是origin</span><br><span class="line">origin</span><br><span class="line">$ git remote -v //更详细的信息</span><br><span class="line">origin</span><br><span class="line">https://github.com/asdf2014/algorithm.git</span><br></pre></td></tr></tbody></table></figure><h2 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h2><p>将本地的master分支推送到远程库origin</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></tbody></table></figure><p>将本地的dev2分支推送到远程库origin</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev2</span><br></pre></td></tr></tbody></table></figure><h2 id="拉取分支"><a href="#拉取分支" class="headerlink" title="拉取分支"></a>拉取分支</h2><p>将origin最新的提交拉取下来</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></tbody></table></figure><p>关联本地dev分支与远程origin/dev分支</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream dev origin/dev</span><br></pre></td></tr></tbody></table></figure><h1 id="回退与撤销"><a href="#回退与撤销" class="headerlink" title="回退与撤销"></a>回退与撤销</h1><h2 id="撤销修改：git-checkout-file"><a href="#撤销修改：git-checkout-file" class="headerlink" title="撤销修改：git checkout - - file"></a>撤销修改：git checkout - - file</h2><p>把该文件在工作区的修改全部撤销，如果文件修改后还没有放到暂存区，撤销修改就是用版本库里的替代工作区内的。如果文件已经被添加到暂存区，那么撤销修改就是用暂存区里的文件替代当前文件。</p><p>总之就是让这个文件回到最近一次git commit或git add时的状态。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></tbody></table></figure><h2 id="历史记录：git-log"><a href="#历史记录：git-log" class="headerlink" title="历史记录：git log"></a>历史记录：git log</h2><p>git log显示从最近到最远的提交日志。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></tbody></table></figure><p>显示简要的commit历史记录。commit ID用SHA1计算出的16进制表示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=online</span><br></pre></td></tr></tbody></table></figure><h2 id="版本回退：git-reset"><a href="#版本回退：git-reset" class="headerlink" title="版本回退：git reset"></a>版本回退：git reset</h2><p>利用git log来查看当前的历史记录</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=online</span><br></pre></td></tr></tbody></table></figure><p>使用git reset回退到上一个版本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></tbody></table></figure><p>Git中，用HEAD表示当前的版本，上一个版本就是HEAD^，上上个版本就是HEAD^^,前100个版本可以用HEAD~100表示。</p><p>如果回退失误，想要改回原来的版本，就必须通过git log命令找到版本的commit id</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=online</span><br></pre></td></tr></tbody></table></figure><p>假如ID为asdhasdjfnaslkgnsd，利用git reset命令进行版本回退</p> <figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard asdhasdjfnaslkgnsd</span><br></pre></td></tr></tbody></table></figure><p>git reflog命令用于显示整个本地库的commit，包括所有branch 的commit，甚至包括已经撤销的commit，只要HEAD发生了变化，就会在reflog中看到。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></tbody></table></figure><h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><h2 id="创建标签：git-tag"><a href="#创建标签：git-tag" class="headerlink" title="创建标签：git tag"></a>创建标签：git tag</h2><p>标签是默认打在最新提交的commit id上的</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switch to branch <span class="string">'master'</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1<span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure><p>也可以直接在某个commit id上打标签</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=online --abbrev-commit //找到历史的commit id</span><br><span class="line">a923sad1 You <span class="keyword">is</span> pig</span><br><span class="line">a923sad2 You <span class="keyword">is</span> cat</span><br><span class="line">$ git tag v0<span class="number">.8</span> a923sad2 //给You <span class="keyword">is</span> cat打标签</span><br><span class="line">$ git tag //查看当前标签</span><br><span class="line">v0<span class="number">.8</span></span><br></pre></td></tr></tbody></table></figure><p>也可以创建带有说明的标签：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0<span class="number">.9</span> -m <span class="string">"This is v0.9"</span></span><br></pre></td></tr></tbody></table></figure><h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><p>可以使用git tag来查看所有的标签</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1<span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure><p>查看标签信息</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0<span class="number">.9</span></span><br></pre></td></tr></tbody></table></figure><h2 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0<span class="number">.9</span></span><br></pre></td></tr></tbody></table></figure><h2 id="推送标签到远程"><a href="#推送标签到远程" class="headerlink" title="推送标签到远程"></a>推送标签到远程</h2><p>推送某个标签到远程</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1<span class="number">.0</span></span><br></pre></td></tr></tbody></table></figure><p>一次性推送全部尚未送到远程的本地标签</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></tbody></table></figure><p>如果标签已经推送到远程，要删除远程标签，先从本地删除</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0<span class="number">.9</span></span><br></pre></td></tr></tbody></table></figure><p>然后从远程删除</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0<span class="number">.9</span> To https://github.com/liming/gitlearn.git</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git配置&quot;&gt;&lt;a href=&quot;#Git配置&quot; class=&quot;headerlink&quot; title=&quot;Git配置&quot;&gt;&lt;/a&gt;Git配置&lt;/h1&gt;&lt;h2 id=&quot;config文件&quot;&gt;&lt;a href=&quot;#config文件&quot; class=&quot;headerlink&quot; title=&quot;config文件&quot;&gt;&lt;/a&gt;config文件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;/etc/gitconfig文件：系统中对所有的用户都普遍适用的配置。若使用git config —system选项，读写就是这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;～/.gitconfig文件：用户目录下的配置文件，只适用于该用户。若使用config —global选项，读写就是这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当前Git仓库的git文件（.git/config），这里配置只对当前项目有效，每个配置级别都会覆盖上层的配置，所以.git/config会覆盖/etc/gitconfig里的文件&lt;/p&gt;
&lt;p&gt;在Windows系统上，Git会找主目录下的.gitconfig文件，主目录即$HOME变量指定的目录，一般在C:\Documents and Settings$USER中&lt;/p&gt;
&lt;p&gt;此外，Git还会尝试找寻/etc/gitconfig文件，只不过看当初Git装在什么目录，就以此作为根目录来定位&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;配置用户信息&quot;&gt;&lt;a href=&quot;#配置用户信息&quot; class=&quot;headerlink&quot; title=&quot;配置用户信息&quot;&gt;&lt;/a&gt;配置用户信息&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --&lt;span class=&quot;keyword&quot;&gt;global&lt;/span&gt; user.name &lt;span class=&quot;string&quot;&gt;&quot;loen&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --&lt;span class=&quot;keyword&quot;&gt;global&lt;/span&gt; user.email loen@qq.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;利用gloabal选项，更改用户主目录下的config文件，以后所有项目都会默认使用这里配置的用户信息&lt;/p&gt;
&lt;p&gt;如果要在某个特定项目里使用其他名字或者邮件，只要去掉—global选项重新配置即可，新的设定保存在当前目录的.git/config 文件里&lt;/p&gt;
&lt;h2 id=&quot;查看配置信息&quot;&gt;&lt;a href=&quot;#查看配置信息&quot; class=&quot;headerlink&quot; title=&quot;查看配置信息&quot;&gt;&lt;/a&gt;查看配置信息&lt;/h2&gt; &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --list&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有时候会看到重复的变量名，那就说明它们来自不同的配置文件( 比如/etc/gitconfig和~./gitconfig)，不过Git实际采用的是最后一个&lt;/p&gt;
&lt;p&gt;也可以在/etc/gitconfig和~./gitconfig里看到&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ vim ~/.gitconfig&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;忽略特殊文件-gitignore&quot;&gt;&lt;a href=&quot;#忽略特殊文件-gitignore&quot; class=&quot;headerlink&quot; title=&quot;忽略特殊文件.gitignore&quot;&gt;&lt;/a&gt;忽略特殊文件.gitignore&lt;/h2&gt;&lt;p&gt;有时必须把某些文件放入Git工作目录中，但是又不能将其提交，如存储了数据库密码的配置文件。&lt;/p&gt;
&lt;p&gt;只需在Git工作区的根目录下创建一个名为.gitignore的文件，写入过滤规则就可以了&lt;/p&gt;
&lt;p&gt;.gitignore不需要从头写，所有配置文件可以直接在线浏览&lt;a href=&quot;https://github.com/github/.gitignore&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/github/.gitignore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;忽略文件的原则是：&lt;/p&gt;
&lt;p&gt;1.忽略系统自动生成的文件&lt;/p&gt;
&lt;p&gt;2.忽略编译生成的中间文件&lt;/p&gt;
&lt;p&gt;3.忽略用户带有敏感信息的配置文件&lt;/p&gt;
&lt;h1 id=&quot;Git工作流程&quot;&gt;&lt;a href=&quot;#Git工作流程&quot; class=&quot;headerlink&quot; title=&quot;Git工作流程&quot;&gt;&lt;/a&gt;Git工作流程&lt;/h1&gt;&lt;p&gt;Git（Global Information Tracker）是一个开源的分布式版本控制系统，是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源代码的软件。&lt;/p&gt;
&lt;p&gt;Git一般的工作流程如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="https://unknown.yuzhouwan.com/categories/Tools/"/>
    
    
      <category term="Git" scheme="https://unknown.yuzhouwan.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV-Base</title>
    <link href="https://unknown.yuzhouwan.com/posts/16645/"/>
    <id>https://unknown.yuzhouwan.com/posts/16645/</id>
    <published>2020-01-01T00:06:00.000Z</published>
    <updated>2020-11-12T10:46:49.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenCV的安装"><a href="#OpenCV的安装" class="headerlink" title="OpenCV的安装"></a>OpenCV的安装</h1><p>国内一些pip的镜像源：</p><p>阿里云 <a href="https://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">https://mirrors.aliyun.com/pypi/simple/</a><br>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>豆瓣(douban) <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a><br>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(base)$ conda create -n py365 python=<span class="number">3.6</span><span class="number">.5</span>   <span class="comment"># anaconda中创建python版本为3.7.3的虚拟环境</span></span><br><span class="line">(base)$ conda activate py365                 <span class="comment"># 激活该环境</span></span><br><span class="line">pip install opencv-python==<span class="number">3.4</span><span class="number">.1</span><span class="number">.15</span> -i http://pypi.douban.com/simple --trusted-host pypi.douban.com                              <span class="comment"># 安装opencv-python 3.4.1.15，同时还会加载相应的依赖库</span></span><br></pre></td></tr></tbody></table></figure><p>内容完善中……</p><a id="more"></a><h1 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h1><h2 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h2><p><img data-src="/images/opencv/Pyramid_1.png" alt="Pyramid_1"></p><p><strong>高斯金字塔：向下采样法（缩小）</strong></p><p><img data-src="/images/opencv/Pyramid_2.png" alt="Pyramid_2"></p><p>实例：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"A.png"</span>)</span><br><span class="line">down = cv2.pyrDown(img)</span><br><span class="line">cv2.imshow(<span class="string">"down"</span>,down)</span><br></pre></td></tr></tbody></table></figure><p><strong>高斯金字塔：向上采样法（放大）</strong></p><p><img data-src="/images/opencv/Pyramid_3.png" alt="Pyramid_3"></p><p>实例：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"A.png"</span>)</span><br><span class="line">up = cv2.pyrUp(img)</span><br><span class="line">cv2.imshow(<span class="string">"up"</span>,up)</span><br></pre></td></tr></tbody></table></figure><h2 id="拉普拉斯金字塔"><a href="#拉普拉斯金字塔" class="headerlink" title="拉普拉斯金字塔"></a>拉普拉斯金字塔</h2><p><img data-src="/images/opencv/Pyramid_4.png" alt="Pyramid_4"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">down=cv2.pyrDown(img)</span><br><span class="line">down_up=cv2.pyrUp(down)</span><br><span class="line">l_img=img-down_up</span><br><span class="line">cv2.imshow(l_img,<span class="string">'l_1'</span>)</span><br></pre></td></tr></tbody></table></figure><h1 id="轮廓检测"><a href="#轮廓检测" class="headerlink" title="轮廓检测"></a>轮廓检测</h1><p><strong>cv2.findContours(img,mode,method)</strong></p><p>mode:轮廓检索模式</p><ul><li>RETR_EXTERNAL ：只检索最外面的轮廓；</li><li>RETR_LIST：检索所有的轮廓，并将其保存到一条链表当中；</li><li>RETR_CCOMP：检索所有的轮廓，并将他们组织为两层：顶层是各部分的外部边界，第二层是空洞的边界;</li><li>RETR_TREE：检索所有的轮廓，并重构嵌套轮廓的整个层次;</li></ul><p>method:轮廓逼近方法</p><ul><li>CHAIN_APPROX_NONE：以Freeman链码的方式输出轮廓，所有其他方法输出多边形（顶点的序列）。</li><li>CHAIN_APPROX_SIMPLE:压缩水平的、垂直的和斜的部分，也就是，函数只保留他们的终点部分。</li></ul><p>为了得到更高的准确率，使用二值图像。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'contours.png'</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(gray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">cv2.imshow(thresh,<span class="string">'thresh'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># binary 输出的二值图；contours 边缘；hierarchy 层次结构</span></span><br><span class="line">binary, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制轮廓：参数分别为，轮廓，轮廓索引（-1表示所有轮廓），颜色，线条厚度</span></span><br><span class="line">draw_img = img.copy()</span><br><span class="line">res = cv2.drawContours(draw_img, contours, <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">cv_show(res,<span class="string">'res'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h2><h3 id="炬"><a href="#炬" class="headerlink" title="炬"></a>炬</h3><h3 id="面积"><a href="#面积" class="headerlink" title="面积"></a>面积</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#面积</span></span><br><span class="line">cv2.contourArea(cnt)</span><br></pre></td></tr></tbody></table></figure><h3 id="周长"><a href="#周长" class="headerlink" title="周长"></a>周长</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line">cv2.arcLength(cnt,<span class="literal">True</span>) <span class="comment"># True表示闭合</span></span><br></pre></td></tr></tbody></table></figure><h3 id="轮廓近似"><a href="#轮廓近似" class="headerlink" title="轮廓近似"></a>轮廓近似</h3><p><img data-src="/images/opencv/contours3.png" alt="contours3"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找轮廓</span></span><br><span class="line">img = cv2.imread(<span class="string">'contours2.png'</span>)</span><br><span class="line"></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(gray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">binary, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">draw_img = img.copy()</span><br><span class="line">res = cv2.drawContours(draw_img, [cnt], <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">cv_show(res,<span class="string">'res'</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">epsilon = <span class="number">0.15</span>*cv2.arcLength(cnt,<span class="literal">True</span>)  <span class="comment"># epsilon一般按照周长的百分比进行设置，越小，轮廓近似值越大</span></span><br><span class="line">approx = cv2.approxPolyDP(cnt,epsilon,<span class="literal">True</span>) </span><br><span class="line"></span><br><span class="line">draw_img = img.copy()</span><br><span class="line">res = cv2.drawContours(draw_img, [approx], <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">cv_show(res,<span class="string">'res'</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="边界矩形"><a href="#边界矩形" class="headerlink" title="边界矩形"></a>边界矩形</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'contours.png'</span>)</span><br><span class="line"></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, thresh = cv2.threshold(gray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">binary, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)</span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">x,y,w,h = cv2.boundingRect(cnt)</span><br><span class="line">img = cv2.rectangle(img,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">cv_show(img,<span class="string">'img'</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)</span><br><span class="line">x, y, w, h = cv2.boundingRect(cnt)</span><br><span class="line">rect_area = w * h</span><br><span class="line">extent = float(area) / rect_area</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'轮廓面积与边界矩形比'</span>,extent)</span><br></pre></td></tr></tbody></table></figure><h3 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(x,y),radius = cv2.minEnclosingCircle(cnt) </span><br><span class="line">center = (int(x),int(y)) </span><br><span class="line">radius = int(radius) </span><br><span class="line">img = cv2.circle(img,center,radius,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">cv_show(img,<span class="string">'img'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="轮廓的性质"><a href="#轮廓的性质" class="headerlink" title="轮廓的性质"></a>轮廓的性质</h2><h3 id="Solidty"><a href="#Solidty" class="headerlink" title="Solidty"></a>Solidty</h3><h3 id="Equivalent-Diameter"><a href="#Equivalent-Diameter" class="headerlink" title="Equivalent Diameter"></a>Equivalent Diameter</h3><h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><h3 id="掩模和像素点"><a href="#掩模和像素点" class="headerlink" title="掩模和像素点"></a>掩模和像素点</h3><h3 id="平均颜色和平均灰度"><a href="#平均颜色和平均灰度" class="headerlink" title="平均颜色和平均灰度"></a>平均颜色和平均灰度</h3><h3 id="极点"><a href="#极点" class="headerlink" title="极点"></a>极点</h3><h1 id="模版匹配"><a href="#模版匹配" class="headerlink" title="模版匹配"></a>模版匹配</h1><p>模版匹配和卷积原理很像，模版在原图上从原点开始滑动，计算模版与（图像被模版覆盖的地方）的差别程度，这个差别程度的计算方法在opencv里有6种。然后将每次计算的结果放入一个矩阵里，作为结果输出。假如原图形是A✖️B大小，而模版是a✖️b的大小，则输出结果的矩阵是（A-a+1）✖️（B-b+1）的大小。</p><ul><li>TM_SQDIFF：计算平方差，计算出来的值越小，越相关</li><li>TM_CCORR：计算相关性，计算出来的值越大，越相关</li><li>TM_CCOEFF：计算相关系数，计算出来的值越大，越相关</li><li>TM_SQDIFF_NORMED：计算归一化平方差，计算出来的值越接近0，越相关</li><li><p>TM_CCORR_NORMED：计算归一化相关性，计算出来的值越接近1，越相关</p></li><li><p>TM_CCOEFF_NORMED：计算归一化相关系数，计算出来的值越接近1，越相关</p></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"lena.jpg"</span>,<span class="number">0</span>)</span><br><span class="line">h,w = img.shape[:<span class="number">2</span>][::<span class="number">-1</span>]</span><br><span class="line">template = cv2.imread(<span class="string">"face"</span>,<span class="number">0</span>)</span><br><span class="line">methods = [<span class="string">'cv2.TM_CCOEFF'</span>,<span class="string">'cv2.TM_CCORR_NORME'</span>,<span class="string">'cv2.TM_CCORR'</span>,<span class="string">'cv2.TM_CCORR_NORMED'</span>,<span class="string">'cv2.TM_SQDIFF'</span>,<span class="string">'cv2.TM_SQDIFF_NORMED'</span>]</span><br><span class="line">res = cv2.matchTemplate(img,template,<span class="number">1</span>) <span class="comment"># 模版匹配</span></span><br><span class="line">min_val,max_val,min_loc,max_loc = cv2.minMacLoc(res) <span class="comment"># 返回最小最大值的坐标和位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> meth <span class="keyword">in</span> methods:</span><br><span class="line">  img2 = img.copy()</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 匹配方法的真值</span></span><br><span class="line">  method = eval(meth)</span><br><span class="line">  res = cv2.matchTemplate(img,template,<span class="number">1</span>) <span class="comment"># 模版匹配</span></span><br><span class="line">  min_val,max_val,min_loc,max_loc = cv2.minMacLoc(res) <span class="comment"># 返回最小最大值的坐标和位置</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 如果是平方差匹配TM_SQDIFF或者归一化平方差匹配TM_SQDIFF_NORMED，取最小值</span></span><br><span class="line">  <span class="keyword">if</span> method <span class="keyword">in</span> [cv2.TM_SQDIFF,cv2.TM_SQDIFF_NORMED]:</span><br><span class="line">    top_left = min_loc</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    top_left = max_loc</span><br><span class="line">  bottom_right = (top_left[<span class="number">0</span>]+w,top_left[<span class="number">1</span>]+h)</span><br><span class="line">  </span><br><span class="line">  cv2.rectangle(img2,top_left,bottom_right,<span class="number">255</span>,<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">  plt.subplot(<span class="number">121</span>),plt.imshow(res,cmap=<span class="string">'gray'</span>)</span><br><span class="line">  plt.sticks([]),plt.yticks([])</span><br><span class="line">  plt.subplot(<span class="number">122</span>),plt.imshow(img2,cmap=<span class="string">'gray'</span>)</span><br><span class="line">  plt.sticks([]),plt.yticks([])</span><br><span class="line">  plt.subtitle(meth)</span><br><span class="line">  plt.show()</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配多个对象</span></span><br><span class="line">img = cv2.imread(<span class="string">"lena.jpg"</span>,<span class="number">0</span>)</span><br><span class="line">h,w = img.shape[:<span class="number">2</span>][::<span class="number">-1</span>]</span><br><span class="line">template = cv2.imread(<span class="string">"face"</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">res = cv2.matchTemplate(img,template,cv2.TM_CCORR_NORME) <span class="comment"># 模版匹配</span></span><br><span class="line">threshold = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取匹配程度大于0.8的坐标</span></span><br><span class="line">loc = np.where(res &gt;= threshold)</span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> zip(*loc[::<span class="number">-1</span>]): <span class="comment">#*号表示可选参数</span></span><br><span class="line">  bottom_right = (pt[<span class="number">0</span>] + w, pt[<span class="number">1</span>] + h)</span><br><span class="line">  cv2.rectangle(img,pt,bottom_right,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">cv2.imshow(<span class="string">"img"</span>,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><h1 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h1><p>统计图中的像素点分布。</p><h2 id="直方图的计算、绘制与分析"><a href="#直方图的计算、绘制与分析" class="headerlink" title="直方图的计算、绘制与分析"></a>直方图的计算、绘制与分析</h2><p>cv2.calcHist(images, channels,mask,histSize,range)</p><ul><li>images:原图像格式为uint8或float32，当传入函数时应用中括号，例如[img]</li><li>channels:同样用中括号，如果图像时灰度图，它的值是[0]，如果是彩色图像，那传入的参数可以是【0】【1】【2】</li><li>mask:掩模图像，统计整幅图像就将它设为None，但是如果只想统计一部分，就制作一个掩模。</li><li>histSize:BIN的数目，也用中括号</li><li>ranges:像素值范围，为[0,256]</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"cat.png"</span>,<span class="number">0</span>)</span><br><span class="line">hist = cv2.calcHist([img],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.hist(img.ravel(),<span class="number">256</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><h2 id="mask操作"><a href="#mask操作" class="headerlink" title="mask操作"></a>mask操作</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建mask</span></span><br><span class="line">mask = np.zeros(img.shape[:<span class="number">2</span>],np.uint8)</span><br><span class="line">mask[<span class="number">100</span>:<span class="number">300</span>,<span class="number">100</span>:<span class="number">400</span>] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作mask</span></span><br><span class="line">mask_img = cv2.bitwise_and(img,img,mask=mask) <span class="comment">#与操作</span></span><br><span class="line">cv2.imshow(<span class="string">"img"</span>,img)</span><br><span class="line"></span><br><span class="line">hist_full = cv2.calHist([img],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">hist_mask = cv2.calHist([img],[<span class="number">0</span>],mask,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h2><p>均衡后，色彩和亮度能够稍微的提升。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equ = cv2.equalizeHist(img)</span><br><span class="line">plt.hist(equ,ravel(<span class="number">0</span>,<span class="number">256</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><ul><li>自适应直方图均衡化</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clahe = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>,tilerGridSize(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">res_clahe = clahe.apple(img)</span><br></pre></td></tr></tbody></table></figure><h1 id="傅立叶变换"><a href="#傅立叶变换" class="headerlink" title="傅立叶变换"></a>傅立叶变换</h1><p>中心思想：<strong>任何函数都能通过傅立叶堆叠出来。</strong></p><p>以时间为参照就是时域分析。</p><p><strong>傅立叶变换的作用：</strong></p><ul><li>高频：变化剧烈的灰度分量，例如边界</li><li>低频：变化缓慢的灰度分量，例如一片大海</li></ul><p>可以找到图像中的高频与低频部分。</p><p><strong>滤波：</strong></p><ul><li>低通滤波器：只保留低频，会使图像模糊</li><li>高通滤波器：只保留高频，会使图像细节增强</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line">img = cv2.imread(<span class="string">"lena.jpg"</span>,<span class="number">0</span>)</span><br><span class="line">img_float32 = np.float32(img)</span><br><span class="line"></span><br><span class="line">dft = cv2.dft(img_float32,flags = cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">dft_shift = np.fft.fftshift(dft) <span class="comment">#将低频值转换到中间的位置</span></span><br><span class="line"><span class="comment"># 得到灰度图能够表示的形式</span></span><br><span class="line">magnitude_spectrum = <span class="number">20</span>*np.log(cv2.magnitude(dft_shift[:,:,<span class="number">0</span>],dft_shift[:,:,<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">plt.subplot((<span class="number">121</span>),plt.imshow(img,cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">"Input image"</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(magnitude_spectrum,cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.title(<span class="string">'magnitude_spectrum'</span>),plt.xticks([]),plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><h1 id="图像特征"><a href="#图像特征" class="headerlink" title="图像特征"></a>图像特征</h1><h2 id="Harris角点检测"><a href="#Harris角点检测" class="headerlink" title="Harris角点检测"></a>Harris角点检测</h2><p>边界：一个特征值大，一个特征值小，自相关函数值在某一方向上大，在其他方向上小。</p><p>平面：两个特征值都小，且近似相等，自相关函数数值在各个方向上都小。</p><p>角点：两个特征值都大，且近似相等，自相关函数在所有方向都增大。</p><h3 id="cv2-cornerHarris"><a href="#cv2-cornerHarris" class="headerlink" title="cv2.cornerHarris()"></a>cv2.cornerHarris()</h3><ul><li>img： 数据类型为 ﬂoat32 的入图像</li><li>blockSize： 角点检测中指定区域的大小</li><li>ksize： Sobel求导中使用的窗口大小</li><li>k： 取值参数为 [0,04,0.06]</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.cornerHarris(gray, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0.04</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'dst.shape:'</span>,dst.shape)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img[dst&gt;<span class="number">0.01</span>*dst.max()]=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>] <span class="comment">#大于最大值的0.01倍，就认为是一个角点</span></span><br><span class="line">cv2.imshow(<span class="string">'dst'</span>,img) </span><br><span class="line">cv2.waitKey(<span class="number">0</span>) </span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h2 id="Sift特征"><a href="#Sift特征" class="headerlink" title="Sift特征"></a>Sift特征</h2><p>Scale Invariant Feature Transform</p><h3 id="图像尺度空间"><a href="#图像尺度空间" class="headerlink" title="图像尺度空间"></a>图像尺度空间</h3><p>在一定的范围内，无论物体是大还是小，人眼都可以分辨出来，然而计算机要有相同的能力却很难，所以要让机器能够对物体在不同尺度下有一个统一的认知，就需要考虑图像在不同的尺度下都存在的特点。</p><p>尺度空间的获取通常使用高斯模糊来实现。</p><p><img data-src="/images/opencv/sift_3.png" alt="sift_3"></p><p><img data-src="/images/opencv/sift_2.png" alt="sift_2"></p><p>不同σ的高斯函数决定了对图像的平滑程度，越大的σ值对应的图像越模糊。</p><h3 id="多分辨率金字塔"><a href="#多分辨率金字塔" class="headerlink" title="多分辨率金字塔"></a>多分辨率金字塔</h3><p><img data-src="/images/opencv/sift_4.png" alt="sift_4"></p><h3 id="高斯差分金字塔（DOG）"><a href="#高斯差分金字塔（DOG）" class="headerlink" title="高斯差分金字塔（DOG）"></a>高斯差分金字塔（DOG）</h3><p><img data-src="/images/opencv/sift_5.png" alt="sift_5"></p><p><img data-src="/images/opencv/sift_6.png" alt="sift_6"></p><h3 id="DoG空间极值检测"><a href="#DoG空间极值检测" class="headerlink" title="DoG空间极值检测"></a>DoG空间极值检测</h3><p>为了寻找尺度空间的极值点，每个像素点要和其图像域（同一尺度空间）和尺度域（相邻的尺度空间）的所有相邻点进行比较，当其大于（或者小于）所有相邻点时，该点就是极值点。如下图所示，中间的检测点要和其所在图像的3×3邻域8个像素点，以及其相邻的上下两层的3×3领域18个像素点，共26个像素点进行比较。</p><p><img data-src="/images/opencv/sift_7.png" alt="sift_7"></p><h3 id="关键点的精确定位"><a href="#关键点的精确定位" class="headerlink" title="关键点的精确定位"></a>关键点的精确定位</h3><p>这些候选关键点是DOG空间的局部极值点，而且这些极值点均为离散的点，精确定位极值点的一种方法是，对尺度空间DoG函数进行曲线拟合，计算其极值点，从而实现关键点的精确定位。</p><p><img data-src="/images/opencv/sift_8.png" alt="sift_8"></p><p><img data-src="/images/opencv/sift_9.png" alt="sift_9"></p><h3 id="消除边界响应"><a href="#消除边界响应" class="headerlink" title="消除边界响应"></a>消除边界响应</h3><p><img data-src="/images/opencv/sift_10.png" alt="sift_10"></p><h3 id="特征点的主方向"><a href="#特征点的主方向" class="headerlink" title="特征点的主方向"></a>特征点的主方向</h3><p><img data-src="/images/opencv/sift_11.png" alt="sift_11"></p><p>每个特征点可以得到三个信息(x,y,σ,θ)，即位置、尺度和方向。具有多个方向的关键点可以被复制成多份，然后将方向值分别赋给复制后的特征点，一个特征点就产生了多个坐标、尺度相等，但是方向不同的特征点。</p><h3 id="生成特征描述"><a href="#生成特征描述" class="headerlink" title="生成特征描述"></a>生成特征描述</h3><p>在完成关键点的梯度计算后，使用直方图统计邻域内像素的梯度和方向。</p><p><img data-src="/images/opencv/sift_12.png" alt="sift_12"></p><p>为了保证特征矢量的旋转不变性，要以特征点为中心，在附近邻域内将坐标轴旋转θ角度，即将坐标轴旋转为特征点的主方向。</p><p><img data-src="/images/opencv/sift_14.png" alt="sift_14"></p><p>旋转之后的主方向为中心取8x8的窗口，求每个像素的梯度幅值和方向，箭头方向代表梯度方向，长度代表梯度幅值，然后利用高斯窗口对其进行加权运算，最后在每个4x4的小块上绘制8个方向的梯度直方图，计算每个梯度方向的累加值，即可形成一个种子点，即每个特征的由4个种子点组成，每个种子点有8个方向的向量信息。</p><p><img data-src="/images/opencv/sift_15.png" alt="sift_15"></p><p>论文中建议对每个关键点使用4x4共16个种子点来描述，这样一个关键点就会产生128维的SIFT特征向量。</p><p><img data-src="/images/opencv/sift_17.png" alt="sift_17"></p><h3 id="OpenCV-SIFT函数"><a href="#OpenCV-SIFT函数" class="headerlink" title="OpenCV SIFT函数"></a>OpenCV SIFT函数</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'test_1.jpg'</span>)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">sift = cv2.xfeatures2d.SIFT_create()</span><br><span class="line">kp = sift.detect(gray, <span class="literal">None</span>) <span class="comment"># kp：关键点</span></span><br><span class="line"></span><br><span class="line">img = cv2.drawKeypoints(gray, kp, img)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">'drawKeypoints'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><p>计算特征</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kp, des = sift.compute(gray, kp)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (np.array(kp).shape)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">des.shape</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">des[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure><h1 id="背景建模"><a href="#背景建模" class="headerlink" title="背景建模"></a>背景建模</h1><h2 id="帧差法"><a href="#帧差法" class="headerlink" title="帧差法"></a><strong>帧差法</strong></h2><p>由于场景中的目标在运动，目标的影像在不同图像帧中的位置不同。该类算法对时间上连续的两帧图像进行差分运算，不同帧对应的像素点相减，判断灰度差的绝对值，当绝对值超过一定阈值时，即可判断为运动目标，从而实现目标的检测功能。</p><p><img data-src="/images/opencv/bg_2.png" alt="bg_2"></p><p>帧差法非常简单，但是会引入噪音和空洞问题。</p><h2 id="混合高斯模型"><a href="#混合高斯模型" class="headerlink" title="混合高斯模型"></a>混合高斯模型</h2><p>（视频变化趋势应该是符合高斯分布的）</p><p>在进行前景检测前，先对背景进行训练，对图像中每个背景采用一个混合高斯模型进行模拟，每个背景的混合高斯的个数可以自适应。然后在测试阶段，对新来的像素进行GMM匹配，如果该像素值能够匹配其中一个高斯，则认为是背景，否则认为是前景。由于整个过程GMM模型在不断更新学习中，所以对动态背景有一定的鲁棒性。最后通过对一个有树枝摇摆的动态背景进行前景检测，取得了较好的效果。</p><p>在视频中对于像素点的变化情况应当是符合高斯分布。</p><p><img data-src="/images/opencv/bg_3.png" alt="bg_3"></p><p>背景的实际分布应当是多个高斯分布混合在一起，每个高斯模型也可以带有权重。</p><p><img data-src="/images/opencv/bg_4.png" alt="bg_4"></p><p><strong>混合高斯模型学习方法</strong></p><ul><li>1.首先初始化每个高斯模型矩阵参数。</li><li>2.取视频中T帧数据图像用来训练高斯混合模型。来了第一个像素之后用它来当做第一个高斯分布。</li><li>3.当后面来的像素值时，与前面已有的高斯的均值比较，如果该像素点的值与其模型均值差在3倍的方差内，则属于该分布，并对其进行参数更新。</li><li>4.如果下一次来的像素不满足当前高斯分布，用它来创建一个新的高斯分布。</li></ul><p><strong>混合高斯模型测试方法</strong></p><p>在测试阶段，对新来像素点的值与混合高斯模型中的每一个均值进行比较，如果其差值在2倍的方差之间的话，则认为是背景，否则认为是前景。将前景赋值为255，背景赋值为0。这样就形成了一副前景二值图。</p><p><img data-src="/images/opencv/bg_5.png" alt="bg_5"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment">#经典的测试视频</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">'test.avi'</span>)</span><br><span class="line"><span class="comment">#形态学操作需要使用</span></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment">#创建混合高斯模型用于背景建模</span></span><br><span class="line">fgbg = cv2.createBackgroundSubtractorMOG2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    fgmask = fgbg.apply(frame)</span><br><span class="line">    <span class="comment">#形态学开运算去噪点</span></span><br><span class="line">    fgmask = cv2.morphologyEx(fgmask, cv2.MORPH_OPEN, kernel)</span><br><span class="line">    <span class="comment">#寻找视频中的轮廓</span></span><br><span class="line">    im, contours, hierarchy = cv2.findContours(fgmask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> contours:</span><br><span class="line">        <span class="comment">#计算各轮廓的周长</span></span><br><span class="line">        perimeter = cv2.arcLength(c,<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> perimeter &gt; <span class="number">188</span>:</span><br><span class="line">            <span class="comment">#找到一个直矩形（不会旋转）</span></span><br><span class="line">            x,y,w,h = cv2.boundingRect(c)</span><br><span class="line">            <span class="comment">#画出这个矩形</span></span><br><span class="line">            cv2.rectangle(frame,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)    </span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>,frame)</span><br><span class="line">    cv2.imshow(<span class="string">'fgmask'</span>, fgmask)</span><br><span class="line">    k = cv2.waitKey(<span class="number">150</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h1 id="光流估计"><a href="#光流估计" class="headerlink" title="光流估计"></a>光流估计</h1><p>光流是空间运动物体在观测成像平面上的<strong>像素运动的“瞬时速度”，</strong>根据各个像素点的速度矢量特征，可以<strong>对图像进行动态分析，例如目标跟踪。</strong></p><ul><li>亮度恒定：同一点随着时间的变化，其亮度不会发生改变。</li><li>小运动：随着时间的变化不会引起位置的剧烈变化，只有小运动情况下才能用前后帧之间单位位置变化引起的灰度变化去近似灰度对位置的偏导数。</li><li>空间一致：一个场景上邻近的点投影到图像上也是邻近点，且邻近点速度一致。因为光流法基本方程约束只有一个，而要求x，y方向的速度，有两个未知变量。所以需要连立n多个方程求解。</li></ul><p><img data-src="/images/opencv/lk_2.png" alt="lk_2"></p><p><img data-src="/images/opencv/lk_1.png" alt="lk_1"></p><h2 id="Lucas-Kanade-算法"><a href="#Lucas-Kanade-算法" class="headerlink" title="Lucas-Kanade 算法"></a>Lucas-Kanade 算法</h2><p><img data-src="/images/opencv/lk_3.png" alt="lk_3"></p><p>如何求解方程组呢？看起来一个像素点根本不够，在物体移动过程中还有哪些特性呢？</p><p><img data-src="/images/opencv/lk_4.png" alt="lk_4"></p><p><strong>cv2.calcOpticalFlowPyrLK():</strong></p><p>参数：</p><ul><li>prevImage 前一帧图像</li><li>nextImage 当前帧图像</li><li>prevPts 待跟踪的特征点向量</li><li>winSize 搜索窗口的大小</li><li>maxLevel 最大的金字塔层数</li></ul><p>返回：</p><ul><li>nextPts 输出跟踪特征点向量</li><li>status 特征点是否找到，找到的状态为1，未找到的状态为0</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="string">'test.avi'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 角点检测所需参数</span></span><br><span class="line">feature_params = dict( maxCorners = <span class="number">100</span>,</span><br><span class="line">                       qualityLevel = <span class="number">0.3</span>,</span><br><span class="line">                       minDistance = <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># lucas kanade参数</span></span><br><span class="line">lk_params = dict( winSize  = (<span class="number">15</span>,<span class="number">15</span>),</span><br><span class="line">                  maxLevel = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机颜色条</span></span><br><span class="line">color = np.random.randint(<span class="number">0</span>,<span class="number">255</span>,(<span class="number">100</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿到第一帧图像</span></span><br><span class="line">ret, old_frame = cap.read()</span><br><span class="line">old_gray = cv2.cvtColor(old_frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 返回所有检测特征点，需要输入图像，角点最大数量（效率），品质因子（特征值越大的越好，来筛选）</span></span><br><span class="line"><span class="comment"># 距离相当于这区间有比这个角点强的，就不要这个弱的了</span></span><br><span class="line">p0 = cv2.goodFeaturesToTrack(old_gray, mask = <span class="literal">None</span>, **feature_params)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个mask</span></span><br><span class="line">mask = np.zeros_like(old_frame)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    ret,frame = cap.read()</span><br><span class="line">    frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 需要传入前一帧和当前图像以及前一帧检测到的角点</span></span><br><span class="line">    p1, st, err = cv2.calcOpticalFlowPyrLK(old_gray, frame_gray, p0, <span class="literal">None</span>, **lk_params)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># st=1表示</span></span><br><span class="line">    good_new = p1[st==<span class="number">1</span>]</span><br><span class="line">    good_old = p0[st==<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制轨迹</span></span><br><span class="line">    <span class="keyword">for</span> i,(new,old) <span class="keyword">in</span> enumerate(zip(good_new,good_old)):</span><br><span class="line">        a,b = new.ravel()</span><br><span class="line">        c,d = old.ravel()</span><br><span class="line">        mask = cv2.line(mask, (a,b),(c,d), color[i].tolist(), <span class="number">2</span>)</span><br><span class="line">        frame = cv2.circle(frame,(a,b),<span class="number">5</span>,color[i].tolist(),<span class="number">-1</span>)</span><br><span class="line">    img = cv2.add(frame,mask)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'frame'</span>,img)</span><br><span class="line">    k = cv2.waitKey(<span class="number">150</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新</span></span><br><span class="line">    old_gray = frame_gray.copy()</span><br><span class="line">    p0 = good_new.reshape(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line">cap.release()</span><br></pre></td></tr></tbody></table></figure><h1 id="DNN模块"><a href="#DNN模块" class="headerlink" title="DNN模块"></a>DNN模块</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">blob_from_images.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入工具包</span></span><br><span class="line"><span class="keyword">import</span> utils_paths</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签文件处理</span></span><br><span class="line">rows = open(<span class="string">"synset_words.txt"</span>).read().strip().split(<span class="string">"\n"</span>)</span><br><span class="line">classes = [r[r.find(<span class="string">" "</span>) + <span class="number">1</span>:].split(<span class="string">","</span>)[<span class="number">0</span>] <span class="keyword">for</span> r <span class="keyword">in</span> rows]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Caffe所需配置文件</span></span><br><span class="line">net = cv2.dnn.readNetFromCaffe(<span class="string">"bvlc_googlenet.prototxt"</span>,</span><br><span class="line"><span class="string">"bvlc_googlenet.caffemodel"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像路径</span></span><br><span class="line">imagePaths = sorted(list(utils_paths.list_images(<span class="string">"images/"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像数据预处理</span></span><br><span class="line">image = cv2.imread(imagePaths[<span class="number">0</span>])</span><br><span class="line">resized = cv2.resize(image, (<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"><span class="comment"># image scalefactor size mean swapRB </span></span><br><span class="line">blob = cv2.dnn.blobFromImage(resized, <span class="number">1</span>, (<span class="number">224</span>, <span class="number">224</span>), (<span class="number">104</span>, <span class="number">117</span>, <span class="number">123</span>))</span><br><span class="line">print(<span class="string">"First Blob: {}"</span>.format(blob.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到预测结果</span></span><br><span class="line">net.setInput(blob)</span><br><span class="line">preds = net.forward()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序，取分类可能性最大的</span></span><br><span class="line">idx = np.argsort(preds[<span class="number">0</span>])[::<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">text = <span class="string">"Label: {}, {:.2f}%"</span>.format(classes[idx],</span><br><span class="line">preds[<span class="number">0</span>][idx] * <span class="number">100</span>)</span><br><span class="line">cv2.putText(image, text, (<span class="number">5</span>, <span class="number">25</span>),  cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line"><span class="number">0.7</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示</span></span><br><span class="line">cv2.imshow(<span class="string">"Image"</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Batch数据制作</span></span><br><span class="line">images = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一样，数据是一个batch</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> imagePaths[<span class="number">1</span>:]:</span><br><span class="line">image = cv2.imread(p)</span><br><span class="line">image = cv2.resize(image, (<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">images.append(image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># blobFromImages函数，注意有s</span></span><br><span class="line">blob = cv2.dnn.blobFromImages(images, <span class="number">1</span>, (<span class="number">224</span>, <span class="number">224</span>), (<span class="number">104</span>, <span class="number">117</span>, <span class="number">123</span>))</span><br><span class="line">print(<span class="string">"Second Blob: {}"</span>.format(blob.shape))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取预测结果</span></span><br><span class="line">net.setInput(blob)</span><br><span class="line">preds = net.forward()</span><br><span class="line"><span class="keyword">for</span> (i, p) <span class="keyword">in</span> enumerate(imagePaths[<span class="number">1</span>:]):</span><br><span class="line">image = cv2.imread(p)</span><br><span class="line">idx = np.argsort(preds[i])[::<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">text = <span class="string">"Label: {}, {:.2f}%"</span>.format(classes[idx],</span><br><span class="line">preds[i][idx] * <span class="number">100</span>)</span><br><span class="line">cv2.putText(image, text, (<span class="number">5</span>, <span class="number">25</span>),  cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line"><span class="number">0.7</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">cv2.imshow(<span class="string">"Image"</span>, image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><h1 id="图像基本操作"><a href="#图像基本操作" class="headerlink" title="图像基本操作"></a>图像基本操作</h1><h1 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h1><h2 id="简单阈值"><a href="#简单阈值" class="headerlink" title="简单阈值"></a>简单阈值</h2><h2 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h2><h2 id="Otsu‘s-二值化"><a href="#Otsu‘s-二值化" class="headerlink" title="Otsu‘s 二值化"></a>Otsu‘s 二值化</h2><h1 id="平滑处理"><a href="#平滑处理" class="headerlink" title="平滑处理"></a>平滑处理</h1><h2 id="平均"><a href="#平均" class="headerlink" title="平均"></a>平均</h2><h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><h2 id="中值模糊"><a href="#中值模糊" class="headerlink" title="中值模糊"></a>中值模糊</h2><h2 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h2><h1 id="形态学处理"><a href="#形态学处理" class="headerlink" title="形态学处理"></a>形态学处理</h1><h2 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h2><h2 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h2><h2 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h2><h2 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h2><h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><h2 id="礼帽"><a href="#礼帽" class="headerlink" title="礼帽"></a>礼帽</h2><h2 id="黑帽"><a href="#黑帽" class="headerlink" title="黑帽"></a>黑帽</h2><h1 id="梯度处理"><a href="#梯度处理" class="headerlink" title="梯度处理"></a>梯度处理</h1><p>边缘检测就是检测出图像上的边缘信息</p><p><strong>1.导数</strong>，连续函数上某点斜率，导数越大表示变化率越大，变化率越大的地方就越是“边缘”，但是在计算机中不常用，因为在斜率90度的地方，导数无穷大，计算机很难表示这些无穷大的东西。</p><p><strong>2.微分</strong>，连续函数上x变化了dx，导致y变化了dy，dy值越大表示变化的越大，那么计算整幅图像的微分，dy的大小就是边缘的强弱了。<br> 微分与导数的关系：dy = f ‘(x) dx</p><h2 id="Sobel算子和Scharr算子"><a href="#Sobel算子和Scharr算子" class="headerlink" title="Sobel算子和Scharr算子"></a>Sobel算子和Scharr算子</h2><p>基于一阶微分</p><p>中心点 f(x, y) 是重点考虑的，它的权重应该多一些，所以改进成下面这样的</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="number">-2</span>, <span class="number">0</span>, <span class="number">2</span></span><br><span class="line"><span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>这就是 Sobel 边缘检测算子，偏 x 方向的。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span></span><br><span class="line"> <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h2 id="laplacian算子"><a href="#laplacian算子" class="headerlink" title="laplacian算子"></a>laplacian算子</h2><p>拉普拉斯是用二阶差分计算边缘的</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>,  <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="number">1</span>, <span class="number">-4</span>, <span class="number">1</span></span><br><span class="line"><span class="number">0</span>,  <span class="number">1</span>, <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><p>考虑两个斜对角的情况</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,  <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="number">1</span>, <span class="number">-8</span>, <span class="number">1</span></span><br><span class="line"><span class="number">1</span>,  <span class="number">1</span>, <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h2 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h2><p>Canny边缘检测的步骤：</p><p>1.<strong>消除噪声</strong>：一般情况下，使用<strong>高斯平滑滤波器卷积降噪</strong>。</p><p>2.<strong>计算梯度幅值和方向</strong>。此时，按照<strong>Sobel滤波器的步骤</strong>。<br>怎么表征这种灰度值的变化呢？这里想到的就是导数微分，导数就是表征变化率的，但是数字图像都是<strong>离散</strong>的，也就是<strong>导数肯定会用差分</strong>来替代。<strong>用相邻像素的差分来计算梯度的大小和方向。</strong></p><p>然后我们可以计算图像中每个像素的梯度大小为$G=\sqrt{G_x^2+G_y^2}$，梯度方向为$\theta=arctan(G_x/G_y)$</p><p>3.<strong>非极大值抑制</strong>。这一步排除非边缘像素，仅仅保留了一些细线条(候选边缘)。</p><p>对规定方向以外的梯度方向进行最大抑制。</p><p>理论上图像梯度幅值的元素值越大，说明图像中该点的梯度值越大，但这不能说明该点就是边缘。非极大值抑制是进行边缘检测的重要步骤，<strong>寻找像素点的局部最大值</strong>，沿着梯度方向，比较它前面和后面的梯度值，<strong>若梯度值局部最大则有可能为边缘像素，进行保留，否则就进行抑制(置为0)。</strong></p><p><img data-src="../images/opencv/NMS.png" alt="NMS"></p><p>4.<strong>滞后阈值</strong>：Canny使用了滞后阈值，滞后阈值需要两个阈值(高阈值和低阈值)：<strong>用双阈值算法检测和连接边缘。</strong>（保证了低错误率：与Sobel之间的区别）</p><p>a.如果某一像素位置的幅值超过高阈值，该像素被保留为边缘像素。</p><p>b.如果某一像素位置的幅值小于低阈值，该像素被排除。</p><p>c.<strong>如果某一像素位置的幅值在两个阈值之间，该像素仅仅在连接到一个高于阈值的像素时被保留。</strong></p><p>Canny推荐的高低阈值比在2:1到3:1之间。</p><p><img data-src="../images/opencv/backNMS.png" alt="滞后阈值"></p><h2 id="三个算子区别"><a href="#三个算子区别" class="headerlink" title="三个算子区别"></a>三个算子区别</h2><p>sobel 产生的边缘有强弱，抗噪性好<br>laplace 对边缘敏感，可能有些是噪声的边缘，也被算进来了<br>canny 产生的边缘很细，可能就一个像素那么细，没有强弱之分。</p><h1 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h1><h1 id="Hough变换"><a href="#Hough变换" class="headerlink" title="Hough变换"></a>Hough变换</h1><h2 id="直线变换"><a href="#直线变换" class="headerlink" title="直线变换"></a>直线变换</h2><ul><li>基本思想</li></ul><p>主要原理是对于边缘的每一个像素点（x0,y0），把可能经过它的所有直线，映射到仿射参数空间（即hough space），然后<strong>投票</strong>，每次有直线方程满足($\theta$，$r_\theta$)，此处</p><p><img data-src="/images/opencv/houghtrans.png" alt="houghtrans"></p><ul><li>详细推导</li></ul><p><a href="https://zhuanlan.zhihu.com/p/47649796" target="_blank" rel="noopener">参考链接</a></p><p><a href="https://www.cnblogs.com/cheermyang/p/5348820.html" target="_blank" rel="noopener">参考链接</a></p><p>它追踪图像中每个点对应曲线间的交点. 如果交于一点的曲线的数量超过了阈值， 那么可以认为这个交点所代表的参数对($\theta$，$r_\theta$)在原图像中为一条直线。</p><p>对图像做霍夫变换，也就是分别代入霍夫变换公式</p><blockquote><p>$r = xcos\theta + ysin\theta$</p></blockquote><p>在仿射参数空间的结果是这个样子的：</p><p><img data-src="/images/opencv/hough_line.png" alt="hough_line"></p><p>原图上红色紫色绿色蓝色的点对应的变换曲线相交在同一个点上，<strong>这个点对应的原点距和角方向就是原图中的四个点所在的直线的方向</strong>：</p><p><img data-src="/images/opencv/line.png" alt="line"></p><p>这意味着一般来说, 一条直线能够通过在平面($\theta$，$r_\theta$)上寻找交于一点的曲线数量来检测。 越多曲线交于一点也就意味着这个交点表示的直线由更多的点组成. 一般来说我们可以通过设置直线上点的 阈值 来定义多少条曲线交于一点我们才认为 检测 到了一条直线。</p><ul><li>代码参考</li></ul><p><a href="https://blog.csdn.net/jia20003/article/details/7724530" target="_blank" rel="noopener">源代码参考链接</a></p><ul><li>OpenCV接口</li></ul><h2 id="圆形变换"><a href="#圆形变换" class="headerlink" title="圆形变换"></a>圆形变换</h2><p><a href="https://kevinnnm.github.io/2019/07/26/Day12/#%E5%9F%BA%E4%BA%8E%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2%E7%9A%84%E5%9C%86%E5%BD%A2%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">参考链接</a></p><ul><li>基本思想</li></ul><p>跟霍夫直线检测一样，同样的原理，可以用于检测圆，只是对于圆的方程。</p><blockquote><p>$(x –a ) ^2 + (y-b) ^ 2 = r^2$</p></blockquote><p>其中(a,b)代表圆心，r是圆的半径<br>依旧是把图像空间转换成参数空间，这里是将X-Y平面转化成a-b-r参数空间，则在图像空间中的一个过(x,y)点的圆，对应参数空间中高度变化的三维锥面。</p><p><img data-src="/images/opencv/houghcircle_1.png" alt="houghcircle"></p><p>同理，过图像空间的任意一点的圆都对应于参数空间的一个三维锥面，因此，过图像空间上同一圆的点，对应的参数空间中的三维锥面，在r平面必然相交于一点(a,b,r)，这样通过这一点就可以得到一个圆的参数。</p><p><img data-src="/images/opencv/houghcircle_1.png" alt="houghcircle_1"></p><ul><li>详细推导</li></ul><p>在极坐标系下，假设圆心为$(𝑥0,𝑦0)$,圆上的点可以表示为:</p><blockquote><p>$𝑥=𝑥0+𝑟𝑐𝑜𝑠𝜃,𝑦=𝑦0+𝑟𝑠𝑖𝑛𝜃$</p></blockquote><p>对于一个圆，假如中心像素点$(𝑥0,𝑦0)$，半径r已知，那么旋转360°，圆上的所有点就可以求得。同样，<strong>假如圆上的所有点，半径r已知，旋转360°，则会得到一个累加的极值点，那么这个点就是圆心了。</strong></p><ul><li>21HT的具体步骤:<br>第一阶段：检测圆心</li></ul><p>1.1、对输入图像边缘检测（Canny）；</p><p>1.2、计算图形的梯度，并确定圆周线，其中圆周的梯度就是它的法线；</p><p>1.3、在二维霍夫空间内，绘出所有图形的梯度直线，某坐标点上累加和的值越大，说明在该点上直线相交的次数越多，也就是越有可能是圆心；</p><p>1.4、在霍夫空间的4邻域内进行非最大值抑制；</p><p>1.5、设定一个阈值，<strong>霍夫空间内累加和大于该阈值的点</strong>就对应于圆心。</p><p>第二阶段：检测圆半径</p><p>2.1、计算某一个圆心到所有圆周线的距离，这些距离中就有该圆心所对应的圆的半径的值，这些半径值当然是相等的，并且这些圆半径的数量要远远大于其他距离值相等的数量；</p><p>2.2、设定两个阈值，定义为最大半径和最小半径，保留距离在这两个半径之间的值，这意味着我们检测的圆不能太大，也不能太小；</p><p>2.3、对保留下来的距离进行排序；</p><p>2.4、找到距离相同的那些值，并计算相同值的数量；</p><p>2.5、设定一个阈值，只有相同值的数量大于该阈值，才认为该值是该圆心对应的圆半径；</p><p>2.6、对每一个圆心，完成上面的2.1～2.5步骤，得到所有的圆半径。</p><ul><li>OpenCV接口</li></ul><blockquote><p>void HoughCircles(InputArray image,OutputArray circles, int method, double dp, double minDist, double param1=100, double param2=100, int minRadius=0,int maxRadius=0 )</p></blockquote><p>image为输入图像，要求是灰度图像<br>circles为输出圆向量，每个向量包括三个浮点型的元素——圆心横坐标，圆心纵坐标和圆半径<br>method为使用霍夫变换圆检测的算法，Opencv2.4.9只实现了2-1霍夫变换，它的参数是CV_HOUGH_GRADIENT<br>dp为第一阶段所使用的霍夫空间的分辨率，dp=1时表示霍夫空间与输入图像空间的大小一致，dp=2时霍夫空间是输入图像空间的一半，以此类推<br>minDist为圆心之间的最小距离，如果检测到的两个圆心之间距离小于该值，则认为它们是同一个圆心<br>param1为边缘检测时使用Canny算子的高阈值<br>param2为步骤1.5和步骤2.5中所共有的阈值<br>minRadius和maxRadius为所检测到的圆半径的最小值和最大值</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OpenCV的安装&quot;&gt;&lt;a href=&quot;#OpenCV的安装&quot; class=&quot;headerlink&quot; title=&quot;OpenCV的安装&quot;&gt;&lt;/a&gt;OpenCV的安装&lt;/h1&gt;&lt;p&gt;国内一些pip的镜像源：&lt;/p&gt;
&lt;p&gt;阿里云 &lt;a href=&quot;https://mirrors.aliyun.com/pypi/simple/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mirrors.aliyun.com/pypi/simple/&lt;/a&gt;&lt;br&gt;中国科技大学 &lt;a href=&quot;https://pypi.mirrors.ustc.edu.cn/simple/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pypi.mirrors.ustc.edu.cn/simple/&lt;/a&gt;&lt;br&gt;豆瓣(douban) &lt;a href=&quot;http://pypi.douban.com/simple/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pypi.douban.com/simple/&lt;/a&gt;&lt;br&gt;清华大学 &lt;a href=&quot;https://pypi.tuna.tsinghua.edu.cn/simple/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pypi.tuna.tsinghua.edu.cn/simple/&lt;/a&gt;&lt;br&gt;中国科学技术大学 &lt;a href=&quot;http://pypi.mirrors.ustc.edu.cn/simple/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://pypi.mirrors.ustc.edu.cn/simple/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(base)$ conda create -n py365 python=&lt;span class=&quot;number&quot;&gt;3.6&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.5&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;# anaconda中创建python版本为3.7.3的虚拟环境&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(base)$ conda activate py365                 &lt;span class=&quot;comment&quot;&gt;# 激活该环境&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip install opencv-python==&lt;span class=&quot;number&quot;&gt;3.4&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.15&lt;/span&gt; -i http://pypi.douban.com/simple --trusted-host pypi.douban.com                              &lt;span class=&quot;comment&quot;&gt;# 安装opencv-python 3.4.1.15，同时还会加载相应的依赖库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;内容完善中……&lt;/p&gt;
    
    </summary>
    
    
      <category term="CV" scheme="https://unknown.yuzhouwan.com/categories/CV/"/>
    
    
      <category term="Python" scheme="https://unknown.yuzhouwan.com/tags/Python/"/>
    
      <category term="OpenCV" scheme="https://unknown.yuzhouwan.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>快捷键汇总</title>
    <link href="https://unknown.yuzhouwan.com/posts/26313/"/>
    <id>https://unknown.yuzhouwan.com/posts/26313/</id>
    <published>2019-01-30T12:00:00.000Z</published>
    <updated>2020-03-01T13:10:54.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MacBook"><a href="#MacBook" class="headerlink" title="MacBook"></a>MacBook</h1><h1 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h1><h1 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MacBook&quot;&gt;&lt;a href=&quot;#MacBook&quot; class=&quot;headerlink&quot; title=&quot;MacBook&quot;&gt;&lt;/a&gt;MacBook&lt;/h1&gt;&lt;h1 id=&quot;PyCharm&quot;&gt;&lt;a href=&quot;#PyCharm&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Tools" scheme="https://unknown.yuzhouwan.com/categories/Tools/"/>
    
    
      <category term="Shortcut Key" scheme="https://unknown.yuzhouwan.com/tags/Shortcut-Key/"/>
    
  </entry>
  
  <entry>
    <title>CNN</title>
    <link href="https://unknown.yuzhouwan.com/posts/16452/"/>
    <id>https://unknown.yuzhouwan.com/posts/16452/</id>
    <published>2018-03-18T20:50:00.000Z</published>
    <updated>2020-04-25T15:05:15.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Convolutional-Neural-Networks"><a href="#Convolutional-Neural-Networks" class="headerlink" title="Convolutional Neural Networks"></a>Convolutional Neural Networks</h1><h2 id="Edge-Detection"><a href="#Edge-Detection" class="headerlink" title="Edge Detection"></a>Edge Detection</h2><p>卷积运算是卷积神经网络最基本的组成成分，使用边缘检测作为入门样例。下面介绍卷积计算是如何实现的。</p><p>使用一个3✖️3的<strong>过滤器(核)</strong>与原始矩阵进行元素相乘，再相加，最后和的结果为<strong>卷积运算</strong>后的第一个元素值，然后依次计算，下面例子中，做一次卷积运算后结果为一个4✖️4的矩阵。</p><p>这种卷积运算可以理解成为，<strong>垂直边缘检测器。</strong></p><p><img data-src="/images/picturesof-4/CNN_1.png" alt="屏幕快照 2018-02-09 下午12.25.09"></p><p>在不同的编程环境中可以使用不同的函数来实现卷积运算。</p><p><img data-src="/images/picturesof-4/CNN_2.png" alt="屏幕快照 2018-02-09 下午12.38.47"></p><p>那么为什么这个可以用作垂直检测呢？来看下面的例子。</p><a id="more"></a><p>这是一个简单的6✖️6的图像，图像左边一半是10，右边一半是0，如果你把它看成一个图像，那么是左白右灰的，10代表比较亮的颜色，0代表比较黑的颜色。图片里，有一个特别明显的垂直边缘在图像中间，这条直线是从黑到白的过度线。<strong>所以当你使用一个3✖️3的过滤器进行卷积运算的时候，这个过滤器可视化成下面这个样子</strong>，在左边有明亮的像素，然后有一个过滤段0在中间，右边是黑色的。使用过滤器进行卷积元算，得到的是右边的矩阵，可视化样子如下，在中间有段亮一点的区域，对应检查到这个6✖️6的图像中间的垂直边缘，这里的维数似乎有点不正确，检测到的边缘太粗了，因为这个例子中的图片太小了，如果你用一个1000✖️1000的图像，而不是6✖️6的图像，你会发现，它可以很好的检测出图像中的垂直边缘。在这个例子中，在输出图像中间区域的亮出，表示在图像中间，有一个特别明显的垂直边缘。</p><p>从垂直边缘检测中可以得到的启发是，因为我们使用的是3✖️3的矩阵，所以垂直边缘是一个3✖️3的区域，左边是明亮的像素，中间的的并不需要考虑，右边是深色像素。在这个6✖️6图像中，明亮的像素在左边，深色的像素在右边，这样的话就会被视为一个垂直边缘。卷积运算提供了一个方便的方法，来发现图像中的垂直边缘。</p><p><img data-src="/images/picturesof-4/CNN_3.png" alt="屏幕快照 2018-02-09 下午1.05.04"></p><h2 id="More-Edge-Detection"><a href="#More-Edge-Detection" class="headerlink" title="More Edge Detection"></a>More Edge Detection</h2><p>使用相同的过滤器过滤两个颜色刚好相反的图片，可以看到，第一个是30，第二个是-30，<strong>其中正数(30)代表第一幅图是由亮向暗过度，负数(-30)代表第二张图片是由暗向亮过度。</strong></p><p><img data-src="/images/picturesof-4/CNN_4.png" alt="屏幕快照 2018-03-01 上午9.41.33"></p><p>有垂直过滤器，就会有水平过滤器。下面举一个更为复杂的例子，在下图的这个图片矩阵中，我们使用水平过滤器进行边缘检测，得到的卷积结果如右下方所示，<strong>用绿色方框圈出的”+30”，代表原始图片中用绿色圈出的3✖️3矩阵的卷积结果，可以看到，这块矩阵的水平边缘确实是由亮到暗过度的，所以卷积结果为正。</strong></p><p><img data-src="/images/picturesof-4/CNN_5.png" alt="屏幕快照 2018-03-01 上午9.56.15"></p><p>事实上，对于这个3✖️3的滤波器来说，我们只使用了其中一种数字组合，但在历史上的计算机视觉的文献中，曾经公平的争论过，怎样的数字组合才是最好的，所以你还可以使用如下图所示的过滤器，<strong>如Sobel过滤器</strong>，它的优点在于，增加了中间一行元素的权重，也就是处在图像中央的像素点，这使得结果的健壮性更高一些。<strong>Scharr过滤器。</strong></p><p>实际上是，当你在做复杂图像的边缘检测时，并不一定要使用刚刚我们提到的9个数字，但是你可以从中学习，把<strong>这矩阵中的9个数字当成9个参数，并且在之后可以使用反向传播算法，学习这9个参数。</strong>得到的结果与原始图片进行卷积，将会得到一个出色的边缘检测结果。</p><p>相比这种单纯的垂直边缘与水平边缘检测，它可以检测出45度、70度、73度，甚至是任何角度的边缘。</p><p><img data-src="/images/picturesof-4/CNN_6.png" alt="屏幕快照 2018-03-01 上午10.19.16"></p><h2 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h2><p>为了构建深度神经网络，你需要学会使用的一个基本的卷积操作就是Padding。Padding出现的原因是，当你在做卷积操作的时候，像素矩阵中，中间的矩阵是被卷积计算多次的，也就是多次使用到了这个矩阵的信息，而边缘的像素矩阵，则会被使用较少次，比如说对角的矩阵，则只是被卷积了一次。这样则会导致会忽略边缘矩阵的信息。<strong>采取的措施是使用“填充(Padding)”方法，进行像素填充。使得边缘像素矩阵信息可以被卷积多次。</strong>填充之后的矩阵再进行卷积操作后，就会得到一个和原始矩阵一样大的矩阵，而不是缩小。</p><p>习惯上，你可以使用”0”去填充。</p><p><img data-src="/images/picturesof-4/CNN_7.png" alt="屏幕快照 2018-03-01 上午11.25.36"></p><p>至于选择填充多少像素，通常有两个选择，<strong>分别叫做Valid卷积和Same卷积。</strong>Valid卷积：意味着不填充，所以得到的输出矩阵会比原始矩阵小。要想和原始矩阵得到的一样大，则使用Same卷积，你可以使用下面的计算公式来计算需要Pad多少个像素。<strong>n是原始图片的维数，f是过滤器的维数，最后得到的输出矩阵大小为n-f+1维。（f通常是奇数，如果为偶数，则会导致左右填充不均匀的情况）</strong></p><p><img data-src="/images/picturesof-4/CNN_8.png" alt="屏幕快照 2018-03-01 上午11.59.32"></p><h2 id="Strided-Convolutions-卷积步长"><a href="#Strided-Convolutions-卷积步长" class="headerlink" title="Strided Convolutions 卷积步长"></a>Strided Convolutions 卷积步长</h2><p>卷积中的步幅是另一个构建卷积神经网络的基本操作。每次卷积移动步长个单位，而不是我们之前提到的1个步长。这时候，计算输出函数的维数公式变成了如下情况。</p><p>如果求得的商不是一个整数怎么办？这里采用向下取整。</p><p><img data-src="/images/picturesof-4/CNN_9.png" alt="屏幕快照 2018-03-01 下午1.59.37"></p><h2 id="Convolutions-Over-Volume"><a href="#Convolutions-Over-Volume" class="headerlink" title="Convolutions Over Volume"></a>Convolutions Over Volume</h2><p>之前讨论的卷积操作是在二维图像上进行的，现在讨论如何在三维立体(RGB)上做卷积操作。注意，图像的通道数和过滤器的通道数需一致。</p><p>和一维图形中类似，使用三层过滤器依次与相对应层级中的元素相乘，每层得到9个数字，3层就是27个数字，将这27个数字相加后，就可以得到输出矩阵中的每个元素值。</p><p><img data-src="/images/picturesof-4/CNN_10.png" alt="屏幕快照 2018-03-01 下午2.30.40"></p><h2 id="One-Layer-of-a-Convolutional-Network-单层卷积网络"><a href="#One-Layer-of-a-Convolutional-Network-单层卷积网络" class="headerlink" title="One Layer of a Convolutional Network 单层卷积网络"></a>One Layer of a Convolutional Network 单层卷积网络</h2><p>下图演示了利用两个过滤器将6✖️6✖️3的矩阵转化为4✖️4✖️2的矩阵的过程，这个4✖️4✖️2的矩阵就是卷积中的一层结果。利用n个过滤器来提取特征，如垂直边缘，水平边缘或者其他特征。</p><p><img data-src="/images/picturesof-4/CNN_11.png" alt="屏幕快照 2018-03-01 下午3.38.38"></p><p>对于一些标识及每层的数量，总结如下：</p><p><img data-src="/images/picturesof-4/CNN_12.png" alt="屏幕快照 2018-03-01 下午4.16.42"></p><h2 id="Simple-Convolutional-Network-Example"><a href="#Simple-Convolutional-Network-Example" class="headerlink" title="Simple Convolutional Network Example"></a>Simple Convolutional Network Example</h2><p>下图是模拟一个卷积神经网络的计算过程。最后我们得到一个7✖️7✖️40的矩阵，也就是1960个元素值，将这1960个元素展开，使用逻辑回归或者SoftMax，进行图片的分类判断。</p><p>可以看到，高度和宽度会在某一时间段内保持一致，然后随着网络深度的加深而逐渐减少，而信道数量在增加。</p><p><img data-src="/images/picturesof-4/CNN_13.png" alt="屏幕快照 2018-03-01 下午4.50.51"></p><p>典型的神经网络通常由三层组成，第一个是卷积层(convolution Layer)，第二个是池化层(Pooling Layer)，最后一个是全连接层(Fully Connect Layer)。虽然仅用卷积层也有可能构建出很好的神经网络，但大部分神经网络架构师依然会添加池化层和全连接层。</p><p><img data-src="/images/picturesof-4/CNN_14.png" alt="屏幕快照 2018-03-01 下午5.06.05"></p><h2 id="Pooling-Layers"><a href="#Pooling-Layers" class="headerlink" title="Pooling Layers"></a>Pooling Layers</h2><p>除了卷积层，卷积网络也经常使用池化层，来缩减模型的大小，提高计算速度，同时提高所提取特征的健壮性。</p><p>所谓<strong>最大池化层</strong>，即将原始矩阵分成四个区域，输出的每个元素都是其对应颜色区域中的最大元素值。</p><p>最大化操作的功能就是只要在任何一个象限内提取到某个特征，他都会保留在最大池化的输出里。最大化运算的实际作用就是，如果在过滤器中提取到某个特征，那么保留其最大值。必须承认，人们使用最大池化的主要原因是，此法在很多实验中，效果都很好。<strong>其中有一个有意思的特点就是，它有一组超级参数，但是并没有参数需要学习，一旦确定了f和s，它就是一个固定运算。</strong></p><p><img data-src="/images/picturesof-4/CNN_15.png" alt="屏幕快照 2018-03-01 下午6.00.49"></p><p>下图是最大池化的演示。</p><p><img data-src="/images/picturesof-4/CNN_16.png" alt="屏幕快照 2018-03-01 下午6.02.50"></p><p>另外还有一种类型的池化，—<strong>平均池化</strong>，它不太常用。这种运算顾名思义，选取的不是每个过滤器的最大值，而是平均值。当建立一个深度很深的神经网络时，你可以利用平均池化来分解规模为7✖️7✖️1000的网络的表示层。但是在神经网络中，最大池化比平均池化用的更多。</p><p><img data-src="/images/picturesof-4/CNN_17.png" alt="屏幕快照 2018-03-01 下午6.18.08"></p><p>总结一下，池化的超级参数包括过滤器大小f和步长s。常用的参数值为f=2，s=2，或者f=3，s=3。你也可以根据自己的意愿来决定是否使用padding，<strong>但是在最大池化操作中，很少使用padding。</strong></p><p><strong>最大池化只是计算神经网络某一层的静态属性，它的超参是不需要学习的。</strong></p><p><img data-src="/images/picturesof-4/CNN_18.png" alt="屏幕快照 2018-03-01 下午6.25.52"></p><h2 id="CNN-Example"><a href="#CNN-Example" class="headerlink" title="CNN Example"></a>CNN Example</h2><p> 我们将卷积层和池化层有时会合并起来看作神经网络中的某一层，因为池化层是不需要权重的，它只有超参数。通过卷积和池化，我们得到一个5✖️5✖️16(=400)的矩阵，现在将POOL2平整化为一个大小为400的一维向量。然后利用这400个单元构建下一层，下一层含有120个单元，<strong>这就是我们第一个全连接层，这400个单元与120个单元紧密相连。它很像一个单神经网络层，这是一个标准的神经网络。</strong>它在120✖️400的维度上具有一个权重矩阵W，这就是全连接层。</p><p>然后我们对这120个单元再添加一个全连接层，这层更小，假设有84个单元。最后，用这84个单元填充一个SoftMax单元，如果你想识别0～9的数字，那么这个SoftMax输出层则会有10个输出。</p><p>在对于超级参数的选择问题上，建议不要自己凭空设定，而是查看文献中别人采取了哪些超级参数，选一个在别人任务重，效果很好的架构。</p><p><img data-src="/images/picturesof-4/CNN_19.png" alt="屏幕快照 2018-03-02 上午10.58.49"></p><p>还有一种在CNN中，另一种常见的模式是，一个或者多个卷积层后跟随一个池化层，然后是几个全连接层，最后是SoftMax层。从下面的表格中可以看出，第一，池化层和最大池化层没有参数。第二，卷积层的参数相对来说比较少。其实许多参数都存在于CNN中的全连接层。观察可发现，随着神经网络的加深，激活值会逐渐变小，如果激活值下降过快，也会影响网络性能。</p><p><strong>（parameters208来源：第一个卷积层中，过滤器维度为5✖️5，每个过滤器有1个bias，一共有8个过滤器，即5✖️5 + 1 ✖️ 8 = 208，所以第一层的weights是208）</strong></p><p><img data-src="/images/picturesof-4/CNN_20.png" alt="屏幕快照 2018-03-02 上午11.17.15"></p><h2 id="Why-Convolutions"><a href="#Why-Convolutions" class="headerlink" title="Why Convolutions?"></a>Why Convolutions?</h2><p>与传统的神经网络相比，CNN的主要两个优势在于：<strong>参数共享、稀疏连接</strong></p><p>参数共享：通过观察发现，特征检测如垂直边缘检测如果适用于图片的某个区域，那么它可能适用于图片的其他区域。<strong>也就是说，如果你用一个3✖️3的过滤器检测垂直边缘，那么图片的左上角区域以及旁边的各个区域都可以使用这个3✖️3的过滤器。每个特征检测器及输出都可以在输入图片的的不同区域中使用相同的参数。以便提取垂直边缘或者其他特征。</strong>它不仅适用于边缘特征这样的低阶特征，同样适用于高阶特征，例如提取脸上的眼睛，猫或者其他特征对象。</p><p>神经网络可以通过这两种机制减少参数，以便于我们用更小的训练集来训练它， 从而预防过度拟合。</p><p><img data-src="/images/picturesof-4/CNN_21.png" alt="屏幕快照 2018-03-02 下午12.04.13"></p><p>计算损失，使用优化算法来优化权重。</p><p><img data-src="/images/picturesof-4/CNN_22.png" alt="屏幕快照 2018-03-02 下午12.11.50"></p><h1 id="Case-studies"><a href="#Case-studies" class="headerlink" title="Case studies"></a>Case studies</h1><h2 id="Classic-Networks-经典网络"><a href="#Classic-Networks-经典网络" class="headerlink" title="Classic Networks 经典网络"></a>Classic Networks 经典网络</h2><p>下面是一些经典的网络。</p><p><img data-src="/images/picturesof-4/CNN_23.png" alt="屏幕快照 2018-03-07 上午10.41.57"></p><p><img data-src="/images/picturesof-4/CNN_24.png" alt="屏幕快照 2018-03-07 上午10.56.07"></p><p><img data-src="/images/picturesof-4/CNN_25.png" alt="屏幕快照 2018-03-07 上午11.02.34"></p><p><img data-src="/images/picturesof-4/CNN_26.png" alt="屏幕快照 2018-03-07 上午11.09.52"></p><h2 id="ResNets-残差网络"><a href="#ResNets-残差网络" class="headerlink" title="ResNets 残差网络"></a>ResNets 残差网络</h2><p>非常非常深的网络是很难被训练的，因为存在<strong>梯度消失</strong>和<strong>梯度爆炸</strong>的问题。下面要提到的是<strong>跳远连接</strong>(Skip Connection)，它可以从某一网络层获取激活，然后迅速反应给另外一层，甚至是神经网络的更深层。我们可以利用Skip Connection构建能够训练深度网络的ResNets，有时深度能够超过100层。</p><p><strong>ResNets是由残差块构建的。</strong>下面解释什么是残差块(Residual Block)。</p><p>在一般的神经网络系统中，激活层a[l]通常经过线性化处理，非线性化处理，再线性化处理，再非线性化，最后得到输出层a[l+2]。这被称作“主路径”(Main Path)</p><p><img data-src="/images/picturesof-4/CNN_27.png" alt="屏幕快照 2018-03-07 下午4.25.01"></p><p><strong>在ResNets中，有一点变化，我们将a[l]直接向后拷贝到神经网络的深层。</strong>在Relu非线性激活前加上a[l]，这是一条捷径(Shortcut)。也就是a[l]不再沿着主路径进行传递。这样一来a[l+2]变成了如下所示的样子，也就是加上的这个a[l]产生了一个残差块。所以a[l]插入的时机是在线性激活之后，Relu激活之前。</p><p><img data-src="/images/picturesof-4/CNN_28.png" alt="屏幕快照 2018-03-07 下午4.45.08"></p><p>除了<strong>捷径(ShortCut)</strong>，你可能还会听到另一个术语<strong>跳远连接(Skip Connection)</strong>，就是指a[l]跳过一层甚至是好几层，从而将消息传递到神经网络的更深层。</p><p>使用残差块能够训练更深的神经网络，所以构建一个ResNet网络就是通过将很多这样的残差块堆砌在一起，形成一个深度神经网络。</p><p>将一个普通的神经网络(PlainNetWork)编程一个残差网络(ResNets)的方法就是添加很多残差块，如下图所示。有5个残差块。如果我们使用标准优化算法训练一个普通网络，比如梯度下降或者其他热门的优化算法，如果没有多余的残差，没有这些捷径或者跳远连接，你会发现，随着网络深度的加深，训练错误会先减少，然后增多，而理论上，应该是随着网络深度的加深，错误应该越少越好。<strong>但事实上，对于一个普通网络来说，深度越深意味着用优化算法越难训练，训练错误就会越来越多，但是有了ResNet就不一样了。</strong>即使网络再深，训练的表现却不错，比如说错误会减少，甚至在100层，1000层的网络中也不例外。这种方式确实能有效的解决梯度消失和梯度爆炸的问题。让我们在训练更深的网络的同时，又能保证好的性能。</p><p><img data-src="/images/picturesof-4/CNN_29.png" alt="屏幕快照 2018-03-07 下午4.59.04"></p><p><img data-src="/images/picturesof-4/CNN_30.png" alt="屏幕快照 2018-03-07 下午6.31.41"></p><h2 id="1x1-Convolutions-1✖️1卷积"><a href="#1x1-Convolutions-1✖️1卷积" class="headerlink" title="1x1 Convolutions 1✖️1卷积"></a>1x1 Convolutions 1✖️1卷积</h2><p>使用1✖️1卷积可以根据自己的意愿来压缩或者保持、甚至增加输入层中信道的数量。</p><p><img data-src="/images/picturesof-4/CNN_31.png" alt="屏幕快照 2018-03-07 下午6.58.29"></p><p>上图中输入层中是28✖️28✖️192的维度，如果我们想要达到降维的效果，可以利用32个1✖️1的filter，因为过滤器的信道数量必须和输出层中的信道数量保持一致，所以每个filter中都有192个信道，每个过滤器进行一次卷积操作，再相加，最后生成一个28✖️28✖️32的输出层，达到了降维的效果。同样，想要达到增加或者保持维度的效果，使用1✖️1的卷积也是可以的。</p><p>下面介绍1✖️1卷积是如何运用到Inception网络中的。</p><h2 id="Inception-Network-Motivation-Inception网络"><a href="#Inception-Network-Motivation-Inception网络" class="headerlink" title="Inception Network Motivation Inception网络"></a>Inception Network Motivation Inception网络</h2><p>在做卷积网络时，你需要<strong>为过滤器的大小做决定，而Inception网络的作用就是它会自动为你做抉择</strong>，虽然网络架构因此会变得更加复杂，但网络表现却非常好。</p><p><strong>Inception网络不需要人为决定使用哪个过滤器，</strong>或是否需要池化，而是由网络自行确定这些参数，你可以给网络添加这些参数的所有可能值，然后把这些输出连接起来，让网络自己学习它需要什么样的参数，采用哪些过滤器组合。</p><p>如下图所示，输入层是一个28✖️28✖️192的矩阵，首先使用一个1✖️1的filter，输出一个28✖️28✖️64的矩阵，得到下图中的绿色块结果，以此类推，将filter的结果全部拼凑在一起，形成一个28✖️28✖️256的输出。</p><p><img data-src="/images/picturesof-4/CNN_32.png" alt="屏幕快照 2018-03-07 下午7.42.53"></p><p><strong>使用1✖️1卷积可以减少运算复杂度。</strong></p><p>如下，不使用1✖️1卷积计算次数为1.2亿次。</p><p><img data-src="/images/picturesof-4/CNN_33.png" alt="屏幕快照 2018-03-07 下午8.06.29"></p><p>使用1✖️1卷积，计算次数相较减少了10倍的计算量。<img data-src="/images/picturesof-4/CNN_34.png" alt="屏幕快照 2018-03-07 下午8.06.09"></p><p>将以上综合起来，构建自己的Inception网络。</p><p><img data-src="/images/picturesof-4/CNN_35.png" alt="屏幕快照 2018-03-07 下午8.36.19"></p><h1 id="Detection-algorithms"><a href="#Detection-algorithms" class="headerlink" title="Detection algorithms"></a>Detection algorithms</h1><h2 id="Object-Localization-对象定位"><a href="#Object-Localization-对象定位" class="headerlink" title="Object Localization 对象定位"></a>Object Localization 对象定位</h2><p><img data-src="/images/picturesof-4/CNN_36.png" alt="屏幕快照 2018-03-09 上午9.35.21"></p><p>首先先谈目标分类和目标定位问题。对于图片中可能的输出进行一个分类，这是分类问题，那么如何对图片中的目标物体进行定位呢？对于这个问题，<strong>我们将神经网络的输出增加一个目标标签y，用来表示目标物体的位置信息。</strong>如下所示，bx表示目标物体的中心的横坐标，by表示目标物体中心的纵坐标，bh表示目标物体的高度，bw表示物体的宽度。当然，这四个数据你在训练集中就应该构建好。<img data-src="/images/picturesof-4/CNN_37.png" alt="屏幕快照 2018-03-09 上午9.40.53"></p><p>那么如何表示<strong>输出呢？它是一个向量</strong>，第一个组件Pc表示是否含有对象，所以如果对象属于前3类，Pc值应该为1，<strong>也可以将Pc理解成被检测对象属于某一分类的概率。</strong>如果检测到了对象，就应该将它的位置信息也一并输出，也就是bx,by,bh,bw，还应该同时输出c1,c2,c3用来表示对象属于哪个类别。</p><p><img data-src="/images/picturesof-4/CNN_38.png" alt="屏幕快照 2018-03-09 上午9.59.35"></p><p>下面来讨论损失函数的定义。两种情况，如果检测到了物体，也就是Pc==1，那么将剩下元素做差平方相加，计算损失，如果没有检测到也就是Pc==0，那么我们只用检测第一个元素值，也就是Pc值即可。</p><p><img data-src="/images/picturesof-4/CNN_39.png" alt="屏幕快照 2018-03-09 上午10.02.14"></p><h2 id="Convolutional-Implementation-of-Sliding-Windows-卷积的滑动窗口实现"><a href="#Convolutional-Implementation-of-Sliding-Windows-卷积的滑动窗口实现" class="headerlink" title="Convolutional Implementation of Sliding Windows 卷积的滑动窗口实现"></a>Convolutional Implementation of Sliding Windows 卷积的滑动窗口实现</h2><p>如何通过卷积网络进行对象检测 —— 采用<strong>基于滑动窗口</strong>的目标检测算法。</p><p><img data-src="/images/picturesof-4/CNN_40.png" alt="屏幕快照 2018-03-12 上午10.06.06"></p><p>滑动窗口的过程在于，首先选取一个合适的窗口大小，将依据这个窗口对要预测的图片进行剪裁，将结果输入CNN，由CNN来预测窗口里是否含有目标物体。然后窗口向一个方向移动相应的步幅，由CNN再进行预测。</p><p><img data-src="/images/picturesof-4/CNN_41.png" alt="屏幕快照 2018-03-12 上午10.22.13"></p><p>滑动窗口算法带来的问题是，<strong>计算成本</strong>。如果你的窗口面积过小，那么将要多次对CNN进行输入操作，计算成本高。但是如果你将窗口调整的过大，则会带来粗粒度影响性能的问题。</p><p>幸运的是，上述过程所造成的计算成本问题已经得到了良好的解决。</p><p>为了构建滑动窗口的卷积运用，首先要知道如何把<strong>神经网络的全连接层转化为卷积层</strong>。我们<strong>使用一定大小的过滤器</strong>来将输出结果与传统意义上的全连接层输出结果保持一致。</p><p><img data-src="/images/picturesof-4/CNN_42.png" alt="屏幕快照 2018-03-12 上午10.40.46"></p><p>其次要解决的是，<strong>如何通过卷积来实现滑动窗口对象检测算法</strong>。可以看到，如果我们的输入图片从训练的14✖️14变成了16✖️16，我们在过滤器不变的情况下，对于最后这个4✖️4的输出矩阵可以理解为，左上角对应图片左上角的输出结果，右上角对应原始图片右上角的输出结果。以此类推。<strong>所以该卷积操作的原理是，我们不需要将输入图片分成四个子集，分别执行前向传播，而是把它们作为一张图片输入给卷积网络进行计算，一次得到所有的预测值。</strong>其中的公有区域可以共享很多计算。</p><p><img data-src="/images/picturesof-4/CNN_43.png" alt="屏幕快照 2018-03-12 上午11.16.05"></p><p>改进的方法大大提高了运算成本，但是也有一个缺点，就是<strong>边界框的位置不够准确</strong>。下面介绍如何解决这个问题。</p><h2 id="Bounding-Box-Predictions-预测边界-—-YOLO算法"><a href="#Bounding-Box-Predictions-预测边界-—-YOLO算法" class="headerlink" title="Bounding Box Predictions 预测边界 — YOLO算法"></a>Bounding Box Predictions 预测边界 — YOLO算法</h2><p>This algorithm “only looks once” at the image in the sense that it requires only one forward propagation pass through the network to make predictions. After non-max suppression, it then outputs recognized objects together with the bounding boxes.</p><p>如下图所示，当你在使用窗口检测目标物体时，如果窗口在移动过程中不能完全覆盖目标物体，那么怎样才能确定精准的边界框呢？</p><p><img data-src="/images/picturesof-4/CNN_44.png" alt="屏幕快照 2018-03-12 下午1.52.28"></p><p><strong>其中一个能得到更精准边界框的算法是，YOLO算法。</strong>YOLO的意思是“你只看一次”。是这么做的，比如你输入的图像是100✖️100的，然后在图像上放一个网格，将图像分类和定位算法分别应用到每个网格上，也就是有多个输出向量y，y的定义和之前一样。假如一个物体同时出现在了两个网格上，<strong>那么取物体的中心点，中心点在哪个网格上，那么物体就属于哪个网格。</strong></p><p><img data-src="/images/picturesof-4/CNN_45.png" alt="屏幕快照 2018-03-12 下午2.27.45"></p><p>再次说明一下，这个方法只对一个网格中出现一个物体的情况有效。对于出现多个物体的情况，稍后做详细的讨论。</p><p><img data-src="/images/picturesof-4/CNN_46.png" alt="屏幕快照 2018-03-12 下午2.34.49"></p><h2 id="Intersection-Over-Union-交并比函数"><a href="#Intersection-Over-Union-交并比函数" class="headerlink" title="Intersection Over Union 交并比函数"></a>Intersection Over Union 交并比函数</h2><p><strong>交并比函数可以用来评价对象检测算法。</strong>如果你希望定位到的对象是红色部分，但是你的算法却给出的是紫色部分，那么这个结果是好是坏呢？交并比的意思就是，<strong>计算两个边框交集和并集的比值(lOU)来检测结果的好坏。</strong>一般情况下，我们将lOU的阈值定义为0.5，并认为大于0.5就是一个可以接受的结果，当然你也可以定义更高。</p><p><img data-src="/images/picturesof-4/CNN_47.png" alt="屏幕快照 2018-03-12 下午3.11.02"></p><h2 id="Non-max-Suppression-非极大值抑制—检测YOLO算法"><a href="#Non-max-Suppression-非极大值抑制—检测YOLO算法" class="headerlink" title="Non-max Suppression 非极大值抑制—检测YOLO算法"></a>Non-max Suppression 非极大值抑制—检测YOLO算法</h2><p>到目前为止对象检测算法中的问题是，算法可能对同一个对象做出多次检测，所以算法不是对某一个对象检测出一次，而是检测出多次，<strong>非极大抑制这个方法可以确保你的算法对某个对象只检测出一次。</strong></p><p>假设下图是你需要进行检测的图片，将它用19✖️19的网格覆盖，每个车只有一个中点，也就是对于一辆覆盖到多个网格中的车来说，应该只有一个网格，也就是中点所在的网格的预测结果是1。</p><p>因为你要在所有网络上都跑一遍图像检测和定位算法，那么覆盖到车子的格子中输出y的PC的值都会是1，而不是所有格子中，只有两个格子会报告检测出了对象。所以最后可能会对一个对象做出多次检测。所以非最大抑制做的就是清理这些检测结果。所以每辆车只检测一次，而不是多次。当你检测出了多次时，<strong>选出输出概率最大的检测结果，对lOU值很高的其他边框进行抑制，这就是非最大值抑制的含义。</strong></p><p><img data-src="/images/picturesof-4/CNN_48.png" alt="屏幕快照 2018-03-12 下午3.50.54"></p><p>下面是Non-max Suppression算法的具体过程。</p><p><img data-src="/images/picturesof-4/CNN_49.png" alt="屏幕快照 2018-03-12 下午4.05.23"></p><h2 id="Anchor-Boxes"><a href="#Anchor-Boxes" class="headerlink" title="Anchor Boxes"></a>Anchor Boxes</h2><p><strong>如果你需要让一个格子能够检测出多个对象，那么就需要用到Anchor Boxes。</strong>如下图所示，如果你要检测的对象是人和车辆，这张图中这两者有同样一个中点，如果我们使用传统的y向量输出，会发现这两者的概率是一样的，那么我们必须从这两者中选择出一个作为结果，这是不合理的。Anchor Boxes的思路是这样的，预先定义两个不同形状的Anchor Boxes，把预测结果和这两个Anchor Boxes关联起来。</p><p><img data-src="/images/picturesof-4/CNN_50.png" alt="屏幕快照 2018-03-12 下午4.19.47"></p><p>总结一下，用Anchor Boxes之前，你做的是，对于训练图像中的每个对象，都根据那个对象中点的位置，将对象分配到某个格子中，然后输出一个3✖️3✖️8的向量，3✖️3是因为你用到9个网格，8是每个网格中的y输出(PC,bx,by,bw,bh,c1,c2,c3)。现在用到Anchor Boxes这个概念，现在每个对象都和之前一样分配到某个格子中（中点所在），但是它还分配到一个和对象形状交并比最高的Anchor Box中。所以现在的输出变成了3✖️3✖️16。</p><p><img data-src="/images/picturesof-4/CNN_51.png" alt="屏幕快照 2018-03-12 下午4.32.57"></p><p>下面举一个具体的例子。</p><p><img data-src="/images/picturesof-4/CNN_52.png" alt="屏幕快照 2018-03-12 下午4.40.30"></p><h2 id="YOLO-Algorithm"><a href="#YOLO-Algorithm" class="headerlink" title="YOLO Algorithm"></a>YOLO Algorithm</h2><p>我们将之前提到的所有组件组合在一起，<strong>构成YOLO对象检测算法</strong>。</p><p>y向量由Anchor Boxes组成，Anchor Boxes就可以看成y向量，下图中我们用到了两个Anchor Boxes，当我们进行检测是，假若检测到了物体，将边框画出后，与两个Anchor Boxes进行对比，发现与第二个Anchor Boxe的IOU值最高，那么车子就和向量的下半部分有关系。因为你将图片分成了9个网格，每个网格的维度是16，所以最后的输出是3✖️3✖️16。</p><p><img data-src="/images/picturesof-4/CNN_53.png" alt="屏幕快照 2018-03-12 下午4.53.00"></p><p><img data-src="/images/picturesof-4/CNN_54.png" alt="屏幕快照 2018-03-12 下午4.57.19"></p><p>最后你要跑一下非最大值抑制，这就是运行非最大值抑制的过程。如果你使用两个Anchor Boxes，那么对于9个格子中的任意一个都会有两个预测的边界框，其中一个的概率PC很低。<img data-src="/images/picturesof-4/CNN_55.png" alt="屏幕快照 2018-03-12 下午5.03.57"></p><p>接着你抛弃PC值很低的边界，连神经网络都说，这里可能什么都没有。</p><p><img data-src="/images/picturesof-4/CNN_56.png" alt="屏幕快照 2018-03-12 下午5.05.25"></p><p>最后，如果你有三个对象检测类别，对于每个类别，单独运行非最大抑制，处理预测结果是那个类别的边界框。</p><p><img data-src="/images/picturesof-4/CNN_57.png" alt="屏幕快照 2018-03-12 下午5.08.12"></p><h2 id="Region-Proposals-—-RPN网络"><a href="#Region-Proposals-—-RPN网络" class="headerlink" title="Region Proposals — RPN网络"></a>Region Proposals — RPN网络</h2><p>带区域的CNN —  这个算法尝试选出一些区域，在这些区域上运行CNN是有意义的。选出候选区域的方法是运行图像分割算法，先找出可能的多个色块，然后在各个色块上放置边界框。然后在边界框上跑CNN分类算法。这样需要处理的位置可能少得多。<img data-src="/images/picturesof-4/CNN_58.png" alt="屏幕快照 2018-03-12 下午5.24.12"></p><p><img data-src="/images/picturesof-4/CNN_59.png" alt="屏幕快照 2018-03-12 下午5.29.09"></p><p><strong>Summary:</strong></p><p><img data-src="/images/picturesof-4/CNN_60.png" alt="屏幕快照 2018-03-13 上午9.52.04"></p><p><img data-src="/images/picturesof-4/CNN_61.png" alt="屏幕快照 2018-03-13 上午9.55.50"></p><p><img data-src="/images/picturesof-4/CNN_62.png" alt="屏幕快照 2018-03-13 上午11.44.02"></p><h1 id="Face-Recognition"><a href="#Face-Recognition" class="headerlink" title="Face Recognition"></a>Face Recognition</h1><h2 id="Face-verification"><a href="#Face-verification" class="headerlink" title="Face verification"></a>Face verification</h2><p><img data-src="/images/picturesof-4/CNN_63.png" alt="屏幕快照 2018-03-13 下午3.11.41"></p><p><img data-src="/images/picturesof-4/CNN_64.png" alt="屏幕快照 2018-03-14 上午10.09.35"></p><h2 id="One-Shot-Learning-一次学习"><a href="#One-Shot-Learning-一次学习" class="headerlink" title="One Shot Learning 一次学习"></a>One Shot Learning 一次学习</h2><p>人脸识别所面临的一个挑战，就是你需要解决“一次学习”问题，即只需要单单一张图片，或者单单一个人脸样例，就能识别出一个人。现在的问题是，你的训练集中通常只有指定一个人的一张照片，如果公司新来一个人，难道要放进庞大的CNN体系中重新学习吗？</p><p><img data-src="/images/picturesof-4/CNN_65.png" alt="屏幕快照 2018-03-13 下午3.19.48"></p><p>所以要让神经网络做到一次学习，应该是学习<strong>“Similarity”函数</strong>。具体的说，你是希望<strong>神经网络能够学习这个用d表示的函数。它以两张照片作为输入，然后输出这两张照片的差异值。</strong></p><p><img data-src="/images/picturesof-4/CNN_66.png" alt="屏幕快照 2018-03-13 下午3.48.26"></p><h2 id="Siamese-Network-Siamese-网络"><a href="#Siamese-Network-Siamese-网络" class="headerlink" title="Siamese Network Siamese 网络"></a>Siamese Network Siamese 网络</h2><p><strong>实现上述d函数的一个方式就是Siamese 网络。</strong>也就是训练一组参数，使得如果输入的不是一个人的话，它的输出f(x1)会跟其他人的输出结果f(x2)产生差距，这个差距可以用诸如曼哈顿距离来衡量，如果两个输入的输出结果很相近，那么可以认为是同一个人。</p><p><img data-src="/images/picturesof-4/CNN_67.png" alt="屏幕快照 2018-03-13 下午4.10.16"></p><p><img data-src="/images/picturesof-4/CNN_68.png" alt="屏幕快照 2018-03-13 下午4.10.36"></p><h2 id="Triplet-Loss-—-三元组损失函数"><a href="#Triplet-Loss-—-三元组损失函数" class="headerlink" title="Triplet Loss — 三元组损失函数"></a>Triplet Loss — 三元组损失函数</h2><p>想要通过学习神经网络的参数来得到优质的人脸图片编码，方式之一就是使用<strong>三元组损失函数</strong>然后使用梯度下降。</p><p><strong>我们希望，相同人的图片的距离可以远远小于不相同的距离。</strong>为了防止无意义的0输出，使用一个间隔参数a。</p><p><img data-src="/images/picturesof-4/CNN_69.png" alt="屏幕快照 2018-03-13 下午4.58.36"></p><p>三元组损失函数的定义基于三张图片，样本图片A(Anchor)，相同人样本P(Positive)，不同人样本N(Negative)。<img data-src="/images/picturesof-4/CNN_70.png" alt="屏幕快照 2018-03-13 下午5.10.42"></p><p>在选择训练集的时候，要尽量避免使用随机的配对方式，因为随机的图片很容易满足损失函数的要求，为了达到更好的效果，<strong>建议使用比较难训练的样本</strong>，“比较难训练”是指A与N的距离，与A与P的距离非常相近。<img data-src="/images/picturesof-4/CNN_71.png" alt="屏幕快照 2018-03-13 下午5.28.22"></p><p><img data-src="/images/picturesof-4/CNN_72.png" alt="屏幕快照 2018-03-13 下午5.33.05"></p><h2 id="Face-Verification-and-Binary-Classification"><a href="#Face-Verification-and-Binary-Classification" class="headerlink" title="Face Verification and Binary Classification"></a>Face Verification and Binary Classification</h2><p>如何将人脸识别问题化作一个二分类问题？</p><p><img data-src="/images/picturesof-4/CNN_73.png" alt="屏幕快照 2018-03-13 下午5.50.23"></p><p><img data-src="/images/picturesof-4/CNN_74.png" alt="屏幕快照 2018-03-13 下午5.51.03"></p><p><img data-src="/images/picturesof-4/CNN_75.png" alt="屏幕快照 2018-03-14 上午11.12.29"></p><h1 id="Neural-Style-Transfer-神经风格迁移"><a href="#Neural-Style-Transfer-神经风格迁移" class="headerlink" title="Neural Style Transfer 神经风格迁移"></a>Neural Style Transfer 神经风格迁移</h1><p><img data-src="/images/picturesof-4/CNN_76.png" alt="屏幕快照 2018-03-13 下午7.02.31"></p><h2 id="What-are-deep-ConvNets-learning"><a href="#What-are-deep-ConvNets-learning" class="headerlink" title="What are deep ConvNets learning?"></a>What are deep ConvNets learning?</h2><p><img data-src="/images/picturesof-4/CNN_77.png" alt="屏幕快照 2018-03-13 下午7.09.06"></p><p><img data-src="/images/picturesof-4/CNN_78.png" alt="屏幕快照 2018-03-13 下午7.13.39"></p><h2 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h2><p>我们<strong>将损失函数定义为“内容损失➕风格损失”</strong>，内容损失是指生成的图片和原图内容的相似性，风格损失是指生成图片和原图风格的相似性。</p><p><img data-src="/images/picturesof-4/CNN_79.png" alt="屏幕快照 2018-03-13 下午7.22.05"></p><p><img data-src="/images/picturesof-4/CNN_80.png" alt="屏幕快照 2018-03-13 下午7.22.37"></p><h2 id="Content-Cost-Function-内容损失函数"><a href="#Content-Cost-Function-内容损失函数" class="headerlink" title="Content Cost Function 内容损失函数"></a>Content Cost Function 内容损失函数</h2><p>内容损失函数定义为某一隐藏层中与既定（如VGG网络）隐藏层激活后的值的相似程度。</p><p><img data-src="/images/picturesof-4/CNN_81.png" alt="屏幕快照 2018-03-13 下午7.32.08"></p><h2 id="Style-Cost-Function-风格损失函数"><a href="#Style-Cost-Function-风格损失函数" class="headerlink" title="Style Cost Function 风格损失函数"></a>Style Cost Function 风格损失函数</h2><p>风格损失函数定义为某一隐藏层中，通道之间的相关程度。</p><p><img data-src="/images/picturesof-4/CNN_82.png" alt="屏幕快照 2018-03-13 下午7.43.28"></p><p>这个相关程度可以理解为，比如风格图片是灰色的地方同时又出现了垂直线条。那么输入图片中，某一隐藏层，观察到了灰色和出现了垂直线条的几率，定义为通道之间的相关程度。</p><p><img data-src="/images/picturesof-4/CNN_83.png" alt="屏幕快照 2018-03-13 下午7.45.28"></p><p>损失函数定义如下：为输入图片与原图片，某一隐藏层，某一通道中激活值的相关性，使用绝对平方值来计算，还乘以了一个归一化常数。<img data-src="/images/picturesof-4/CNN_84.png" alt="屏幕快照 2018-03-13 下午8.00.14"></p><p>“内容损失➕风格损失  =  损失函数”</p><p><img data-src="/images/picturesof-4/CNN_85.png" alt="屏幕快照 2018-03-13 下午8.03.07"></p><p><img data-src="/images/picturesof-4/CNN_86.png" alt="屏幕快照 2018-03-14 上午9.16.13"></p><p><img data-src="/images/picturesof-4/CNN_87.png" alt="屏幕快照 2018-03-14 上午9.20.42"></p><p><img data-src="/images/picturesof-4/CNN_88.png" alt="屏幕快照 2018-03-14 上午9.40.49"></p><h2 id="1D-and-3D-Generalizations-一维到三维推广"><a href="#1D-and-3D-Generalizations-一维到三维推广" class="headerlink" title="1D and 3D Generalizations 一维到三维推广"></a>1D and 3D Generalizations 一维到三维推广</h2><p>许多图片不仅限于二维，有可能是1维或者3维。那么如何进行处理呢？我们一样可以使用卷积操作。<img data-src="/images/picturesof-4/CNN_89.png" alt="屏幕快照 2018-03-13 下午8.28.53"></p><p><img data-src="/images/picturesof-4/CNN_90.png" alt="屏幕快照 2018-03-13 下午8.29.33"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Convolutional-Neural-Networks&quot;&gt;&lt;a href=&quot;#Convolutional-Neural-Networks&quot; class=&quot;headerlink&quot; title=&quot;Convolutional Neural Networks&quot;&gt;&lt;/a&gt;Convolutional Neural Networks&lt;/h1&gt;&lt;h2 id=&quot;Edge-Detection&quot;&gt;&lt;a href=&quot;#Edge-Detection&quot; class=&quot;headerlink&quot; title=&quot;Edge Detection&quot;&gt;&lt;/a&gt;Edge Detection&lt;/h2&gt;&lt;p&gt;卷积运算是卷积神经网络最基本的组成成分，使用边缘检测作为入门样例。下面介绍卷积计算是如何实现的。&lt;/p&gt;
&lt;p&gt;使用一个3✖️3的&lt;strong&gt;过滤器(核)&lt;/strong&gt;与原始矩阵进行元素相乘，再相加，最后和的结果为&lt;strong&gt;卷积运算&lt;/strong&gt;后的第一个元素值，然后依次计算，下面例子中，做一次卷积运算后结果为一个4✖️4的矩阵。&lt;/p&gt;
&lt;p&gt;这种卷积运算可以理解成为，&lt;strong&gt;垂直边缘检测器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/picturesof-4/CNN_1.png&quot; alt=&quot;屏幕快照 2018-02-09 下午12.25.09&quot;&gt;&lt;/p&gt;
&lt;p&gt;在不同的编程环境中可以使用不同的函数来实现卷积运算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/picturesof-4/CNN_2.png&quot; alt=&quot;屏幕快照 2018-02-09 下午12.38.47&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么为什么这个可以用作垂直检测呢？来看下面的例子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CV" scheme="https://unknown.yuzhouwan.com/categories/CV/"/>
    
    
      <category term="CNN" scheme="https://unknown.yuzhouwan.com/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>Numpy基础</title>
    <link href="https://unknown.yuzhouwan.com/posts/21763/"/>
    <id>https://unknown.yuzhouwan.com/posts/21763/</id>
    <published>2017-09-28T11:09:26.000Z</published>
    <updated>2020-02-08T15:08:59.267Z</updated>
    
    <content type="html"><![CDATA[<p>Numpy是Python中用于科学计算的核心库。它提供了高性能的多维数组对象，以及相关工具</p><h1 id="绘制雪花"><a href="#绘制雪花" class="headerlink" title="绘制雪花"></a>绘制雪花</h1><p>转自博客上看到的一位大牛的程序，利用Numpy + matplotlib 绘制雪花，效果如下：</p><p><img data-src="/images/snow.jpg" alt="snow"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'FangSong'</span>]  <span class="comment"># 指定默认字体</span></span><br><span class="line">plt.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>  <span class="comment"># 解决中文显示为方块的问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(p, d)</span>:</span></span><br><span class="line">    <span class="string">"""返回点p绕原点逆时针旋转d度的坐标"""</span></span><br><span class="line"></span><br><span class="line">    a = np.radians(d)</span><br><span class="line">    m = np.array([[np.cos(a), np.sin(a)], [-np.sin(a), np.cos(a)]])</span><br><span class="line">    <span class="keyword">return</span> np.dot(p, m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">koch_curve</span><span class="params">(p, q)</span>:</span></span><br><span class="line">    <span class="string">"""将线段pq生成科赫曲线，返回uvw三个点"""</span></span><br><span class="line"></span><br><span class="line">    p, q = np.array(p), np.array(q)</span><br><span class="line">    u = p + (q - p) / <span class="number">3</span>  <span class="comment"># 三等分点u的坐标</span></span><br><span class="line">    v = q - (q - p) / <span class="number">3</span>  <span class="comment"># 三等分点V的坐标</span></span><br><span class="line">    w = rotate(v - u, <span class="number">60</span>) + u  <span class="comment"># 线段uv绕u点逆时针旋转60°得到点w的坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> u.tolist(), v.tolist(), w.tolist()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snow</span><span class="params">(triangle, k)</span>:</span></span><br><span class="line">    <span class="string">"""给定三角形，生成封闭的科赫雪花"""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        result = list()</span><br><span class="line">        t_len = len(triangle)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(t_len):</span><br><span class="line">            p = triangle[j]</span><br><span class="line">            q = triangle[(j + <span class="number">1</span>) % t_len]</span><br><span class="line">            u, v, w = koch_curve(p, q)</span><br><span class="line">            result.extend([p, u, w, v])</span><br><span class="line">        triangle = result.copy()</span><br><span class="line"></span><br><span class="line">    triangle.append(triangle[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> triangle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_snow</span><span class="params">(snow_list)</span>:</span></span><br><span class="line">    <span class="string">"""绘制雪花"""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> triangle, k <span class="keyword">in</span> snow_list:</span><br><span class="line">        data = np.array(snow(triangle, k))</span><br><span class="line">        x, y = np.split(data, <span class="number">2</span>, axis=<span class="number">1</span>)</span><br><span class="line">        plt.plot(x, y)</span><br><span class="line"></span><br><span class="line">    plt.axis(<span class="string">'equal'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">snow_list = [</span><br><span class="line">    ([(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">0.5</span>, <span class="number">0.8660254</span>), (<span class="number">1</span>, <span class="number">0</span>)], <span class="number">5</span>),</span><br><span class="line">    ([(<span class="number">1.1</span>, <span class="number">0.4</span>), (<span class="number">1.35</span>, <span class="number">0.8330127</span>), (<span class="number">1.6</span>, <span class="number">0.4</span>)], <span class="number">4</span>),</span><br><span class="line">    ([(<span class="number">1.1</span>, <span class="number">-0.1</span>), (<span class="number">1.25</span>, <span class="number">0.15980761</span>), (<span class="number">1.4</span>, <span class="number">-0.1</span>)], <span class="number">3</span>)</span><br><span class="line">]</span><br><span class="line">plot_snow(snow_list)</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h1 id="数组Arrays"><a href="#数组Arrays" class="headerlink" title="数组Arrays"></a>数组Arrays</h1><p>numpy数组是一个由不同数值组成的网格。网格中的数据都是<strong>同一种数据类型</strong>，可以通过非负整型数的元组来访问。</p><p>我们可以从列表创建数组，然后利用方括号访问其中的元素。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])   <span class="comment">#创建一个一维数组</span></span><br><span class="line">print(type(a))</span><br><span class="line">print(a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>])</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">numpy</span>.<span class="title">ndarray</span>'&gt;</span></span><br><span class="line"><span class="class">1 2 3</span></span><br><span class="line"><span class="class">[5 2 3]</span></span><br></pre></td></tr></tbody></table></figure><h1 id="函数shape-用法"><a href="#函数shape-用法" class="headerlink" title="函数shape()用法"></a>函数shape()用法</h1><p>shape函数功能室查看矩阵或者数组的<strong>维度</strong>。</p><p>例如：建立一个3✖3的单位矩阵e，e.shape()为（3，3），<strong>表示三行三列</strong>，第一维的长度是3，第二维的长度也是3。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">e = np.eye(<span class="number">3</span>)</span><br><span class="line">print(e)</span><br><span class="line">print(e.shape)</span><br><span class="line">print(e[<span class="number">0</span>,<span class="number">0</span>],e[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">1.</span>]]</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1.0</span> <span class="number">1.0</span></span><br></pre></td></tr></tbody></table></figure><p>建立一个一维矩阵b，b.shape为矩阵的长度。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(b.shape)</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>,)</span><br></pre></td></tr></tbody></table></figure><p>建立一个4✖2的矩阵c，c.shape[1]为第一维的长度，c.shape[0]为第二维的长度，c.shape[1]为第一维的长度。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">9</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">0</span>]])</span><br><span class="line">print(c.shape[<span class="number">0</span>])</span><br><span class="line">print(c.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>一个单独的数值，返回值为空。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.shape(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">()</span><br></pre></td></tr></tbody></table></figure><h1 id="其他创建数组的方法"><a href="#其他创建数组的方法" class="headerlink" title="其他创建数组的方法"></a>其他创建数组的方法</h1><p>Numpy还提供了很多其他创建数组的方法：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">3</span>))        <span class="comment">#创建一个2✖️3全0数组</span></span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">b = np.ones((<span class="number">1</span>,<span class="number">2</span>))         <span class="comment">#创建一个1✖️2全1数组</span></span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">c = np.full((<span class="number">4</span>,<span class="number">2</span>),<span class="number">7</span>)       <span class="comment">#创建一个4✖️2的全7数组</span></span><br><span class="line">print(c)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">d = np.eye(<span class="number">2</span>)              <span class="comment">#创建一个二维单位矩阵</span></span><br><span class="line">print(d)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">e = np.random.random((<span class="number">2</span>,<span class="number">2</span>))<span class="comment">#创建一个2✖️2由随机数字组成的数组</span></span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line">[[ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">0.</span>  <span class="number">0.</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">1.</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[<span class="number">7</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">0.</span>]</span><br><span class="line"> [ <span class="number">0.</span>  <span class="number">1.</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[ <span class="number">0.82662589</span>  <span class="number">0.93604335</span>]</span><br><span class="line"> [ <span class="number">0.20764393</span>  <span class="number">0.53211415</span>]]</span><br></pre></td></tr></tbody></table></figure><h1 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h1><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片：和Python列表类似，numpy数组可以使用切片语法。因为数组是多维的，所以必须为每个维度指定好切片。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个3✖️4的数组</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用切片来截取前两行，第1到2列。注意这里“：2”是第0，1行，不包含第二行，与range()相同</span></span><br><span class="line">b = a[:<span class="number">2</span>,<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#切片是原数组的一部分，所以改变切片，原数组也会改变</span></span><br><span class="line">print(a[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">b[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">77</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">6</span> <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line">[[ <span class="number">1</span> <span class="number">77</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]]</span><br></pre></td></tr></tbody></table></figure><p>你可以<strong>同时使用整型和切片语法来访问数组</strong>。但是，这样<strong>会产生一个比原数组低阶的新数组。</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#3✖️4</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">print(a)</span><br><span class="line">print(a.shape)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">row_r1 = a[<span class="number">1</span>,:]</span><br><span class="line">row_r2 = a[<span class="number">1</span>:<span class="number">2</span>,:]</span><br><span class="line"></span><br><span class="line">print(row_r1)</span><br><span class="line">print(row_r1.shape)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">print(row_r2)</span><br><span class="line">print(row_r2.shape)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]]</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line">(<span class="number">4</span>,)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]]</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="整型数组访问"><a href="#整型数组访问" class="headerlink" title="整型数组访问"></a>整型数组访问</h2><p> 当我们使用切片语法访问数组时，得到的总是原数组的一个子集。整型数组访问允许我们利用其他数组的数据构建一个新的数组。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">print(a[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#上面的print等价于</span></span><br><span class="line">print([a[<span class="number">0</span>,<span class="number">0</span>],a[<span class="number">1</span>,<span class="number">1</span>],a[<span class="number">2</span>,<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></tbody></table></figure><p>整型数组访问语法还有一个有用的技巧，可以用来选择或者更改矩阵中每行中的一个元素：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">b = np.array([<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用b中的索引在a的每行选择一个元素</span></span><br><span class="line">print(a[np.arange(<span class="number">4</span>),b])</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">a[np.arange(<span class="number">4</span>),b] += <span class="number">10</span></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">[[ <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line"> [ <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">11</span> <span class="number">12</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ <span class="number">1</span>  <span class="number">6</span>  <span class="number">7</span> <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line">[[<span class="number">11</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span> <span class="number">16</span>]</span><br><span class="line"> [<span class="number">17</span>  <span class="number">8</span>  <span class="number">9</span>]</span><br><span class="line"> [<span class="number">10</span> <span class="number">21</span> <span class="number">12</span>]]</span><br></pre></td></tr></tbody></table></figure><h2 id="布尔型数组访问"><a href="#布尔型数组访问" class="headerlink" title="布尔型数组访问"></a>布尔型数组访问</h2><p>布尔数组访问可以让你选择数组中任意元素。通常，这种访问方式用于选取数组中满足某些条件的元素。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回大于2的元素，这返回一个与原数组同型的布尔数组</span></span><br><span class="line">bool_idx = (a &gt; <span class="number">2</span>) </span><br><span class="line"></span><br><span class="line">print(bool_idx)</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用生成的布尔数组构建一个大于2的一维数组</span></span><br><span class="line">print(a[bool_idx])</span><br><span class="line"></span><br><span class="line">print(a[a &gt; <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">[[<span class="literal">False</span> <span class="literal">False</span>]</span><br><span class="line"> [ <span class="literal">True</span>  <span class="literal">True</span>]</span><br><span class="line"> [ <span class="literal">True</span>  <span class="literal">True</span>]]</span><br><span class="line">[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br></pre></td></tr></tbody></table></figure><h1 id="数组计算"><a href="#数组计算" class="headerlink" title="数组计算"></a>数组计算</h1><p>既可利用操作符重载，也可以使用函数方式：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]],dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]],dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment">#加</span></span><br><span class="line">print(x+y)</span><br><span class="line">print(np.add(x,y))</span><br><span class="line"></span><br><span class="line"><span class="comment">#减</span></span><br><span class="line">print(x-y)</span><br><span class="line">print(np.subtract(x,y))</span><br><span class="line"></span><br><span class="line"><span class="comment">#乘,对应元素乘法</span></span><br><span class="line">print(x*y)</span><br><span class="line">print(np.multiply(x,y))</span><br><span class="line"></span><br><span class="line"><span class="comment">#除，对应元素除法</span></span><br><span class="line">print(x/y)</span><br><span class="line">print(np.divide(x,y))</span><br><span class="line"></span><br><span class="line"><span class="comment">#开方</span></span><br><span class="line">print(np.sqrt(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">#矩阵乘法</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>,<span class="number">12</span>])</span><br><span class="line"></span><br><span class="line">print(v.dot(w))</span><br><span class="line">print(np.dot(v,w))</span><br><span class="line">print(a.dot(v))</span><br><span class="line">print(np.dot(a,v))</span><br></pre></td></tr></tbody></table></figure><p>Numpy提供了很多计算数组的函数，其中最常用的一个是sum:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#Compute sum of all elements</span></span><br><span class="line">print(np.sum(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Compute sum of each column</span></span><br><span class="line">print(np.sum(x,axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Compute sum of each row</span></span><br><span class="line">print(np.sum(x,axis=<span class="number">1</span>))</span><br></pre></td></tr></tbody></table></figure><p>查看更多函数，查看<a href="https://docs.scipy.org/doc/numpy/reference/routines.math.html" target="_blank" rel="noopener">SciPy.org</a></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="comment">#转置</span></span><br><span class="line">print(x.T)</span><br></pre></td></tr></tbody></table></figure><p>查看<a href="https://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html" target="_blank" rel="noopener">更多操作数组的方法</a></p><h1 id="广播Broadcasting"><a href="#广播Broadcasting" class="headerlink" title="广播Broadcasting"></a>广播Broadcasting</h1><p>广播是一种强有力的机制，它让Numpy可以让不同大小的矩阵在一起进行数学计算。我们常会有一个小的矩阵和一个大的矩阵，然后需要用小的矩阵对大的矩阵做一些计算。</p><p>例如，我们想要把一个向量加到矩阵的每一行，我们可以这样做：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment">#Create an empty matrix with the same shape as x</span></span><br><span class="line">y = np.empty_like(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    y[i,:] = x[i,:] + v</span><br><span class="line">    </span><br><span class="line">print(y)</span><br></pre></td></tr></tbody></table></figure><p>这样是行的通的，但是当x矩阵非常大，利用循环开计算就会变得很慢很慢。我们可以换一种思路。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#stack 4 copies of v on top of each other</span></span><br><span class="line">vv = np.tile(v,(<span class="number">4</span>,<span class="number">1</span>))</span><br><span class="line">print(vv)</span><br><span class="line"></span><br><span class="line">y = x + vv</span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">[[ <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">5</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">8</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">11</span> <span class="number">13</span>]]</span><br></pre></td></tr></tbody></table></figure><p><strong>Numpy广播机制可以让我们不用创建vv，就能直接运算</strong>，看看下面的例子。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">y = x + v</span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line">[[ <span class="number">2</span>  <span class="number">2</span>  <span class="number">4</span>]</span><br><span class="line"> [ <span class="number">5</span>  <span class="number">5</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">8</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">11</span> <span class="number">11</span> <span class="number">13</span>]]</span><br></pre></td></tr></tbody></table></figure><p>对两个数组使用广播机制要遵守下列规则：</p><p>1.如果数组的秩不同，使用1来将秩小的数组进行扩展，直到两个数组的尺寸长度都一样。</p><p>2.如果两个数组在某个维度上的长度是一样的，或者其中一个数组在该维度上的长度为1，那么我们说这两个数组在该维度上是<strong>相容</strong>的。</p><p>3.<strong>如果两个数组在所有维度上都是相容的，它们就能使用广播。</strong></p><p>4.如果两个输入数组的尺寸不同，那么注意其中较大的那个尺寸。因为广播之后，两个数组的尺寸将和较大的尺寸一样。</p><p>5.在任何一个维度上，如果一个数组的长度为1，另一个数组的长度大于1，那么在该维度上，就好像是对第一个数组进行了复制。</p><p>参阅<a href="https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank" rel="noopener">文档</a>和<a href="http://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc" target="_blank" rel="noopener">注释</a>。支持广播机制的函数是全局函数。哪些是全局函数可以在<a href="https://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs" target="_blank" rel="noopener">文档</a>中查找。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#v is [1,2,3],w is [4,5]</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">w = np.array([<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">print(np.reshape(v,(<span class="number">3</span>,<span class="number">1</span>)) * w)</span><br><span class="line"></span><br><span class="line"><span class="comment">#x is [[1,2,3]</span></span><br><span class="line"><span class="comment">#     [4,5,6]]</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(x + v)</span><br><span class="line"></span><br><span class="line">print(x.T + w)</span><br><span class="line"></span><br><span class="line">print(x + np.reshape(w,(<span class="number">2</span>,<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">print(x * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">[[ <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">8</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">12</span> <span class="number">15</span>]]</span><br><span class="line"></span><br><span class="line">[[<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">7</span> <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">[[ <span class="number">5</span>  <span class="number">9</span>]</span><br><span class="line"> [ <span class="number">6</span> <span class="number">10</span>]</span><br><span class="line"> [ <span class="number">7</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">[[ <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line">[[ <span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>]</span><br><span class="line"> [ <span class="number">8</span> <span class="number">10</span> <span class="number">12</span>]]</span><br></pre></td></tr></tbody></table></figure><h1 id="Numpy文档"><a href="#Numpy文档" class="headerlink" title="Numpy文档"></a>Numpy文档</h1><p>此文介绍了numpy中的一些重要内容，但是numpy远不止如此，可以查阅<a href="https://docs.scipy.org/doc/numpy/reference/" target="_blank" rel="noopener">numpy</a>文献来学习更多。</p><h1 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install Pillow</span><br></pre></td></tr></tbody></table></figure><p>Numpy提供了高性能的多维数组，以及计算和操作数组的基本工具。Scipy基于Numpy，提供了大量的计算和操作数组的函数，这些函数对于不同类型的科学和工程计算非常有用。</p><p><a href="https://docs.scipy.org/doc/scipy/reference/index.html" target="_blank" rel="noopener">SciPy文档</a>。</p><h1 id="点之间的距离"><a href="#点之间的距离" class="headerlink" title="点之间的距离"></a>点之间的距离</h1><p>SciPy定义了一些有用的函数，可以计算集合中点之间的距离。</p><p>函数scipy.spatial.distance.pdist能够计算集合中所有两点之间的距离。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.spatial.distance <span class="keyword">import</span> pdist, squareform</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>]])</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line">d = squareform(pdist(x,<span class="string">'euclidean'</span>))</span><br><span class="line">print(d)</span><br></pre></td></tr></tbody></table></figure><p>具体细节请阅读<a href="http://link.zhihu.com/?target=http%3A//docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html">文档</a>。</p><p>函数<strong>scipy.spatial.distance.cdist</strong>可以计算不同集合中点的距离，具体请查看<a href="http://link.zhihu.com/?target=http%3A//docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html">文档</a>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Numpy是Python中用于科学计算的核心库。它提供了高性能的多维数组对象，以及相关工具&lt;/p&gt;
&lt;h1 id=&quot;绘制雪花&quot;&gt;&lt;a href=&quot;#绘制雪花&quot; class=&quot;headerlink&quot; title=&quot;绘制雪花&quot;&gt;&lt;/a&gt;绘制雪花&lt;/h1&gt;&lt;p&gt;转自博客上看到的一位大牛的程序，利用Numpy + matplotlib 绘制雪花，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/snow.jpg&quot; alt=&quot;snow&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.rcParams[&lt;span class=&quot;string&quot;&gt;&#39;font.sans-serif&#39;&lt;/span&gt;] = [&lt;span class=&quot;string&quot;&gt;&#39;FangSong&#39;&lt;/span&gt;]  &lt;span class=&quot;comment&quot;&gt;# 指定默认字体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.rcParams[&lt;span class=&quot;string&quot;&gt;&#39;axes.unicode_minus&#39;&lt;/span&gt;] = &lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# 解决中文显示为方块的问题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rotate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(p, d)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;返回点p绕原点逆时针旋转d度的坐标&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a = np.radians(d)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m = np.array([[np.cos(a), np.sin(a)], [-np.sin(a), np.cos(a)]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; np.dot(p, m)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;koch_curve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(p, q)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;将线段pq生成科赫曲线，返回uvw三个点&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p, q = np.array(p), np.array(q)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u = p + (q - p) / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# 三等分点u的坐标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    v = q - (q - p) / &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# 三等分点V的坐标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    w = rotate(v - u, &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;) + u  &lt;span class=&quot;comment&quot;&gt;# 线段uv绕u点逆时针旋转60°得到点w的坐标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; u.tolist(), v.tolist(), w.tolist()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;snow&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(triangle, k)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;给定三角形，生成封闭的科赫雪花&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(k):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = list()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t_len = len(triangle)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(t_len):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p = triangle[j]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            q = triangle[(j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % t_len]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            u, v, w = koch_curve(p, q)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            result.extend([p, u, w, v])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        triangle = result.copy()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    triangle.append(triangle[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; triangle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;plot_snow&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(snow_list)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;绘制雪花&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; triangle, k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; snow_list:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        data = np.array(snow(triangle, k))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x, y = np.split(data, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, axis=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        plt.plot(x, y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    plt.axis(&lt;span class=&quot;string&quot;&gt;&#39;equal&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    plt.show()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;snow_list = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ([(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.8660254&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)], &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ([(&lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.4&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;1.35&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.8330127&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;1.6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.4&lt;/span&gt;)], &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ([(&lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.1&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;1.25&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.15980761&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;1.4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;-0.1&lt;/span&gt;)], &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plot_snow(snow_list)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="DataView" scheme="https://unknown.yuzhouwan.com/categories/DataView/"/>
    
    
      <category term="Python" scheme="https://unknown.yuzhouwan.com/tags/Python/"/>
    
      <category term="Numpy" scheme="https://unknown.yuzhouwan.com/tags/Numpy/"/>
    
  </entry>
  
</feed>
