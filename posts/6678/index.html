<!DOCTYPE html>
<html lang="Zh">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/me.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/me.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/me.jpg">
  <link rel="mask-icon" href="/images/me.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"unknown.yuzhouwan.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="三次握手 客户端通过向服务器端发送一个请求报文SYN来创建一个主动打开。  Server端接受连接后回复ACK报文，并为这次连接分配资源。 如果只有两次通信的话，这时候B不确定A是否收到了确认消息，有可能这个确认消息由于某些原因丢了。  Client端接收到ACK报文后也向Server段发送报文，并分配资源，这样TCP连接就建立了。 这个时候经过了三次握手，A和B双方确认了两边都是通的，可以相互通">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="https://unknown.yuzhouwan.com/posts/6678/index.html">
<meta property="og:site_name" content="Grace Koo&#39;s Blog">
<meta property="og:description" content="三次握手 客户端通过向服务器端发送一个请求报文SYN来创建一个主动打开。  Server端接受连接后回复ACK报文，并为这次连接分配资源。 如果只有两次通信的话，这时候B不确定A是否收到了确认消息，有可能这个确认消息由于某些原因丢了。  Client端接收到ACK报文后也向Server段发送报文，并分配资源，这样TCP连接就建立了。 这个时候经过了三次握手，A和B双方确认了两边都是通的，可以相互通">
<meta property="og:locale">
<meta property="og:image" content="https://unknown.yuzhouwan.com/images/data/Screen%20Shot%202020-11-08%20at%2000.57.08.png">
<meta property="og:image" content="https://unknown.yuzhouwan.com/images/data/Screen%20Shot%202020-11-08%20at%2000.57.38.png">
<meta property="og:image" content="https://unknown.yuzhouwan.com/images/data/Screen%20Shot%202020-11-08%20at%2011.56.48.png">
<meta property="og:image" content="https://unknown.yuzhouwan.com/images/data/Screen%20Shot%202020-11-08%20at%2015.31.08.png">
<meta property="og:image" content="https://unknown.yuzhouwan.com/images/data/Screen%20Shot%202020-11-08%20at%2015.41.48.png">
<meta property="og:image" content="https://unknown.yuzhouwan.com/images/data/Screen%20Shot%202020-11-08%20at%2015.42.01.png">
<meta property="og:image" content="https://unknown.yuzhouwan.com/images/data/Screen%20Shot%202020-11-08%20at%2015.42.14.png">
<meta property="og:image" content="https://unknown.yuzhouwan.com/images/data/截屏2020-11-17%2016.52.08.png">
<meta property="article:published_time" content="2020-01-30T23:55:00.000Z">
<meta property="article:modified_time" content="2020-12-03T10:56:37.344Z">
<meta property="article:author" content="Grace Koo">
<meta property="article:tag" content="Computer Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unknown.yuzhouwan.com/images/data/Screen%20Shot%202020-11-08%20at%2000.57.08.png">

<link rel="canonical" href="https://unknown.yuzhouwan.com/posts/6678/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'Zh'
  };
</script>

  <title>计算机网络 | Grace Koo's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Grace Koo's Blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Grace Koo's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">LaLaLa~~~</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-mr.sweet">

    <a href="/sweet/" rel="section"><i class="paw fa-fw"></i>Mr.Sweet</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="Zh">
    <link itemprop="mainEntityOfPage" href="https://unknown.yuzhouwan.com/posts/6678/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Grace Koo">
      <meta itemprop="description" content="正在深入学习各种CV知识">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Grace Koo's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-30 23:55:00" itemprop="dateCreated datePublished" datetime="2020-01-30T23:55:00Z">2020-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-03 10:56:37" itemprop="dateModified" datetime="2020-12-03T10:56:37Z">2020-12-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Basic/" itemprop="url" rel="index"><span itemprop="name">Computer Basic</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Basic/Interview/" itemprop="url" rel="index"><span itemprop="name">Interview</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>11 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><ol>
<li><p>客户端通过向服务器端<strong>发送一个请求报文SYN</strong>来创建一个主动打开。</p>
</li>
<li><p>Server端接受连接后<strong>回复ACK报文</strong>，并为这次连接分配资源。</p>
<p>如果只有两次通信的话，这时候B不确定A是否收到了确认消息，有可能这个确认消息由于某些原因丢了。</p>
</li>
<li><p>Client端接收到<strong>ACK报文</strong>后也向Server段发送报文，并分配资源，这样TCP连接就建立了。</p>
<p>这个时候经过了三次握手，A和B双方确认了两边都是通的，可以相互通信了，已经可以建立一个可靠的连接，并且可以相互发送数据。</p>
<p>这个时候已经不需要B再发送一个确认消息了，两边已经通过前三次建立了一个可靠的连接，如果再发送第四次确认消息的话，就浪费资源了。</p>
</li>
</ol>
<a id="more"></a>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 00.57.08.png" alt="Screen Shot 2020-11-08 at 00.57.08"></p>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p><em>注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.</em></p>
<ol>
<li>客户端发送一个<strong>FIN报文</strong>. 客户端进入 <strong>FIN-WAIT 状态</strong>. 该状态下客户端只接收数据, 不再发送数据.</li>
<li>服务器接收到带有 FIN = 1 的数据分段, 发送带有 <strong>ACK = 1 的剩余数据分段</strong>, 确认收到客户端发来的 FIN 信息.</li>
<li>服务器<strong>等到所有数据传输结束,</strong> 向客户端发送一个带有 <strong>FIN = 1 的数据分段</strong>, 并进入 <strong>CLOSE-WAIT 状态</strong>, 等待客户端发来带有 ACK = 1 的确认报文.</li>
<li>客户端收到服务器发来带有 FIN = 1 的报文, 返回 <strong>ACK = 1 的报文</strong>确认, <strong>为了防止服务器端未收到需要重发</strong>, 进入 <strong>TIME-WAIT</strong> 状态. 服务器接收到报文后关闭连接. 客户端等待 <strong>2MSL 后未收到回复, 则认为服务器成功关闭</strong>, 客户端关闭连接。</li>
</ol>
<blockquote>
<p> 注：MSL是报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。RFC规定为两分钟，实际应用中常用的是30秒，1分钟和2分钟。</p>
</blockquote>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 00.57.38.png" alt="Screen Shot 2020-11-08 at 00.57.38"></p>
<p>图解: <a target="_blank" rel="noopener" href="http://blog.csdn.net/whuslei/article/details/6667471">http://blog.csdn.net/whuslei/article/details/6667471</a></p>
<h1 id="七层网络模型"><a href="#七层网络模型" class="headerlink" title="七层网络模型"></a>七层网络模型</h1><p>网络通信的分层模型讲起：七层模型，也称OSI (Open System Interconnection)模型。</p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 11.56.48.png" alt="Screen Shot 2020-11-08 at 11.56.48"></p>
<h1 id="TCP和UDP对比"><a href="#TCP和UDP对比" class="headerlink" title="TCP和UDP对比"></a>TCP和UDP对比</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>TCP</th>
<th style="text-align:left">UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">是否连接</td>
<td>面向连接</td>
<td style="text-align:left">无连接，想发就发</td>
</tr>
<tr>
<td style="text-align:left">是否可靠</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
<td style="text-align:left">不可靠传输，不使用流量控制和拥塞控制</td>
</tr>
<tr>
<td style="text-align:left">连接对象个数</td>
<td>只能是一对一通信</td>
<td style="text-align:left">支持一对一，一对多，多对一和多对多交互通信</td>
</tr>
<tr>
<td style="text-align:left">传输方式</td>
<td>面向字节流</td>
<td style="text-align:left">面向报文</td>
</tr>
<tr>
<td style="text-align:left">首部开销</td>
<td>首部最小20字节，最大60字节</td>
<td style="text-align:left">首部开销小，仅8字节</td>
</tr>
<tr>
<td style="text-align:left">适用场景</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
<td style="text-align:left">适用于实时应用（IP电话、视频会议、直播等）</td>
</tr>
</tbody>
</table>
</div>
<p>总结</p>
<ul>
<li>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。</li>
<li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li>
<li>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</li>
</ul>
<h1 id="Socket-Ip-address-TCP-UDP-port"><a href="#Socket-Ip-address-TCP-UDP-port" class="headerlink" title="Socket(Ip address+ TCP/UDP + port)"></a>Socket(Ip address+ TCP/UDP + port)</h1><p><strong>套接字用于描述IP地址和端口，是一个通信链的句柄。</strong>应用程序通过套接字向网络发出请求或应答网络请求。注意的是套接字既不是程序也不是协议，只是<strong>操作系统提供给通信层的一组抽象API接口。</strong></p>
<p>Socket=Ip address+ TCP/UDP + port</p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.31.08.png" alt="Screen Shot 2020-11-08 at 15.31.08"></p>
<p>推荐: <a target="_blank" rel="noopener" href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></p>
<p>使用Socket套接字需要传入哪些参数？</p>
<ul>
<li><p><strong>地址族(Address Family)</strong></p>
<p>地址族通常作为 socket() 函数的第一个参数。</p>
<p>socket.AF_INET 　IPv4地址族，(host, port) 形式的二元组，host是一个表示网络主机的字符串，port为套接字的端口号。AF_INET对应的数值是：2。</p>
<p>socket.AF_INET6 　(host, port, flowinfo, scopeid) 形式的四元组。AF_INET6对应的数值是：23。</p>
</li>
<li><p><strong>套接字类型（Type）</strong></p>
<p>套接字类型用于 socket() 函数的第二个参数。</p>
<p>但是只有 SOCK_STREAM （TCP）和 SOCK_DGRAM （UDP）是比较常见的。</p>
</li>
</ul>
<h1 id="怎么强行关闭客户端和服务器的连接"><a href="#怎么强行关闭客户端和服务器的连接" class="headerlink" title="怎么强行关闭客户端和服务器的连接"></a>怎么强行关闭客户端和服务器的连接</h1><ul>
<li><p>关闭TCP连接是指TCP协议层的东西，就是两个TCP端之间交换了一些协议包（FIN，RST等），具体的交换过程可以看TCP协议。</p>
</li>
<li><p>而关闭socket是指<strong>关闭用户应用程序中的socket句柄，释放相关资源</strong>。但是当用户<strong>关闭socket句柄时会隐含的触发TCP连接的关闭过程</strong>。</p>
</li>
</ul>
<p>TCP连接的关闭过程有两种，一种是<strong>优雅关闭</strong>（graceful close），一种是<strong>强制关闭</strong>（hard close或abortive close）</p>
<ul>
<li>优雅关闭是指，如果<strong>发送缓存</strong>中还有数据未发出则其发出去，<strong>并且收到所有数据的ACK之后，发送FIN包，开始关闭过程</strong>。</li>
<li>强制关闭是指如果<strong>缓存中</strong>还有数据，则这些数据都将被丢弃，然后发送<strong>RST</strong>包，直接重置TCP连接。</li>
</ul>
<p>shutdown函数，用于关闭TCP连接，但并不关闭socket句柄。</p>
<ul>
<li>SD_RECEIVE表明<strong>关闭接收通道</strong>，在该socket上不能再接收数据，如果当前接收缓存中仍有未取出数据或者<strong>以后再有数据到达，则TCP会向发送端发送RST包</strong>，将连接重置。</li>
<li>SD_SEND表明<strong>关闭发送通道</strong>，TCP会将发送缓存中的数据都发送完毕并<strong>收到所有数据的ACK后向对端发送FIN包</strong>，表明本端没有更多数据发送。这个是一个优雅关闭过程。</li>
<li>SD_BOTH则表示<strong>同时关闭接收通道和发送通道</strong>。</li>
</ul>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1xx 报告</td>
<td style="text-align:left">接收到请求，继续进程</td>
</tr>
<tr>
<td style="text-align:left">2xx 成功</td>
<td style="text-align:left">步骤成功接收，被理解，并被接受</td>
</tr>
<tr>
<td style="text-align:left">3xx 重定向</td>
<td style="text-align:left">为了完成请求,必须采取进一步措施</td>
</tr>
<tr>
<td style="text-align:left">4xx 客户端出错</td>
<td style="text-align:left">请求包括错的顺序或不能完成</td>
</tr>
<tr>
<td style="text-align:left">5xx 服务器出错</td>
<td style="text-align:left">服务器无法完成显然有效的请求</td>
</tr>
</tbody>
</table>
</div>
<p>403: Forbidden<br>404: Not Found</p>
<h2 id="HTTP1-0和HTTP1-1"><a href="#HTTP1-0和HTTP1-1" class="headerlink" title="HTTP1.0和HTTP1.1"></a>HTTP1.0和HTTP1.1</h2><p>推荐: <a target="_blank" rel="noopener" href="http://blog.csdn.net/elifefly/article/details/3964766">http://blog.csdn.net/elifefly/article/details/3964766</a></p>
<p><strong>HTTP 1.0*规定浏览器与服务器只保持短暂的连接</strong>，浏览器的每次请求都需要与服务器建立一个<em>TCP</em>连接，服务器完成请求处理后立即断开<em>TCP</em>连接，服务器不跟踪每个客户也不记录过去的请求。</p>
<p><strong>HTTP1.1改进点</strong></p>
<ol>
<li><strong>支持了长链接</strong>：在一个<em>TCP</em>连接上可以传送多个<em>HTTP</em>请求和响应，减少了建立和关闭连接的消耗和延迟。</li>
<li><strong>HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求</strong>。但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</li>
<li><strong>增加请求头Host字段</strong>：一个服务器多个虚拟Web站点。</li>
<li><strong>身份认证,状态管理,Cache缓存等机制</strong>相关的请求头和响应头。</li>
</ol>
<h2 id="HTTP常见请求头与响应头"><a href="#HTTP常见请求头与响应头" class="headerlink" title="HTTP常见请求头与响应头"></a>HTTP常见请求头与响应头</h2><p>常见请求头：Request</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Accept</th>
<th>可接受的响应内容类型（<code>Content-Types</code>）。</th>
<th><code>Accept: text/plain</code></th>
<th>固定</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Charset</td>
<td>浏览器可接受的字符集</td>
<td><code>Accept-Charset: utf-8</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>可接受的响应内容的数据压缩格式</td>
<td><code>Accept-Encoding: gzip, deflate</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>可接受的响应内容语言列表。</td>
<td><code>Accept-Language: en-US</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Datetime</td>
<td>可接受的按照时间来表示的响应内容版本</td>
<td>Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT</td>
<td>临时</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>用来指定当前的请求/回复中的，是否使用缓存机制。</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>常见响应头：Response</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">响应头</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Age</td>
<td style="text-align:left">响应对象在代理缓存中存在的时间，以秒为单位</td>
<td style="text-align:left"><code>Age: 12</code></td>
<td style="text-align:left">固定</td>
</tr>
<tr>
<td style="text-align:left">Cache-Control</td>
<td style="text-align:left">通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒</td>
<td style="text-align:left"><code>Cache-Control: max-age=3600</code></td>
<td style="text-align:left">固定</td>
</tr>
</tbody>
</table>
</div>
<p><a target="_blank" rel="noopener" href="https://itbilu.com/other/relate/EJ3fKUwUx.html">https://itbilu.com/other/relate/EJ3fKUwUx.html</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903745004765198">https://juejin.im/post/6844903745004765198</a></p>
<h2 id="HTTP协议以及协议头部中表示数据类型的字段"><a href="#HTTP协议以及协议头部中表示数据类型的字段" class="headerlink" title="HTTP协议以及协议头部中表示数据类型的字段"></a>HTTP协议以及协议头部中表示数据类型的字段</h2><div class="table-container">
<table>
<thead>
<tr>
<th>Accept</th>
<th>可接受的响应内容类型（<code>Content-Types</code>）。</th>
<th><code>Accept: text/plain</code></th>
<th>固定</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Charset</td>
<td>浏览器可接受的字符集</td>
<td><code>Accept-Charset: utf-8</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>可接受的响应内容的数据压缩格式</td>
<td><code>Accept-Encoding: gzip, deflate</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>可接受的响应内容语言列表。</td>
<td><code>Accept-Language: en-US</code></td>
<td>固定</td>
</tr>
</tbody>
</table>
</div>
<h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>HTTP请求8种方法介绍<br>HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。</p>
<ol>
<li>GET</li>
</ol>
<p><strong>GET请求会显示请求指定的资源</strong>。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的幂等的操作中。</p>
<p>GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。</p>
<ol>
<li>HEAD</li>
</ol>
<p><strong>HEAD方法与GET方法一样，都是向服务器发出指定资源的请求</strong>。但是，服务器在响应HEAD请求时<strong>不会回传资源的内容部分，即：响应主体</strong>。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。</p>
<ol>
<li>POST</li>
</ol>
<p><strong>POST请求会向指定资源提交数据，请求服务器进行处理</strong>，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。<strong>POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。</strong></p>
<ol>
<li>PUT</li>
</ol>
<p><strong>PUT请求会身向指定资源位置上传其最新内容</strong>，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。</p>
<ol>
<li>DELETE</li>
</ol>
<p><strong>DELETE请求用于请求服务器删除所请求URI</strong>（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。</p>
<ol>
<li>CONNECT</li>
</ol>
<p><strong>CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器</strong>。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p>
<ol>
<li>OPTIONS</li>
</ol>
<p><strong>OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能</strong>。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许</p>
<ol>
<li>TRACE</li>
</ol>
<p><strong>TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。</strong></p>
<p>HTTP/1.1之后增加的方法</p>
<p>在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：</p>
<ol>
<li>PATCH</li>
</ol>
<p>PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：</p>
<p><strong>但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。</strong><br>当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。</p>
<h2 id="Post和Get"><a href="#Post和Get" class="headerlink" title="Post和Get"></a>Post和Get</h2><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html">GET和POST有什么区别？及为什么网上的多数答案都是错的</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31640769?rf=37401322">知乎回答</a></p>
<p>get: <a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc2616#section-9.3">RFC 2616 - Hypertext Transfer Protocol — HTTP/1.1</a><br>post: <a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc2616#section-9.5">RFC 2616 - Hypertext Transfer Protocol — HTTP/1.1</a></p>
<p>HTTP协议用法的约定，使用上的区别：</p>
<ol>
<li><strong>GET使用URL或Cookie传参，而POST将数据放在BODY中。</strong></li>
<li><strong>GET方式提交的数据长度有限，而POST的数据则可以非常大。</strong>（这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。也不是GET和POST本身的区别。）</li>
<li><strong>POST比GET安全，因为数据在地址栏上不可见。</strong></li>
<li>对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据</li>
</ol>
<p>终极区别：</p>
<ol>
<li><strong>GET请求是满足幂等性的，POST请求不是。</strong>所以不应该且不能用get请求做数据的<strong>增删改</strong>这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用。</li>
</ol>
<blockquote>
<p>什么是幂等性？简单来说意味着对同一URL的多个请求应该返回同样的结果。</p>
</blockquote>
<h2 id="幂等-Idempotence"><a href="#幂等-Idempotence" class="headerlink" title="幂等 Idempotence"></a>幂等 Idempotence</h2><p><strong>HTTP方法的幂等性是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用</strong>。(注意是副作用)</p>
<p>1.、HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。<br>2、GET：<strong>向特定的资源发出请求数据。（要数据）</strong><br>3、POST：<strong>向指定资源提交数据进行处理请求（给数据）</strong>（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。<br>4、PUT：向指定资源位置上传其最新内容。<br>5、DELETE：请求服务器删除Request-URI所标识的资源。 </p>
<p>如：</p>
<p><code>GET http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，<strong>这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。</strong><code>GET http://www.news.com/latest-news</code>这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，<strong>因而是满足幂等性的。</strong></p>
<p>DELETE方法用于删除资源，有副作用，但它<strong>应该满足幂等性</strong>。比如：<code>DELETE http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p>
<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：<code>POST http://www.forum.com/articles</code>的语义是在<code>http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，<strong>POST方法不具备幂等性</strong>。</p>
<p>PUT所对应的URI是要创建或更新的资源本身。比如：<code>PUT http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，<strong>PUT方法具有幂等性</strong>。</p>
<h2 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h2><p>HTTPS协议是由<strong>SSL+HTTP协议构建的可进行加密传输</strong>、身份认证的网络协议，要比http协议安全。(SSL: Secure Sockets Layer)</p>
<p>HTTPS和HTTP的区别主要如下：</p>
<ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li><p>http的连接很简单，<strong>是无状态的</strong>；HTTPS协议是由SSL+HTTP协议构建的<strong>可进行加密传输、身份认证的网络协议</strong>，比http协议安全。</p>
</li>
<li><p>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
</li>
</ol>
<h1 id="URL的形式"><a href="#URL的形式" class="headerlink" title="URL的形式"></a>URL的形式</h1><ul>
<li>定义</li>
</ul>
<p>URL(Uniform Resource Locator,统一资源定位符)，定义资源在网上唯一的地址。</p>
<ul>
<li>组成部分</li>
</ul>
<p>URL由三部分组成：资源类型、存放资源的主机域名、资源文件名</p>
<blockquote>
<p>protocol :// hostname[:port] / path / [;parameters][?query]#fragment</p>
</blockquote>
<ul>
<li>protocol(协议):</li>
</ul>
<p>file 资源是本地计算机上的文件。格式file:///，注意后边应是三个斜杠。</p>
<p>ftp 通过 FTP访问资源。格式 FTP://</p>
<p>http 通过 HTTP 访问该资源。 格式 </p>
<p>HTTP:// https 通过安全的 HTTPS 访问该资源。 格式 HTTPS://</p>
<p>mailto 资源为电子邮件地址，通过 SMTP 访问。 格式 mailto:</p>
<ul>
<li>hostname(主机名)</li>
</ul>
<p>是指存放资源的服务器的域名系统(DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式: username:password@hostname）。</p>
<ul>
<li>Path(路径)</li>
</ul>
<p>由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。parameters（参数）</p>
<ul>
<li>query（查询）</li>
</ul>
<p>可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“=”符号隔开。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//变量url即具有了url模块所提供的方法</span><br><span class="line">var url = require(<span class="string">'url'</span>);</span><br><span class="line">var queryUrl = <span class="string">"http://localhost:8888/bb?name=bigbear&amp;memo-helloworld"</span>;</span><br><span class="line">console.log(typeof url.parse(queryUrl));</span><br><span class="line">console.log(url.parse(queryUrl));</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span></span><br><span class="line">Url {</span><br><span class="line">  protocol: <span class="string">'http:'</span>,</span><br><span class="line">  slashes: true,</span><br><span class="line">  auth: null,</span><br><span class="line">  host: <span class="string">'localhost:8888'</span>,</span><br><span class="line">  port: <span class="string">'8888'</span>,</span><br><span class="line">  hostname: <span class="string">'localhost'</span>,</span><br><span class="line">  <span class="built_in">hash</span>: null,</span><br><span class="line">  search: <span class="string">'?name=bigbear&amp;memo-helloworld'</span>,</span><br><span class="line">  query: <span class="string">'name=bigbear&amp;memo-helloworld'</span>,</span><br><span class="line">  pathname: <span class="string">'/bb'</span>,</span><br><span class="line">  path: <span class="string">'/bb?name=bigbear&amp;memo-helloworld'</span>,</span><br><span class="line">  href: <span class="string">'http://localhost:8888/bb?name=bigbear&amp;memo-helloworld'</span> }</span><br></pre></td></tr></tbody></table></figure>
<h1 id="urllib和urllib2的区别"><a href="#urllib和urllib2的区别" class="headerlink" title="urllib和urllib2的区别"></a>urllib和urllib2的区别</h1><p>这个面试官确实问过,当时答的<strong>urllib2可以Post而urllib不可以</strong>.</p>
<ol>
<li>urllib提供<strong>urlencode</strong>方法用来<strong>GET查询字符串的产生</strong>，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li>
<li>urllib2可以接受一个<strong>Request类的实例来设置URL请求的headers，urllib仅可以接受URL</strong>。<strong>这意味着，你不可以伪装你的用户代理字符串等</strong>。</li>
</ol>
<h1 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h1><p><strong>地址解析协议(Address Resolution Protocol)</strong>，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，<strong>以保证通信的顺利进行</strong>。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被<strong>邻居发现协议（NDP）所替代</strong>（Neighbor Discovery Protocol）。</p>
<h1 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Cookie</th>
<th style="text-align:left">Session</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">储存位置</td>
<td style="text-align:left">客户端</td>
<td style="text-align:left">服务器端</td>
</tr>
<tr>
<td style="text-align:left">目的</td>
<td style="text-align:left">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td>
<td style="text-align:left">跟踪会话</td>
</tr>
<tr>
<td style="text-align:left">安全性</td>
<td style="text-align:left">不安全</td>
<td style="text-align:left">安全</td>
</tr>
</tbody>
</table>
</div>
<p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p>
<p>但是禁用Cookie就不能得到Session。因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于SessionID,也就得不到Session。</p>
<h1 id="apache和nginx的区别（Web服务器）"><a href="#apache和nginx的区别（Web服务器）" class="headerlink" title="apache和nginx的区别（Web服务器）"></a>apache和nginx的区别（Web服务器）</h1><p>nginx 相对 apache 的优点：</p>
<ul>
<li><strong>轻量级</strong>，同样起web 服务，比apache 占用更少的内存及资源</li>
<li><strong>抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接</strong>，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能</li>
<li><strong>配置简洁</strong></li>
<li>高度模块化的设计，编写模块相对简单</li>
<li>社区活跃</li>
</ul>
<p>apache 相对nginx 的优点：</p>
<ul>
<li><p><strong>rewrite ，比nginx 的rewrite 强大</strong></p>
</li>
<li><p><strong>模块超多</strong>，基本想到的都可以找到</p>
</li>
<li><p><strong>少bug</strong> ，nginx 的bug 相对较多</p>
</li>
<li><p><strong>超稳定</strong></p>
</li>
</ul>
<h1 id="网站用户密码保存"><a href="#网站用户密码保存" class="headerlink" title="网站用户密码保存"></a>网站用户密码保存</h1><ol>
<li><strong>明文保存</strong>在数据库中</li>
<li><strong>明文hash后保存,如MD5</strong></li>
<li><strong>MD5+Salt方式,这个Salt可以随机</strong></li>
<li>知乎使用了Bcrypy(好像)加密</li>
</ol>
<h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><p>推荐: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p>
<p>304 Not Modified</p>
<p>浏览器缓存机制，其实<strong>主要就是HTTP协议定义的缓存机制</strong>（如：Expires；Cache-control等）</p>
<p>但是也有非HTTP协议定义的缓存机制。</p>
<p><strong>一、非HTTP协议定义的缓存机制</strong></p>
 <figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">"Pragma"</span> <span class="attr">CONTENT</span>=<span class="string">"no-cache"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有<strong>缓存代理服务器都不支持，因为代理不解析HTML内容本身。</strong></p>
<p><strong>二、HTTP协议定义的缓存机制</strong></p>
<ol>
<li><p>Expires策略:  是Web服务器响应消息头字段，在响应http请求时告诉<strong>浏览器在过期时间前</strong>浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.41.48.png" alt="Screen Shot 2020-11-08 at 15.41.48"></p>
</li>
<li><p>Cache-control策略:Cache-Control与Expires的作用一致，都是指明当前资源的<strong>有效期</strong>，控制浏览器<strong>是否直接从浏览器缓存取数据还是重新发请求到服务器取数据</strong>。只不过Cache-Control的<strong>选择更多，设置更细致</strong>，如果同时设置的话，其<strong>优先级高于</strong>Expires。</p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.42.01.png" alt="Screen Shot 2020-11-08 at 15.42.01"></p>
<p><img data-src="/images/data/Screen Shot 2020-11-08 at 15.42.14.png" alt="Screen Shot 2020-11-08 at 15.42.14"></p>
</li>
</ol>
<h1 id="CSRF和XSS"><a href="#CSRF和XSS" class="headerlink" title="CSRF和XSS"></a>CSRF和XSS</h1><ul>
<li><strong>CSRF(Cross-site request forgery)跨站请求伪造</strong>：<strong>网站过分信任用户</strong>，放任来自所谓通过<strong>访问控制机制</strong>的代表合法用户的请求执行网站的某个特定功能。（利用cookies进行CSRF攻击）</li>
<li><strong>XSS(Cross Site Scripting)跨站脚本攻击：用户过分信任网站</strong>，放任来自来自浏览器地址代表的那个网站代码在自己本地任意执行。如果没有浏览器的安全机制限制，XSS代码可以在用户浏览器为所欲为。</li>
</ul>
<p>CSRF重点在<strong>请求</strong>,XSS重点在<strong>脚本</strong></p>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><p><strong>RPC（Remote Procedure Call Protocol）——远程过程调用协议</strong>。</p>
<p>该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。<strong>RPC是一个分布式计算的CS模式，总是由Client向Server发出一个执行若干过程请求，Server接受请求，使用客户端提供的参数，计算完成之后将结果返回给客户端。</strong></p>
<p><strong>RPC是面向过程，Restful是面向资源</strong>，并且使用了Http动词。从这个维度上看，Restful风格的url在表述的精简性、可读性上都要更好。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RPC风格</span></span><br><span class="line">/queryOrder?orderId=123</span><br><span class="line"></span><br><span class="line"><span class="comment"># Restful风格</span></span><br><span class="line">Get  </span><br><span class="line">/order/<span class="number">123</span></span><br></pre></td></tr></tbody></table></figure>
<p>RPC原理：</p>
<p>比如 A (client) 调用 B (server) 提供的<code>remoteAdd</code>方法：</p>
<ol>
<li>首先A与B之间建立一个TCP连接；</li>
<li>然后A把需要调用的方法名（这里是remoteAdd）以及方法参数（10， 20）<strong>序列化成字节流发送出去；</strong></li>
<li>B接受A发送过来的字节流，然后<strong>反序列化得到目标方法名，方法参数</strong>，接着执行相应的方法调用（可能是localAdd）并把结果30返回；</li>
<li>A接受远程调用结果,输出30。</li>
</ol>
<p><strong>进化的顺序: RPC -&gt; SOAP -&gt; RESTful</strong></p>
<h1 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h1><ol>
<li>SOAP（原为<strong>Simple Object Access Protocol</strong>的首字母缩写，即<strong>简单对象访问协议</strong>）是交换数据的一种协议规范，<strong>使用在计算机网络Web服务（web service）中</strong>，交换带结构信息。</li>
<li>SOAP为了简化<strong>网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间</strong>。不同应用程序之间按照<strong>HTTP通信协议，遵从XML格式执行资料互换</strong>，使其抽象于语言实现、平台和硬件。</li>
</ol>
<h1 id="RESTful架构-SOAP-RPC"><a href="#RESTful架构-SOAP-RPC" class="headerlink" title="RESTful架构(SOAP,RPC)"></a>RESTful架构(SOAP,RPC)</h1><p>推荐: <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/09/restful.html">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>
<p>Representational State Transfer：表现层状态转移</p>
<p>RESTful架构，<strong>就是目前最流行的一种互联网软件架构</strong>。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p>
<p>总结一下什么是RESTful架构：</p>
<p>（1）<strong>每一个URI代表一种资源；</strong></p>
<p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p>
<p>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”<strong>表现层状态转化</strong>“。</p>
<h1 id="CGI和WSGI"><a href="#CGI和WSGI" class="headerlink" title="CGI和WSGI"></a>CGI和WSGI</h1><ul>
<li><p>CGI(Common Gateway Interface)是<strong>通用网关接口</strong>，是连接web服务器和应用程序的接口，用户通过CGI来获取<strong>动态数据或文件</strong>等。<br>CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。</p>
</li>
<li><p>WSGI(Web Server Gateway Interface)<strong>Web服务器网关接口</strong>，是<strong>Python应用程序或框架和Web服务器</strong>之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p>
<p>它不是服务器,也不是python模块,<strong>它是一种规范,描述Web服务器和应用之间的交互</strong>.通俗来讲, 它就是一条纽带,连接着Web服务器和应用。</p>
</li>
</ul>
<p>官方说明：<a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-3333/">PEP-3333</a></p>
<h1 id="简述浏览器通过WSGI请求动态资源的过程"><a href="#简述浏览器通过WSGI请求动态资源的过程" class="headerlink" title="简述浏览器通过WSGI请求动态资源的过程"></a>简述浏览器通过WSGI请求动态资源的过程</h1><ul>
<li>静态服务器加载的是一个静态html页面，或是存在服务器中的静态数据。</li>
<li><p>动态服务器是，当客户端发送一个请求，<strong>服务器拿到这个请求找到相关的程序代码执行，将执行结果返回给客户端的一个过程</strong></p>
</li>
<li><p>WSGI</p>
<p>怎么在你刚刚建立的web服务器上运行一个Django应用和一个Flask应用呢。如何做不做任何改变而适应不同的web架构呢：WSGI</p>
</li>
</ul>
<ol>
<li>浏览器发送http请求动态资源给web服务器（flask）</li>
<li>web服务器收到请求后<strong>通过WSGI调用一个属性给应用程序框架</strong></li>
<li>应用程序框架通过引用WSGI调用Web服务器，<strong>设置返回的状态和头信息</strong></li>
<li>调用后返回，此时Web服务器保存了刚刚设置的信息</li>
<li><strong>应用程序查询数据库，生成动态页面的body信息</strong></li>
<li><strong>把生成的body信息返回给Web服务器</strong></li>
<li>Web服务器把数据返回给浏览器</li>
</ol>
<p><img data-src="/images/data/截屏2020-11-17 16.52.08.png" alt="截屏2020-11-17 16.52.08"></p>
<h1 id="WSGI与Flask之间的关系"><a href="#WSGI与Flask之间的关系" class="headerlink" title="WSGI与Flask之间的关系"></a>WSGI与Flask之间的关系</h1><ol>
<li>使用<code>app.run()</code>方法来启动flask应用（<code>app.run()</code>代码隐藏着创建一个服务器），<strong>app应用本身会作为参数传递到WSGI服务器中</strong>。</li>
<li>在客户端（这里就是浏览器）输入网址（发送一个请求），服务器使用WSGI 中间件来处理这个请求。</li>
<li>WSGI 处理请求对应着<code>wsgi_app(self, environ, start_response)</code>方法，<code>self</code>参数对应着<code>app</code>，即flask程序；<code>environ</code>和 <code>start_response</code>由服务器提供。</li>
<li><code>wsgi_app()</code>作用就是调用各种请求处理函数来处理请求，然后返回处理结果。即用户输入网址后，看到了网页响应。</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)  </span><br><span class="line"><span class="comment">#生成app实例，传递 __name__参数，__name__ 就是当前模块名字。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">"/"</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"2017-08-21"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_36651044/article/details/77462831">https://blog.csdn.net/sinat_36651044/article/details/77462831</a></p>
<h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p>在<strong>GFW(Great Firewall: 中国国家防火墙)</strong>里屡见不鲜的,呵呵.</p>
<p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指<strong>攻击者与通讯的两端分别创建独立的联系</strong>，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p>
<h1 id="c10k问题"><a href="#c10k问题" class="headerlink" title="c10k问题"></a>c10k问题</h1><p>所谓<strong>c10k</strong>问题，指的是<strong>服务器同时支持成千上万个客户端</strong>的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。</p>
<p>解决方法：</p>
<ol>
<li><strong>每个连接分配一个独立的线程/进程</strong>：该思路最为直接，但是申请进程/线程是需要系统资源的，且系统需要管理这些进程/线程，所以<strong>会使资源占用过多，可扩展性差</strong></li>
<li><strong>同一个线程/进程同时处理多个连接（I/O多路复用）</strong>：select方式、poll方式、epoll方式、异步I/O以及Windows</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/xianggao/blog/664275">https://my.oschina.net/xianggao/blog/664275</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ba7fa25d3590">C10K问题及其解决方法</a></p>
<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>AJAX(Asynchronous JavaScript and XML)（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与<strong>服务器交换数据并更新部分网页的技术</strong>。</p>
<h1 id="描述用浏览器访问www-baidu-com的过程"><a href="#描述用浏览器访问www-baidu-com的过程" class="headerlink" title="描述用浏览器访问www.baidu.com的过程"></a>描述用浏览器访问www.baidu.com的过程</h1><ol>
<li>浏览器获取用户输入的域名：www.baidu.com</li>
<li><p>浏览器<strong>向域名解析器DNS获取www.baidu.com的IP地址</strong></p>
</li>
<li><p>DNS解析出IP地址</p>
</li>
<li>浏览器与服务器<strong>建立TCP连接</strong>（默认端口号80）</li>
<li><p><strong>浏览器发出HTTP请求</strong>，请求百度页面</p>
</li>
<li><p><strong>服务器通过HTTP响应</strong>把首页内容发送给浏览器</p>
</li>
<li><p>TCP连接释放</p>
</li>
<li><strong>浏览器解析首页文件</strong>，并将WEB页面显示给用户</li>
</ol>
<h1 id="简述QQ登陆过程"><a href="#简述QQ登陆过程" class="headerlink" title="简述QQ登陆过程"></a>简述QQ登陆过程</h1><p>qq登录，在我们的项目中分为了三个接口</p>
<ul>
<li><p>第一个接口是请求qq服务器返回一个qq登录的界面;</p>
</li>
<li><p>第二个接口是通过扫码或账号登陆进行验证，qq服务器返回给浏览器一个code和state, 利用这个code通过<strong>本地服务器去向qq服务器获取access_token</strong>，凭借access_token再向qq服务器获取用户的openid(openid用户的唯一标识)</p>
</li>
<li><p>第三个接口是判断用户是否是第一次qq登录，如果不是的话直接登录返回的jwt-token给用户，对没有绑定过本网站的用户，对openid进行加密生成token进行绑定</p>
</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Grace Koo
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://unknown.yuzhouwan.com/posts/6678/" title="计算机网络">https://unknown.yuzhouwan.com/posts/6678/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-ND</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Computer-Network/" rel="tag"># Computer Network</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/22488/" rel="prev" title="数据库基础">
      <i class="fa fa-chevron-left"></i> 数据库基础
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/23063/" rel="next" title="Python进阶">
      Python进阶 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">2.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">七层网络模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP%E5%92%8CUDP%E5%AF%B9%E6%AF%94"><span class="nav-number">4.</span> <span class="nav-text">TCP和UDP对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Socket-Ip-address-TCP-UDP-port"><span class="nav-number">5.</span> <span class="nav-text">Socket(Ip address+ TCP&#x2F;UDP + port)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%BC%BA%E8%A1%8C%E5%85%B3%E9%97%AD%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.</span> <span class="nav-text">怎么强行关闭客户端和服务器的连接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP"><span class="nav-number">7.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">7.1.</span> <span class="nav-text">HTTP状态码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP1-0%E5%92%8CHTTP1-1"><span class="nav-number">7.2.</span> <span class="nav-text">HTTP1.0和HTTP1.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="nav-number">7.3.</span> <span class="nav-text">HTTP常见请求头与响应头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8A%E5%8D%8F%E8%AE%AE%E5%A4%B4%E9%83%A8%E4%B8%AD%E8%A1%A8%E7%A4%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="nav-number">7.4.</span> <span class="nav-text">HTTP协议以及协议头部中表示数据类型的字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="nav-number">7.5.</span> <span class="nav-text">HTTP请求方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Post%E5%92%8CGet"><span class="nav-number">7.6.</span> <span class="nav-text">Post和Get</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%82%E7%AD%89-Idempotence"><span class="nav-number">7.7.</span> <span class="nav-text">幂等 Idempotence</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E4%B8%8EHTTPS"><span class="nav-number">7.8.</span> <span class="nav-text">HTTP与HTTPS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#URL%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">URL的形式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#urllib%E5%92%8Curllib2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">urllib和urllib2的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ARP%E5%8D%8F%E8%AE%AE"><span class="nav-number">10.</span> <span class="nav-text">ARP协议</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Cookie%E5%92%8CSession"><span class="nav-number">11.</span> <span class="nav-text">Cookie和Session</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#apache%E5%92%8Cnginx%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88Web%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89"><span class="nav-number">12.</span> <span class="nav-text">apache和nginx的区别（Web服务器）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%AB%99%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E4%BF%9D%E5%AD%98"><span class="nav-number">13.</span> <span class="nav-text">网站用户密码保存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="nav-number">14.</span> <span class="nav-text">浏览器缓存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CSRF%E5%92%8CXSS"><span class="nav-number">15.</span> <span class="nav-text">CSRF和XSS</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RPC"><span class="nav-number">16.</span> <span class="nav-text">RPC</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SOAP"><span class="nav-number">17.</span> <span class="nav-text">SOAP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RESTful%E6%9E%B6%E6%9E%84-SOAP-RPC"><span class="nav-number">18.</span> <span class="nav-text">RESTful架构(SOAP,RPC)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CGI%E5%92%8CWSGI"><span class="nav-number">19.</span> <span class="nav-text">CGI和WSGI</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E9%80%9A%E8%BF%87WSGI%E8%AF%B7%E6%B1%82%E5%8A%A8%E6%80%81%E8%B5%84%E6%BA%90%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">20.</span> <span class="nav-text">简述浏览器通过WSGI请求动态资源的过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WSGI%E4%B8%8EFlask%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">21.</span> <span class="nav-text">WSGI与Flask之间的关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB"><span class="nav-number">22.</span> <span class="nav-text">中间人攻击</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c10k%E9%97%AE%E9%A2%98"><span class="nav-number">23.</span> <span class="nav-text">c10k问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ajax"><span class="nav-number">24.</span> <span class="nav-text">Ajax</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEwww-baidu-com%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">25.</span> <span class="nav-text">描述用浏览器访问www.baidu.com的过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0QQ%E7%99%BB%E9%99%86%E8%BF%87%E7%A8%8B"><span class="nav-number">26.</span> <span class="nav-text">简述QQ登陆过程</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Grace Koo</p>
  <div class="site-description" itemprop="description">正在深入学习各种CV知识</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GraceKoo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;GraceKoo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-nd.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://yuzhouwan.com/" title="https:&#x2F;&#x2F;yuzhouwan.com" rel="noopener" target="_blank">宇宙湾</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">unknown.yuzhouwan.com</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">409k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">6:12</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  

  

  

</body>
</html>
